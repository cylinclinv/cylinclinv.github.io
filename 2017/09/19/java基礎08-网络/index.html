

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/logo.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="clyde">
  <meta name="keywords" content="">
  
  <title>java基礎08-网络 - Clyde</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Clyde</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/cover/05.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="java基礎08-网络">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2017-09-19 11:21" pubdate>
        2017年9月19日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      240
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java基礎08-网络</h1>
            
            <div class="markdown-body">
              <h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件</li>
</ul>
<ul>
<li><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
</ul>
<ul>
<li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img src="/img/cphoto/net01.jpg" srcset="/img/loading.gif" lazyload></p>
<p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示</p>
</li>
</ul>
<p><img src="/img/cphoto/net02.jpg" srcset="/img/loading.gif" lazyload></p>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/cphoto/net03.jpg" srcset="/img/loading.gif" lazyload></p>
<p> 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ipconfig<br></code></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ping 空格 IP地址<br>ping <span class="hljs-number">220.181</span><span class="hljs-number">.57</span><span class="hljs-number">.216</span><br></code></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> ：关闭此套接字。</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。 </li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li>
</ul>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="/img/cphoto/net04.jpg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p>服务端实现：**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      	<span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      	<span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>        <span class="hljs-comment">//5.关闭资源.</span><br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br>		<span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>		Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>		<span class="hljs-comment">// 2.获取流对象 . 输出流</span><br>		OutputStream os = client.getOutputStream();<br>		<span class="hljs-comment">// 3.写出数据.</span><br>		os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br>		<span class="hljs-comment">// 4. 关闭资源 .</span><br>		os.close();<br>		client.close();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      	<span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      	<span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>      	<span class="hljs-comment">// =================回写数据=======================</span><br>      	<span class="hljs-comment">// 5. 通过 socket 获取输出流</span><br>      	 OutputStream out = server.getOutputStream();<br>      	<span class="hljs-comment">// 6. 回写数据</span><br>      	 out.write(<span class="hljs-string">&quot;我很好,谢谢你&quot;</span>.getBytes());<br>      	<span class="hljs-comment">// 7.关闭资源.</span><br>      	out.close();<br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br>		<span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>		Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>		<span class="hljs-comment">// 2.通过Scoket,获取输出流对象 </span><br>		OutputStream os = client.getOutputStream();<br>		<span class="hljs-comment">// 3.写出数据.</span><br>		os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br>      	<span class="hljs-comment">// ==============解析回写=========================</span><br>      	<span class="hljs-comment">// 4. 通过Scoket,获取 输入流对象</span><br>      	InputStream in = client.getInputStream();<br>      	<span class="hljs-comment">// 5. 读取数据数据</span><br>      	<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];<br>      	<span class="hljs-keyword">int</span> len = in.read(b);<br>      	System.out.println(<span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len));<br>		<span class="hljs-comment">// 6. 关闭资源 .</span><br>      	in.close();<br>		os.close();<br>		client.close();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<p><img src="/img/cphoto/net05.jpg" srcset="/img/loading.gif" lazyload>    </p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>      	ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>  		<span class="hljs-comment">// 2. 建立连接 </span><br>        Socket accept = serverSocket.accept();<br>      	<span class="hljs-comment">// 3. 创建流对象</span><br>      	<span class="hljs-comment">// 3.1 获取输入流,读取文件数据</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>        <span class="hljs-comment">// 3.2 创建输出流,保存到本地 .</span><br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.jpg&quot;</span>));<br>		<span class="hljs-comment">// 4. 读写数据</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        <span class="hljs-comment">//5. 关闭 资源</span><br>        bos.close();<br>        bis.close();<br>        accept.close();<br>        System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUPload_Client</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件  </span><br>        BufferedInputStream bis  = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.jpg&quot;</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端 </span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream   bos   = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据. </span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ; <br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>            bos.flush();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;文件发送完毕&quot;</span>);<br>        <span class="hljs-comment">// 3.释放资源</span><br><br>        bos.close(); <br>        socket.close();<br>        bis.close(); <br>        System.out.println(<span class="hljs-string">&quot;文件上传完毕 &quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="hljs-string">&quot;.jpg&quot;</span>) <span class="hljs-comment">// 文件名称</span><br>BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次接收新的连接,创建一个Socket</span><br><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    <span class="hljs-comment">// accept 交给子线程处理.</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      	......<br>        InputStream bis = accept.getInputStream();<br>      	......<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>      	<span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          	<span class="hljs-comment">/* </span><br><span class="hljs-comment">          	3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                      bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    <span class="hljs-comment">//4. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                  	e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<p><img src="/img/cphoto/net06.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          	<span class="hljs-comment">/*</span><br><span class="hljs-comment">          	3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br>                ) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                        bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br><br>                    <span class="hljs-comment">// 4.=======信息回写===========================</span><br>                    System.out.println(<span class="hljs-string">&quot;back ........&quot;</span>);<br>                    OutputStream out = accept.getOutputStream();<br>                    out.write(<span class="hljs-string">&quot;上传成功&quot;</span>.getBytes());<br>                    out.close();<br>                    <span class="hljs-comment">//================================</span><br><br>                    <span class="hljs-comment">//5. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.jpg&quot;</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据.</span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ;<br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>      	<span class="hljs-comment">// 关闭输出流,通知服务端,写出数据完毕</span><br>        socket.shutdownOutput();<br>        System.out.println(<span class="hljs-string">&quot;文件发送完毕&quot;</span>);<br>        <span class="hljs-comment">// 3. =====解析回写============</span><br>        InputStream in = socket.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] back = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">20</span>];<br>        in.read(back);<br>        System.out.println(<span class="hljs-keyword">new</span> String(back));<br>        in.close();<br>        <span class="hljs-comment">// ============================</span><br><br>        <span class="hljs-comment">// 4.释放资源</span><br>        socket.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>准备页面数据，web文件夹。</p>
<p>复制到我们Module中，比如复制到day08中</p>
<p><img src="/img/cphoto/net07.jpg" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    	ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8000</span>);<br>    	Socket socket = server.accept();<br>    	InputStream in = socket.getInputStream();<br>   	    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    	<span class="hljs-keyword">int</span> len = in.read(bytes);<br>    	System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,len));<br>    	socket.close();<br>    	server.close();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="/img/cphoto/net08.jpg" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>BufferedReader readWb = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>String requst = readWb.readLine();<br><span class="hljs-comment">//取出请求资源的路径</span><br>String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-comment">//去掉web前面的/</span><br>String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>System.out.println(path);<br></code></pre></td></tr></table></figure>

<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端  启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 创建ServerSocket 对象</span><br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        Socket socket = server.accept();<br>        <span class="hljs-comment">// 转换流读取浏览器的请求消息</span><br>        BufferedReader readWb = <span class="hljs-keyword">new</span><br>        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        String requst = readWb.readLine();<br>        <span class="hljs-comment">// 取出请求资源的路径</span><br>        String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-comment">// 去掉web前面的/</span><br>        String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 读取客户端请求的资源文件</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>        <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// 字节输出流,将文件写会客户端</span><br>        OutputStream out = socket.getOutputStream();<br>        <span class="hljs-comment">// 写入HTTP协议响应头,固定写法</span><br>        out.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>        out.write(<span class="hljs-string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());<br>        <span class="hljs-comment">// 必须要写入空行,否则浏览器不解析</span><br>        out.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>        <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>            out.write(bytes,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fis.close();<br>        out.close();<br>        readWb.close();	<br>        socket.close();<br>        server.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><strong>火狐</strong></li>
</ul>
<p><img src="/img/cphoto/net09.jpg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            Socket socket = server.accept();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Web(socket)).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Web</span><span class="hljs-params">(Socket socket)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.socket=socket;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>                BufferedReader readWb = <span class="hljs-keyword">new</span><br>                        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>                String requst = readWb.readLine();<br>                <span class="hljs-comment">//取出请求资源的路径</span><br>                String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br>                System.out.println(Arrays.toString(strArr));<br>                String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>                System.out.println(path);<br><br>                FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>                System.out.println(fis);<br>                <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>                <span class="hljs-comment">//向浏览器 回写数据</span><br>                OutputStream out = socket.getOutputStream();<br>                out.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>                out.write(<span class="hljs-string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());<br>                out.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>                <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>                    out.write(bytes,<span class="hljs-number">0</span>,len);<br>                &#125;<br>                fis.close();<br>                out.close();<br>                readWb.close();<br>                socket.close();<br>            &#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>图解：</p>
<h6 id><a href="#" class="headerlink" title></a><img src="/img/cphoto/net10.jpg" srcset="/img/loading.gif" lazyload></h6><h1 id="第四章-函数式接口"><a href="#第四章-函数式接口" class="headerlink" title="第四章 函数式接口"></a>第四章 函数式接口</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>函数式接口在Java中是指：有且仅有一个抽象方法的接口。<br>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>
<blockquote>
<p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p>
</blockquote>
<h2 id="1-2-格式"><a href="#1-2-格式" class="headerlink" title="1.2 格式"></a>1.2 格式</h2><p>只要确保接口中有且仅有一个抽象方法即可：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">abstract</span> 返回值类型 方法名称(<span class="hljs-type">可选参数信息</span>);</span><br><span class="hljs-class">// 其他非抽象方法内容</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure>

<p>由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="1-3-FunctionalInterface注解"><a href="#1-3-FunctionalInterface注解" class="headerlink" title="1.3 @FunctionalInterface注解"></a>1.3 @FunctionalInterface注解</h2><p>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注<br>解可用于一个接口的定义上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注<br>意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>
<h2 id="1-4-自定义函数式接口"><a href="#1-4-自定义函数式接口" class="headerlink" title="1.4 自定义函数式接口"></a>1.4 自定义函数式接口</h2><p>对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09FunctionalInterface</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义的函数式接口作为方法参数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doSomething</span>(<span class="hljs-params">MyFunctionalInterface inter</span>)</span> &#123;<br>   		inter.myMethod(); <span class="hljs-comment">// 调用自定义的函数式接口方法</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 调用使用函数式接口的方法</span><br>        doSomething(() ‐&gt; System.out.println(<span class="hljs-string">&quot;Lambda执行啦！&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第五章-函数式编程"><a href="#第五章-函数式编程" class="headerlink" title="第五章 函数式编程"></a>第五章 函数式编程</h1><p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。<br>下面我们做一个初探。</p>
<h2 id="2-1-Lambda的延迟执行"><a href="#2-1-Lambda的延迟执行" class="headerlink" title="2.1 Lambda的延迟执行"></a>2.1 Lambda的延迟执行</h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以<br>作为解决方案，提升性能。<br><em><strong>性能浪费的日志案例</strong></em><br>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。<br>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Logger</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, <span class="hljs-keyword">String</span> msg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        	System.out.<span class="hljs-built_in">println</span>(msg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>, msgA + msgB + msgC);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码存在问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方<br>法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p>
<blockquote>
<p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p>
</blockquote>
<p><strong>体验Lambda的更优写法</strong><br>使用Lambda必然需要一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageBuilder</span> </span>&#123;<br>	<span class="hljs-function">String <span class="hljs-title">buildMessage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后对 log 方法进行改造：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02LoggerLambda</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        	System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">buildMessage</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>, () ‐&gt; msgA + msgB + msgC );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p>
<p><strong>证明Lambda的延迟</strong><br>下面的代码可以通过结果进行验证：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03LoggerDelay</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        	System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">buildMessage</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>, () ‐&gt; &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Lambda执行！&quot;</span>);<br>            <span class="hljs-keyword">return</span> msgA + msgB + msgC;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。<br>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法<br>来完成。而是否调用其所在方法是在条件判断之后才执行的。</p>
<h2 id="2-2-使用Lambda作为参数和返回值"><a href="#2-2-使用Lambda作为参数和返回值" class="headerlink" title="2.2 使用Lambda作为参数和返回值"></a>2.2 使用Lambda作为参数和返回值</h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数<br>式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式<br>接口作为方法参数。</p>
<p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就<br>可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">startThread</span>(<span class="hljs-params">Runnable task</span>)</span> &#123;<br>    	<span class="hljs-keyword">new</span> Thread(task).start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	startThread(() ‐&gt; System.out.println(<span class="hljs-string">&quot;线程任务执行！&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一<br>个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import java.util.Arrays;<br>import java.util.Comparator;<br>public <span class="hljs-keyword">class</span> Demo06Comparator &#123;<br>    <span class="hljs-keyword">private</span> static Comparator&lt;String&gt; <span class="hljs-keyword">new</span><span class="hljs-constructor">Comparator()</span> &#123;<br>    	return (a, b) ‐&gt; b.length<span class="hljs-literal">()</span> ‐ a.length<span class="hljs-literal">()</span>;<br>    &#125;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        String<span class="hljs-literal">[]</span> <span class="hljs-built_in">array</span> = &#123; <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span> &#125;;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">array</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(<span class="hljs-built_in">array</span>, <span class="hljs-keyword">new</span><span class="hljs-constructor">Comparator()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">array</span>)</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中直接return一个Lambda表达式即可。</p>
<h1 id="第六章-常用函数式接口"><a href="#第六章-常用函数式接口" class="headerlink" title="第六章 常用函数式接口"></a>第六章 常用函数式接口</h1><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。<br>下面是最简单的几个接口及使用示例。</p>
<h2 id="3-1-Supplier接口"><a href="#3-1-Supplier接口" class="headerlink" title="3.1 Supplier接口"></a>3.1 Supplier接口</h2><p>java.util.function.Supplier<T> 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对<br>象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象<br>数据。</T></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08Supplier</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getString</span>(<span class="hljs-params">Supplier&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">function</span></span>)</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>.get();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-built_in">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        System.out.println(getString(() ‐&gt; msgA + msgB));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-2-练习：求数组元素最大值"><a href="#3-2-练习：求数组元素最大值" class="headerlink" title="3.2 练习：求数组元素最大值"></a>3.2 练习：求数组元素最大值</h2><p><strong>题目</strong><br>使用 Supplier 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型请使用<br>java.lang.Integer 类。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Test</span> &#123;</span><br>    <span class="hljs-comment">//定一个方法,方法的参数传递Supplier,泛型使用Integer</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;<br>    	<span class="hljs-keyword">return</span> sup.<span class="hljs-built_in">get</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">333</span>,<span class="hljs-number">23</span>&#125;;<br>        <span class="hljs-comment">//调用getMax方法,参数传递Lambda</span><br>        <span class="hljs-keyword">int</span> maxNum = <span class="hljs-built_in">getMax</span>(()‐&gt;&#123;<br>            <span class="hljs-comment">//计算数组的最大值</span><br>            <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;max)&#123;<br>                max = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>        &#125;);<br>        System.out.<span class="hljs-built_in">println</span>(maxNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-3-Consumer接口"><a href="#3-3-Consumer接口" class="headerlink" title="3.3 Consumer接口"></a>3.3 Consumer接口</h2><p>java.util.function.Consumer<T> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，<br>其数据类型由泛型决定。<br><strong>抽象方法：accept</strong><br>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。基本使用如：</T></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Consumer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">consumeString</span>(<span class="hljs-params">Consumer&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">function</span></span>)</span> &#123;<br>    	<span class="hljs-keyword">function</span>.accept(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	consumeString(s ‐&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，更好的写法是使用方法引用。<br><strong>默认方法：andThen</strong><br>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，<br>然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。下面是JDK的源代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">default Consumer&lt;T&gt; <span class="hljs-keyword">and</span><span class="hljs-constructor">Then(Consumer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">after</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>require<span class="hljs-constructor">NonNull(<span class="hljs-params">after</span>)</span>;<br>    return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>备注： java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出<br>NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p>
</blockquote>
<p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组<br>合的情况：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConsumerAndThen</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeString</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">String</span>&gt; one, Consumer&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        one.<span class="hljs-built_in">andThen</span>(two).<span class="hljs-built_in">accept</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">consumeString</span>(<br>            s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s.<span class="hljs-built_in">toUpperCase</span>()),<br>            s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s.<span class="hljs-built_in">toLowerCase</span>()));<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的<br>组合。<br>3.4 练习：格式化打印信息<br>题目<br>下面的字符串数组当中存有多条信息，请按照格式“ 姓名：XX。性别：XX。 ”的格式将信息打印出来。要求将打印姓<br>名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实<br>例，将两个 Consumer 接口按照顺序“拼接”到一起。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">public<span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br>	String[]<span class="hljs-built_in"> array </span>= &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConsumer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span> &#125;;<br>        <span class="hljs-built_in">printInfo</span>(s ‐&gt; System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;姓名：&quot;</span> + s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>]),<br>        s ‐&gt; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;。性别：&quot;</span> + s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;。&quot;</span>),<br>        array);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">String</span>&gt; one, Consumer&lt;<span class="hljs-keyword">String</span>&gt; two, <span class="hljs-keyword">String</span>[] array)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> info : array) &#123;<br>        	one.<span class="hljs-built_in">andThen</span>(two).<span class="hljs-built_in">accept</span>(info); <span class="hljs-comment">// 姓名：迪丽热巴。性别：女。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-5-Predicate接口"><a href="#3-5-Predicate接口" class="headerlink" title="3.5 Predicate接口"></a>3.5 Predicate接口</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<br>java.util.function.Predicate<T> 接口。<br><strong>抽象方法：test</strong><br>Predicate 接口中包含一个抽象方法： boolean test(T t) 。用于条件判断的场景：```</T></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo15PredicateTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Predicate&lt;<span class="hljs-built_in">String</span>&gt; predicate</span>)</span> &#123;<br>        <span class="hljs-built_in">boolean</span> veryLong = predicate.test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	method(s ‐&gt; s.length() &gt; <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。<br><strong>默认方法：and</strong><br>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实<br>现“并且”的效果时，可以使用default方法 and 。其JDK源码为：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;<br>    Objects<span class="hljs-selector-class">.requireNonNull</span>(other);<br>    return (t) ‐&gt; test(t) &amp;&amp; other<span class="hljs-selector-class">.test</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;<span class="hljs-keyword">String</span>&gt; one, Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isValid = one.<span class="hljs-built_in"><span class="hljs-keyword">and</span></span>(two).<span class="hljs-built_in">test</span>(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    	<span class="hljs-built_in">method</span>(s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;W&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h2><p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。JDK源码为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-function"><span class="hljs-title">or</span>(<span class="hljs-params">Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other</span>)</span> &#123;<br>    Objects.requireNonNull(other);<br>    <span class="hljs-keyword">return</span> (t) ‐&gt; test(t) || other.test(t);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不<br>变：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;<span class="hljs-keyword">String</span>&gt; one, Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isValid = one.<span class="hljs-built_in"><span class="hljs-keyword">or</span></span>(two).<span class="hljs-built_in">test</span>(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    	<span class="hljs-built_in">method</span>(s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;W&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>默认方法：negate</strong><br>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-function"><span class="hljs-title">negate</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> (t) ‐&gt; !test(t);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前<br>调用 negate 方法，正如 and 和 or 方法一样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo17PredicateNegate</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Predicate&lt;<span class="hljs-built_in">String</span>&gt; predicate</span>)</span> &#123;<br>        <span class="hljs-built_in">boolean</span> veryLong = predicate.negate().test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	method(s ‐&gt; s.length() &lt; <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-6-练习：集合信息筛选"><a href="#3-6-练习：集合信息筛选" class="headerlink" title="3.6 练习：集合信息筛选"></a>3.6 练习：集合信息筛选</h2><p><strong>题目</strong><br>数组当中有多条“姓名+性别”的信息如下，请通过 Predicate 接口的拼装将符合要求的字符串筛选到集合<br>ArrayList 中，需要同时满足两个条件：</p>
<ol>
<li>必须为女生；</li>
<li>姓名为4个字。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPredicate</span> </span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	<span class="hljs-built_in">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span>, <span class="hljs-string">&quot;赵丽颖,女&quot;</span> &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPredicate</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span>, <span class="hljs-string">&quot;赵丽颖,女&quot;</span> &#125;;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-built_in">filter</span>(array,<br>        s ‐&gt; <span class="hljs-string">&quot;女&quot;</span>.<span class="hljs-built_in">equals</span>(s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]),<br>        s ‐&gt; s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>() == <span class="hljs-number">4</span>);<br>        System.out.<span class="hljs-built_in">println</span>(list);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] array, Predicate&lt;<span class="hljs-keyword">String</span>&gt; one,</span></span><br><span class="hljs-params"><span class="hljs-function">        Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>            List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> info : array) &#123;<br>                <span class="hljs-keyword">if</span> (one.<span class="hljs-built_in"><span class="hljs-keyword">and</span></span>(two).<span class="hljs-built_in">test</span>(info)) &#123;<br>                    list.<span class="hljs-built_in">add</span>(info);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-7-Function接口"><a href="#3-7-Function接口" class="headerlink" title="3.7 Function接口"></a>3.7 Function接口</h2><p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，<br>后者称为后置条件。<br><strong>抽象方法：apply</strong><br>Function 接口中最主要的抽象方法为： R apply(T t) ，根据类型T的参数获取类型R的结果。<br>使用的场景例如：将 String 类型转换为 Integer 类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11FunctionApply</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"><span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, Integer&gt; <span class="hljs-keyword">function</span></span>)</span> &#123;<br>        int num = <span class="hljs-keyword">function</span>.apply(<span class="hljs-string">&quot;10&quot;</span>);<br>        System.out.println(num + <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	method(s ‐&gt; Integer.parseInt(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，最好是通过方法引用的写法。<br><strong>默认方法：andThen</strong><br>Function 接口中有一个默认的 andThen 方法，用来进行组合操作。JDK源代码如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-built_in">Function</span>&lt;T, V&gt; <span class="hljs-function"><span class="hljs-title">andThen</span>(<span class="hljs-params"><span class="hljs-built_in">Function</span>&lt;? <span class="hljs-built_in">super</span> R, ? <span class="hljs-keyword">extends</span> V&gt; after</span>)</span> &#123;<br>    Objects.requireNonNull(after);<br>    <span class="hljs-keyword">return</span> (T t) ‐&gt; after.apply(apply(t));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">function</span>.<span class="hljs-keyword">Function</span>;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo12FunctionAndThen &#123;<br>    private static <span class="hljs-type">void</span> <span class="hljs-keyword">method</span>(<span class="hljs-keyword">Function</span>&lt;String, <span class="hljs-type">Integer</span>&gt; one, <span class="hljs-keyword">Function</span>&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt; two) &#123;<br>        <span class="hljs-type">int</span> num = one.andThen(two).apply(&quot;10&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(num + <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    	<span class="hljs-keyword">method</span>(str‐&gt;<span class="hljs-type">Integer</span>.parseInt(str)+<span class="hljs-number">10</span>, i ‐&gt; i *= <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一<br>起。<br>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p>
<h2 id="3-8-练习：自定义函数模型拼接"><a href="#3-8-练习：自定义函数模型拼接" class="headerlink" title="3.8 练习：自定义函数模型拼接"></a>3.8 练习：自定义函数模型拼接</h2><p>题目<br>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：<br>String str = “赵丽颖,20”;</p>
<ol>
<li>将字符串截取数字年龄部分，得到字符串；</li>
<li>将上一步的字符串转换成为int类型的数字；</li>
<li>将上一步的int数字累加100，得到结果int数字。</li>
</ol>
<p>解答</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">public</span> class DemoFunction &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;赵丽颖,20&quot;</span>;<br>        <span class="hljs-built_in">int</span> age = getAgeNum(<span class="hljs-built_in">str</span>, s ‐&gt; s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>],<br>        s ‐&gt;Integer.parseInt(s),<br>        n ‐&gt; n += <span class="hljs-number">100</span>);<br>        System.out.<span class="hljs-built_in">println</span>(age);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> getAgeNum(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>, Function&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; one,<br>        Function&lt;<span class="hljs-keyword">String</span>, Integer&gt; two,<br>        Function&lt;Integer, Integer&gt; three) &#123;<br>        <span class="hljs-keyword">return</span> one.andThen(two).andThen(three).apply(<span class="hljs-built_in">str</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第七章-Stream流"><a href="#第七章-Stream流" class="headerlink" title="第七章 Stream流"></a>第七章 Stream流</h1><p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带<br>来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</p>
<h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p><strong>传统集合的多步遍历代码</strong><br>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元<br>素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> class Demo01ForEach &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : list) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(name);<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。<br><strong>循环遍历的弊端</strong><br>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行<br>了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p>
<ul>
<li><p>for循环的语法就是“怎么做”</p>
</li>
<li><p>for循环的循环体才是“做什么”</p>
<p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。</p>
</li>
</ul>
<p>试想一下，如果希望对集合中的元素进行筛选过滤：</p>
<ol>
<li>将集合A根据条件一过滤为子集B；</li>
<li>然后再根据条件二过滤为子集C。</li>
</ol>
<p>那怎么办？在Java 8之前的做法可能为：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo02NormalFilter &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>        List&lt;String&gt; zhangList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : list) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">name</span>.startsWith(&quot;张&quot;)) &#123;<br>            	zhangList.<span class="hljs-keyword">add</span>(<span class="hljs-type">name</span>);<br>            &#125;<br>    	&#125;<br>        List&lt;String&gt; shortList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : zhangList) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">name</span>.length() == <span class="hljs-number">3</span>) &#123;<br>                shortList.<span class="hljs-keyword">add</span>(<span class="hljs-type">name</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : shortList) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码中含有三个循环，每一个作用不同：</p>
<ol>
<li>首先筛选所有姓张的人；</li>
<li>然后筛选名字有三个字的人；</li>
<li>最后进行对结果进行打印输出。<br>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</li>
</ol>
<p><strong>Stream的更优写法</strong><br>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo03StreamFilter &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>            list.stream()<br>                .<span class="hljs-keyword">filter</span>(s ‐&gt; s.startsWith(&quot;张&quot;))<br>                .<span class="hljs-keyword">filter</span>(s ‐&gt; s.length() == <span class="hljs-number">3</span>)<br>                .<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印。代码<br>中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p>
<h2 id="1-2-流式思想概述"><a href="#1-2-流式思想概述" class="headerlink" title="1.2 流式思想概述"></a>1.2 流式思想概述</h2><p>注意：请暂时忘记对传统IO流的固有印象！<br>整体来看，流式思想类似于工厂车间的“生产流水线”</p>
<p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤<br>方案，然后再按照方案去执行它。<br><img src="/img/cphoto/flow01.jpg" srcset="/img/loading.gif" lazyload></p>
<p>过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。<br>这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 count执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p>
<blockquote>
<p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p>
</blockquote>
<p>Stream（流）是一个来自数据源的元素队列</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组 等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><p>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p>
</li>
<li><p>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭<br>代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</p>
</li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结  果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以  像链条一样排列，变成一个管道。</p>
<h2 id="1-3-获取流"><a href="#1-3-获取流" class="headerlink" title="1.3 获取流"></a>1.3 获取流</h2><p>java.util.stream.Stream<T> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）获取一个流非常简单，有以下几种常用的方式：</T></p>
<ul>
<li>所有的 Collection 集合都可以通过 stream 默认方法获取流；</li>
<li>Stream 接口的静态方法 of 可以获取数组对应的流。</li>
</ul>
<p><strong>根据Collection获取流</strong><br>首先， java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream1 = list.<span class="hljs-built_in">stream</span>();<br>        Set&lt;<span class="hljs-keyword">String</span>&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream2 = set.<span class="hljs-built_in">stream</span>();<br>        Vector&lt;<span class="hljs-keyword">String</span>&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream3 = vector.<span class="hljs-built_in">stream</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>根据Map获取流</strong><br>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        Map&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; keyStream = map.<span class="hljs-built_in">keySet</span>().<span class="hljs-built_in">stream</span>();<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; valueStream = map.<span class="hljs-built_in">values</span>().<span class="hljs-built_in">stream</span>();<br>        <span class="hljs-built_in">Stream</span>&lt;Map.Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt;&gt; entryStream = map.<span class="hljs-built_in">entrySet</span>().<span class="hljs-built_in">stream</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>根据数组获取流</strong><br>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法<br>of ，使用很简单：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张翠山&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;张一元&quot;</span> &#125;;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p> 备注： of 方法的参数其实是一个可变参数，所以支持数组。</p>
</blockquote>
<h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p>
<ul>
<li><p>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方<br>法均为延迟方法。）</p>
</li>
<li><p>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调<br>用。本小节中，终结方法包括 count 和 forEach 方法。</p>
</li>
</ul>
<blockquote>
<p>备注：本小节之外的更多方法，请自行参考API文档。</p>
</blockquote>
<p><strong>逐一处理：forEach</strong><br>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure>

<p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。<br><strong>复习Consumer接口</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">java.util.function.Consumer&lt;<span class="hljs-built_in">T</span>&gt;接口是一个消费型接口。<br>Consumer接口中包含抽象方法void accept(<span class="hljs-built_in">T</span> <span class="hljs-built_in">t</span>)，意为消费一个指定泛型的数据。<br></code></pre></td></tr></table></figure>

<p><strong>基本使用：</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamForEach</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        stream.forEach(name‐&gt; System.out.<span class="hljs-built_in">println</span>(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>过滤：filter</strong></p>
<p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Stream</span>&lt;<span class="hljs-type">T</span>&gt; filter(<span class="hljs-type">Predicate</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; predicate);<br></code></pre></td></tr></table></figure>

<p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p>
<p><strong>复习Predicate接口</strong><br>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure>

<p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法<br>将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。<br><strong>基本使用</strong><br>Stream流中的 filter 方法基本使用的代码如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07StreamFilter</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。<br><strong>映射：map</strong><br>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-keyword">map</span>(<span class="hljs-built_in">Function</span>&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> R&gt; mapper);<br></code></pre></td></tr></table></figure>

<p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<p><strong>复习Function接口</strong><br>此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">R apply(<span class="hljs-built_in">T</span> <span class="hljs-built_in">t</span>);<br><br></code></pre></td></tr></table></figure>

<p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。<br><strong>基本使用</strong><br>Stream流中的 map 方法基本使用的代码如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08StreamMap</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;Integer&gt; result = original.<span class="hljs-built_in">map</span>(str‐&gt;Integer.<span class="hljs-built_in">parseInt</span>(str));<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>

<p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。<br><strong>统计个数：count</strong><br>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09StreamCount</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>

<h2 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h2><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br><br></code></pre></td></tr></table></figure>

<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10StreamLimit</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">limit</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>跳过前几个：skip</strong><br>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure>

<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11StreamSkip</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">skip</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 1</span><br>    &#125;<br>&#125;<br>	<br></code></pre></td></tr></table></figure>

<p><strong>组合：concat</strong><br>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p>
<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="xml">static <span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> Stream<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> concat(Stream</span><span class="php"><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; a, Stream<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; b)</span><br><span class="php"></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p>
</blockquote>
<p>该方法的基本使用代码如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamConcat</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamA = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamB = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张翠山&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(streamA, streamB);<br>    &#125;<br>&#125;<br>		<br></code></pre></td></tr></table></figure>

<h2 id="1-5-练习：集合元素处理（传统方式）"><a href="#1-5-练习：集合元素处理（传统方式）" class="headerlink" title="1.5 练习：集合元素处理（传统方式）"></a>1.5 练习：集合元素处理（传统方式）</h2><p><strong>题目</strong><br>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以下若干操作步骤：</p>
<ol>
<li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li>
<li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li>
<li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li>
<li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li>
<li>将两个队伍合并为一个队伍；存储到一个新集合中。</li>
<li>根据姓名创建 Person 对象；存储到一个新集合中。</li>
<li>打印整个队伍的Person对象信息。</li>
</ol>
<p>两个队伍（集合）的代码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> class DemoArrayListNames &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">//第一支队伍</span><br>        ArrayList&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;宋远桥&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;苏星河&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;石破天&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;石中玉&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;老子&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;庄子&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;洪七公&quot;</span>);<br>        <span class="hljs-comment">//第二支队伍</span><br>        ArrayList&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;古力娜扎&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;赵丽颖&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;尼古拉斯赵四&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张天爱&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张二狗&quot;</span>);<br>        <span class="hljs-comment">// ....</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>而 Person 类的代码为：    </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	<span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解答<br>既然使用传统的for循环写法，那么：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoArrayListNames</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 第一个队伍只要名字为3个字的成员姓名；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; oneA = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">one</span>) &#123;<br>            <span class="hljs-keyword">if</span> (name.length() == <span class="hljs-number">3</span>) &#123;<br>            	oneA.add(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 第一个队伍筛选之后只要前3个人；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; oneB = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        	oneB.add(oneA.<span class="hljs-keyword">get</span>(i));<br>        &#125;<br>        <span class="hljs-comment">// 第二个队伍只要姓张的成员姓名；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; twoA = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">two</span>) &#123;<br>            <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)) &#123;<br>            	twoA.add(name);<br>        	&#125;<br>        &#125;<br>        <span class="hljs-comment">// 第二个队伍筛选之后不要前2个人；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; twoB = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">2</span>; i &lt; twoA.size(); i++) &#123;<br>        	twoB.add(twoA.<span class="hljs-keyword">get</span>(i));<br>        &#125;<br>        <span class="hljs-comment">// 将两个队伍合并为一个队伍；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; totalNames = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        totalNames.addAll(oneB);<br>        totalNames.addAll(twoB);<br>        <span class="hljs-comment">// 根据姓名创建Person对象；</span><br>        List&lt;Person&gt; totalPersonList = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">totalNames</span>) &#123;<br>        	totalPersonList.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name));<br>        &#125;<br>        <span class="hljs-comment">// 打印整个队伍的Person对象信息。</span><br>        <span class="hljs-keyword">for</span> (Person person : <span class="hljs-type">totalPersonList</span>) &#123;<br>        	System.out.println(person);<br>        &#125;		<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery">Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;石破天&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="1-6-练习：集合元素处理（Stream方式）"><a href="#1-6-练习：集合元素处理（Stream方式）" class="headerlink" title="1.6 练习：集合元素处理（Stream方式）"></a>1.6 练习：集合元素处理（Stream方式）</h2><p><strong>题目</strong><br>将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变， Person 类的定义也不变</p>
<p>解答</p>
<p>等效的Stream流式处理代码为：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoStreamNames</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 第一个队伍只要名字为3个字的成员姓名；</span><br>        <span class="hljs-comment">// 第一个队伍筛选之后只要前3个人；</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamOne = one.<span class="hljs-built_in">stream</span>().<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">length</span>() == <span class="hljs-number">3</span>).<span class="hljs-built_in">limit</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 第二个队伍只要姓张的成员姓名；</span><br>        <span class="hljs-comment">// 第二个队伍筛选之后不要前2个人；</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamTwo = two.<span class="hljs-built_in">stream</span>().<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>)).<span class="hljs-built_in">skip</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 将两个队伍合并为一个队伍；</span><br>        <span class="hljs-comment">// 根据姓名创建Person对象；</span><br>        <span class="hljs-comment">// 打印整个队伍的Person对象信息。</span><br>        <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(streamOne, 	streamTwo).<span class="hljs-built_in">map</span>(Person::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行效果完全一样：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xquery">Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;石破天&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person<span class="hljs-built_in">&#123;name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第八章-方法引用"><a href="#第八章-方法引用" class="headerlink" title="第八章 方法引用"></a>第八章 方法引用</h1><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑<br>一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p>
<h2 id="2-1-冗余的Lambda场景"><a href="#2-1-冗余的Lambda场景" class="headerlink" title="2.1 冗余的Lambda场景"></a>2.1 冗余的Lambda场景</h2><p>来看一个简单的函数式接口以应用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01PrintSimple</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printString</span>(<span class="hljs-params">Printable data</span>)</span> &#123;<br>    	data.print(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	printString(s ‐&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 Printable 的具体操作方案为：拿到String（类型可推导，所以可省略）数据后，在控制台中输出它。</p>
<p>2## .2 问题分析<br>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out对象中的 println(String) 方法。既然Lambda希望做的事情就是调用 println(String) 方法，那何必自己手动调用呢？</p>
<h2 id="2-3-用方法引用改进代码"><a href="#2-3-用方法引用改进代码" class="headerlink" title="2.3 用方法引用改进代码"></a>2.3 用方法引用改进代码</h2><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02PrintRef</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>    	data.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    	<span class="hljs-built_in">printString</span>(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>请注意其中的双冒号 :: 写法，这被称为“方法引用”，而双冒号是一种新的语法。</p>
<h2 id="2-4-方法引用符"><a href="#2-4-方法引用符" class="headerlink" title="2.4 方法引用符"></a>2.4 方法引用符</h2><p>双冒号 :: 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方<br>法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>例如上例中， System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于printString 方法的函数式接口参数，对比下面两种写法，完全等效：</p>
<ul>
<li>Lambda表达式写法： s -&gt; System.out.println(s);</li>
<li>方法引用写法： System.out::println</li>
</ul>
<p>1, 第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。<br> 2, 第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一  样，而第二种方法引用的写法复用了已有方案，更加简洁。<br>  注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>
<p><strong>推导与省略</strong><br>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都<br>将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。<br>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。<br>下面这段代码将会调用 println 方法的不同重载形式，将函数式接口改为int类型的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PrintableInteger</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03PrintOverload</span> &#123;</span>		<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInteger</span><span class="hljs-params">(PrintableInteger data)</span> </span>&#123;<br>        data.<span class="hljs-built_in">print</span>(<span class="hljs-number">1024</span>);<br>    &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>   		<span class="hljs-built_in">printInteger</span>(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这次方法引用将会自动匹配到 println(int) 的重载形式。</p>
<h2 id="2-5-通过对象名引用成员方法"><a href="#2-5-通过对象名引用成员方法" class="headerlink" title="2.5 通过对象名引用成员方法"></a>2.5 通过对象名引用成员方法</h2><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodRefObject</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printUpperCase</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str</span>)</span> &#123;<br>    	System.out.println(str.toUpperCase());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>函数式接口仍然定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的Lambda的时候，已经具有了<br>MethodRefObject 类的对象实例，则可以通过对象名引用成员方法，代码为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04MethodRef</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printString</span>(<span class="hljs-params">Printable lambda</span>)</span> &#123;<br>    	lambda.print(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        MethodRefObject obj = <span class="hljs-keyword">new</span> MethodRefObject();<br>        printString(obj::printUpperCase);<br>    &#125;<br>&#125;		<br></code></pre></td></tr></table></figure>

<h2 id="2-6-通过类名称引用静态方法"><a href="#2-6-通过类名称引用静态方法" class="headerlink" title="2.6 通过类名称引用静态方法"></a>2.6 通过类名称引用静态方法</h2><p>由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calcable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>第一种写法是使用Lambda表达式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05Lambda</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">int num, Calcable lambda</span>)</span> &#123;<br>   		System.out.println(lambda.calc(num));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	method(‐<span class="hljs-number">10</span>, n ‐&gt; <span class="hljs-built_in">Math</span>.abs(n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是使用方法引用的更好写法是：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06MethodRef</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>    	System.out.<span class="hljs-built_in">println</span>(lambda.<span class="hljs-built_in">calc</span>(num));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    	<span class="hljs-built_in">method</span>(‐<span class="hljs-number">10</span>, Math::abs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： n -&gt; Math.abs(n)</li>
<li>方法引用： Math::abs</li>
</ul>
<h2 id="2-7-通过super引用成员方法"><a href="#2-7-通过super引用成员方法" class="headerlink" title="2.7 通过super引用成员方法"></a>2.7 通过super引用成员方法</h2><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Greetable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>然后是父类 Human 的内容：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Human &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> sayHello() &#123;<br>    	<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Hello!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后是子类 Man 的内容，其中使用了Lambda的写法：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Man extends Human <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    @Override</span><br><span class="hljs-comment">    public void sayHello() &#123;</span><br><span class="hljs-comment">    	System.out.println(&quot;大家好,我是Man!&quot;);</span><br><span class="hljs-comment">    &#125;</span><br>    <span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(Greetable g)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    	g.greet();</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    //调用method方法,使用Lambda表达式</span></span><br><span class="hljs-comment"><span class="hljs-function">    method(()‐&gt;&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">        //创建Human对象,调用sayHello方法</span></span><br><span class="hljs-comment"><span class="hljs-function">        new Human().sayHello();</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span>);</span><br>    <span class="hljs-comment">//简化Lambda</span><br>    <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(()</span>‐&gt;<span class="hljs-title">new</span> <span class="hljs-title">Human</span><span class="hljs-params">()</span>.<span class="hljs-title">sayHello</span><span class="hljs-params">()</span>);</span><br>    <span class="hljs-comment">//使用super关键字代替父类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(()</span>‐&gt;<span class="hljs-title">super</span>.<span class="hljs-title">sayHello</span><span class="hljs-params">()</span>);</span><br>    &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Greetable g</span>)</span>&#123;<br>    	g.greet();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>&#123;<br>    	method(<span class="hljs-built_in">super</span>::sayHello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：<br>Lambda表达式： () -&gt; super.sayHello()<br>方法引用： super::sayHello</p>
<h2 id="2-8-通过this引用成员方法"><a href="#2-8-通过this引用成员方法" class="headerlink" title="2.8 通过this引用成员方法"></a>2.8 通过this引用成员方法</h2><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Richable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是一个丈夫 Husband 类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    	lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	marry(() ‐&gt; System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>开心方法 beHappy 调用了结婚方法 marry ，后者的参数为函数式接口 Richable ，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 Husband 丈夫类进行修改：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">buyHouse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    	lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	marry(() ‐&gt; <span class="hljs-built_in">this</span>.buyHouse());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">buyHouse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    	lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	marry(<span class="hljs-built_in">this</span>::buyHouse);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： () -&gt; this.buyHouse()</li>
<li>方法引用： this::buyHouse</li>
</ul>
<h2 id="2-9-类的构造器引用"><a href="#2-9-类的构造器引用" class="headerlink" title="2.9 类的构造器引用"></a>2.9 类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。首先是一个简单的 Person 类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    	<span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后是用来创建 Person 对象的函数式接口：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>	Person buildPerson(<span class="hljs-keyword">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>要使用这个函数式接口，可以通过Lambda表达式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Lambda</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, PersonBuilder buil	der</span>)</span> &#123;<br>    System.out.println(builder.buildPerson(name).getName());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="hljs-keyword">new</span> Person(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是通过构造器引用，有更好的写法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConstructorRef</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, PersonBuilder builder</span>)</span> &#123;<br>    	System.out.println(builder.buildPerson(name).getName());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    	printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-attr">Person</span>::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： name -&gt; new Person(name)</li>
<li>方法引用： Person::new</li>
</ul>
<h2 id="2-10-数组的构造器引用"><a href="#2-10-数组的构造器引用" class="headerlink" title="2.10 数组的构造器引用"></a>2.10 数组的构造器引用</h2><p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，<br>需要一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArrayBuilder</span> </span>&#123;<br>	<span class="hljs-keyword">int</span>[] buildArray(<span class="hljs-keyword">int</span> length);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在应用该接口的时候，可以通过Lambda表达式：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class Demo11ArrayInitRef &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> int[] initArray(int length, ArrayBuilder builder) &#123;<br>    <span class="hljs-built_in">	return </span>builder.buildArray(length);<br>    &#125;<br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br>    	int[]<span class="hljs-built_in"> array </span>= initArray(10, length ‐&gt;<span class="hljs-built_in"> new </span>int[length]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是更好的写法是使用数组的构造器引用：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12ArrayInitRef</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">initArray</span>(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-built_in">buildArray</span>(length);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] array = <span class="hljs-built_in">initArray</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： length -&gt; new int[length]</li>
<li>方法引用： int[]::new</li>
</ul>
<h1 id="第九章-Junit反射注解"><a href="#第九章-Junit反射注解" class="headerlink" title="第九章 Junit反射注解"></a>第九章 Junit反射注解</h1><pre><code>1. Junit单元测试
2. 反射
3. 注解
</code></pre>
<h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><pre><code>* 测试分类：
    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。
    2. 白盒测试：需要写代码的。关注程序具体的执行流程。

* Junit使用：白盒测试
    * 步骤：
        1. 定义一个测试类(测试用例)
            * 建议：
                * 测试类名：被测试的类名Test        CalculatorTest
                * 包名：xxx.xxx.xx.test        cn.itcast.test

        2. 定义测试方法：可以独立运行
            * 建议：
                * 方法名：test测试的方法名        testAdd()  
                * 返回值：void
                * 参数列表：空参

        3. 给方法加@Test
        4. 导入junit依赖环境

    * 判定结果：
        * 红色：失败
        * 绿色：成功
        * 一般我们会使用断言操作来处理结果
            * Assert.assertEquals(期望的结果,运算的结果);

    * 补充：
        * @Before:
            * 修饰的方法会在测试方法之前被自动执行
        * @After:
            * 修饰的方法会在测试方法执行之后自动被执行
</code></pre>
<h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
    * 好处：
        1. 可以在程序运行过程中，操作这些对象。
        2. 可以解耦，提高程序的可扩展性。


* 获取Class对象的方式：
    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象
        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
    2. 类名.class：通过类名的属性class获取
        * 多用于参数的传递
    3. 对象.getClass()：getClass()方法在Object类中定义着。
        * 多用于对象的获取字节码的方式

    * 结论：
        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。


* Class对象功能：
    * 获取功能：
        1. 获取成员变量们
            * Field[] getFields() ：获取所有public修饰的成员变量
            * Field getField(String name)   获取指定名称的 public修饰的成员变量

            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
            * Field getDeclaredField(String name)  
        2. 获取构造方法们
            * Constructor&lt;?&gt;[] getConstructors()  
            * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)  

            * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)  
            * Constructor&lt;?&gt;[] getDeclaredConstructors()  
        3. 获取成员方法们：
            * Method[] getMethods()  
            * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)  

            * Method[] getDeclaredMethods()  
            * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)  

        4. 获取全类名    
            * String getName()  


* Field：成员变量
    * 操作：
        1. 设置值
            * void set(Object obj, Object value)  
        2. 获取值
            * get(Object obj) 

        3. 忽略访问权限修饰符的安全检查
            * setAccessible(true):暴力反射



* Constructor:构造方法
    * 创建对象：
        * T newInstance(Object... initargs)  

        * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法


* Method：方法对象
    * 执行方法：
        * Object invoke(Object obj, Object... args)  

    * 获取方法名称：
        * String getName:获取方法名


* 案例：
    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法
        * 实现：
            1. 配置文件
            2. 反射
        * 步骤：
            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
            2. 在程序中加载读取配置文件
            3. 使用反射技术来加载类文件进内存
            4. 创建对象
            5. 执行方法
</code></pre>
<h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><pre><code>* 概念：说明程序的。给计算机看的
* 注释：用文字描述程序的。给程序员看的

* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
* 概念描述：
    * JDK1.5之后的新特性
    * 说明程序的
    * 使用注解：@注解名称
</code></pre>
<p>​    </p>
<pre><code>* 作用分类：
    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】
    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】


* JDK中预定义的一些注解
    * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的
    * @Deprecated：该注解标注的内容，表示已过时
    * @SuppressWarnings：压制警告
        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)

* 自定义注解
    * 格式：
        元注解
        public @interface 注解名称&#123;
            属性列表;
        &#125;

    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口
        * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125;

    * 属性：接口中的抽象方法
        * 要求：
            1. 属性的返回值类型有下列取值
                * 基本数据类型
                * String
                * 枚举
                * 注解
                * 以上类型的数组

            2. 定义了属性，在使用时需要给属性赋值
                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。
                3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略
    
    * 元注解：用于描述注解的注解
        * @Target：描述注解能够作用的位置
            * ElementType取值：
                * TYPE：可以作用于类上
                * METHOD：可以作用于方法上
                * FIELD：可以作用于成员变量上
        * @Retention：描述注解被保留的阶段
            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
        * @Documented：描述注解是否被抽取到api文档中
        * @Inherited：描述注解是否被子类继承


* 在程序使用(解析)注解：获取注解中定义的属性值
    1. 获取注解定义的位置的对象  （Class，Method,Field）
    2. 获取指定的注解
        * getAnnotation(Class)
        //其实就是在内存中生成了一个该注解接口的子类实现对象

                public class ProImpl implements Pro&#123;
                    public String className()&#123;
                        return &quot;cn.itcast.annotation.Demo1&quot;;
                    &#125;
                    public String methodName()&#123;
                        return &quot;show&quot;;
                    &#125;
                &#125;
    3. 调用注解中的抽象方法获取配置的属性值


* 案例：简单的测试框架
* 小结：
    1. 以后大多数时候，我们会使用注解，而不是自定义注解
    2. 注解给谁用？
        1. 编译器
        2. 给解析程序用
    3. 注解不是程序的一部分，可以理解为注解就是一个标签
</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/09/21/mysql/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">mysql</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/09/18/java%E5%9F%BA%E7%A4%8E07-%E6%96%87%E4%BB%B6%E7%B1%BB/">
                        <span class="hidden-mobile">java基礎07-文件类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"fc36e17008bd1e3e898d","clientSecret":"d9d3bc7feb2b8abbb2d05b43b2d16a1d19c9bba2","repo":"cylinclinv.github.io","owner":"cylinclinv","admin":["cylinclinv"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":true,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'd4acf7af38a10a50b1945137d618c97e'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>clyde</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
