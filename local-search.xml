<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>红黑树笔记</title>
    <link href="/2019/05/01/rbtree%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/05/01/rbtree%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/cphoto/rbtree01.jpg" alt="红黑树笔记图"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim命令</title>
    <link href="/2017/10/04/Vim%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/10/04/Vim%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vim命令合集"><a href="#Vim命令合集" class="headerlink" title="Vim命令合集"></a>Vim命令合集</h1><h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</p><h2 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h2><p>在命令行窗口中输入以下命令即可<br>vim 直接启动vim<br>vim filename 打开vim并创建名为filename的文件</p><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><p>打开单个文件<br>vim file<br>同时打开多个文件<br>vim file1 file2 file3 …<br>在vim窗口中打开一个新文件<br>:open file<br>在新窗口中打开文件<br>:split file<br>切换到下一个文件<br>:bn<br>切换到上一个文件<br>:bp<br>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。<br>:args<br>打开远程文件，比如ftp或者share folder<br>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a><br>:e \qadrive\test\1.txt</p><h2 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h2><p>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i键进入） 左下角显示–INSERT–<br>可视模式（不知道如何进入） 左下角显示–VISUAL–</p><h2 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h2><p>% 括号匹配</p><h2 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h2><p>i 在当前位置生前插入<br>I 在当前行首插入<br>a 在当前位置后插入<br>A 在当前行尾插入<br>o 在当前行之后插入一行<br>O 在当前行之前插入一行</p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>/text　　查找text，按n健查找下一个，按N健查找前一个。<br>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。<br>vim中有一些特殊字符在查找时需要转义　　.<em>[]^%/?~$<br>:set ignorecase　　忽略大小写的查找<br>:set noignorecase　　不忽略大小写的查找<br>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按</em>或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。<br>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。<br>:set nohlsearch　　关闭高亮搜索显示<br>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。<br>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。<br>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>ra 将当前字符替换为a，当期字符即光标所在字符。<br>s/old/new/ 用old替换new，替换当前行的第一个匹配<br>s/old/new/g 用old替换new，替换当前行的所有匹配<br>%s/old/new/ 用old替换new，替换所有行的第一个匹配<br>%s/old/new/g 用old替换new，替换整个文件的所有匹配<br>:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。<br>ddp 交换光标所在行和其下紧邻的一行。</p><h2 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h2><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符<br>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。<br>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以## 代替l命令。<br>b 向后移动一个单词 2b 向后移动2个单词<br>e，同w，只不过是光标停在单词尾部<br>ge，同b，光标停在单词尾部。<br>^ 移动到本行第一个非空白字符上。<br>0（数字0）移动到本行第一个字符上，<br><HOME> 移动到本行第一个字符。同0健。<br>$ 移动到行尾 3$ 移动到下面3行的行尾<br>gg 移动到文件头。 = [[<br>G（shift + g） 移动到文件尾。 = ]]<br>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。<br>F 同f，反向查找。<br>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。<br>Ctrl + e 向下滚动一行<br>Ctrl + y 向上滚动一行<br>Ctrl + d 向下滚动半屏<br>Ctrl + u 向上滚动半屏<br>Ctrl + f 向下滚动一屏<br>Ctrl + b 向上滚动一屏</HOME></Esc></p><h2 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h2><p>u 撤销（Undo）<br>U 撤销对整行的操作<br>Ctrl + r 重做（Redo），即撤销的撤销。</p><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><p>x 删除当前字符<br>3x 删除当前光标开始向后三个字符<br>X 删除当前字符的前一个字符。X=dh<br>dl 删除当前字符， dl=x<br>dh 删除前一个字符<br>dd 删除当前行<br>dj 删除上一行<br>dk 删除下一行<br>10d 删除当前行开始的10行。<br>D 删除当前字符至行尾。D=d$<br>d$ 删除当前字符之后的所有字符（本行）<br>kdgg 删除当前行之前所有行（不包括当前行）<br>jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）<br>:1,10d 删除1-10行<br>:11,$d 删除11行及以后所有的行<br>:1,$d 删除所有行<br>J(shift + j)　　删除两行之间的空行，实际上是合并两行。</p><h2 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h2><p>yy 拷贝当前行<br>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。<br>p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。<br>shift+p 在当前行前粘贴<br>:1,10 co 20 将1-10行插入到第20行之后。<br>:1,$ co $ 将整个文件复制一份并添加到文件尾部。<br>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制<br>ddp交换当前行和其下一行<br>xp交换当前字符和其后一个字符</p><h2 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h2><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切<br>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴<br>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。<br>:1, 10 m 20 将第1-10行移动到第20行之后。</p><h2 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h2><p>:wq 保存并退出<br>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件。</p><h2 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h2><p>:split或new 打开一个新窗口，光标停在顶层的窗口上<br>:split file或:new file 用新窗口打开文件<br>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。<br>Ctrl+ww 移动到下一个窗口<br>Ctrl+wj 移动到下方的窗口<br>Ctrl+wk 移动到上方的窗口</p><h2 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h2><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。<br>:q 如果是最后一个被关闭的窗口，那么将退出vim。<br>ZZ 保存并退出。<br>关闭所有窗口，只保留当前窗口<br>:only</p><h2 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h2><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。<br>执行shell命令<br>:!command<br>:!ls 列出当前目录下文件<br>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。<br>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。<br>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p><h2 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h2><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#<br>3,5 s/^/#/g 注释第3-5行<br>3,5 s/^#//g 解除3-5行的注释<br>1,$ s/^/#/g 注释整个文档。<br>:%s/^/#/g 注释整个文档，此法更快。</p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>:help or F1 显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起<br>:help <Esc> 特殊键的帮助用&lt;&gt;扩起<br>:help -t Vim启动参数的帮助用-<br>：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</Esc></Esc></p><h2 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h2><p>. 重复前一次命令<br>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看<br>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。<br>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。<br>Vim教程<br>在Unix系统上<br>$ vimtutor<br>在Windows系统上<br>:help tutor</p><p>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p><h1 id="vi命令"><a href="#vi命令" class="headerlink" title="vi命令"></a>vi命令</h1><p>vi使用方法详细介绍</p><p>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 </p><h2 id="1、vi的基本概念"><a href="#1、vi的基本概念" class="headerlink" title="1、vi的基本概念"></a>1、vi的基本概念</h2><p>　　基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：<br>    1) 命令行模式command mode）<br>　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>    2) 插入模式（Insert mode）<br>　　只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>    3) 底行模式（last line mode）<br>　　将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 </p><blockquote><p>不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 </p></blockquote><h2 id="2、vi的基本操作"><a href="#2、vi的基本操作" class="headerlink" title="2、vi的基本操作"></a>2、vi的基本操作</h2><p>a) 进入vi<br>   　在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：<br>　　　$ vi myfile<br>　　不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ </p><p>b) 切换至插入模式（Insert mode）编辑文件<br>　　在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 </p><p>c) Insert 的切换<br>　　您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 </p><dl><dt>d) 退出vi及保存文件<br>　　在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如：<br>: w filename （输入 「w filename」将文章以指定的文件名filename保存）<br>: wq (输入「wq」，存盘并退出vi)</dt><dd>q! (输入q!， 不存盘强制退出vi) </dd></dl><h2 id="3、命令行模式（command-mode）功能键"><a href="#3、命令行模式（command-mode）功能键" class="headerlink" title="3、命令行模式（command mode）功能键"></a>3、命令行模式（command mode）功能键</h2><p>1）. 插入模式<br>       按「i」切换进入插入模式「insert mode」，按”i”进入插入模式后是从光标当前位置开始输入文件；<br>　　按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；<br>　　按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 </p><p>2）. 从插入模式切换为命令行模式<br>      按「ESC」键。 </p><p>3）. 移动光标<br>　　vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。<br>　　按「ctrl」+「b」：屏幕往”后”移动一页。<br>　　按「ctrl」+「f」：屏幕往”前”移动一页。<br>　　按「ctrl」+「u」：屏幕往”后”移动半页。<br>　　按「ctrl」+「d」：屏幕往”前”移动半页。<br>　　按数字「0」：移到文章的开头。<br>　　按「G」：移动到文章的最后。<br>　　按「$」：移动到光标所在行的”行尾”。<br>　　按「^」：移动到光标所在行的”行首”<br>　　按「w」：光标跳到下个字的开头<br>　　按「e」：光标跳到下个字的字尾<br>　　按「b」：光标回到上个字的开头<br>　　按「#l」：光标移到该行的第#个位置，如：5l,56l。 </p><p>4）. 删除文字<br>　　「x」：每按一次，删除光标所在位置的”后面”一个字符。<br>　　「#x」：例如，「6x」表示删除光标所在位置的”后面”6个字符。<br>　　「X」：大写的X，每按一次，删除光标所在位置的”前面”一个字符。<br>　　「#X」：例如，「20X」表示删除光标所在位置的”前面”20个字符。<br>　　「dd」：删除光标所在行。<br>　　「#dd」：从光标所在行开始删除#行 </p><p>5）. 复制<br>　　「yw」：将光标所在之处到字尾的字符复制到缓冲区中。<br>　　「#yw」：复制#个字到缓冲区<br>　　「yy」：复制光标所在行到缓冲区。<br>　　「#yy」：例如，「6yy」表示拷贝从光标所在的该行”往下数”6行文字。<br>　　「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能。 </p><p>6）. 替换<br>　　「r」：替换光标所在处的字符。<br>　　「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 </p><p>7）. 回复上一次操作<br>　　「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次”u”可以执行多次回复。 </p><p>8）. 更改<br>　　「cw」：更改光标所在处的字到字尾处<br>　　「c#w」：例如，「c3w」表示更改3个字 </p><p>9）. 跳至指定的行<br>　　「ctrl」+「g」列出光标所在行的行号。<br>　　「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 </p><h2 id="4、Last-line-mode下命令简介"><a href="#4、Last-line-mode下命令简介" class="headerlink" title="4、Last line mode下命令简介"></a>4、Last line mode下命令简介</h2><p>　　在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 </p><p>A) 列出行号 </p><p>　「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 </p><p>B) 跳到文件中的某一行 </p><p>　「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 </p><p>C) 查找字符 </p><p>　「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 </p><p>　「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 </p><p>D) 保存文件 </p><p>　「w」：在冒号输入字母「w」就可以将文件保存起来。 </p><p>E) 离开vi </p><p>　「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 </p><p>　「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 </p><h2 id="5、vi命令列表"><a href="#5、vi命令列表" class="headerlink" title="5、vi命令列表"></a>5、vi命令列表</h2><p>1、下表列出命令模式下的一些键的功能： </p><p>h<br>左移光标一个字符 </p><p>l<br>右移光标一个字符 </p><p>k<br>光标上移一行 </p><p>j<br>光标下移一行 </p><p>^<br>光标移动至行首 </p><p>0<br>数字”0”，光标移至文章的开头 </p><p>G<br>光标移至文章的最后 </p><p>$<br>光标移动至行尾 </p><p>Ctrl+f<br>向前翻屏 </p><p>Ctrl+b<br>向后翻屏 </p><p>Ctrl+d<br>向前翻半屏 </p><p>Ctrl+u<br>向后翻半屏 </p><p>i<br>在光标位置前插入字符 </p><p>a<br>在光标所在位置的后一个字符开始增加 </p><p>o<br>插入新的一行，从行首开始输入 </p><p>ESC<br>从输入状态退至命令状态 </p><p>x<br>删除光标后面的字符 </p><p>#x<br>删除光标后的＃个字符 </p><p>X<br>(大写X)，删除光标前面的字符 </p><p>#X<br>删除光标前面的#个字符 </p><p>dd<br>删除光标所在的行 </p><p>#dd<br>删除从光标所在行数的#行 </p><p>yw<br>复制光标所在位置的一个字 </p><p>#yw<br>复制光标所在位置的#个字 </p><p>yy<br>复制光标所在位置的一行 </p><p>#yy<br>复制从光标所在行数的#行 </p><p>p<br>粘贴 </p><p>u<br>取消操作 </p><p>cw<br>更改光标所在位置的一个字 </p><p>#cw<br>更改光标所在位置的#个字 </p><p>2、下表列出行命令模式下的一些指令<br>w filename<br>储存正在编辑的文件为filename </p><p>wq filename<br>储存正在编辑的文件为filename，并退出vi </p><p>q!<br>放弃所有修改，退出vi </p><p>set nu<br>显示行号 </p><p>/或?<br>查找，在/后输入要查找的内容 </p><p>n<br>与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。 </p><p>对于第一次用vi，有几点注意要提醒一下：<br>1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。切换方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。<br>2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键。<br>3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的）</p><h2 id="vi使用"><a href="#vi使用" class="headerlink" title="vi使用"></a>vi使用</h2><p>VI是unix上最常用的文本编辑工具，作为unix软件测试人员，有必要熟练掌握它。</p><p>进入vi的命令<br>vi filename :打开或新建文件，并将光标置于第一行首<br>vi +n filename ：打开文件，并将光标置于第n行首<br>vi + filename ：打开文件，并将光标置于最后一行首<br>vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处<br>vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename<br>vi filename….filename ：打开多个文件，依次编辑</p><h2 id="移动光标类命令"><a href="#移动光标类命令" class="headerlink" title="移动光标类命令"></a>移动光标类命令</h2><p>h ：光标左移一个字符<br>l ：光标右移一个字符<br>space：光标右移一个字符<br>Backspace：光标左移一个字符<br>k或Ctrl+p：光标上移一行<br>j或Ctrl+n ：光标下移一行<br>Enter ：光标下移一行<br>w或W ：光标右移一个字至字首<br>b或B ：光标左移一个字至字首<br>e或E ：光标右移一个字j至字尾<br>) ：光标移至句尾<br>( ：光标移至句首<br>}：光标移至段落开头<br>{：光标移至段落结尾<br>nG：光标移至第n行首<br>n+：光标下移n行<br>n-：光标上移n行<br>n$：光标移至第n行尾<br>H ：光标移至屏幕顶行<br>M ：光标移至屏幕中间行<br>L ：光标移至屏幕最后行<br>0：（注意是数字零）光标移至当前行首<br>$：光标移至当前行尾</p><h2 id="屏幕翻滚类命令"><a href="#屏幕翻滚类命令" class="headerlink" title="屏幕翻滚类命令"></a>屏幕翻滚类命令</h2><p>Ctrl+u：向文件首翻半屏<br>Ctrl+d：向文件尾翻半屏<br>Ctrl+f：向文件尾翻一屏<br>Ctrl＋b；向文件首翻一屏<br>nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。</p><h2 id="插入文本类命令"><a href="#插入文本类命令" class="headerlink" title="插入文本类命令"></a>插入文本类命令</h2><p>i ：在光标前<br>I ：在当前行首<br>a：光标后<br>A：在当前行尾<br>o：在当前行之下新开一行<br>O：在当前行之上新开一行<br>r：替换当前字符<br>R：替换当前字符及其后的字符，直至按ESC键<br>s：从当前光标位置处开始，以输入的文本替代指定数目的字符<br>S：删除指定数目的行，并以所输入文本代替之<br>ncw或nCW：修改指定数目的字<br>nCC：修改指定数目的行</p><h2 id="删除命令-1"><a href="#删除命令-1" class="headerlink" title="删除命令"></a>删除命令</h2><p>ndw或ndW：删除光标处开始及其后的n-1个字<br>do：删至行首<br>d$：删至行尾<br>ndd：删除当前行及其后n-1行<br>x或X：删除一个字符，x删除光标后的，而X删除光标前的<br>Ctrl+u：删除输入方式下所输入的文本</p><h2 id="搜索及替换命令"><a href="#搜索及替换命令" class="headerlink" title="搜索及替换命令 :"></a>搜索及替换命令 :</h2><p>/pattern：从光标开始处向文件尾搜索pattern<br>?pattern：从光标开始处向文件首搜索pattern<br>n：在同一方向重复上一次搜索命令<br>N：在反方向上重复上一次搜索命令<br>：s/p1/p2/g：将当前行中所有p1均用p2替代<br>：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代<br>：g/p1/s//p2/g：将文件中所有p1均用p2替换</p><h2 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h2><p>all：列出所有选项设置情况<br>term：设置终端类型<br>ignorance：在搜索中忽略大小写<br>list：显示制表位(Ctrl+I)和行尾标志（$)<br>number：显示行号<br>report：显示由面向行的命令修改过的数目<br>terse：显示简短的警告信息<br>warn：在转到别的文件时若没保存当前文件则显示NO write信息<br>nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符<br>nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始<br>mesg：允许vi显示其他用户用write写到自己终端上的信息</p><h2 id="最后行方式命令"><a href="#最后行方式命令" class="headerlink" title="最后行方式命令"></a>最后行方式命令</h2><p>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下<br>：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下<br>：n1,n2 d ：将n1行到n2行之间的内容删除<br>：w ：保存当前文件<br>：e filename：打开文件filename进行编辑<br>：x：保存当前文件并退出<br>：q：退出vi<br>：q!：不保存文件并退出vi<br>：!command：执行shell命令command<br>：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指<br>定n1，n2，则表示将整个文件内容作为command的输入<br>：r!command：将命令command的输出结果放到当前行 。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下Top命令</title>
    <link href="/2017/10/03/Linux%E4%B8%8BTop%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/10/03/Linux%E4%B8%8BTop%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Top命令"><a href="#Top命令" class="headerlink" title="Top命令"></a>Top命令</h1><p>TOP命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。</p><p>TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p><p><img src="/img/cphoto/linux06.jpg"></p><h1 id="一-统计信息区"><a href="#一-统计信息区" class="headerlink" title="一. 统计信息区"></a>一. 统计信息区</h1><p>统计信息区前五行是系统整体的统计信息。</p><p><img src="/img/cphoto/linux07.jpg"></p><h2 id="1-第一行是任务队列信息"><a href="#1-第一行是任务队列信息" class="headerlink" title="1. 第一行是任务队列信息"></a>1. 第一行是任务队列信息</h2><p>同 uptime 命令的执行结果:</p><p>[root@localhost ~]# uptime</p><p> 13:22:30 up 8 min, 4 users, load average: 0.14, 0.38, 0.25</p><p>其内容如下：</p><table><thead><tr><th>12:38:33</th><th>当前时间</th></tr></thead><tbody><tr><td>up 50days</td><td>系统运行时间，格式为时:分</td></tr><tr><td>1 user</td><td>当前登录用户数</td></tr><tr><td>load average: 0.06, 0.60, 0.48</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</td></tr></tbody></table><h2 id="2-第二、三行为进程和CPU的信息"><a href="#2-第二、三行为进程和CPU的信息" class="headerlink" title="2. 第二、三行为进程和CPU的信息"></a>2. 第二、三行为进程和CPU的信息</h2><p>当有多个CPU时，这些内容可能会超过两行。内容如下：</p><table><thead><tr><th>Tasks: 29 total</th><th>进程总数</th></tr></thead><tbody><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>28 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>Cpu(s): 0.3% us</td><td>用户空间占用CPU百分比</td></tr><tr><td>1.0% sy</td><td>内核空间占用CPU百分比</td></tr><tr><td>0.0% ni</td><td>用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td>98.7% id</td><td>空闲CPU百分比</td></tr><tr><td>0.0% wa</td><td>等待输入输出的CPU时间百分比</td></tr><tr><td>0.0% hi</td><td></td></tr><tr><td>0.0% si</td><td></td></tr></tbody></table><h2 id="3-第四五行为内存信息。"><a href="#3-第四五行为内存信息。" class="headerlink" title="3. 第四五行为内存信息。"></a>3. 第四五行为内存信息。</h2><p>内容如下：</p><table><thead><tr><th>Mem: 191272k total</th><th>物理内存总量</th></tr></thead><tbody><tr><td>173656k used</td><td>使用的物理内存总量</td></tr><tr><td>17616k free</td><td>空闲内存总量</td></tr><tr><td>22052k buffers</td><td>用作内核缓存的内存量</td></tr><tr><td>Swap: 192772k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>192772k free</td><td>空闲交换区总量</td></tr><tr><td>123988k cached</td><td>缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些<strong>内容已存在于内存中</strong>的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。</td></tr></tbody></table><h1 id="二-进程信息区"><a href="#二-进程信息区" class="headerlink" title="二. 进程信息区"></a>二. 进程信息区</h1><p>统计信息区域的下方显示了各个进程的详细信息。我们来认识一下各列的含义：</p><p><img src="/img/cphoto/linux08.jpg"></p><h2 id="1-列信息"><a href="#1-列信息" class="headerlink" title="1.列信息"></a>1.列信息</h2><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程id</td></tr><tr><td>PPID</td><td>父进程id</td></tr><tr><td>RUSER</td><td>Real user name</td></tr><tr><td>UID</td><td>进程所有者的用户id</td></tr><tr><td>USER</td><td>进程所有者的用户名</td></tr><tr><td>GROUP</td><td>进程所有者的组名</td></tr><tr><td>TTY</td><td>启动进程的终端名。不是从终端启动的进程则显示为 ?</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>P</td><td>最后使用的CPU，仅在多CPU环境下有意义</td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>TIME</td><td>进程使用的CPU时间总计，单位秒</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td>SWAP</td><td>进程使用的虚拟内存中，被换出的大小，单位kb。</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td>CODE</td><td>可执行代码占用的物理内存大小，单位kb</td></tr><tr><td>DATA</td><td>可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td></tr><tr><td>SHR</td><td>共享内存大小，单位kb</td></tr><tr><td>nFLT</td><td>页面错误次数</td></tr><tr><td>nDRT</td><td>最后一次写入到现在，被修改过的页面数。</td></tr><tr><td>S</td><td>进程状态。           D=不可中断的睡眠状态           R=运行           S=睡眠           T=跟踪/停止           Z=僵尸进程</td></tr><tr><td>COMMAND</td><td>命令名/命令行</td></tr><tr><td>WCHAN</td><td>若该进程在睡眠，则显示睡眠中的系统函数名</td></tr><tr><td>Flags</td><td>任务标志，参考 sched.h</td></tr></tbody></table><h2 id="2-用快捷键更改显示内容"><a href="#2-用快捷键更改显示内容" class="headerlink" title="2.用快捷键更改显示内容"></a>2.用快捷键更改显示内容</h2><p>h或者? : 显示帮助画面，给出一些简短的命令总结说明。</p><p>k ：终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。</p><p>i：忽略闲置和僵死进程。这是一个开关式命令。</p><p>q： 退出程序。</p><p>r： 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。</p><p>S：切换到累计模式。</p><p>s : 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。</p><p>f或者F :从当前显示中添加或者删除项目。</p><p>o或者O :改变显示项目的顺序。</p><p>l: 切换显示平均负载和启动时间信息。即显示影藏第一行</p><p>m： 切换显示内存信息。即显示影藏内存行</p><p>t ： 切换显示进程和CPU状态信息。即显示影藏CPU行</p><p>c： 切换显示命令名称和完整命令行。 显示完整的命令。 这个功能很有用。</p><p>M ： 根据驻留内存大小进行排序。</p><p>P：根据CPU使用百分比大小进行排序。</p><p>T： 根据时间/累计时间进行排序。</p><p>W： 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p><p>z：改变显示的颜色</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rpm执行安装包</title>
    <link href="/2017/10/03/rpm%E6%89%A7%E8%A1%8C%E5%AE%89%E8%A3%85%E5%8C%85/"/>
    <url>/2017/10/03/rpm%E6%89%A7%E8%A1%8C%E5%AE%89%E8%A3%85%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rpm 执行安装包<br> 二进制包（Binary）以及源代码包（Source）两种。二进制包可以直接安装在计算机中，而源代码包将会由 RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。</p><p>常用命令组合：</p><p>－ivh：安装显示安装进度–install–verbose–hash<br> －Uvh：升级软件包–Update；<br> －qpl： 列出RPM软件包内的文件信息[Query Package list]；<br> －qpi：列出RPM软件包的描述信息[Query Package install package(s)]；<br> －qf：查找指定文件属于哪个RPM软件包[Query File]；<br> －Va：校验所有的 RPM软件包，查找丢失的文件[View Lost]；<br> －e：删除包</p><p>rpm -q samba //查询程序是否安装</p><p>rpm -ivh /media/cdrom/RedHat/RPMS/samba-3.0.10-1.4E.i386.rpm //按路径安装并显示进度<br> rpm -ivh –relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm  //指定安装目录</p><p>rpm -ivh –test gaim-1.3.0-1.fc4.i386.rpm　　　 //用来检查依赖关系；并不是真正的安装；<br> rpm -Uvh –oldpackage gaim-1.3.0-1.fc4.i386.rpm //新版本降级为旧版本</p><p>rpm -qa | grep httpd　　　　　 ＃[搜索指定rpm包是否安装]–all搜索<em>httpd</em><br> rpm -ql httpd　　　　　　　　　＃[搜索rpm包]–list所有文件安装目录</p><p>rpm -qpi Linux-1.4-6.i368.rpm　＃[查看rpm包]–query–package–install package信息<br> rpm -qpf Linux-1.4-6.i368.rpm　＃[查看rpm包]–file<br> rpm -qpR file.rpm　　　　　　　＃[查看包]依赖关系<br> rpm2cpio file.rpm |cpio -div  ＃[抽出文件]</p><p>rpm -ivh file.rpm 　＃[安装新的rpm]–install–verbose–hash<br> rpm -ivh [<a href="http://my.chinaunix.net/link.php?url=http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm">url]http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm[/url]</a><br> rpm -Uvh file.rpm  ＃[升级一个rpm]–upgrade<br> rpm -e file.rpm   ＃[删除一个rpm包]–erase</p><p>常用参数：</p><p>Install/Upgrade/Erase options:<br> -i, –install           install package(s)<br> -v, –verbose           provide more detailed output<br> -h, –hash            print hash marks as package installs (good with -v)<br> -e, –erase            erase (uninstall) package<br> -U, –upgrade=<packagefile>+   upgrade package(s)<br> －-replacepkge          无论软件包是否已被安装，都强行安装软件包<br> –test              安装测试，并不实际安装<br> –nodeps             忽略软件包的依赖关系强行安装<br> –force              忽略软件包及文件的冲突</packagefile></p><p>Query options (with -q or –query):<br> -a, –all             query/verify all packages<br> -p, –package           query/verify a package file<br> -l, –list            list files in package<br> -d, –docfiles          list all documentation files<br> -f, –file            query/verify package(s) owning file</p><p><strong>RPM****源代码包装安装</strong></p><p>.src.rpm结尾的文件，这些文件是由软件的源代码包装而成的，用户要安装这类RPM软件包，必须使用命令：</p><p>rpm　–recompile　vim-4.6-4.src.rpm  ＃这个命令会把源代码解包并编译、安装它，如果用户使用命令：</p><p>rpm　–rebuild　vim-4.6-4.src.rpm　　＃在安装完成后，还会把编译生成的可执行文件重新包装成i386.rpm 的RPM软件包。</p><p> [root@localhost src]# rpm -ivh awstats-6.8-1.noarch.rpm<br> error: Failed dependencies:<br> perl(LWP::UserAgent) is needed by awstats-6.8-1.noarch<br> [root@localhost src]#</p><p> 使用rpm 属性相依套件的档案</p><p> [root@localhost src]# rpm -qpR awstats-6.8-1.noarch.rpm<br> /bin/sh<br> /usr/bin/perl<br> config(awstats) = 6.8-1<br> perl &gt;= 0:5.005<br> perl(LWP::UserAgent)<br> perl(POSIX)<br> perl(Socket)<br> perl(Time::Local)<br> perl(strict)<br> perl(vars)<br> rpmlib(CompressedFileNames) &lt;= 3.0.4-1<br> rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</p><p>另外：# rpm -ivh –aid samba*.rpm (一定要安装rpmdb后才可以用这种方式安装排除依赖关系)</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2017/10/03/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2017/10/03/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1-1-Linux的概述："><a href="#1-1-Linux的概述：" class="headerlink" title="1.1   Linux的概述："></a>1.1   Linux的概述：</h2><h3 id="1-1-1-什么是Linux："><a href="#1-1-1-什么是Linux：" class="headerlink" title="1.1.1  什么是Linux："></a>1.1.1  什么是Linux：</h3><h4 id="1-1-1-1-学习Linux之前先了解Unix"><a href="#1-1-1-1-学习Linux之前先了解Unix" class="headerlink" title="1.1.1.1 学习Linux之前先了解Unix"></a>1.1.1.1 学习Linux之前先了解Unix</h4><p>Unix是一个强大的多用户、多任务操作系统。</p><p>于1969年在AT&amp;T的贝尔实验室开发。</p><p>UNIX的商标权由国际开放标准组织（The Open Group）所拥有。</p><p>UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。</p><h4 id="1-1-1-2-Linux的概述："><a href="#1-1-1-2-Linux的概述：" class="headerlink" title="1.1.1.2 Linux的概述："></a>1.1.1.2 Linux的概述：</h4><p>Linux是基于Unix的</p><p>Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机</p><p>诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成</p><p>Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统.</p><h4 id="1-1-1-4-Linux系统的应用："><a href="#1-1-1-4-Linux系统的应用：" class="headerlink" title="1.1.1.4 Linux系统的应用："></a>1.1.1.4 Linux系统的应用：</h4><p>服务器系统</p><p>Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； </p><p>嵌入式系统</p><p>路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，</p><p>高性能运算、计算密集型应用</p><p>Linux有强大的运算能力。</p><p>桌面应用系统</p><p>移动手持系统</p><h4 id="1-1-1-5-Linux的版本"><a href="#1-1-1-5-Linux的版本" class="headerlink" title="1.1.1.5 Linux的版本"></a>1.1.1.5 Linux的版本</h4><p><strong>Linux****的版本分为两种：内核版本和发行版本；</strong></p><p>内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；</p><p>发行版本是一些组织和公司根据自己发行版的不同而自定的 ；</p><h2 id="1-2-Linux的安装："><a href="#1-2-Linux的安装：" class="headerlink" title="1.2   Linux的安装："></a>1.2   Linux的安装：</h2><h3 id="1-2-1-虚拟机安装："><a href="#1-2-1-虚拟机安装：" class="headerlink" title="1.2.1  虚拟机安装："></a>1.2.1  虚拟机安装：</h3><h4 id="1-2-1-1-什么是虚拟机"><a href="#1-2-1-1-什么是虚拟机" class="headerlink" title="1.2.1.1 什么是虚拟机"></a>1.2.1.1 什么是虚拟机</h4><p>虚拟机：一台虚拟的电脑.</p><p>虚拟机软件:</p><p>* VmWare    :收费的.</p><p>* VirtualBox  :免费的.</p><h3 id="1-2-3-Linux的目录结构："><a href="#1-2-3-Linux的目录结构：" class="headerlink" title="1.2.3  Linux的目录结构："></a>1.2.3  Linux的目录结构：</h3><p><img src="/img/cphoto/linux01.jpg"></p><p>root管理员的home目录root</p><p>其他用户的home目录home目录中</p><h2 id="1-3-Linux的常用命令"><a href="#1-3-Linux的常用命令" class="headerlink" title="1.3   Linux的常用命令"></a>1.3   Linux的常用命令</h2><h3 id="1-3-1-切换目录命令cd："><a href="#1-3-1-切换目录命令cd：" class="headerlink" title="1.3.1  切换目录命令cd："></a>1.3.1  切换目录命令cd：</h3><p>使用</p><p>cd app 切换到app目录</p><p>cd ..  切换到上一层目录</p><p>cd /   切换到系统根目录</p><p>cd ~   切换到用户主目录</p><p>cd -   切换到上一个所在目录</p><h3 id="1-3-2-列出文件列表：ls-ll-dir"><a href="#1-3-2-列出文件列表：ls-ll-dir" class="headerlink" title="1.3.2  列出文件列表：ls ll dir(*****)"></a>1.3.2  列出文件列表：ls ll dir(*****)</h3><p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。</p><p>  格式：ls[参数] [路径或文件名]</p><p>常用：</p><p>在linux中以 . 开头的文件都是隐藏的文件</p><p>* ls</p><p>* ls -a 显示所有文件或目录（包含隐藏的文件）</p><p>* ls -l 缩写成ll</p><h3 id="1-3-3-创建目录和移除目录：mkdir-rmdir"><a href="#1-3-3-创建目录和移除目录：mkdir-rmdir" class="headerlink" title="1.3.3  创建目录和移除目录：mkdir rmdir"></a>1.3.3  创建目录和移除目录：mkdir rmdir</h3><p>mkdir(make directory)命令可用来创建子目录。</p><p>mkdir app  在当前目录下创建app目录</p><p>mkdir –p app2/test  级联创建aap2以及test目</p><p>rmdir(remove directory)命令可用来删除“空”的子目录：</p><p>rmdir app  删除app目录</p><h3 id="1-3-4-浏览文件"><a href="#1-3-4-浏览文件" class="headerlink" title="1.3.4  浏览文件"></a>1.3.4  浏览文件</h3><p>【cat、more、less】</p><p>cat</p><p>用于显示文件的内容。</p><p>格式：cat[参数]&lt;文件名&gt;</p><p>  * cat yum.conf</p><p>more</p><p>一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。</p><p>回车显示下一行内容。</p><p>按 q 键退出查看。</p><p>* more yum.conf</p><p>  * 空格显示下一页数据 回车显示下一行的数据</p><p>less</p><p>用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。</p><p>  * less yum.conf</p><p>​    * PgUp 和 PgDn 进行上下翻页.</p><p>【tail】</p><p>tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。</p><p>用法:</p><p>tail -10 /etc/passwd  查看后10行数据</p><p>tail -f catalina.log  动态查看日志(*****)</p><p>ctrl+c 结束查看</p><h3 id="1-3-5-文件操作："><a href="#1-3-5-文件操作：" class="headerlink" title="1.3.5  文件操作："></a>1.3.5  文件操作：</h3><p>【rm】</p><p>rm 删除文件</p><p>用法：rm [选项]… 文件…</p><p>rm a.txt  删除a.txt文件</p><p>删除需要用户确认，y/n</p><p>rm 删除不询问</p><p>rm -f a.txt  不询问，直接删除</p><p>rm 删除目录</p><p>rm -r a  递归删除</p><p>不询问递归删除（慎用）</p><p>rm -rf a  不询问递归删除</p><p>rm -rf *    删除所有文件</p><p>rm -rf /*    自杀</p><p>【cp、mv】</p><p>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p><p>cp a.txt b.txt  将a.txt复制为b.txt文件</p><p>cp a.txt ../  将a.txt文件复制到上一层目录中</p><p>mv 移动或者重命名</p><p>mv a.txt ../  将a.txt文件移动到上一层目录中</p><p>mv a.txt b.txt  将a.txt文件重命名为b.txt</p><p>【tar】命令:(***** 打包或解压)</p><p>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。</p><p>常用参数：</p><p>-c：创建一个新tar文件</p><p>-v：显示运行过程的信息</p><p>-f：指定文件名</p><p>-z：调用gzip压缩命令进行压缩</p><p>-t：查看压缩文件的内容</p><p>-x：解开tar文件</p><p>打包：</p><p>tar –cvf xxx.tar ./*</p><p>打包并且压缩：</p><p>tar –zcvf xxx.tar.gz ./* </p><p>解压 </p><p>   tar –xvf xxx.tar</p><p>tar -xvf xxx.tar.gz -C /usr/aaa</p><p>【grep】命令</p><p>查找符合条件的字符串。</p><p>用法: grep [选项]… PATTERN [FILE]…</p><p>示例：</p><p>grep lang anaconda-ks.cfg 在文件中查找lang</p><p>grep lang anaconda-ks.cfg –color 高亮显示</p><p> <img src="/img/cphoto/linux02.jpg"></p><h3 id="1-3-6-其他常用命令"><a href="#1-3-6-其他常用命令" class="headerlink" title="1.3.6  其他常用命令"></a>1.3.6  其他常用命令</h3><p>【pwd】</p><p>显示当前所在目录</p><p>【touch】</p><p>创建一个空文件</p><p>* touch a.txt</p><p>【ll -h】</p><p>友好显示文件大小</p><p>【wget】</p><p>下载资料</p><p>* wget <a href="http://nginx.org/download/nginx-1.9.12.tar.gz">http://nginx.org/download/nginx-1.9.12.tar.gz</a></p><h2 id="1-4-Vi和Vim编辑器"><a href="#1-4-Vi和Vim编辑器" class="headerlink" title="1.4   Vi和Vim编辑器"></a>1.4   Vi和Vim编辑器</h2><h3 id="1-4-1-Vim编辑器："><a href="#1-4-1-Vim编辑器：" class="headerlink" title="1.4.1  Vim编辑器："></a>1.4.1  Vim编辑器：</h3><p>在Linux下一般使用vi编辑器来编辑文件。</p><p>vi既可以查看文件也可以编辑文件。</p><p>三种模式：命令行、插入、底行模式。</p><p>切换到命令行模式：按Esc键；</p><p>切换到插入模式：按 i 、o、a键；</p><p>  i 在当前位置生前插入</p><p>  I 在当前行首插入</p><p>  a 在当前位置后插入</p><p>  A 在当前行尾插入</p><p>  o 在当前行之后插入一行</p><p>  O 在当前行之前插入一行</p><p>切换到底行模式：按 :（冒号）；</p><p>更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》</p><p>打开文件：vim file</p><p>退出：esc à :q</p><p>修改文件：输入i进入插入模式</p><p>保存并退出：escà:wq</p><p>不保存退出：escà:q!</p><p>3中进入插入模式：</p><p>i:在当前的光标所在处插入</p><p>o:在当前光标所在的行的下一行插入</p><p>a:在光标所在的下一个字符插入</p><p>快捷键：</p><p>dd – 快速删除一行</p><p>R – 替换</p><h3 id="1-4-2-重定向输出-gt-和-gt-gt"><a href="#1-4-2-重定向输出-gt-和-gt-gt" class="headerlink" title="1.4.2  重定向输出&gt;和&gt;&gt;"></a>1.4.2  重定向输出&gt;和&gt;&gt;</h3><p>&gt; 重定向输出，覆盖原有内容；</p><p>&gt;&gt; 重定向输出，又追加功能；</p><p>示例：</p><p>cat /etc/passwd &gt; a.txt 将输出定向到a.txt中</p><p>cat /etc/passwd &gt;&gt; a.txt 输出并且追加</p><p>ifconfig &gt; ifconfig.txt</p><h3 id="1-4-3-管道"><a href="#1-4-3-管道" class="headerlink" title="1.4.3  管道 |"></a>1.4.3  管道 |</h3><p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。</p><p>示例</p><p>ls –help | more 分页查询帮助信息</p><p>ps –ef | grep java 查询名称中包含java的进程</p><p>ifconfig | more</p><p>cat index.html | more</p><p>ps –ef | grep aio</p><h3 id="1-4-4-amp-amp-命令执行控制："><a href="#1-4-4-amp-amp-命令执行控制：" class="headerlink" title="1.4.4  &amp;&amp;命令执行控制："></a>1.4.4  &amp;&amp;命令执行控制：</h3><p>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 </p><p>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 </p><p>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p><p>mkdir test &amp;&amp; cd test</p><h3 id="1-4-5-网络通讯命令"><a href="#1-4-5-网络通讯命令" class="headerlink" title="1.4.5  网络通讯命令"></a>1.4.5  网络通讯命令</h3><p>ifconfig 显示或设置网络设备。</p><p>ifconfig 显示网络设备</p><p>ifconfig eth0 up 启用eth0网卡</p><p>ifconfig eth0 down 停用eth0网卡</p><p>ping  探测网络是否通畅。</p><p>ping 192.168.0.1</p><p>netstat 查看网络端口。</p><p>netstat -an | grep 3306 查询3306端口占用情况</p><h3 id="1-4-6-系统管理命令"><a href="#1-4-6-系统管理命令" class="headerlink" title="1.4.6  系统管理命令"></a>1.4.6  系统管理命令</h3><p>date 显示或设置系统时间</p><p>date 显示当前系统时间</p><p>date -s “2014-01-01 10:10:10“ 设置系统时间</p><p>df 显示磁盘信息</p><p>df –h 友好显示大小</p><p>free 显示内存状态</p><p>free –m 以mb单位显示内存组昂头</p><p>top 显示，管理执行中的程序</p><p>clear 清屏幕</p><p>ps 正在运行的某个进程的状态</p><p>ps –ef 查看所有进程</p><p>ps –ef | grep ssh 查找某一进程</p><p>kill 杀掉某一进程</p><p>kill 2868 杀掉2868编号的进程</p><p>kill -9 2868 强制杀死进程</p><p>du 显示目录或文件的大小。</p><p>du –h 显示当前目录的大小</p><p>who 显示目前登入系统的用户信息。</p><p>hostname 查看当前主机名</p><p>修改：vi /etc/sysconfig/network</p><p>uname 显示系统信息。</p><p>uname -a 显示本机详细信息。</p><p>依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p><h2 id="1-5-Linux的用户和组"><a href="#1-5-Linux的用户和组" class="headerlink" title="1.5   Linux的用户和组"></a>1.5   Linux的用户和组</h2><h3 id="1-5-1-用户的管理"><a href="#1-5-1-用户的管理" class="headerlink" title="1.5.1  用户的管理"></a>1.5.1  用户的管理</h3><p>useradd 添加一个用户</p><p>useradd test 添加test用户</p><p>useradd test -d /home/t1 指定用户home目录</p><p>passwd 设置、修改密码</p><p>passwd test 为test用户设置密码</p><p>切换登录：</p><p>ssh -l test -p 22 192.168.19.128</p><p>su – 用户名</p><p>userdel 删除一个用户</p><p>userdel test 删除test用户(不会删除home目录)</p><p>userdel –r test 删除用户以及home目录</p><h3 id="1-5-2-组管理："><a href="#1-5-2-组管理：" class="headerlink" title="1.5.2  组管理："></a>1.5.2  组管理：</h3><p>当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组</p><p>创建用户时也可以指定所在组</p><p>groupadd 创建组</p><p>groupadd public 创建一个名为public的组</p><p>useradd u1 –g public 创建用户指定组</p><p>groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。</p><p>groupdel public</p><h3 id="1-5-3-id，su命令"><a href="#1-5-3-id，su命令" class="headerlink" title="1.5.3  id，su命令"></a>1.5.3  id，su命令</h3><p>【id命令】</p><p>功能：查看一个用户的UID和GID</p><p>用法：id [选项]… [用户名]</p><p>直接使用id</p><p>直接使用id 用户名</p><p>【su命令】</p><p>功能：切换用户。</p><p>用法：su [选项]… [-] [用户 [参数]… ]</p><p>示例：</p><p>su u1 切换到u1用户</p><p>su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用）</p><p>【账户文件】</p><p>/etc/passwd 用户文件</p><p>/etc/shadow 密码文件</p><p>/etc/group 组信息文件</p><p>【用户文件】</p><p>root​ x:0:0:root:/root:/bin/bash</p><p>账号名称：    在系统中是唯一的</p><p>用户密码：    此字段存放加密口令</p><p>用户标识码(User ID)： 系统内部用它来标示用户</p><p>组标识码(Group ID)：  系统内部用它来标识用户属性</p><p>用户相关信息：    例如用户全名等</p><p>用户目录：    用户登录系统后所进入的目录</p><p>用户环境:    用户工作的环境</p><p>【密码文件】</p><p>shadow文件中每条记录用冒号间隔的9个字段组成.</p><p>用户名：用户登录到系统时使用的名字，而且是惟一的</p><p>口令： 存放加密的口令</p><p>最后一次修改时间: 标识从某一时刻起到用户最后一次修改时间</p><p>最大时间间隔: 口令保持有效的最大天数，即多少天后必须修改口令</p><p>最小时间间隔：  再次修改口令之间的最小天数</p><p>警告时间：从系统开始警告到口令正式失效的天数</p><p>不活动时间： 口令过期少天后，该账号被禁用</p><p>失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算)</p><p>标志：未使用</p><p>【组文件】</p><p>root​ x:0:</p><p>组名：用户所属组</p><p>组口令：一般不用</p><p>GID：组ID</p><p>用户列表：属于该组的所有用户</p><h2 id="1-6-Linux的权限命令"><a href="#1-6-Linux的权限命令" class="headerlink" title="1.6   Linux的权限命令"></a>1.6   Linux的权限命令</h2><h3 id="1-6-1-文件权限"><a href="#1-6-1-文件权限" class="headerlink" title="1.6.1  文件权限"></a>1.6.1  文件权限</h3><p><img src="/img/cphoto/linux03.jpg"></p><table><thead><tr><th><strong>属主（<strong><strong>user</strong></strong>）</strong></th><th><strong>属组（<strong><strong>group</strong></strong>）</strong></th><th><strong>其他用户</strong></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>r</td><td>w</td><td>x</td><td>r</td><td>w</td><td>x</td><td>r</td><td>w</td><td>x</td></tr><tr><td>4</td><td>2</td><td>1</td><td>4</td><td>2</td><td>1</td><td>4</td><td>2</td><td>1</td></tr></tbody></table><h3 id="1-6-2-Linux三种文件类型："><a href="#1-6-2-Linux三种文件类型：" class="headerlink" title="1.6.2  Linux三种文件类型："></a>1.6.2  Linux三种文件类型：</h3><p>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </p><p>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 </p><p>设备文件： Linux系统把每一个设备都看成是一个文件</p><h3 id="1-6-3-文件类型标识"><a href="#1-6-3-文件类型标识" class="headerlink" title="1.6.3  文件类型标识"></a>1.6.3  文件类型标识</h3><p>普通文件（-）</p><p>目录（d）</p><p>符号链接（l）</p><p>* 进入etc可以查看，相当于快捷方式</p><p>字符设备文件（c）</p><p>块设备文件（s）</p><p>套接字（s）</p><p>命名管道（p）</p><h3 id="1-6-4-文件权限管理："><a href="#1-6-4-文件权限管理：" class="headerlink" title="1.6.4  文件权限管理："></a>1.6.4  文件权限管理：</h3><p>chmod 变更文件或目录的权限。</p><p>chmod 755 a.txt </p><p>chmod u=rwx,g=rx,o=rx a.txt</p><p>chmod 000 a.txt / chmod 777 a.txt</p><p>chown 变更文件或目录改文件所属用户和组</p><p>chown u1:public a.txt ：变更当前的目录或文件的所属用户和组</p><p>chown -R u1:public dir ：变更目录中的所有的子目录及文件的所属用户和组</p><h1 id="Linux下安装lrzsz"><a href="#Linux下安装lrzsz" class="headerlink" title="Linux下安装lrzsz"></a>Linux下安装lrzsz</h1><h2 id="1-手动编译安装"><a href="#1-手动编译安装" class="headerlink" title="1. 手动编译安装"></a>1. 手动编译安装</h2><p>1、下载安装包，wget <a href="https://ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz">https://ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</a> 或者是 上传已经下载好的安装包</p><p>2、cd /usr/local/src/</p><p>3、mkdir lrzsz</p><p>4、cd lrzsz/</p><p>5、解压：tar -xvf lrzsz-0.12.20.tar.gz</p><p>6、cd lrzsz-0.12.20</p><p>7、执行配置：./configure </p><p>a)    会提示 configure: error: no acceptable cc found in $PATH，意思是缺少gcc命令，需要安装gcc</p><p>b)   手动安装gcc比较麻烦，所有选择使用yum安装</p><p>c)    yum install gcc</p><p>8、编译：make</p><p>9、安装：make install</p><p>10、     cd /usr/bin</p><p>11、     ln -s /usr/local/bin/lrz rz</p><p>12、     ln -s /usr/local/bin/lsz sz</p><p>13、     输入命令：rz</p><p>   安装成功！</p><h2 id="2-使用yum安装"><a href="#2-使用yum安装" class="headerlink" title="2. 使用yum安装"></a>2. 使用yum安装</h2><p>yum -y install lrzsz</p><h1 id="Linux安装jdk"><a href="#Linux安装jdk" class="headerlink" title="Linux安装jdk"></a>Linux安装jdk</h1><p>先卸载open-jdk</p><p>java –version</p><p>rpm -qa | grep java</p><p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64</p><p>rpm -e –nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64</p><p>开始安装：</p><p>mkdir /usr/local/src/java</p><p>rz 上传jdk tar包</p><p>tar -xvf jdk-7u71-linux-i586.tar.gz</p><p>yum install glibc.i686</p><p>配置环境变量：</p><p>① vi /etc/profile</p><p>② 在末尾行添加</p><p>​    #set java environment</p><p>​    JAVA_HOME=/usr/local/src/java/jdk1.7.0_71</p><p>​    CLASSPATH=.:$JAVA_HOME/lib.tools.jar</p><p>​    PATH=$JAVA_HOME/bin:$PATH</p><p>​    export JAVA_HOME CLASSPATH PATH</p><p>保存退出</p><p>③source /etc/profile 使更改的配置立即生效</p><p>④java -version 查看JDK版本信息，如果显示出1.7.0证明成功</p><h1 id="Linux下安装Mysql"><a href="#Linux下安装Mysql" class="headerlink" title="Linux下安装Mysql"></a>Linux下安装Mysql</h1><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><p><a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a></p><p>或者使用wget下载：</p><p>wget <a href="http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar">http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar</a></p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><h3 id="2-1-检测是否已经安装了mysql"><a href="#2-1-检测是否已经安装了mysql" class="headerlink" title="2.1. 检测是否已经安装了mysql"></a>2.1. 检测是否已经安装了mysql</h3><p>rpm -qa | grep mysql  </p><p>如果已经安装了，将其卸载，如：</p><p>rpm -e –nodeps mysql-libs-5.1.71-1.el6.x86_64</p><h3 id="2-2-安装mysql"><a href="#2-2-安装mysql" class="headerlink" title="2.2. 安装mysql"></a>2.2. 安装mysql</h3><p>1、mkdir /usr/local/src/mysql</p><p>2、cd /usr/local/src/mysql</p><p>3、tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar</p><p>4、安装server<br> rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</p><p>如果安装出错,可能还需要安装依赖</p><p> 安装依赖：yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 </p><p> 需要升级libstdc++-4.4.7-4.el6.x86_64<br> yum update libstdc++-4.4.7-4.el6.x86_64</p><p>6、安装client</p><p>rpm -ivh mysql-client-5.6.22-1.el6.i686.rpm</p><p> 安装依赖：yum -y install libncurses.so.5 libtinfo.so.5</p><p>7、查询mysq服务运行状态</p><p>service mysql status<br> 服务未启动。</p><p>8、启动mysql服务<br> service mysql start</p><p>9、使用root账号登录mysql</p><p> 在安装mysql server时有句提示：<br> 随机生成的root用户密码保存在/root/.mysql_secret</p><p><img src="/img/cphoto/linux04.jpg"></p><p> 注意：这个密码是不安全的，所有需要修改初始密码。</p><p>10、     使用密码登录mysql账号：mysql -uroot -p</p><p>11、     修改root密码：SET PASSWORD = PASSWORD(‘123456’);</p><h3 id="2-3-系统启动时自动启动mysql服务"><a href="#2-3-系统启动时自动启动mysql服务" class="headerlink" title="2.3. 系统启动时自动启动mysql服务"></a>2.3. 系统启动时自动启动mysql服务</h3><p>加入到系统服务：</p><p>chkconfig –add mysql</p><p>自动启动：</p><p>chkconfig mysql on</p><p>查询列表：</p><p>chkconfig</p><p>说明：都没关闭（off）时是没有自动启动。</p><h3 id="2-4-开启远程访问"><a href="#2-4-开启远程访问" class="headerlink" title="2.4. 开启远程访问"></a>2.4. 开启远程访问</h3><p>登录：</p><p>mysql -uroot –p123456</p><p>设置远程访问（使用root密码）：</p><p>grant all privileges on <em>.</em> to ‘root’ @’%’ identified by ‘123456’; </p><p>flush privileges;</p><p>防火墙打开3306端口</p><p>/sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT</p><p>/etc/rc.d/init.d/iptables save</p><p>/etc/init.d/iptables status</p><h1 id="Linux部署web程序"><a href="#Linux部署web程序" class="headerlink" title="Linux部署web程序"></a>Linux部署web程序</h1><h2 id="1-创建ucenter用户"><a href="#1-创建ucenter用户" class="headerlink" title="1. 创建ucenter用户"></a>1. 创建ucenter用户</h2><p>一般情况下，发布应用程序都不是使用root用户的，需要创建一个普通用户来发布程序；</p><p>创建ucenter用户：<br>useradd -d /ucenter ucenter</p><p>设置密码：<br>passwd ucenter （密码 ucenter）<br>切换用户：<br>su - ucenter</p><h2 id="2-安装Tomcat"><a href="#2-安装Tomcat" class="headerlink" title="2. 安装Tomcat"></a>2. 安装Tomcat</h2><p>tomcat只要解压就可以使用。<br>1、创建web目录<br> mkdir /ucenter/web</p><p>2、上传apache-tomcat-7.0.57.tar.gz</p><p>3、解压：tar -xvf apache-tomcat-7.0.57.tar.gz</p><p>4、重命名：mv apache-tomcat-7.0.57 itcast-usermanage</p><p>5、启动tomcat：<br> cd itcast-usermanage/bin/<br> ./startup.sh 或者 sh startup.sh</p><p>6、查看日志：<br> tail -f ../logs/catalina.out</p><p>7、查看效果 <a href="http://192.168.0.160:8080/">http://192.168.0.160:8080/</a><br> 发现无法访问</p><p>8、防火墙打开 8080 端口<br> /sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT</p><p>/etc/rc.d/init.d/iptables save</p><p>9、安装成功</p><h2 id="3-部署用户管理项目"><a href="#3-部署用户管理项目" class="headerlink" title="3. 部署用户管理项目"></a>3. 部署用户管理项目</h2><h2 id="3-1-上传usermanage-sql和ROOT-war到-ucenter-web"><a href="#3-1-上传usermanage-sql和ROOT-war到-ucenter-web" class="headerlink" title="3.1. 上传usermanage.sql和ROOT.war到/ucenter/web"></a>3.1. 上传usermanage.sql和ROOT.war到/ucenter/web</h2><h2 id="3-2-执行数据库脚本"><a href="#3-2-执行数据库脚本" class="headerlink" title="3.2. 执行数据库脚本"></a>3.2. 执行数据库脚本</h2><p>cat usermanage.sql | mysql -uroot -p123456</p><h2 id="3-3-部署web程序"><a href="#3-3-部署web程序" class="headerlink" title="3.3. 部署web程序"></a>3.3. 部署web程序</h2><h3 id="3-3-1-删除webapps下的所有文件"><a href="#3-3-1-删除webapps下的所有文件" class="headerlink" title="3.3.1.  删除webapps下的所有文件"></a>3.3.1.  删除webapps下的所有文件</h3><p>cd /ucenter/web/itcast-usermanage/webapps</p><p>rm -rf *</p><h3 id="3-3-2-拷贝ROOT-war到webapps"><a href="#3-3-2-拷贝ROOT-war到webapps" class="headerlink" title="3.3.2.  拷贝ROOT.war到webapps"></a>3.3.2.  拷贝ROOT.war到webapps</h3><p>cp /ucenter/web/ROOT.war .</p><h3 id="3-3-3-重新启动tomcat"><a href="#3-3-3-重新启动tomcat" class="headerlink" title="3.3.3.  重新启动tomcat"></a>3.3.3.  重新启动tomcat</h3><p>cd ../bin/</p><p>sh startup.sh &amp;&amp; tail -f ../logs/catalina.out</p><h3 id="3-3-4-启动浏览器测试"><a href="#3-3-4-启动浏览器测试" class="headerlink" title="3.3.4.  启动浏览器测试"></a>3.3.4.  启动浏览器测试</h3><p><a href="http://192.168.0.160:8080/user/page/query">http://192.168.0.160:8080/user/page/query</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux目录介绍</title>
    <link href="/2017/10/03/Linux%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2017/10/03/Linux%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux各目录及每个目录的详细介绍"><a href="#Linux各目录及每个目录的详细介绍" class="headerlink" title="Linux各目录及每个目录的详细介绍"></a>Linux各目录及每个目录的详细介绍</h1><h2 id="常见目录说明"><a href="#常见目录说明" class="headerlink" title="常见目录说明"></a>常见目录说明</h2><p>目录<br>/bin    存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。<br>/etc    存放系统管理和配置文件<br>/home    存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示</p><p>/usr    用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。<br>/usr/x11r6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令<br>/usr/local/lib 本地增加的库<br>/opt    额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。<br>/proc    虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/root    超级用户（系统管理员）的主目录（特权阶级^o^）<br>/sbin    存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。<br>/dev    用于存放设备文件。<br>/mnt    系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。<br>/boot    存放用于系统引导时使用的各种文件<br>/lib    存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。<br>/tmp    用于存放各种临时文件，是公用的临时文件存储点。<br>/var    用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。<br>/lost+found    这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</p><p>Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图：<br> <img src="/img/cphoto/linux05.jpg"></p><p>/bin 二进制可执行命令<br>/dev 设备特殊文件<br>/etc 系统管理和配置文件<br>/etc/rc.d 启动的配置文件和脚本<br>/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示<br>/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>/sbin 超级管理命令，这里存放的是系统管理员使用的管理程序<br>/tmp 公共的临时文件存储点<br>/root 系统管理员的主目录<br>/mnt 系统提供这个目录是让用户临时挂载其他的文件系统<br>/lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里<br>/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/var 某些大文件的溢出区，比方说各种服务的日志文件<br>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：<br>/usr/x11R6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令<br>/usr/local/lib 本地增加的库根文件系统</p><p>通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的不经常改变的文件系统不容易损坏。<br>除了可能的一个叫/ vmlinuz标准的系统引导映像之外，根目录一般不含任何文件。所有其他文件在根文件系统的子目录中。</p><ol><li>/bin目录<br>/ b i n目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命令都是二进制文件的可执行程序( b i n是b i n a r y - -二进制的简称)，多是系统中重要的系统文件。</li><li>/sbin目录<br>/ s b i n目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用。</li><li>/etc目录<br>/ e t c目录存放着各种系统配置文件，其中包括了用户信息文件/ e t c / p a s s w d，系统初始化文件/ e t c / r c等。l i n u x正是*这些文件才得以正常地运行。</li><li>/root目录<br>/root 目录是超级用户的目录。</li><li>/lib目录<br>/ l i b目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。</li><li>/lib/modules 目录<br>/lib/modules 目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引导系统所需的模块(例如网络和文件系统驱动)。</li><li>/dev目录<br>/ d e v目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可以通过访问/ d e v / m o u s e来访问鼠标的输入，就像访问其他文件一样。</li><li>/tmp目录<br>/tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/ v a r / t m p来代替/tmp ，因为前者可能拥有一个更大的磁盘空间。</li><li>/boot目录<br>/ b o o t目录存放引导加载器(bootstrap loader)使用的文件，如l i lo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在i d e硬盘的前1 0 2 4柱面内。</li><li>/mnt目录<br>/ m n t目录是系统管理员临时安装( m o u n t )文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用m s d o s文件系统的软驱，而/mnt/exta 可能是使用e x t 2文件系统的软驱，/mnt/cdrom 光驱等等。</li><li>/proc, /usr,/var,/home目录<br>其他文件系统的安装点。</li></ol><h2 id="详细介绍；"><a href="#详细介绍；" class="headerlink" title="详细介绍；"></a>详细介绍；</h2><p>/etc文件系统<br>/etc 目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的m a n页。许多网络配置文件也在/etc 中。</p><ol><li>/etc/rc或/etc/rc.d或/etc/rc?.d<br>启动、或改变运行级时运行的脚本或脚本的目录。</li><li>/etc/passwd<br>用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其<br>他信息。</li><li>/etc/fdprm<br>软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见s e t f d p r m<br>的帮助页。</li><li>/etc/fstab<br>指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的s w a p区的信息。</li><li>/etc/group<br>类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。</li><li>/etc/inittab<br>init 的配置文件。</li><li>/etc/issue<br>包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。</li><li>/etc/magic<br>“f i l e”的配置文件。包含不同文件格式的说明，“f i l e”基于它猜测文件类型。</li><li>/etc/motd<br>m o t d是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。</li><li>/etc/mtab<br>当前安装的文件系统列表。由脚本( s c r i t p )初始化，并由mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df 命令)。</li><li>/etc/shadow<br>在安装了影子( s h a d o w )口令软件的系统上的影子口令文件。影子口令文件将/ e t c / p a s s wd文件中的加密口令移动到/ e t c / s h a d o w中，而后者只对超级用户( r o o t)可读。这使破译口令更困难，以此增加系统的安全性。</li><li>/etc/login.defs<br>l o g i n命令的配置文件。</li><li>/etc/printcap<br>类似/etc/termcap ，但针对打印机。语法不同。</li><li>/etc/profile 、/ e t c / c s h . l o g i n、/etc/csh.cshrc<br>登录或启动时b o u r n e或c shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。</li><li>/etc/securetty<br>确认安全终端，即哪个终端允许超级用户( r o o t )登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器( m o d e m )或网络闯入系统并得到超级用户特权。</li><li>/etc/shells<br>列出可以使用的s h e l l。chsh 命令允许用户在本文件指定范围内改变登录的s h e l l。提供一台机器f t p服务的服务进程ftpd 检查用户s h e l l是否列在/etc/shells 文件中，如果不是，将不允许该用户登录。</li><li>/etc/termcap<br>终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。<br>这样，多数的程序可以在多数终端上运行。</li></ol><p>/dev文件系统<br>/dev 目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。<br>设备文件在安装时由系统产生，以后可以用/dev/makedev 描述。/ d e v / m a k e d e v.local是<br>系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准<br>makedev 的一部分)。下面简要介绍/ d e v下一些常用文件。</p><ol><li>/dev/console<br>系统控制台，也就是直接和系统连接的监视器。</li><li>/dev/hd<br>i d e硬盘驱动程序接口。如： / d e v / h d a指的是第一个硬盘， h a d 1则是指/ d e v / h da的第一个<br>分区。如系统中有其他的硬盘，则依次为/ d e v / h d b、/ d e v / h d c、. . . . ..；如有多个分区则依次为<br>h d a 1、h d a 2 . . . . . .</li><li>/dev/sd<br>s c s i磁盘驱动程序接口。如有系统有s c s i硬盘，就不会访问/ d e v / h a d，而会访问/ d e v / sd a。</li><li>/dev/fd<br>软驱设备驱动程序。如： / d e v / f d 0指系统的第一个软盘，也就是通常所说的a：盘，<br>/ d e v / f d 1指第二个软盘，. . . . . .而/ d e v / f d 1 h 1 4 40则表示访问驱动器1中的4 . 5高密盘。</li><li>/dev/st<br>s c s i磁带驱动器驱动程序。</li><li>/dev/tty<br>提供虚拟控制台支持。如： / d e v / t t y 1指的是系统的第一个虚拟控制台， / d e v / t t y2则是系统<br>的第二个虚拟控制台。</li><li>/dev/pty<br>提供远程登陆伪终端支持。在进行te l n e t登录时就要用到/ d e v / p t y设备。</li><li>/dev/ttys<br>计算机串行接口，对于d o s来说就是“ c o m 1”口。</li><li>/dev/cua<br>计算机串行接口，与调制解调器一起使用的设备。</li><li>/dev/null<br>“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输入到/ d e v / n u l l中即可。</li></ol><p>/usr文件系统<br>/usr 是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的<br>所有文件一般来自l i n u x发行版( d i s t r i b u t i o n)；本地安装的程序和其他东西在/usr/local 下，因为这样可以在升级新版系统或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/ u s r可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。</p><ol><li>/usr/x11r6<br>包含x wi n d o w系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x wi n d o w系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft wi n d o w s或m a c h i n t o s h比较熟悉的话，就不会对x win d o w系统感到束手无策了。</li><li>/usr/x386<br>类似/ u s r / x 11r6 ，但是是专门给x 11 release 5的。</li><li>/usr/bin<br>集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin 或/usr/local/bin 中。</li><li>/usr/sbin<br>包括了根文件系统不必要的系统管理命令，例如多数服务程序。</li><li>/usr/man、/ u s r / i n f o、/ u s r / d o c<br>这些目录包含所有手册页、g n u信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如： / u s r / m a n / m a n 1中包含联机手册第一节的源码(没有格式化的原始文件)，/ u s r / m a n / c a t 1包含第一节已格式化的内容。l联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、系统管理和核心程序。</li><li>/usr/include<br>包含了c语言的头文件，这些文件多以. h结尾，用来描述c语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib 下，但习惯上一直沿用了这个名字。</li><li>/usr/lib<br>包含了程序或子系统的不变的数据文件，包括一些s i t e - w i d e配置文件。名字l i b来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。</li><li>/usr/local<br>本地安装的软件和其他文件放在这里。这与/ u s r很相似。用户可能会在这发现一些比较大的软件包，如t e x、e m a c s等。</li></ol><p>/var文件系统<br>/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来/ v a r目录中有些内容是在/ u s r中的，但为了保持/ u s r目录的相对稳定，就把那些需要经常改变的目录放到/ v a r中了。每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。</p><ol><li>/var/catman<br>包括了格式化过的帮助( m a n )页。帮助页的源文件一般存在/ u s r / m a n / m a n中；有些m an页可能有预格式化的版本，存在/ u s r / m a n / c a t中。而其他的m a n页在第一次看时都需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman 经常被清除，就像清除临时目录一样。)</li><li>/var/lib<br>存放系统正常运行时要改变的文件。</li><li>/var/local<br>存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。</li><li>/var/lock<br>锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。</li><li>/var/log<br>各种程序的日志( l o g )文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log里的文件经常不确定地增长，应该定期清除。</li><li>/var/run<br>保存在下一次系统引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。</li><li>/var/spool<br>放置“假脱机( s p o o l )”程序的目录，如m a i l、n e w s、打印队列和其他队列工作的目录。每个不同的s p o o l在/var/spool 下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail中。</li><li>/var/tmp<br>比/tmp 允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许/var/tmp 有很旧的文件。</li></ol><p>/proc文件系统<br>/proc 文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一<br>个非常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提<br>供关于系统的信息。下面说明一些最重要的文件和目录(/proc 文件系统在proc man页中有更详<br>细的说明)。</p><ol><li>/proc/x<br>关于进程x的信息目录，这一x是这一进程的标识号。每个进程在/proc 下有一个名为自<br>己进程号的目录。</li><li>/proc/cpuinfo<br>存放处理器( c p u )的信息，如c p u的类型、制造商、型号和性能等。</li><li>/proc/devices<br>当前运行的核心配置的设备驱动的列表。</li><li>/proc/dma<br>显示当前使用的d m a通道。</li><li>/proc/filesystems<br>核心配置的文件系统信息。</li><li>/proc/interrupts<br>显示被占用的中断信息和占用者的信息，以及被占用的数量。</li><li>/proc/ioports<br>当前使用的i / o端口。</li><li>/proc/kcore<br>系统物理内存映像。与物理内存大小完全一样，然而实际上没有占用这么多内存；它仅仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc 下没有任何东西占用任何磁盘空间。)</li><li>/proc/kmsg<br>核心输出的消息。也会被送到s y s l o g。</li><li>/proc/ksyms<br>核心符号表。</li><li>/proc/loadavg<br>系统“平均负载”； 3个没有意义的指示器指出系统当前的工作量。</li><li>/proc/meminfo<br>各种存储器使用信息，包括物理内存和交换分区( s w a p )。</li><li>/proc/modules<br>存放当前加载了哪些核心模块信息。</li><li>/proc/net<br>网络协议状态信息。</li><li>/proc/self<br>存放到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，这将会是不同的连接。这主要便于程序得到它自己的进程目录。</li><li>/proc/stat<br>系统的不同状态，例如，系统启动后页面发生错误的次数。</li><li>/proc/uptime<br>系统启动的时间长度。</li><li>/proc/version<br>核心版本</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2017/10/01/Maven/"/>
    <url>/2017/10/01/Maven/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>一个对Maven比较正式的定义是这么说的：Maven是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p><h2 id="Maven是干什么的？"><a href="#Maven是干什么的？" class="headerlink" title="Maven是干什么的？"></a>Maven是干什么的？</h2><p>即使不使用Maven 我们仍然可以进行B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案。</p><p>其实Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。</p><p>Maven所解决的问题<br>1、我们需要引用各种jar包，尤其是比较大的工程，引用的jar包往往有几十个乃至上百个， 每用到一种jar包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的jar包冲突，版本冲突。</p><p>2、我们辛辛苦苦写好了Java文件，可是只懂0和1的白痴电脑却完全读不懂，需要将它编译成二进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA等都可以将代码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用javac命令一个个地去编译，逗电脑玩。</p><p>3、世界上没有不存在bug的代码，计算机喜欢bug就和人们总是喜欢美女帅哥一样。为了追求美为了减少bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。</p><p>4、再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是web项目，还需要将之发布到服务器，供人蹂躏。</p><p>Maven就可以帮你构建工程，管理jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成Web站点。</p><h2 id="Maven的优势举例"><a href="#Maven的优势举例" class="headerlink" title="Maven的优势举例"></a>Maven的优势举例</h2><p>Web项目，要能够将项目运行起来，就必须将该项目所依赖的一些jar包添加到工程中，否则项目就不能运行。 试想如果具有相同架构的项目有十个，那么我们就需要将这一份jar包复制到十个不同的工程中。我们一起来看一个CRM项目的工程大小。</p><p>使用传统Web项目构建的CRM项目如下：</p><p>原因主要是因为上面的WEB程序要运行，我们必须将项目运行所需的Jar包复制到工程目录中，从而导致了工程很大。<br>同样的项目，如果我们使用Maven工程来构建，会发现总体上工程的大小会少很多。如下图:</p><h2 id="Maven的两个比较重要的作用"><a href="#Maven的两个比较重要的作用" class="headerlink" title="Maven的两个比较重要的作用"></a>Maven的两个比较重要的作用</h2><p>1.Maven的依赖管理<br>Maven的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven展示出了它对处理这种情形的高度控制。</p><p>传统的WEB项目中，我们必须将工程所依赖的jar包复制到工程中，导致了工程的变得很大。</p><p>那么maven工程是如何使得工程变得很少呢？<br><img src="/img/cphoto/maven01.jpg"></p><p>通过分析发现： maven工程中不直接将jar包导入到工程中， 而是通过在pom.xml文件中添加所需jar包的坐标，这样就很好的避免了jar直接引入进来，在需要用到jar包的时候，只要查找pom.xml文件，再通过pom.xml文件中的坐标，到一个专门用于”存放jar包的仓库”(maven仓库) 中根据坐标从而找到这些jar包，再把这些jar包拿去运行。</p><p>问题：通过读取pom.xml 文件中的坐标，再到仓库中找到jar包，会不会很慢？从而导致这种方式不可行！</p><p>答案： 通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包了，为了解决这个过程中速度慢的问题，maven中也有索引的概念，通过建立索引，可以大大提高加载jar包的速度，使得我们认为jar包基本跟放在本地的工程文件中再读取出来的速度是一样的。这个过程就好比我们查阅字典时，为了能够加快查找到内容，书前面的目录就好比是索引，有了这个目录我们就可以方便找到内容了，一样的在maven仓库中有了索引我们就可以认为可以快速找到jar包。</p><p>2.项目的一键构建<br>我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。</p><p>什么是构建？<br>指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven进行管理，这个过程称为构建。</p><p>①清理 ： 删除以前的编译结果，为重新编译做好准备。<br>②编译 ： 将 Java 源程序编译为字节码文件。<br>③测试 ： 针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。<br>④报告 ： 在每一次测试后以标准的格式记录和展示测试结果。<br>⑤打包 ： 将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。 Java 工程对应 jar 包， Web工程对应 war 包。<br>⑥安装 ： 在 Mav en 环境下特指将打包的结果 jar 包或 war 包安装到本地仓库中。<br>⑦部署 ： 将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</p><p>一键构建<br>指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。</p><p>Maven规范化构建流程如下：</p><p><img src="/img/cphoto/maven04.jpg"></p><h2 id="Maven核心概念"><a href="#Maven核心概念" class="headerlink" title="Maven核心概念"></a>Maven核心概念</h2><p>Maven能够 实现自动化构建 是 和它的内部原理 分不开 的， 这里 我们 从 Maven 的九个核心概念入手</p><p>Maven 自动化构建:<br>①POM<br>②约定的目录结构<br>③坐标<br>④依赖管理<br>⑤仓库管理<br>⑥生命周期<br>⑦插件和目标<br>⑧继承<br>⑨聚合</p><h2 id="Maven构建模型"><a href="#Maven构建模型" class="headerlink" title="Maven构建模型"></a>Maven构建模型</h2><p>Maven包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p><p>项目对象模型 (Project Object Model)<br>一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。</p><p>依赖管理系统(Dependency Management System)</p><p>一个项目生命周期(Project Lifecycle)</p><p>使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段：</p><p>maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。</p><p>一组标准集合</p><p>maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。</p><p>插件(plugin)目标(goal)<br>maven 管理项目生命周期过程都是基于插件完成的。</p><h2 id="Maven指令生命周期"><a href="#Maven指令生命周期" class="headerlink" title="Maven指令生命周期"></a>Maven指令生命周期</h2><p>maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”， 这三套生命周期分别是：</p><p>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。<br>Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。<br>Site Lifecycle 生成项目报告，站点，发布站点。</p><p>插件和目标<br>生命周期的各个阶段仅仅定义了要执行的任务是什么<br>各个阶段和插件的目标是对应的<br>相似的目标特定的插件来完成<br>可以将目标看作“调用插件功能的命令”</p><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><p>maven的工作需要从仓库下载一些jar包，如下图所示，本地的项目A、项目B等都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。</p><p><img src="/img/cphoto/maven05.jpg"></p><p>本地仓库 ： 用来存储从远程仓库或中央仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找<br>默认本地仓库位置在 u s e r . d i r / . m 2 / r e p o s i t o r y ， {user.dir}/.m2/repository，user.dir/.m2/repository，{user.dir}表示windows用户目录。</p><p>远程仓库(俗称私服）： 如果本地需要插件或者jar包，本地仓库没有，默认去远程仓库下载。<br>远程仓库可以在互联网内也可以在局域网内。</p><p>中央仓库 ： 在maven软件中内置一个远程仓库地址<a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。</p><p>仓库中保存的内容： Maven工程</p><p>1.maven自身所需要的插件</p><p>2.第三方的框架或工具的jar包</p><p>3.我们自己开发的maven工程</p><p>常见问题：</p><p>运行Maven工程时如果本地仓库配置错误会报下边的错误：</p><p>分析：<br>maven工程运行先从本地仓库找jar包，本地仓库没有再从中央仓库找，上边提示downloading…<br>表示 从中央仓库下载jar，由于本地没有联网，报错。<br>解决：<br>在maven安装目录的conf/setting.xml文件中配置本地仓库地址</p><p>Maven安装与配置<br>百度官网打开下载：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a><br>下载完后将Maven解压到自己规定的文件夹（不要用中文名）</p><p>Maven目录结构</p><p>bin:存放了maven的命令，比如我们前面用到的mvn tomcat:run<br>boot:存放了一些maven本身的引导程序，如类加载器等<br>conf:存放了maven的一些配置文件，如setting.xml文件<br>lib:存放了maven本身运行所需的一些jar包<br>至此我们的maven软件就可以使用了，前提是你的电脑上之前已经安装并配置好了JDK,运行Maven需要有JDK的支持</p><p>Maven配置<br>电脑上需安装java环境，安装JDK1.7 + 版本 （将JAVA_HOME/bin 配置环境变量path ），我们使用的是JDK8相关版本</p><p>配置 MAVEN_HOME ，变量值就是你的maven安装 的路径（bin目录之前一级目录）</p><p>再次检查JDK的安装目录，如下图：</p><p>配置好测试<br>cmd输入：mvn -v出现以下内容说明已经成功</p><p>配置本地仓库<br>在MAVE_HOME/conf/settings.xml文件中配置本地仓库位置（maven的安装目录下）</p><p>打开settings.xml文件，配置如下：</p><p> <localRepository>你的本地仓库路径</localRepository><br>这是我的本地仓库路径，以及存放的jar包</p><p>全局setting与用户setting<br>maven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。<br>在maven安装目录下的有 conf/setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。<br>如需要个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在：u s e r . d i r / . m 2 / s e t t i n g s . x m l 目 录 中 , {user.dir} /.m2/settings.xml目录中,user.dir/.m2/settings.xml目录中,{user.dir} 指windows 中的用户目录。<br>maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。</p><h2 id="Maven工程的认识"><a href="#Maven工程的认识" class="headerlink" title="Maven工程的认识"></a>Maven工程的认识</h2><p>Maven工程的目录结构</p><p>我以IDEA普通Maven工程为例：</p><p>IDEA中Web工程为例</p><p>src/main/java—— 存放项目的.java文件<br>src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件<br>src/test/java —— 存放所有单元测试.java文件，如JUnit测试类<br>src/test/resources —— 测试资源文件<br>target —— 项目输出位置，编译后的class文件会输出到此目录<br>pom.xml——maven项目核心配置文件<br>注意：如果是普通的java项目，那么就没有webapp目录。</p><h2 id="Maven的常用命令介绍"><a href="#Maven的常用命令介绍" class="headerlink" title="Maven的常用命令介绍"></a>Maven的常用命令介绍</h2><p>我在cmd中通过一系列的maven命令来对我的maven工程进行编译、测试、运行、打包、安装、部署。</p><p>compile<br>compile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。</p><p>cmd进入命令状态，执行mvn compile，如下图提示成功：</p><p>发现在我的项目目录里多出了这个文件：</p><p>test<br>test是maven工程的测试命令 mvn test，会执行src/test/java下的单元测试类。</p><p>cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行1个测试用例，全部成功：</p><p>clean<br>clean是maven工程的清理命令，执行 clean会删除target目录及内容。</p><p>package<br>package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。</p><p>install<br>install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。</p><h2 id="Maven坐标依赖"><a href="#Maven坐标依赖" class="headerlink" title="Maven坐标依赖"></a>Maven坐标依赖</h2><p>坐标使用如下三个向量在Maven 的仓库中唯一的确定一个 Maven 工程。</p><p>groupid：公司或组织的域名倒序 当前项目名称<br>artifactId：当前项目的模块名称<br>version：当前模块的版本</p><!--项目名称，定义为组织名+项目名，类似包名--><p><groupId>cn.itcast.maven</groupId></p><!-- 模块名称 --><p><artifactId>maven-first</artifactId></p><!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 --><p><version>0.0.1-SNAPSHOT</version><br><packaging>打包类型</packaging><br>jar：执行package会打成jar包<br>war：执行package会打成war包<br>pom ：用于maven工程的继承，通常父工程设置为pom</p><p>依赖小demo：</p><p>比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9</p><p>如下所示是junit4.9的依赖定义：</p><!-- 依赖关系 --><dependencies>        <!-- 此项目运行使用junit，所以此项目依赖junit -->        <dependency>            <!-- junit的项目名称 -->            <groupId>junit</groupId>            <!-- junit的模块名称 -->            <artifactId>junit</artifactId>            <!-- junit版本 -->            <version>4.9</version>            <!-- 依赖范围：单元测试时使用junit -->            <scope>test</scope>        </dependency></dependencies><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>A依赖B，需要在A的pom.xml文件中添加B的坐标，添加坐标时需要指定依赖范围，依赖范围包括：</p><p>compile：编译范围，指A在编译时依赖B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打z包。<br>provided：provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依赖在编译和测试时需要，在运行时不需要，比如：servlet api被tomcat容器提供。<br>runtime：runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以runtime范围的依赖会被打包。<br>test：test范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。<br>system：system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径，需要指定systemPath磁盘路径，system依赖不推荐使用。</p><p>在maven-web工程中测试各各scop。<br>测试总结：</p><p>默认引入 的jar包 ——- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ）<br>servlet-api 、jsp-api ——- provided （编译、测试 有效， 运行时无效 防止和tomcat下jar冲突）<br>jdbc驱动jar包 —- runtime （测试、运行 有效 ）<br>junit —– test （测试有效）<br>依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test<br>pom.xml基本配置<br>pom.xml是Maven项目的核心配置文件，位于每个工程的根目录，基本配置如下：</p><p>文件的根节点<br><project><br>    <artifactId> 模块名称，子项目名或模块名称就是Idea中的Module</artifactId><br>    <!--pom.xml使用的对象模型版本--><br>    <modelVersion>4.0.0</modelVersion><br>     <!--项目依赖构件配置，配置项目依赖构件的坐标--><br>    <dependencies><br>        <dependency><br>            <groupId>项目名称，一般写项目的域名</groupId><br>        <artifactId>模块名称，子项目名或模块名称</artifactId><br>            <version>产品的版本号</version><br>            <scope>依赖范围</scope><br>        </dependency><br>    </dependencies><br>    <build> 项目构建配置，配置编译、运行插件等。</build><br>    <name> 项目的显示名，常用于 Maven 生成的文档。</name><br>    <description>项目描述，常用于 Maven 生成的文档</description><br></project></p><p>依赖的传递性<br>假如：在你的Maven项目里定义了3个Maven工程</p><p>HelloFriend工程与工程2，和工程3</p><p>依赖关系：HelloFriend→工程2→工程3</p><p>我在HelloFriend这个最底层的工程添加了Spring-core依赖，那么在工程2和工程3中都有Spring-core的依赖，这个就是依赖的传递性</p><p>但是： 非compile范围的依赖不能传递，所以在各个工程的模块中，如果由需要，就得重复声明依赖。</p><p>依赖的排除</p><p>排除依赖的方式：</p><exclusions>        <exclusion>            <groupId>commos-logging</groupId>            <artifactId>commons-logging</artifactId>        </exclusion>    </exclusions><p>依赖的原则：</p><p>统一管理依赖的版本</p><p>继承<br>问题出现：</p><p>工程1依赖的Junit：4.0<br>工程2依赖的Junit：4.0<br>工程3依赖的Junit：4.9<br>由于依赖范围中的test不能传递，所以在各个模块的工程中，容易造成版本不一致</p><p>那么如何解决问题：让各个版本统一。</p><p>答案：将junit依赖统一到“父”工程中，在子工程中声明junit依赖时不指定版本</p><p>聚合<br>将多个工程拆分为模块后， 需要 手动逐个 安装 到仓库后 依赖 才能够生效。 修改 源码后 也 需要 逐个 手动进行 clean 操作。 而 使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。</p><p>在总的聚合工程中 使用 modules /module 标签 组合， 指定 模块工程的 相对 路径即 可</p><modules><module>../Hello</module><module>../HelloFriend</module><module>../MakeFriends</module></modules><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><h2 id="第一章：Maven基础回顾"><a href="#第一章：Maven基础回顾" class="headerlink" title="第一章：Maven基础回顾"></a>第一章：Maven基础回顾</h2><h3 id="1-1-Maven介绍"><a href="#1-1-Maven介绍" class="headerlink" title="1.1-Maven介绍"></a>1.1-Maven介绍</h3><ol><li>Maven是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。</li><li>依赖管理：就是对象jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。</li><li>项目构建：通过Maven的一个命令就可完成项目从清理、编译、测试、报告、打包，部署整个过程。</li></ol><h3 id="1-2-Maven仓库类型"><a href="#1-2-Maven仓库类型" class="headerlink" title="1.2-Maven仓库类型"></a>1.2-Maven仓库类型</h3><ol><li>本地仓库</li><li>远程仓库<ul><li>Maven中央仓库（地址：<a href="http://repo2.maven.org/maven2/%EF%BC%89">http://repo2.maven.org/maven2/）</a></li><li>maven私服（公司局域网内的仓库，需要自己搭建）</li><li>其他公共远程仓库（例如apache提供的远程仓库，地址：<a href="http://repo.maven.apache.org/maven2%EF%BC%89">http://repo.maven.apache.org/maven2）</a></li></ul></li></ol><h3 id="1-3-Maven常用命令"><a href="#1-3-Maven常用命令" class="headerlink" title="1.3-Maven常用命令"></a>1.3-Maven常用命令</h3><p><img src="/img/cphoto/maven06.jpg"></p><h3 id="1-4-Maven坐标书写规范"><a href="#1-4-Maven坐标书写规范" class="headerlink" title="1.4-Maven坐标书写规范"></a>1.4-Maven坐标书写规范</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>项目名<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>模块名<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Maven的依赖范围"><a href="#1-5-Maven的依赖范围" class="headerlink" title="1.5-Maven的依赖范围"></a>1.5-Maven的依赖范围</h3><p><img src="/img/cphoto/maven08.jpg"></p><h2 id="第二章：Maven的依赖传递"><a href="#第二章：Maven的依赖传递" class="headerlink" title="第二章：Maven的依赖传递"></a>第二章：Maven的依赖传递</h2><h3 id="2-1-什么是Maven的依赖传递"><a href="#2-1-什么是Maven的依赖传递" class="headerlink" title="2.1-什么是Maven的依赖传递"></a>2.1-什么是Maven的依赖传递</h3><p><img src="/img/cphoto/maven09.jpg"></p><h3 id="2-2-什么是依赖冲突"><a href="#2-2-什么是依赖冲突" class="headerlink" title="2.2-什么是依赖冲突"></a>2.2-什么是依赖冲突</h3><p><img src="/img/cphoto/maven10.jpg"></p><h3 id="2-3-如何解决依赖冲突"><a href="#2-3-如何解决依赖冲突" class="headerlink" title="2.3-如何解决依赖冲突"></a>2.3-如何解决依赖冲突</h3><p>1,使用maven提供的依赖调节原则</p><ul><li>第一声明者优先原则</li><li>路径近者优先原则</li></ul><p>2,排除依赖<br>3,锁定版本</p><h3 id="2-4-依赖调节原则"><a href="#2-4-依赖调节原则" class="headerlink" title="2.4-依赖调节原则"></a>2.4-依赖调节原则</h3><blockquote><p>第一声明优先原则</p></blockquote><p><img src="/img/cphoto/maven11.jpg"></p><blockquote><p>路径近者优先原则</p></blockquote><p><img src="/img/cphoto/maven12.jpg"></p><h3 id="2-5-排除依赖"><a href="#2-5-排除依赖" class="headerlink" title="2.5-排除依赖"></a>2.5-排除依赖</h3><p><img src="/img/cphoto/maven13.jpg"></p><h3 id="2-6-版本锁定"><a href="#2-6-版本锁定" class="headerlink" title="2.6-版本锁定"></a>2.6-版本锁定</h3><p><img src="/img/cphoto/maven14.jpg"></p><p><img src="/img/cphoto/maven15.jpg"></p><h2 id="第三章：分模块构建Maven工程"><a href="#第三章：分模块构建Maven工程" class="headerlink" title="第三章：分模块构建Maven工程"></a>第三章：分模块构建Maven工程</h2><h3 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1-分析"></a>3.1-分析</h3><blockquote><p>开发中</p></blockquote><p><img src="/img/cphoto/maven16.jpg"></p><h3 id="3-2-Maven工程的继承"><a href="#3-2-Maven工程的继承" class="headerlink" title="3.2-Maven工程的继承"></a>3.2-Maven工程的继承</h3><p><img src="/img/cphoto/maven17.jpg"></p><h3 id="3-3-Maven工程的聚合"><a href="#3-3-Maven工程的聚合" class="headerlink" title="3.3-Maven工程的聚合"></a>3.3-Maven工程的聚合</h3><p><img src="/img/cphoto/maven18.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2017/09/30/Redis/"/>
    <url>/2017/09/30/Redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库    1.1.什么是NOSQL        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。        1.1.1.    NOSQL和关系型数据库比较            优点：                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。            缺点：                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。                3）不提供关系型数据库对事务的处理。        1.1.2.    非关系型数据库的优势：            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。        1.1.3.    关系型数据库的优势：            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。        1.1.4.    总结            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，            让NoSQL数据库对关系型数据库的不足进行弥补。            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据    1.2.主流的NOSQL产品        •    键值(Key-Value)存储数据库                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。                 数据模型： 一系列键值对                优势： 快速查询                劣势： 存储的数据缺少结构化        •    列存储数据库                相关产品：Cassandra, HBase, Riak                典型应用：分布式的文件系统                数据模型：以列簇式存储，将同一列数据存在一起                优势：查找速度快，可扩展性强，更容易进行分布式扩展                劣势：功能相对局限        •    文档型数据库                相关产品：CouchDB、MongoDB                典型应用：Web应用（与Key-Value类似，Value是结构化的）                数据模型： 一系列键值对                优势：数据结构要求不严格                劣势： 查询性能不高，而且缺乏统一的查询语法        •    图形(Graph)数据库                相关数据库：Neo4J、InfoGrid、Infinite Graph                典型应用：社交网络                数据模型：图结构                优势：利用图结构相关算法。                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。    1.3 什么是Redis        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：            1) 字符串类型 string            2) 哈希类型 hash            3) 列表类型 list            4) 集合类型 set            5) 有序集合类型 sortedset        1.3.1 redis的应用场景            •    缓存（数据查询、短连接、新闻内容、商品内容等等）            •    聊天室的在线好友列表            •    任务队列。（秒杀、抢购、12306等等）            •    应用排行榜            •    网站访问统计            •    数据过期处理（可以精确到毫秒            •    分布式集群架构中的session分离2. 下载安装    1. 官网：https://redis.io    2. 中文网：http://www.redis.net.cn/    3. 解压直接可以使用：        * redis.windows.conf：配置文件        * redis-cli.exe：redis的客户端        * redis-server.exe：redis服务器端    3. 命令操作    1. redis的数据结构：        * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构            * value的数据结构：                1) 字符串类型 string                2) 哈希类型 hash ： map格式                  3) 列表类型 list ： linkedlist格式。支持重复元素                4) 集合类型 set  ： 不允许重复元素                5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序        2. 字符串类型 string        1. 存储： set key value            127.0.0.1:6379&gt; set username zhangsan            OK        2. 获取： get key            127.0.0.1:6379&gt; get username            &quot;zhangsan&quot;        3. 删除： del key            127.0.0.1:6379&gt; del age            (integer) 1    3. 哈希类型 hash        1. 存储： hset key field value            127.0.0.1:6379&gt; hset myhash username lisi            (integer) 1            127.0.0.1:6379&gt; hset myhash password 123            (integer) 1        2. 获取：             * hget key field: 获取指定的field对应的值                127.0.0.1:6379&gt; hget myhash username                &quot;lisi&quot;            * hgetall key：获取所有的field和value                127.0.0.1:6379&gt; hgetall myhash                1) &quot;username&quot;                2) &quot;lisi&quot;                3) &quot;password&quot;                4) &quot;123&quot;                        3. 删除： hdel key field            127.0.0.1:6379&gt; hdel myhash username            (integer) 1        4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）        1. 添加：            1. lpush key value: 将元素加入列表左表                            2. rpush key value：将元素加入列表右边                                127.0.0.1:6379&gt; lpush myList a                (integer) 1                127.0.0.1:6379&gt; lpush myList b                (integer) 2                127.0.0.1:6379&gt; rpush myList c                (integer) 3        2. 获取：            * lrange key start end ：范围获取                127.0.0.1:6379&gt; lrange myList 0 -1                1) &quot;b&quot;                2) &quot;a&quot;                3) &quot;c&quot;        3. 删除：            * lpop key： 删除列表最左边的元素，并将元素返回            * rpop key： 删除列表最右边的元素，并将元素返回    5. 集合类型 set ： 不允许重复元素        1. 存储：sadd key value            127.0.0.1:6379&gt; sadd myset a            (integer) 1            127.0.0.1:6379&gt; sadd myset a            (integer) 0        2. 获取：smembers key:获取set集合中所有元素            127.0.0.1:6379&gt; smembers myset            1) &quot;a&quot;        3. 删除：srem key value:删除set集合中的某个元素                127.0.0.1:6379&gt; srem myset a            (integer) 1    6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。        1. 存储：zadd key score value            127.0.0.1:6379&gt; zadd mysort 60 zhangsan            (integer) 1            127.0.0.1:6379&gt; zadd mysort 50 lisi            (integer) 1            127.0.0.1:6379&gt; zadd mysort 80 wangwu            (integer) 1        2. 获取：zrange key start end [withscores]            127.0.0.1:6379&gt; zrange mysort 0 -1            1) &quot;lisi&quot;            2) &quot;zhangsan&quot;            3) &quot;wangwu&quot;            127.0.0.1:6379&gt; zrange mysort 0 -1 withscores            1) &quot;zhangsan&quot;            2) &quot;60&quot;            3) &quot;wangwu&quot;            4) &quot;80&quot;            5) &quot;lisi&quot;            6) &quot;500&quot;        3. 删除：zrem key value            127.0.0.1:6379&gt; zrem mysort lisi            (integer) 1    7. 通用命令        1. keys * : 查询所有的键        2. type key ： 获取键对应的value的类型        3. del key：删除指定的key value4. 持久化    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。    2. redis持久化机制：        1. RDB：默认方式，不需要进行配置，默认就使用这种机制            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据            1. 编辑redis.windwos.conf文件                #   after 900 sec (15 min) if at least 1 key changed                save 900 1                #   after 300 sec (5 min) if at least 10 keys changed                save 300 10                #   after 60 sec if at least 10000 keys changed                save 60 10000                            2. 重新启动redis服务器，并指定配置文件名称                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf                        2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据            1. 编辑redis.windwos.conf文件                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）                                # appendfsync always ： 每一次操作都进行持久化                appendfsync everysec ： 每隔一秒进行一次持久化                # appendfsync no     ： 不进行持久化5. Java客户端 Jedis    * Jedis: 一款java操作redis数据库的工具.    * 使用步骤：        1. 下载jedis的jar包        2. 使用            //1. 获取连接            Jedis jedis = new Jedis(&quot;localhost&quot;,6379);               //2. 操作               jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //3. 关闭连接            jedis.close();</code></pre><p>​        </p><pre><code>    * Jedis操作各种redis中的数据结构        1) 字符串类型 string            set            get                         //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            //存储            jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //获取            String username = jedis.get(&quot;username&quot;);            System.out.println(username);                //可以使用setex()方法存储可以指定过期时间的 key value            jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对                //3. 关闭连接            jedis.close();        2) 哈希类型 hash ： map格式              hset            hget            hgetAll            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // 存储hash            jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);            jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);            jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);                // 获取hash            String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);            System.out.println(name);</code></pre><p>​        </p><pre><code>            // 获取hash的所有map中的数据            Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;);                // keyset            Set&lt;String&gt; keySet = user.keySet();            for (String key : keySet) &#123;                //获取value                String value = user.get(key);                System.out.println(key + &quot;:&quot; + value);            &#125;                //3. 关闭连接            jedis.close();        3) 列表类型 list ： linkedlist格式。支持重复元素            lpush / rpush            lpop / rpop            lrange start end : 范围获取                         //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // list 存储            jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存            jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存                // list 范围获取            List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist);                        // list 弹出            String element1 = jedis.lpop(&quot;mylist&quot;);//c            System.out.println(element1);                String element2 = jedis.rpop(&quot;mylist&quot;);//c            System.out.println(element2);                // list 范围获取            List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist2);                //3. 关闭连接            jedis.close();        4) 集合类型 set  ： 不允许重复元素            sadd            smembers:获取所有元素            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作</code></pre><p>​        </p><pre><code>            // set 存储            jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);                // set 获取            Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);            System.out.println(myset);                //3. 关闭连接            jedis.close();        5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序            zadd            zrange            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // sortedset 存储            jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);            jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);            jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);                // sortedset 获取            Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);                System.out.println(mysortedset);</code></pre><p>​        </p><pre><code>            //3. 关闭连接            jedis.close();</code></pre><p>​        </p><pre><code>    * jedis连接池： JedisPool        * 使用：            1. 创建JedisPool连接池对象            2. 调用方法 getResource()方法获取Jedis连接                //0.创建一个配置对象                JedisPoolConfig config = new JedisPoolConfig();                config.setMaxTotal(50);                config.setMaxIdle(10);                        //1.创建Jedis连接池对象                JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379);                        //2.获取连接                Jedis jedis = jedisPool.getResource();                //3. 使用                jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);</code></pre><p>​            </p><pre><code>                //4. 关闭 归还到连接池中                jedis.close();                * 连接池工具类            public class JedisPoolUtils &#123;                private static JedisPool jedisPool;                            static&#123;                    //读取配置文件                    InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);                    //创建Properties对象                    Properties pro = new Properties();                    //关联文件                    try &#123;                        pro.load(is);                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                    //获取数据，设置到JedisPoolConfig中                    JedisPoolConfig config = new JedisPoolConfig();                    config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));                    config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));                                //初始化JedisPool                    jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</code></pre><p>​<br>​                </p><pre><code>                &#125;</code></pre><p>​                </p><pre><code>                /**                 * 获取连接方法                 */                public static Jedis getJedis()&#123;                    return jedisPool.getResource();                &#125;            &#125;</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：    1. 提供index.html页面，页面中有一个省份 下拉列表    2. 当 页面加载完成后 发送ajax请求，加载所有省份* 注意：使用redis缓存一些不经常发生变化的数据。    * 数据库的数据一旦发生改变，则需要更新缓存。        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入        * 在service对应的增删改方法中，将redis数据删除。</code></pre><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery</title>
    <link href="/2017/09/29/JQuery/"/>
    <url>/2017/09/29/JQuery/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JQuery-基础："><a href="#JQuery-基础：" class="headerlink" title="JQuery 基础："></a>JQuery 基础：</h1><pre><code>1. 概念： 一个JavaScript框架。简化JS开发    * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。    * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已2. 快速入门    1. 步骤：        1. 下载JQuery            * 目前jQuery有三个大版本：                1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，                     功能不再新增。因此一般项目来说，使用1.x版本就可以了，                     最终版本：1.12.4 (2016年5月20日)                2.x：不兼容ie678，很少有人使用，官方只做BUG维护，                     功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，                     最终版本：2.2.4 (2016年5月20日)                3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，                     一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。                     目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）            * jquery-xxx.js 与 jquery-xxx.min.js区别：                1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些                2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快        2. 导入JQuery的js文件：导入min.js文件        3. 使用            var div1 = $(&quot;#div1&quot;);               alert(div1.html());3. JQuery对象和JS对象区别与转换    1. JQuery对象在操作时，更加方便。    2. JQuery对象和js对象方法不通用的.    3. 两者相互转换        * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引)        * js -- &gt; jq : $(js对象)4. 选择器：筛选具有相似特征的元素(标签)    1. 基本操作学习：        1. 事件绑定            //1.获取b1按钮            $(&quot;#b1&quot;).click(function()&#123;                alert(&quot;abc&quot;);            &#125;);        2. 入口函数             $(function () &#123;                               &#125;);             window.onload  和 $(function) 区别                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉                 * $(function)可以定义多次的。        3. 样式控制：css方法             // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);              $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);    2. 分类        1. 基本选择器            1. 标签选择器（元素选择器）                * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素            2. id选择器                 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素            3. 类选择器                * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素            4. 并集选择器：                * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素        2. 层级选择器            1. 后代选择器                * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素                    2. 子选择器                * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素        3. 属性选择器            1. 属性名称选择器                 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器            2. 属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器            3. 复合属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器        4. 过滤选择器            1. 首元素选择器                 * 语法： :first 获得选择的元素中的第一个元素            2. 尾元素选择器                 * 语法： :last 获得选择的元素中的最后一个元素            3. 非元素选择器                * 语法： :not(selector) 不包括指定内容的元素            4. 偶数选择器                * 语法： :even 偶数，从 0 开始计数            5. 奇数选择器                * 语法： :odd 奇数，从 0 开始计数            6. 等于索引选择器                * 语法： :eq(index) 指定索引元素            7. 大于索引选择器                 * 语法： :gt(index) 大于指定索引元素            8. 小于索引选择器                 * 语法： :lt(index) 小于指定索引元素            9. 标题选择器                * 语法： :header 获得标题（h1~h6）元素，固定写法        5. 表单过滤选择器            1. 可用元素选择器                 * 语法： :enabled 获得可用元素            2. 不可用元素选择器                 * 语法： :disabled 获得不可用元素            3. 选中选择器                 * 语法： :checked 获得单选/复选框选中的元素            4. 选中选择器                 * 语法： :selected 获得下拉框选中的元素5. DOM操作    1. 内容操作        1. html(): 获取/设置元素的标签体内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;        2. text(): 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容        3. val()： 获取/设置元素的value属性值    2. 属性操作        1. 通用属性操作            1. attr(): 获取/设置元素的属性            2. removeAttr():删除属性            3. prop():获取/设置元素的属性            4. removeProp():删除属性            * attr和prop区别？                1. 如果操作的是元素的固有属性，则建议使用prop                2. 如果操作的是元素自定义的属性，则建议使用attr        2. 对class属性操作            1. addClass():添加class属性值            2. removeClass():删除class属性值            3. toggleClass():切换class属性                * toggleClass(&quot;one&quot;):                     * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。  如果元素对象上不存在class=&quot;one&quot;，则添加            4. css():    3. CRUD操作:        1. append():父元素将子元素追加到末尾            * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾        2. prepend():父元素将子元素追加到开头            * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头        3. appendTo():            * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾        4. prependTo()：            * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头        5. after():添加元素到元素后边            * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系        6. before():添加元素到元素前边            * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        7. insertAfter()            * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系        8. insertBefore()            * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        9. remove():移除元素            * 对象.remove():将对象删除掉        10. empty():清空元素的所有后代元素。            * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点6. 案例</code></pre><h2 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h2><pre><code>1. JQuery 高级    1. 动画    2. 遍历    3. 事件绑定    4. 案例    5. 插件</code></pre><h2 id="JQuery-高级"><a href="#JQuery-高级" class="headerlink" title="JQuery 高级"></a>JQuery 高级</h2><pre><code>1. 动画    1. 三种方式显示和隐藏元素        1. 默认显示和隐藏方式            1. show([speed,[easing],[fn]])                1. 参数：                    1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)                    2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;                        * swing：动画执行时效果是 先慢，中间快，最后又慢                        * linear：动画执行时速度是匀速的                    3. fn：在动画完成时执行的函数，每个元素执行一次。            2. hide([speed,[easing],[fn]])            3. toggle([speed],[easing],[fn])                2. 滑动显示和隐藏方式            1. slideDown([speed],[easing],[fn])            2. slideUp([speed,[easing],[fn]])            3. slideToggle([speed],[easing],[fn])        3. 淡入淡出显示和隐藏方式            1. fadeIn([speed],[easing],[fn])            2. fadeOut([speed],[easing],[fn])            3. fadeToggle([speed,[easing],[fn]])2. 遍历    1. js的遍历方式        * for(初始化值;循环结束条件;步长)    2. jq的遍历方式        1. jq对象.each(callback)            1. 语法：                jquery对象.each(function(index,element)&#123;&#125;);                    * index:就是元素在集合中的索引                    * element：就是集合中的每一个元素对象                    * this：集合中的每一个元素对象            2. 回调函数返回值：                * true:如果当前function返回为false，则结束循环(break)。                * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)        2. $.each(object, [callback])        3. for..of: jquery 3.0 版本之后提供的方式            for(元素对象 of 容器对象)    3. 事件绑定    1. jquery标准的绑定方式        * jq对象.事件方法(回调函数)；        * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。            * 表单对象.submit();//让表单提交    2. on绑定事件/off解除绑定        * jq对象.on(&quot;事件名称&quot;,回调函数)        * jq对象.off(&quot;事件名称&quot;)            * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑    3. 事件切换：toggle        * jq对象.toggle(fn1,fn2...)            * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....                    * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。             &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;4. 案例    1. 广告显示和隐藏        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt;            &lt;style&gt;                #content&#123;width:100%;height:500px;background:#999&#125;            &lt;/style&gt;                    &lt;!--引入jquery--&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script&gt;                /*                    需求：                        1. 当页面加载完，3秒后。自动显示广告                        2. 广告显示5秒后，自动消失。                            分析：                        1. 使用定时器来完成。setTimeout (执行一次定时器)                        2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display                        3. 使用  show/hide方法来完成广告的显示                 */                        //入口函数，在页面加载完成之后，定义定时器，调用这两个方法                $(function () &#123;                   //定义定时器，调用adShow方法 3秒后执行一次                   setTimeout(adShow,3000);                   //定义定时器，调用adHide方法，8秒后执行一次                    setTimeout(adHide,8000);                &#125;);                //显示广告                function adShow() &#123;                    //获取广告div，调用显示方法                    $(&quot;#ad&quot;).show(&quot;slow&quot;);                &#125;                //隐藏广告                function adHide() &#123;                    //获取广告div，调用隐藏方法                    $(&quot;#ad&quot;).hide(&quot;slow&quot;);                &#125;</code></pre><p>​<br>​            </p><pre><code>            &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;!-- 整体的DIV --&gt;        &lt;div&gt;            &lt;!-- 广告DIV --&gt;            &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt;                &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt;            &lt;/div&gt;                    &lt;!-- 下方正文部分 --&gt;            &lt;div id=&quot;content&quot;&gt;                正文部分            &lt;/div&gt;        &lt;/div&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 抽奖        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;jquery案例之抽奖&lt;/title&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;                    &lt;script language=&#39;javascript&#39; type=&#39;text/javascript&#39;&gt;                        /*                    分析：                        1. 给开始按钮绑定单击事件                            1.1 定义循环定时器                            1.2 切换小相框的src属性                                * 定义数组，存放图片资源路径                                * 生成随机数。数组索引</code></pre><p>​            </p><pre><code>                        2. 给结束按钮绑定单击事件                            1.1 停止定时器                            1.2 给大相框设置src属性                         */                var imgs = [&quot;../img/man00.jpg&quot;,                            &quot;../img/man01.jpg&quot;,                            &quot;../img/man02.jpg&quot;,                            &quot;../img/man03.jpg&quot;,                            &quot;../img/man04.jpg&quot;,                            &quot;../img/man05.jpg&quot;,                            &quot;../img/man06.jpg&quot;,                            ];                var startId;//开始定时器的id                var index;//随机角标                $(function () &#123;                    //处理按钮是否可以使用的效果                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</code></pre><p>​            </p><pre><code>                   //1. 给开始按钮绑定单击事件                    $(&quot;#startID&quot;).click(function () &#123;                        // 1.1 定义循环定时器 20毫秒执行一次                        startId = setInterval(function () &#123;                            //处理按钮是否可以使用的效果                            $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true);                            $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false);</code></pre><p>​            </p><pre><code>                            //1.2生成随机角标 0-6                            index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999                            //1.3设置小相框的src属性                            $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);                                &#125;,20);                    &#125;);</code></pre><p>​            </p><pre><code>                    //2. 给结束按钮绑定单击事件                    $(&quot;#stopID&quot;).click(function () &#123;                        //处理按钮是否可以使用的效果                        $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                        $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</code></pre><p>​            </p><pre><code>                       // 1.1 停止定时器                        clearInterval(startId);                       // 1.2 给大相框设置src属性                        $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide();                        //显示1秒之后                        $(&quot;#img2ID&quot;).show(1000);                    &#125;);                &#125;);</code></pre><p>​<br>​<br>​            </p><pre><code>            &lt;/script&gt;                &lt;/head&gt;        &lt;body&gt;                &lt;!-- 小像框 --&gt;        &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;            &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;        &lt;/div&gt;                &lt;!-- 大像框 --&gt;        &lt;div                style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;            &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;        &lt;/div&gt;                &lt;!-- 开始按钮 --&gt;        &lt;input                id=&quot;startID&quot;                type=&quot;button&quot;                value=&quot;点击开始&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;                &lt;!-- 停止按钮 --&gt;        &lt;input                id=&quot;stopID&quot;                type=&quot;button&quot;                value=&quot;点击停止&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;</code></pre><p>​            </p><pre><code>        &lt;/body&gt;        &lt;/html&gt;5. 插件：增强JQuery的功能    1. 实现方式：        1. $.fn.extend(object)             * 增强通过Jquery获取的对象的功能  $(&quot;#id&quot;)        2. $.extend(object)            * 增强JQeury对象自身的功能  $/jQuery</code></pre><p>​            </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat&amp;Servlet</title>
    <link href="/2017/09/26/Tomcat&amp;Servlet/"/>
    <url>/2017/09/26/Tomcat&amp;Servlet/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tomcat-amp-Servlet"><a href="#Tomcat-amp-Servlet" class="headerlink" title="Tomcat&amp;Servlet"></a>Tomcat&amp;Servlet</h1><pre><code>1. web相关概念回顾2. web服务器软件：Tomcat3. Servlet入门学习</code></pre><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人                * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称                * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。* 快速入门：    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;            &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;* 执行原理：    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法* Servlet中的生命周期方法：    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target(&#123;ElementType.TYPE&#125;)            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet &#123;                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                            String[] value() default &#123;&#125;;//代表urlPatterns()属性配置                            String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;                            int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                            WebInitParam[] initParams() default &#123;&#125;;                            boolean asyncSupported() default false;                            String smallIcon() default &quot;&quot;;                            String largeIcon() default &quot;&quot;;                            String description() default &quot;&quot;;                            String displayName() default &quot;&quot;;            &#125;</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre><h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><pre><code>1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0 注解配置6. Servlet的体系结构        Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法7. Servlet相关配置    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre><h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><pre><code>* 概念：Hyper Text Transfer Protocol 超文本传输协议    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式    * 特点：        1. 基于TCP/IP的高级协议        2. 默认端口号:80        3. 基于请求/响应模型的:一次请求对应一次响应        4. 无状态的：每次请求之间相互独立，不能交互数据    * 历史版本：        * 1.0：每一次请求响应都会建立新的连接        * 1.1：复用连接* 请求消息数据格式    1. 请求行        请求方式 请求url 请求协议/版本        GET /login.html    HTTP/1.1        * 请求方式：            * HTTP协议有7中请求方式，常用的有2种                * GET：                    1. 请求参数在请求行中，在url后。                    2. 请求的url长度有限制的                    3. 不太安全                * POST：                    1. 请求参数在请求体中                    2. 请求的url长度没有限制的                    3. 相对安全    2. 请求头：客户端浏览器告诉服务器一些信息        请求头名称: 请求头值        * 常见的请求头：            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题            2. Referer：http://localhost/login.html                * 告诉服务器，我(当前请求)从哪里来？                    * 作用：                        1. 防盗链：                        2. 统计工作：    3. 请求空行        空行，就是用于分割POST请求的请求头，和请求体的。    4. 请求体(正文)：        * 封装POST请求消息的请求参数的    * 字符串格式：        POST /login.html    HTTP/1.1        Host: localhost        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2        Accept-Encoding: gzip, deflate        Referer: http://localhost/login.html        Connection: keep-alive        Upgrade-Insecure-Requests: 1                username=zhangsan    * 响应消息数据格式</code></pre><h2 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h2><pre><code>1. request对象和response对象的原理    1. request和response对象是由服务器创建的。我们来使用它们    2. request对象是来获取请求消息，response对象是来设置响应消息2. request对象继承体系结构：        ServletRequest        --    接口        |    继承    HttpServletRequest    -- 接口        |    实现    org.apache.catalina.connector.RequestFacade 类(tomcat)3. request功能：    1. 获取请求消息数据        1. 获取请求行数据            * GET /day14/demo1?name=zhangsan HTTP/1.1            * 方法：                1. 获取请求方式 ：GET                    * String getMethod()                  2. (*)获取虚拟目录：/day14                    * String getContextPath()                3. 获取Servlet路径: /demo1                    * String getServletPath()                4. 获取get方式请求参数：name=zhangsan                    * String getQueryString()                5. (*)获取请求URI：/day14/demo1                    * String getRequestURI():        /day14/demo1                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国                    * URI：统一资源标识符 : /day14/demo1                    共和国                                6. 获取协议及版本：HTTP/1.1                    * String getProtocol()                7. 获取客户机的IP地址：                    * String getRemoteAddr()                        2. 获取请求头数据            * 方法：                * (*)String getHeader(String name):通过请求头的名称获取请求头的值                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称                    3. 获取请求体数据:            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数            * 步骤：                1. 获取流对象                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据                        * 在文件上传知识点后讲解                2. 再从流对象中拿数据</code></pre><p>​                </p><pre><code>    2. 其他功能：        1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数            1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123            2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game            3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称            4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合            * 中文乱码问题：                * get方式：tomcat 8 已经将get方式乱码问题解决了                * post方式：会乱码                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);</code></pre><p>​                    </p><pre><code>        2. 请求转发：一种在服务器内部的资源跳转方式            1. 步骤：                1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)                2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)             2. 特点：                1. 浏览器地址栏路径不发生变化                2. 只能转发到当前服务器内部资源中。                3. 转发是一次请求        3. 共享数据：            * 域对象：一个有作用范围的对象，可以在范围内共享数据            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据            * 方法：                1. void setAttribute(String name,Object obj):存储数据                2. Object getAttitude(String name):通过键获取值                3. void removeAttribute(String name):通过键移除键值对        4. 获取ServletContext：            * ServletContext getServletContext()</code></pre><h2 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h2><pre><code>* 用户登录案例需求：    1.编写login.html登录页面        username &amp; password 两个输入框    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表    3.使用JdbcTemplate技术封装JDBC    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误* 分析* 开发步骤    1. 创建项目，导入html页面，配置文件，jar包    2. 创建数据库环境        CREATE DATABASE day14;        USE day14;        CREATE TABLE USER(                    id INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(32) UNIQUE NOT NULL,            PASSWORD VARCHAR(32) NOT NULL        );    3. 创建包cn.itcast.domain,创建类User        package cn.itcast.domain;        /**         * 用户的实体类         */        public class User &#123;                    private int id;            private String username;            private String password;</code></pre><p>​            </p><pre><code>            public int getId() &#123;                return id;            &#125;                    public void setId(int id) &#123;                this.id = id;            &#125;                    public String getUsername() &#123;                return username;            &#125;                    public void setUsername(String username) &#123;                this.username = username;            &#125;                    public String getPassword() &#123;                return password;            &#125;                    public void setPassword(String password) &#123;                this.password = password;            &#125;                    @Override            public String toString() &#123;                return &quot;User&#123;&quot; +                        &quot;id=&quot; + id +                        &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                        &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                        &#39;&#125;&#39;;            &#125;        &#125;    4. 创建包cn.itcast.util,编写工具类JDBCUtils        package cn.itcast.util;        import com.alibaba.druid.pool.DruidDataSourceFactory;                import javax.sql.DataSource;        import javax.xml.crypto.Data;        import java.io.IOException;        import java.io.InputStream;        import java.sql.Connection;        import java.sql.SQLException;        import java.util.Properties;                /**         * JDBC工具类 使用Durid连接池         */        public class JDBCUtils &#123;                    private static DataSource ds ;                    static &#123;                        try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    //使用ClassLoader加载配置文件，获取字节输入流                    InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);                    pro.load(is);                            //2.初始化连接池对象                    ds = DruidDataSourceFactory.createDataSource(pro);                        &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;                    /**             * 获取连接池对象             */            public static DataSource getDataSource()&#123;                return ds;            &#125;</code></pre><p>​            </p><pre><code>            /**             * 获取连接Connection对象             */            public static Connection getConnection() throws SQLException &#123;                return  ds.getConnection();            &#125;        &#125;    5. 创建包cn.itcast.dao,创建类UserDao,提供login方法                package cn.itcast.dao;        import cn.itcast.domain.User;        import cn.itcast.util.JDBCUtils;        import org.springframework.dao.DataAccessException;        import org.springframework.jdbc.core.BeanPropertyRowMapper;        import org.springframework.jdbc.core.JdbcTemplate;                /**         * 操作数据库中User表的类         */        public class UserDao &#123;                    //声明JDBCTemplate对象共用            private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                    /**             * 登录方法             * @param loginUser 只有用户名和密码             * @return user包含用户全部数据,没有查询到，返回null             */            public User login(User loginUser)&#123;                try &#123;                    //1.编写sql                    String sql = &quot;select * from user where username = ? and password = ?&quot;;                    //2.调用query方法                    User user = template.queryForObject(sql,                            new BeanPropertyRowMapper&lt;User&gt;(User.class),                            loginUser.getUsername(), loginUser.getPassword());</code></pre><p>​            </p><pre><code>                    return user;                &#125; catch (DataAccessException e) &#123;                    e.printStackTrace();//记录日志                    return null;                &#125;            &#125;        &#125;        6. 编写cn.itcast.web.servlet.LoginServlet类        package cn.itcast.web.servlet;        import cn.itcast.dao.UserDao;        import cn.itcast.domain.User;                import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;</code></pre><p>​            </p><pre><code>        @WebServlet(&quot;/loginServlet&quot;)        public class LoginServlet extends HttpServlet &#123;</code></pre><p>​            </p><pre><code>            @Override            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                //1.设置编码                req.setCharacterEncoding(&quot;utf-8&quot;);                //2.获取请求参数                String username = req.getParameter(&quot;username&quot;);                String password = req.getParameter(&quot;password&quot;);                //3.封装user对象                User loginUser = new User();                loginUser.setUsername(username);                loginUser.setPassword(password);                        //4.调用UserDao的login方法                UserDao dao = new UserDao();                User user = dao.login(loginUser);                        //5.判断user                if(user == null)&#123;                    //登录失败                    req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp);                &#125;else&#123;                    //登录成功                    //存储数据                    req.setAttribute(&quot;user&quot;,user);                    //转发                    req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp);                &#125;                    &#125;                    @Override            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                this.doGet(req,resp);            &#125;        &#125;    7. 编写FailServlet和SuccessServlet类        @WebServlet(&quot;/successServlet&quot;)        public class SuccessServlet extends HttpServlet &#123;            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                //获取request域中共享的user对象                User user = (User) request.getAttribute(&quot;user&quot;);                        if(user != null)&#123;                    //给页面写一句话                            //设置编码                    response.setContentType(&quot;text/html;charset=utf-8&quot;);                    //输出                    response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;);                &#125;</code></pre><p>​            </p><pre><code>            &#125;                @WebServlet(&quot;/failServlet&quot;)        public class FailServlet extends HttpServlet &#123;            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                //给页面写一句话                        //设置编码                response.setContentType(&quot;text/html;charset=utf-8&quot;);                //输出                response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;);                    &#125;                    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                this.doPost(request,response);            &#125;        &#125;    8. login.html中form表单的action路径的写法        * 虚拟目录+Servlet的资源路径    9. BeanUtils工具类，简化数据封装        * 用于封装JavaBean的        1. JavaBean：标准的Java类            1. 要求：                1. 类必须被public修饰                2. 必须提供空参的构造器                3. 成员变量必须使用private修饰                4. 提供公共setter和getter方法            2. 功能：封装数据        2. 概念：            成员变量：            属性：setter和getter方法截取后的产物                例如：getUsername() --&gt; Username--&gt; username        3. 方法：            1. setProperty()            2. getProperty()            3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre><h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><pre><code>1. 请求消息：客户端发送给服务器端的数据    * 数据格式：        1. 请求行        2. 请求头        3. 请求空行        4. 请求体2. 响应消息：服务器端发送给客户端的数据    * 数据格式：        1. 响应行            1. 组成：协议/版本 响应状态码 状态码描述            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。                1. 状态码都是3位数字                 2. 分类：                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码                    2. 2xx：成功。代表：200                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)                    4. 4xx：客户端错误。                        * 代表：                            * 404（请求路径没有对应的资源）                             * 405：请求方式没有对应的doXxx方法                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)</code></pre><p>​                    </p><pre><code>        2. 响应头：            1. 格式：头名称： 值            2. 常见的响应头：                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据                    * 值：                        * in-line:默认值,在当前页面内打开                        * attachment;filename=xxx：以附件形式打开响应体。文件下载        3. 响应空行        4. 响应体:传输的数据    * 响应字符串格式        HTTP/1.1 200 OK        Content-Type: text/html;charset=UTF-8        Content-Length: 101        Date: Wed, 06 Jun 2018 07:08:42 GMT        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;$Title$&lt;/title&gt;          &lt;/head&gt;          &lt;body&gt;          hello , response          &lt;/body&gt;        &lt;/html&gt;</code></pre><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息    1. 设置响应行        1. 格式：HTTP/1.1 200 ok        2. 设置状态码：setStatus(int sc)     2. 设置响应头：setHeader(String name, String value)             3. 设置响应体：        * 使用步骤：            1. 获取输出流                * 字符输出流：PrintWriter getWriter()                * 字节输出流：ServletOutputStream getOutputStream()            2. 使用输出流，将数据输出到客户端浏览器* 案例：    1. 完成重定向        * 重定向：资源跳转的方式        * 代码实现：            //1. 设置状态码为302            response.setStatus(302);            //2.设置响应头location            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);            //简单的重定向方法            response.sendRedirect(&quot;/day15/responseDemo2&quot;);        * 重定向的特点:redirect            1. 地址栏发生变化            2. 重定向可以访问其他站点(服务器)的资源            3. 重定向是两次请求。不能使用request对象来共享数据        * 转发的特点：forward            1. 转发地址栏路径不变            2. 转发只能访问当前服务器下的资源            3. 转发是一次请求，可以使用request对象来共享数据                * forward 和  redirect 区别                    * 路径写法：            1. 路径分类                1. 相对路径：通过相对路径不可以确定唯一资源                    * 如：./index.html                    * 不以/开头，以.开头路径                    * 规则：找到当前资源和目标资源之间的相对位置关系                        * ./：当前目录                        * ../:后退一级目录                2. 绝对路径：通过绝对路径可以确定唯一资源                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2                    * 以/开头的路径                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)                            * 建议虚拟目录动态获取：request.getContextPath()                            * &lt;a&gt; , &lt;form&gt; 重定向...                        * 给服务器使用：不需要加虚拟目录                            * 转发路径</code></pre><p>​<br>​                        </p><pre><code>    2. 服务器输出字符数据到浏览器        * 步骤：            1. 获取字符输出流            2. 输出数据        * 注意：            * 乱码问题：                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1                2. 设置该流的默认编码                3. 告诉浏览器响应体使用的编码                //简单的形式，设置编码，是在获取流之前设置                response.setContentType(&quot;text/html;charset=utf-8&quot;);    3. 服务器输出字节数据到浏览器        * 步骤：            1. 获取字节输出流            2. 输出数据    4. 验证码        1. 本质：图片        2. 目的：防止恶意表单注册</code></pre><h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信2. 获取：    1. 通过request对象获取        request.getServletContext();    2. 通过HttpServlet获取        this.getServletContext();3. 功能：    1. 获取MIME类型：        * MIME类型:在互联网通信过程中定义的一种文件数据类型            * 格式： 大类型/小类型   text/html        image/jpeg        * 获取：String getMimeType(String file)      2. 域对象：共享数据        1. setAttribute(String name,Object value)        2. getAttribute(String name)        3. removeAttribute(String name)        * ServletContext对象范围：所有用户所有请求的数据    3. 获取文件的真实(服务器)路径        1. 方法：String getRealPath(String path)               String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问             System.out.println(b);                String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问            System.out.println(c);                String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问            System.out.println(a);</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：    1. 页面显示超链接    2. 点击超链接后弹出下载提示框    3. 完成图片文件下载* 分析：    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求    2. 任何资源都必须弹出下载提示框    3. 使用响应头设置资源的打开方式：        * content-disposition:attachment;filename=xxx* 步骤：    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename    2. 定义Servlet        1. 获取文件名称        2. 使用字节输入流加载文件进内存        3. 指定response的响应头： content-disposition:attachment;filename=xxx        4. 将数据写出到response输出流* 问题：    * 中文文件问题        * 解决思路：            1. 获取客户端使用的浏览器版本信息            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><pre><code>1. 会话：一次会话中包含多次请求和响应。    * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止2. 功能：在一次会话的范围内的多次请求间，共享数据3. 方式：    1. 客户端会话技术：Cookie    2. 服务器端会话技术：Session</code></pre><h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2><pre><code>1. 概念：客户端会话技术，将数据保存到客户端2. 快速入门：    * 使用步骤：        1. 创建Cookie对象，绑定数据            * new Cookie(String name, String value)         2. 发送Cookie对象            * response.addCookie(Cookie cookie)         3. 获取Cookie，拿到数据            * Cookie[]  request.getCookies()  3. 实现原理    * 基于响应头set-cookie和请求头cookie实现4. cookie的细节    1. 一次可不可以发送多个cookie?        * 可以        * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。    2. cookie在浏览器中保存多长时间？        1. 默认情况下，当浏览器关闭后，Cookie数据被销毁        2. 持久化存储：            * setMaxAge(int seconds)                1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效                2. 负数：默认值                3. 零：删除cookie信息    3. cookie能不能存中文？        * 在tomcat 8 之前 cookie中不能直接存储中文数据。            * 需要将中文数据转码---一般采用URL编码(%E3)        * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析    4. cookie共享问题？        1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？            * 默认情况下cookie不能共享            * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录                * 如果要共享，则可以将path设置为&quot;/&quot;</code></pre><p>​            </p><pre><code>        2. 不同的tomcat服务器间cookie共享问题？            * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享                * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享5. Cookie的特点和作用    1. cookie存储数据在客户端浏览器    2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)    * 作用：        1. cookie一般用于存出少量的不太敏感的数据        2. 在不登录的情况下，完成服务器对客户端的身份识别6. 案例：记住上一次访问时间    1. 需求：        1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。        2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串    2. 分析：        1. 可以采用Cookie来完成        2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie            1. 有：不是第一次访问                1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20                2. 写回Cookie：lastTime=2018年6月10日11:50:01            2. 没有：是第一次访问                1. 响应数据：您好，欢迎您首次访问                2. 写回Cookie：lastTime=2018年6月10日11:50:01    3. 代码实现：        package cn.itcast.cookie;        import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.Cookie;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;        import java.net.URLDecoder;        import java.net.URLEncoder;        import java.text.SimpleDateFormat;        import java.util.Date;    @WebServlet(&quot;/cookieTest&quot;)    public class CookieTest extends HttpServlet &#123;        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            //设置响应的消息体的数据格式以及编码            response.setContentType(&quot;text/html;charset=utf-8&quot;);                //1.获取所有Cookie            Cookie[] cookies = request.getCookies();            boolean flag = false;//没有cookie为lastTime            //2.遍历cookie数组            if(cookies != null &amp;&amp; cookies.length &gt; 0)&#123;                for (Cookie cookie : cookies) &#123;                    //3.获取cookie的名称                    String name = cookie.getName();                    //4.判断名称是否是：lastTime                    if(&quot;lastTime&quot;.equals(name))&#123;                        //有该Cookie，不是第一次访问                            flag = true;//有lastTime的cookie                            //设置Cookie的value                        //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                        Date date  = new Date();                        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                        String str_date = sdf.format(date);                        System.out.println(&quot;编码前：&quot;+str_date);                        //URL编码                        str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                        System.out.println(&quot;编码后：&quot;+str_date);                        cookie.setValue(str_date);                        //设置cookie的存活时间                        cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                        response.addCookie(cookie);</code></pre><p>​        </p><pre><code>                        //响应数据                        //获取Cookie的value，时间                        String value = cookie.getValue();                        System.out.println(&quot;解码前：&quot;+value);                        //URL解码：                        value = URLDecoder.decode(value,&quot;utf-8&quot;);                        System.out.println(&quot;解码后：&quot;+value);                        response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;);                            break;                        &#125;                &#125;            &#125;</code></pre><p>​        </p><pre><code>            if(cookies == null || cookies.length == 0 || flag == false)&#123;                //没有，第一次访问                    //设置Cookie的value                //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                Date date  = new Date();                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                String str_date = sdf.format(date);                System.out.println(&quot;编码前：&quot;+str_date);                //URL编码                str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                System.out.println(&quot;编码后：&quot;+str_date);                    Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);                //设置cookie的存活时间                cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                response.addCookie(cookie);                    response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;);            &#125;</code></pre><p>​        </p><pre><code>        &#125;            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            this.doPost(request, response);        &#125;    &#125;</code></pre><h2 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h2><pre><code>1. 概念：    * Java Server Pages： java服务器端页面        * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码        * 用于简化书写！！！2. 原理    * JSP本质上就是一个Servlet3. JSP的脚本：JSP定义Java代码的方式    1. &lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。    2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。    3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。4. JSP的内置对象：    * 在jsp页面中不需要获取和创建，可以直接使用的对象    * jsp一共有9个内置对象。    * 今天学习3个：        * request        * response        * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似            * response.getWriter()和out.write()的区别：                * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。                * response.getWriter()数据输出永远在out.write()之前            5. 案例:改造Cookie案例</code></pre><h2 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h2><pre><code>1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession2. 快速入门：    1. 获取HttpSession对象：        HttpSession session = request.getSession();    2. 使用HttpSession对象：        Object getAttribute(String name)          void setAttribute(String name, Object value)        void removeAttribute(String name)  3. 原理    * Session的实现是依赖于Cookie的。</code></pre><p>​    </p><pre><code>4. 细节：    1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？        * 默认情况下。不是。        * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。             Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());             c.setMaxAge(60*60);             response.addCookie(c);    2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？        * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作            * session的钝化：                * 在服务器正常关闭之前，将session对象系列化到硬盘上            * session的活化：                * 在服务器启动后，将session文件转化为内存中的session对象即可。                3. session什么时候被销毁？        1. 服务器关闭        2. session对象调用invalidate() 。        3. session默认失效时间 30分钟            选择性配置修改                &lt;session-config&gt;                &lt;session-timeout&gt;30&lt;/session-timeout&gt;            &lt;/session-config&gt; 5. session的特点     1. session用于存储一次会话的多次请求的数据，存在服务器端     2. session可以存储任意类型，任意大小的数据    * session与Cookie的区别：        1. session存储数据在服务器端，Cookie在客户端        2. session没有数据大小限制，Cookie有        3. session数据安全，Cookie相对于不安全</code></pre><h2 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h2><pre><code>1. 案例需求：    1. 访问带有验证码的登录页面login.jsp    2. 用户输入用户名，密码以及验证码。        * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误        * 如果验证码输入有误，跳转登录页面，提示：验证码错误        * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</code></pre><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP:"></a>JSP:</h2><pre><code>1. 指令    * 作用：用于配置JSP页面，导入资源文件    * 格式：        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;    * 分类：        1. page        ： 配置JSP页面的            * contentType：等同于response.setContentType()                1. 设置响应体的mime类型以及字符集                2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）            * import：导包            * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面            * isErrorPage：标识当前也是是否是错误页面。                * true：是，可以使用内置对象exception                * false：否。默认值。不可以使用内置对象exception        2. include    ： 页面包含的。导入页面的资源文件            * &lt;%@include file=&quot;top.jsp&quot;%&gt;        3. taglib    ： 导入资源            * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;                * prefix：前缀，自定义的2. 注释:    1. html注释：        &lt;!-- --&gt;:只能注释html代码片段    2. jsp注释：推荐使用        &lt;%-- --%&gt;：可以注释所有3. 内置对象    * 在jsp页面中不需要创建，直接使用的对象    * 一共有9个：            变量名                    真实类型                        作用        * pageContext                PageContext                    当前页面共享数据，还可以获取其他八个内置对象        * request                    HttpServletRequest            一次请求访问的多个资源(转发)        * session                    HttpSession                    一次会话的多个请求间        * application                ServletContext                所有用户间共享数据        * response                    HttpServletResponse            响应对象        * page                        Object                        当前页面(Servlet)的对象  this        * out                        JspWriter                    输出对象，数据输出到页面上        * config                    ServletConfig                Servlet的配置对象        * exception                    Throwable                    异常对象</code></pre><p>​    </p><h2 id="MVC：开发模式"><a href="#MVC：开发模式" class="headerlink" title="MVC：开发模式"></a>MVC：开发模式</h2><pre><code>1. jsp演变历史    1. 早期只有servlet，只能使用response输出标签数据，非常麻烦    2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作    3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性2. MVC：    1. M：Model，模型。JavaBean        * 完成具体的业务操作，如：查询数据库，封装对象    2. V：View，视图。JSP        * 展示数据    3. C：Controller，控制器。Servlet        * 获取用户的输入        * 调用模型        * 将数据交给视图进行展示    * 优缺点：        1. 优点：            1. 耦合性低，方便维护，可以利于分工协作            2. 重用性高        2. 缺点：            1. 使得项目架构变得复杂，对开发人员要求高</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. 概念：Expression Language 表达式语言2. 作用：替换和简化jsp页面中java代码的编写3. 语法：$&#123;表达式&#125;4. 注意：    * jsp默认支持el表达式的。如果要忽略el表达式        1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式        2. \$&#123;表达式&#125; ：忽略当前这个el表达式5. 使用：    1. 运算：        * 运算符：            1. 算数运算符： + - * /(div) %(mod)            2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=            3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not)            4. 空运算符： empty                * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0                * $&#123;empty list&#125;:判断字符串、集合、数组对象是否为null或者长度为0                * $&#123;not empty str&#125;:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0    2. 获取值        1. el表达式只能从域对象中获取值        2. 语法：            1. $&#123;域名称.键名&#125;：从指定域中获取指定键的值                * 域名称：                    1. pageScope        --&gt; pageContext                    2. requestScope     --&gt; request                    3. sessionScope     --&gt; session                    4. applicationScope --&gt; application（ServletContext）                * 举例：在request域中存储了name=张三                * 获取：$&#123;requestScope.name&#125;            2. $&#123;键名&#125;：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</code></pre><p>​<br>​                </p><pre><code>            3. 获取对象、List集合、Map集合的值                1. 对象：$&#123;域名称.键名.属性名&#125;                    * 本质上会去调用对象的getter方法                2. List集合：$&#123;域名称.键名[索引]&#125;                3. Map集合：                    * $&#123;域名称.键名.key名称&#125;                    * $&#123;域名称.键名[&quot;key名称&quot;]&#125;    3. 隐式对象：        * el表达式中有11个隐式对象        * pageContext：            * 获取jsp其他八个内置对象                * $&#123;pageContext.request.contextPath&#125;：动态获取虚拟目录</code></pre><p>​    </p><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><pre><code>1. 概念：JavaServer Pages Tag Library  JSP标准标签库    * 是由Apache组织提供的开源的免费的jsp标签        &lt;标签&gt;2. 作用：用于简化和替换jsp页面上的java代码        3. 使用步骤：    1. 导入jstl相关jar包    2. 引入标签库：taglib指令：  &lt;%@ taglib %&gt;    3. 使用标签4. 常用的JSTL标签    1. if:相当于java代码的if语句        1. 属性：            * test 必须属性，接受boolean表达式                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容                * 一般情况下，test属性值会结合el表达式一起使用            2. 注意：                * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签    2. choose:相当于java代码的switch语句        1. 使用choose标签声明                     相当于switch声明        2. 使用when标签做判断                     相当于case        3. 使用otherwise标签做其他情况的声明        相当于default    3. foreach:相当于java代码的for语句5. 练习：    * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中</code></pre><h2 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h2><pre><code>1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互2. 业务逻辑层：处理业务逻辑的。3. 数据访问层：操作数据存储文件。</code></pre><h2 id="案例：用户信息列表展示"><a href="#案例：用户信息列表展示" class="headerlink" title="案例：用户信息列表展示"></a>案例：用户信息列表展示</h2><pre><code>1. 需求：用户信息的增删改查操作2. 设计：    1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat    2. 数据库设计：        create database day17; -- 创建数据库        use day17;                -- 使用数据库        create table user(   -- 创建表            id int primary key auto_increment,            name varchar(20) not null,            gender varchar(5),            age int,            address varchar(32),            qq    varchar(20),            email varchar(50)        );3. 开发：    1. 环境搭建        1. 创建数据库环境        2. 创建项目，导入需要的jar包    2. 编码4. 测试5. 部署运维</code></pre><h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1><pre><code>1. 概念：    * 生活中的过滤器：净水器,空气净化器，土匪、    * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。    * 过滤器的作用：        * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...2. 快速入门：    1. 步骤：        1. 定义一个类，实现接口Filter        2. 复写方法        3. 配置拦截路径            1. web.xml            2. 注解    2. 代码：        @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器        public class FilterDemo1 implements Filter &#123;            @Override            public void init(FilterConfig filterConfig) throws ServletException &#123;                    &#125;                    @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                System.out.println(&quot;filterDemo1被执行了....&quot;);</code></pre><p>​            </p><pre><code>                //放行                filterChain.doFilter(servletRequest,servletResponse);                    &#125;                    @Override            public void destroy() &#123;                    &#125;        &#125;3. 过滤器细节：    1. web.xml配置            &lt;filter&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;        &lt;/filter&gt;        &lt;filter-mapping&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;!-- 拦截路径 --&gt;            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;        &lt;/filter-mapping&gt;    2. 过滤器执行流程        1. 执行过滤器        2. 执行放行后的资源        3. 回来执行过滤器放行代码下边的代码    3. 过滤器生命周期方法        1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源        2. doFilter:每一次请求被拦截资源时，会执行。执行多次        3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源    4. 过滤器配置详解        * 拦截路径配置：            1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行            2. 拦截目录： /user/*    访问/user下的所有资源时，过滤器都会被执行            3. 后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行            4. 拦截所有资源：/*        访问所有资源时，过滤器都会被执行        * 拦截方式配置：资源被访问的方式            * 注解配置：                * 设置dispatcherTypes属性                    1. REQUEST：默认值。浏览器直接请求资源                    2. FORWARD：转发访问资源                    3. INCLUDE：包含访问资源                    4. ERROR：错误跳转资源                    5. ASYNC：异步访问资源            * web.xml配置                * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可                5. 过滤器链(配置多个过滤器)        * 执行顺序：如果有两个过滤器：过滤器1和过滤器2            1. 过滤器1            2. 过滤器2            3. 资源执行            4. 过滤器2            5. 过滤器1         * 过滤器先后顺序问题：            1. 注解配置：按照类名的字符串比较规则比较，值小的先执行                * 如： AFilter 和 BFilter，AFilter就先执行了。            2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行4. 案例：    1. 案例1_登录验证        * 需求：            1. 访问day17_case案例的资源。验证其是否登录            2. 如果登录了，则直接放行。            3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。</code></pre><p>​    </p><pre><code>    2. 案例2_敏感词汇过滤        * 需求：            1. 对day17_case案例录入的数据进行敏感词汇过滤            2. 敏感词汇参考《敏感词汇.txt》            3. 如果是敏感词汇，替换为 ***         * 分析：            1. 对request对象进行增强。增强获取参数相关方法            2. 放行。传递代理对象        * 增强对象的功能：            * 设计模式：一些通用的解决固定问题的方式            1. 装饰模式            2. 代理模式                * 概念：                    1. 真实对象：被代理的对象                    2. 代理对象：                    3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的                 * 实现方式：                     1. 静态代理：有一个类文件描述代理模式                     2. 动态代理：在内存中形成代理类                        * 实现步骤：                            1. 代理对象和真实对象实现相同的接口                            2. 代理对象 = Proxy.newProxyInstance();                            3. 使用代理对象调用方法。                            4. 增强方法                        * 增强方式：                            1. 增强参数列表                            2. 增强返回值类型                            3. 增强方法体执行逻辑    </code></pre><h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><pre><code>* 概念：web的三大组件之一。    * 事件监听机制        * 事件    ：一件事情        * 事件源 ：事件发生的地方        * 监听器 ：一个对象        * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码* ServletContextListener:监听ServletContext对象的创建和销毁    * 方法：        * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法        * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法    * 步骤：        1. 定义一个类，实现ServletContextListener接口        2. 复写方法        3. 配置            1. web.xml                    &lt;listener&gt;                      &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;                       &lt;/listener&gt;                    * 指定初始化参数&lt;context-param&gt;            2. 注解：                * @WebListener</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XML&amp;AJAX&amp;JSON</title>
    <link href="/2017/09/25/xml/"/>
    <url>/2017/09/25/xml/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ol><li>概念：Extensible Markup Language 可扩展标记语言<ul><li>可扩展：标签都是自定义的。<br><code>&lt;user&gt;  &lt;student&gt;</code><ul><li>功能<ul><li>存储数据<ol><li>配置文件</li><li>在网络中传输</li></ol></li><li>xml与html的区别<ol><li>xml标签都是自定义的，html标签是预定义。</li><li>xml的语法严格，html语法松散</li><li>xml是存储数据的，html是展示数据</li></ol></li></ul></li><li>w3c:万维网联盟</li></ul></li></ul> 语法：<ol start="2"><li><ul><li>基本语法：<ol><li>xml文档的后缀名 .xml</li><li>xml第一行必须定义为文档声明</li><li>xml文档中有且仅有一个根标签</li><li>属性值必须使用引号(单双都可)引起来</li><li>标签必须正确关闭</li><li>xml标签名称区分大小写</li></ol></li><li>快速入门：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">users</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;1&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>23<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>male<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;2&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>24<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>female<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>组成部分：<ol><li><p>文档声明</p><ol><li>格式：<?xml 属性列表 ?></li><li>属性列表：<ul><li>version：版本号，必须的属性</li><li>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li><li>standalone：是否独立<ul><li>取值：<ul><li>yes：不依赖其他文件</li><li>no：依赖其他文件</li></ul></li></ul></li></ul></li></ol></li><li><p>指令(了解)：结合css的</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>标签：标签名称自定义的</p><ul><li>规则：</li><li>名称可以包含字母、数字以及其他的字符 <ul><li>名称不能以数字或者标点符号开始 </li><li>名称不能以字母 xml（或者 XML、Xml 等等）开始 </li><li>名称不能包含空格 </li></ul></li></ul></li><li><p>属性：<br> id属性值唯一</p></li><li><p>文本：</p><ul><li>CDATA区：在该区域中的数据会被原样展示<ul><li>格式：  <!--[CDATA[ 数据 ]]--></li></ul></li></ul></li></ol></li></ul></li></ol></li></ol><ul><li><p>约束：规定xml文档的书写规则</p><ul><li><p>作为框架的使用者(程序员)：</p><ol><li>能够在xml中引入约束文档</li><li>能够简单的读懂约束文档</li></ol></li><li><p>分类：</p><ol><li>DTD:一种简单的约束技术</li><li>Schema:一种复杂的约束技术</li></ol></li><li><p>DTD：</p><ul><li>引入dtd文档到xml文档中<ul><li>内部dtd：将约束规则定义在xml文档中</li><li>外部dtd：将约束的规则定义在外部的dtd文件中<ul><li>本地：<!DOCTYPE 根标签名 SYSTEM "dtd文件的位置"></li><li>网络：<!DOCTYPE 根标签名 PUBLIC "dtd文件名字" "dtd文件的位置URL"></li></ul></li></ul></li></ul></li><li><p>Schema:</p><ul><li>引入：<br>  1.填写xml文档的根元素<br>  2.引入xsi前缀.  xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>  3.引入xsd文件命名空间.  xsi:schemaLocation=”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a>  student.xsd”<br>  4.为每一个xsd约束声明一个前缀,作为标识  xmlns=”<a href="http://www.itcast.cn/xml&quot;">http://www.itcast.cn/xml&quot;</a> </li></ul></li></ul>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;students   xmlns:<span class="hljs-attribute">xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="hljs-attribute">xmlns</span>=<span class="hljs-string">&quot;http://www.itcast.cn/xml&quot;</span><br>xsi:<span class="hljs-attribute">schemaLocation</span>=<span class="hljs-string">&quot;http://www.itcast.cn/xml  student.xsd&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>解析：操作xml文档，将文档中的数据读取到内存中</p><ul><li><p>操作xml文档</p><ol><li>解析(读取)：将文档中的数据读取到内存中</li><li>写入：将内存中的数据保存到xml文档中。持久化的存储</li></ol></li><li><p>解析xml的方式：</p><ol><li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul><li>优点：操作方便，可以对文档进行CRUD的所有操作</li><li>缺点：占内存</li></ul></li><li>SAX：逐行读取，基于事件驱动的。<ul><li>优点：不占内存。</li><li>缺点：只能读取，不能增删改</li></ul></li></ol></li><li><p>xml常见的解析器：</p><ol><li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li><li>DOM4J：一款非常优秀的解析器</li><li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li></ol></li></ul><ol start="4"><li>PULL：Android操作系统内置的解析器，sax方式的。<h1 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h1></li></ol><ul><li>jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<ul><li>快速入门：<ul><li>步骤：</li></ul><ol><li>导入jar包<ol start="2"><li>获取Document对象</li><li>获取对应的标签Element对象</li></ol></li><li>获取数据</li></ol></li><li>代码：</li></ul>   <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">   //<span class="hljs-number">2.1</span>获取student.xml的<span class="hljs-type">path</span><br>String <span class="hljs-type">path</span> = JsoupDemo1.<span class="hljs-keyword">class</span>.getClassLoader().getResource(&quot;student.xml&quot;).getPath();<br>   <br>   //<span class="hljs-number">2.2</span>解析<span class="hljs-type">xml</span>文档，加载文档进内存，获取dom树<span class="hljs-comment">---&gt;Document</span><br>     Document document = Jsoup.parse(<span class="hljs-built_in">new</span> File(<span class="hljs-type">path</span>), &quot;utf-8&quot;);<br>   <br>   //<span class="hljs-number">3.</span>获取元素对象 Element<br>   //<span class="hljs-number">3.1</span>获取第一个<span class="hljs-type">name</span>的Element对象<br>  Element element = elements.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(elements.size());<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><br>//<span class="hljs-number">3.1</span>获取第一个<span class="hljs-type">name</span>的Element对象<br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>Element element = elements.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br><br>//<span class="hljs-number">3.1</span>获取第一个<span class="hljs-type">name</span>的Element对象<br>Element element = elements.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(elements.size());<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br></code></pre></td></tr></table></figure></li><li>对象的使用：<ol><li><p>Jsoup：工具类，可以解析html或xml文档，返回Document</p><ul><li>parse：解析html或xml文档，返回Document<ul><li>parse​(File in, String charsetName)：解析xml或html文件的。</li><li>parse​(String html)：解析xml或html字符串</li><li>parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象</li></ul></li></ul></li><li><p>Document：文档对象。代表内存中的dom树</p><ul><li>获取Element对象<ul><li>getElementById​(String id)：根据id属性值获取唯一的element对象</li><li>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合</li><li>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul></li></ul></li><li><p>Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用</Element></p></li><li><p>Element：元素对象</p><ol><li>获取子元素对象<ul><li>getElementById​(String id)：根据id属性值获取唯一的element对象</li></ul></li></ol><ul><li>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合<ul><li>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul></li></ul><ol start="2"><li>获取属性值<ul><li>String attr(String key)：根据属性名称获取属性值</li></ul></li><li>获取文本内容<ul><li>String text():获取文本内容</li><li>String html():获取标签体的所有内容(包括字标签的字符串内容)</li></ul></li></ol></li><li><p>Node：节点对象</p><ul><li>是Document和Element的父类</li></ul></li></ol></li></ul></li></ol><p>​            </p><ul><li>快捷查询方式：<ol><li>selector:选择器<ul><li>使用的方法：Elements    select​(String cssQuery)<ul><li>语法：参考Selector类中定义的语法</li></ul></li></ul></li><li>XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言<ul><li>使用Jsoup的Xpath需要额外导入jar包。</li><li>查询w3cshool参考手册，使用xpath的语法完成查询</li><li>代码：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1.获取student.xml的path</span><br>    String path = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JsoupDemo6</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.get<span class="hljs-constructor">Resource(<span class="hljs-string">&quot;student.xml&quot;</span>)</span>.get<span class="hljs-constructor">Path()</span>;<br>  <span class="hljs-comment">//2.获取Document对象</span><br> Document document = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Jsoup</span>.</span></span>parse(<span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">path</span>)</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br> <br>  <span class="hljs-comment">//3.根据document对象，创建JXDocument对象</span><br>    JXDocument jxDocument = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JXDocument(<span class="hljs-params">document</span>)</span>;<br> <br>    <span class="hljs-comment">//4.结合xpath语法查询</span><br>    <span class="hljs-comment">//4.1查询所有student标签</span><br> List&lt;JXNode&gt; jxNodes = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes) &#123;<br>   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br>   <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br> <br>    <span class="hljs-comment">//4.2查询所有student标签下的name标签</span><br> List&lt;JXNode&gt; jxNodes2 = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student/name&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes2) &#123;<br>   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br>   <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br> <br>    <span class="hljs-comment">//4.3查询student标签下带有id属性的name标签</span><br>    List&lt;JXNode&gt; jxNodes3 = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student/name[@id]&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes3) &#123;<br>     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>    <span class="hljs-comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span><br> <br>    List&lt;JXNode&gt; jxNodes4 = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes4) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h1 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h1><pre><code>1. 概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML    1. 异步和同步：客户端和服务器端相互通信的基础上        * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。        * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。        Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1]         通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。        传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。        提升用户的体验2. 实现方式：    1. 原生的JS实现方式（了解）                 //1.创建核心对象                var xmlhttp;                if (window.XMLHttpRequest)                &#123;// code for IE7+, Firefox, Chrome, Opera, Safari                    xmlhttp=new XMLHttpRequest();                &#125;                else                &#123;// code for IE6, IE5                    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);                &#125;                    //2. 建立连接                /*                    参数：                        1. 请求方式：GET、POST                            * get方式，请求参数在URL后边拼接。send方法为空参                            * post方式，请求参数在send方法中定义                        2. 请求的URL：                        3. 同步或异步请求：true（异步）或 false（同步）                     */                xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);                    //3.发送请求                xmlhttp.send();                    //4.接受并处理来自服务器的响应结果                //获取方式 ：xmlhttp.responseText                //什么时候获取？当服务器响应成功后再获取                    //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。                xmlhttp.onreadystatechange=function()                &#123;                    //判断readyState就绪状态是否为4，判断status响应状态码是否为200                    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)                    &#123;                       //获取服务器的响应结果                        var responseText = xmlhttp.responseText;                        alert(responseText);                    &#125;                &#125;    2. JQeury实现方式        1. $.ajax()            * 语法：$.ajax(&#123;键值对&#125;);             //使用$.ajax()发送异步请求                $.ajax(&#123;                    url:&quot;ajaxServlet1111&quot; , // 请求路径                    type:&quot;POST&quot; , //请求方式                    //data: &quot;username=jack&amp;age=23&quot;,//请求参数                    data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;,                    success:function (data) &#123;                        alert(data);                    &#125;,//响应成功后的回调函数                    error:function () &#123;                        alert(&quot;出错啦...&quot;)                    &#125;,//表示如果请求响应出现错误，会执行的回调函数                        dataType:&quot;text&quot;//设置接受到的响应数据的格式                &#125;);        2. $.get()：发送get请求            * 语法：$.get(url, [data], [callback], [type])                * 参数：                    * url：请求路径                    * data：请求参数                    * callback：回调函数                    * type：响应结果的类型        3. $.post()：发送post请求            * 语法：$.post(url, [data], [callback], [type])                * 参数：                    * url：请求路径                    * data：请求参数                    * callback：回调函数                    * type：响应结果的类型</code></pre><h1 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h1><pre><code>1. 概念： JavaScript Object Notation        JavaScript对象表示法    Person p = new Person();    p.setName(&quot;张三&quot;);    p.setAge(23);    p.setGender(&quot;男&quot;);    var p = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;;    * json现在多用于存储和交换文本信息的语法    * 进行数据的传输    * JSON 比 XML 更小、更快，更易解析。2. 语法：    1. 基本规则        * 数据在名称/值对中：json数据是由键值对构成的            * 键用引号(单双都行)引起来，也可以不使用引号            * 值得取值类型：                1. 数字（整数或浮点数）                2. 字符串（在双引号中）                3. 逻辑值（true 或 false）                4. 数组（在方括号中）    &#123;&quot;persons&quot;:[&#123;&#125;,&#123;&#125;]&#125;                5. 对象（在花括号中） &#123;&quot;address&quot;:&#123;&quot;province&quot;：&quot;陕西&quot;....&#125;&#125;                6. null        * 数据由逗号分隔：多个键值对由逗号分隔        * 花括号保存对象：使用&#123;&#125;定义json 格式        * 方括号保存数组：[]    2. 获取数据:        1. json对象.键名        2. json对象[&quot;键名&quot;]        3. 数组对象[索引]        4. 遍历                 //1.定义基本格式                var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &#39;gender&#39;: true&#125;;                        var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;,                    &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;,                    &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];</code></pre><p>​<br>​<br>​            </p><pre><code>                //获取person对象中所有的键和值                //for in 循环               /* for(var key in person)&#123;                    //这样的方式获取不行。因为相当于  person.&quot;name&quot;                    //alert(key + &quot;:&quot; + person.key);                    alert(key+&quot;:&quot;+person[key]);                &#125;*/                       //获取ps中的所有值                for (var i = 0; i &lt; ps.length; i++) &#123;                    var p = ps[i];                    for(var key in p)&#123;                        alert(key+&quot;:&quot;+p[key]);                    &#125;                &#125;3. JSON数据和Java对象的相互转换    * JSON解析器：        * 常见的解析器：Jsonlib，Gson，fastjson，jackson        1. JSON转为Java对象        1. 导入jackson的相关jar包        2. 创建Jackson核心对象 ObjectMapper        3. 调用ObjectMapper的相关方法进行转换            1. readValue(json字符串数据,Class)    2. Java对象转换JSON        1. 使用步骤：            1. 导入jackson的相关jar包            2. 创建Jackson核心对象 ObjectMapper            3. 调用ObjectMapper的相关方法进行转换                1. 转换方法：                    * writeValue(参数1，obj):                        参数1：                            File：将obj对象转换为JSON字符串，并保存到指定的文件中                            Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中                            OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中                    * writeValueAsString(obj):将对象转为json字符串                2. 注解：                    1. @JsonIgnore：排除属性。                    2. @JsonFormat：属性值得格式化                        * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)                3. 复杂java对象转换                    1. List：数组                    2. Map：对象格式一致</code></pre><h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><pre><code>* 校验用户名是否存在    1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：        1. $.get(type):将最后一个参数type指定为&quot;json&quot;        2. 在服务器端设置MIME类型            response.setContentType(&quot;application/json;charset=utf-8&quot;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Xml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bootstrap</title>
    <link href="/2017/09/24/Bootstrap/"/>
    <url>/2017/09/24/Bootstrap/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Bootstrap："><a href="#Bootstrap：" class="headerlink" title="Bootstrap："></a>Bootstrap：</h1><ol><li><p>概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。</p><ul><li>框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</li><li>好处：<ol><li>定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。</li><li>响应式布局。<ul><li>同一套页面可以兼容不同分辨率的设备。</li></ul></li></ol></li></ul></li><li><p>快速入门</p><ol><li>下载Bootstrap</li><li>在项目中将这三个文件夹复制</li><li>创建html页面，引入必要的资源文件</li></ol> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Bootstrap HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-3.2.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好，世界！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul><li><p>同一套页面可以兼容不同分辨率的设备。</p></li><li><p>实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子</p></li><li><p>步骤：</p><ol><li>定义容器。相当于之前的table、<ul><li>容器分类：<ol><li>container：两边留白</li><li>container-fluid：每一种设备都是100%宽度</li></ol></li></ul></li><li>定义行。相当于之前的tr   样式：row</li><li>定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目<ul><li>设备代号：<ol><li>xs：超小屏幕 手机 (&lt;768px)：col-xs-12</li><li>sm：小屏幕 平板 (≥768px)</li><li>md：中等屏幕 桌面显示器 (≥992px)</li><li>lg：大屏幕 大桌面显示器 (≥1200px)</li></ol></li></ul></li></ol><ul><li>注意：<ol><li>一行中如果格子数目超过12，则超出部分自动换行。</li><li>栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</li><li>如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</li></ol></li></ul></li></ul><h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><ol><li>全局CSS样式：<ul><li>按钮：class=”btn btn-default”</li><li>图片：<ul><li>class=”img-responsive”：图片在任意尺寸都占100%</li><li>图片形状<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-rounded&quot;</span>&gt;：方形<br>*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-circle&quot;</span>&gt; ： 圆形<br>*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-thumbnail&quot;</span>&gt; ：相框<br></code></pre></td></tr></table></figure></li></ul></li><li>表格<ul><li>table</li><li>table-bordered</li><li>table-hover</li></ul></li><li>表单<ul><li>给表单项添加：class=”form-control” </li></ul></li></ul></li><li>组件：<ul><li>导航条</li><li>分页条</li></ul></li><li>插件：<ul><li>轮播图</li></ul></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;        .paddtop&#123;            padding-top: 10px;        &#125;        .search-btn&#123;            float: left;            border:1px solid #ffc900;            width: 90px;            height: 35px;            background-color:#ffc900 ;            text-align: center;            line-height: 35px;            margin-top: 15px;        &#125;        .search-input&#123;            float: left;            border:2px solid #ffc900;            width: 400px;            height: 35px;            padding-left: 5px;            margin-top: 15px;        &#125;        .jx&#123;            border-bottom: 2px solid #ffc900;            padding: 5px;        &#125;        .company&#123;            height: 40px;            background-color: #ffc900;            text-align: center;            line-height:40px ;            font-size: 8px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;!-- 1.页眉部分--&gt;   &lt;header class=&quot;container-fluid&quot;&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;img src=&quot;img/top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt;       &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;img src=&quot;img/logo.jpg&quot; class=&quot;img-responsive&quot;&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-5&quot;&gt;               &lt;input class=&quot;search-input&quot; placeholder=&quot;请输入线路名称&quot;&gt;               &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-4&quot;&gt;               &lt;img src=&quot;img/hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt;           &lt;/div&gt;       &lt;/div&gt;              &lt;!--导航栏--&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;nav class=&quot;navbar navbar-default&quot;&gt;               &lt;div class=&quot;container-fluid&quot;&gt;                   &lt;!-- Brand and toggle get grouped for better mobile display --&gt;                   &lt;div class=&quot;navbar-header&quot;&gt;                       &lt;!-- 定义汉堡按钮 --&gt;                       &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;                           &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                       &lt;/button&gt;                       &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;                   &lt;/div&gt;                   &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;                   &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;                       &lt;ul class=&quot;nav navbar-nav&quot;&gt;                           &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                       &lt;/ul&gt;                   &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;               &lt;/div&gt;&lt;!-- /.container-fluid --&gt;           &lt;/nav&gt;       &lt;/div&gt;              &lt;!--轮播图--&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;               &lt;!-- Indicators --&gt;               &lt;ol class=&quot;carousel-indicators&quot;&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;               &lt;/ol&gt;               &lt;!-- Wrapper for slides --&gt;               &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;                   &lt;div class=&quot;item active&quot;&gt;                       &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;               &lt;/div&gt;                              &lt;!-- Controls --&gt;               &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;               &lt;/a&gt;               &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;               &lt;/a&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/header&gt;   &lt;!-- 2.主体部分--&gt;   &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row jx&quot;&gt;            &lt;img src=&quot;img/icon_5.jpg&quot;&gt;            &lt;span&gt;精选&lt;/span&gt;        &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                    &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;       &lt;div class=&quot;row jx&quot;&gt;           &lt;img src=&quot;img/icon_6.jpg&quot;&gt;           &lt;span&gt;国内游&lt;/span&gt;       &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-4&quot;&gt;               &lt;img src=&quot;img/guonei_1.jpg&quot;&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-8&quot;&gt;               &lt;div class=&quot;row&quot;&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;               &lt;/div&gt;               &lt;div class=&quot;row&quot;&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;               &lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;!-- 3.页脚部分--&gt;   &lt;footer class=&quot;container-fluid&quot;&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;img src=&quot;img/footer_service.png&quot; class=&quot;img-responsive&quot;&gt;       &lt;/div&gt;       &lt;div class=&quot;row company&quot;&gt;           ccllyy 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882       &lt;/div&gt;       &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootstrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML&amp;CSS&amp;JS</title>
    <link href="/2017/09/23/HTML&amp;CSS&amp;JS/"/>
    <url>/2017/09/23/HTML&amp;CSS&amp;JS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><pre><code>1. web概念概述2. HTML</code></pre><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。    * 代码：        &lt;html&gt;                    &lt;head&gt;                &lt;title&gt;title&lt;/title&gt;            &lt;/head&gt;                        &lt;body&gt;                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;                                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;                        &lt;/body&gt;            &lt;/html&gt;3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例        * 案例：公司简介            &lt;!DOCTYPE html&gt;            &lt;html lang=&quot;ch&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;黑马程序员简介&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                        &lt;h1&gt;                公司简介            &lt;/h1&gt;            &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;p&gt;            &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。            &lt;/p&gt;                        &lt;p&gt;            目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。            &lt;/p&gt;                        &lt;p&gt;                        黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。            中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。            &lt;/p&gt;                        &lt;p&gt;                        一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。            &lt;/p&gt;                        &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                &lt;center&gt;                    江苏传智播客教育科技股份有限公司&lt;br&gt;                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                &lt;/center&gt;            &lt;/font&gt;</code></pre><p>​<br>​                </p><pre><code>            &lt;/body&gt;            &lt;/html&gt;    3. 图片标签：        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;                    &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;                    &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;                    &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;    4. 列表标签：        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:    5. 链接标签：        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;                    &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;                    &lt;br&gt;                    &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;                    &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;    6. div和span：        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚    8. 表格标签：        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分</code></pre><h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用    &lt;tr&gt;        &lt;td&gt;            &lt;table&gt;&lt;/table&gt;        &lt;/td&gt;    &lt;/tr&gt;4. 代码实现    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;黑马旅游网&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            &lt;!--采用table来完成布局--&gt;        &lt;!--最外层的table，用于整个页面的布局--&gt;        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;           &lt;!-- 第1行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第2行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第3行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;                            &lt;td&gt;                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第4行 轮播图 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第5行 黑马精选--&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;                    黑马精选                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第6行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第7行 国内游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;                    国内游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第8行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第9行 境外游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;                    境外游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第10行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第11行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第12行 --&gt;            &lt;tr&gt;                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                    江苏传智播客教育科技股份有限公司                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                    &lt;/font&gt;                &lt;/td&gt;            &lt;/tr&gt;                    &lt;/table&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性</code></pre><p>​        </p><pre><code>    * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项                    * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率3. CSS的使用：CSS与html结合方式    1. 内联样式         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;    2. 内部样式        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;                    &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;    3. 外部样式        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；5. 选择器：筛选具有相似特征的元素    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;                        3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;注册页面&lt;/title&gt;    &lt;style&gt;        *&#123;            margin: 0px;            padding: 0px;            box-sizing: border-box;        &#125;        body&#123;            background: url(&quot;img/register_bg.png&quot;) no-repeat center;            padding-top: 25px;        &#125;            .rg_layout&#123;            width: 900px;            height: 500px;            border: 8px solid #EEEEEE;            background-color: white;            /*让div水平居中*/            margin: auto;        &#125;            .rg_left&#123;            /*border: 1px solid red;*/            float: left;            margin: 15px;        &#125;        .rg_left &gt; p:first-child&#123;            color:#FFD026;            font-size: 20px;        &#125;            .rg_left &gt; p:last-child&#123;            color:#A6A6A6;            font-size: 20px;            &#125;</code></pre><p>​        </p><pre><code>        .rg_center&#123;            float: left;           /* border: 1px solid red;*/            &#125;            .rg_right&#123;            /*border: 1px solid red;*/            float: right;            margin: 15px;        &#125;            .rg_right &gt; p:first-child&#123;            font-size: 15px;            &#125;        .rg_right p a &#123;            color:pink;        &#125;            .td_left&#123;            width: 100px;            text-align: right;            height: 45px;        &#125;        .td_right&#123;            padding-left: 50px ;        &#125;            #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;            width: 251px;            height: 32px;            border: 1px solid #A6A6A6 ;            /*设置边框圆角*/            border-radius: 5px;            padding-left: 10px;        &#125;        #checkcode&#123;            width: 110px;        &#125;            #img_check&#123;            height: 32px;            vertical-align: middle;        &#125;            #btn_sub&#123;            width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026 ;        &#125;        &lt;/style&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;rg_layout&quot;&gt;        &lt;div class=&quot;rg_left&quot;&gt;            &lt;p&gt;新用户注册&lt;/p&gt;            &lt;p&gt;USER REGISTER&lt;/p&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_center&quot;&gt;            &lt;div class=&quot;rg_form&quot;&gt;                &lt;!--定义表单 form--&gt;                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;</code></pre><p>​        </p><pre><code>                        &lt;tr&gt;                            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/form&gt;</code></pre><p>​        </p><pre><code>            &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_right&quot;&gt;            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><pre><code>1. JavaScript基础</code></pre><h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><pre><code>* 概念：    一门客户端脚本语言    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了* 功能：    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。* JavaScript发展史：    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--    ，后来更名为：ScriptEase    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript    3. 1996年，微软抄袭JavaScript开发出JScript语言    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)* ECMAScript：客户端脚本语言的标准    1. 基本语法：        1. 与html结合方式            1. 内部JS：                * 定义&lt;script&gt;，标签体内容就是js代码            2. 外部JS：                * 定义&lt;script&gt;，通过src属性引入外部的js文件            * 注意：                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。                2. &lt;script&gt;可以定义多个。        2. 注释            1. 单行注释：//注释内容            2. 多行注释：/*注释内容*/        3. 数据类型：            1. 原始数据类型(基本数据类型)：                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &#39;abc&#39;                3. boolean: true和false                4. null：一个对象为空的占位符                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined                            2. 引用数据类型：对象                    4. 变量            * 变量：一小块存储数据的内存空间            * Java语言是强类型语言，而JavaScript是弱类型语言。                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。            * 语法：                * var 变量名 = 初始化值;                        * typeof运算符：获取变量的类型。                * 注：null运算后得到的是object        5. 运算符            1. 一元运算符：只有一个运算数的运算符                ++，-- ， +(正号)                  * ++ --: 自增(自减)                    * ++(--) 在前，先自增(自减)，再运算                    * ++(--) 在后，先运算，再自增(自减)                * +(-)：正负号                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换                    * 其他类型转number：                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）                        * boolean转number：true转为1，false转为0            2. 算数运算符                + - * / % ...            3. 赋值运算符                = += -+....            4. 比较运算符                &gt; &lt; &gt;= &lt;= == ===(全等于)                * 比较方式                  1. 类型相同：直接比较                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。                  2. 类型不同：先进行类型转换，再比较                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false            5. 逻辑运算符                &amp;&amp; || !                * 其他类型转boolean：                   1. number：0或NaN为假，其他为真                   2. string：除了空字符串(&quot;&quot;)，其他都是true                   3. null&amp;undefined:都是false                   4. 对象：所有对象都为true                        6. 三元运算符                ? : 表达式                var a = 3;                var b = 4;                        var c = a &gt; b ? 1:0;                * 语法：                    * 表达式? 值1:值2;                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；                    6. 流程控制语句：            1. if...else...            2. switch:                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)                    * switch(变量):                        case 值:                * 在JS中,switch语句可以接受任意的原始数据类型            3. while            4. do...while            5. for        7. JS特殊语法：            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)            2. 变量的定义使用var关键字，也可以不使用                * 用： 定义的变量是局部变量                * 不用：定义的变量是全局变量(不建议)        8. 练习：99乘法表        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;99乘法表&lt;/title&gt;            &lt;style&gt;                td&#123;                    border: 1px solid;                &#125;                    &lt;/style&gt;                    &lt;script&gt;                        document.write(&quot;&lt;table  align=&#39;center&#39;&gt;&quot;);</code></pre><p>​            </p><pre><code>                //1.完成基本的for循环嵌套，展示乘法表                for (var i = 1; i &lt;= 9 ; i++) &#123;                    document.write(&quot;&lt;tr&gt;&quot;);                    for (var j = 1; j &lt;=i ; j++) &#123;                        document.write(&quot;&lt;td&gt;&quot;);                                //输出  1 * 1 = 1                        document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);                                document.write(&quot;&lt;/td&gt;&quot;);                    &#125;                    /*//输出换行                    document.write(&quot;&lt;br&gt;&quot;);*/                            document.write(&quot;&lt;/tr&gt;&quot;);                &#125;                        //2.完成表格嵌套                document.write(&quot;&lt;/table&gt;&quot;);                    &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;                &lt;/body&gt;        &lt;/html&gt;    2. 基本对象：        1. Function：函数(方法)对象            1. 创建：                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧                2.                     function 方法名称(形式参数列表)&#123;                        方法体                    &#125;                3.                    var 方法名 = function(形式参数列表)&#123;                        方法体                   &#125;            2. 方法：            3. 属性：                length:代表形参的个数            4. 特点：                1. 方法定义是，形参的类型不用写,返回值类型也不写。                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数            5. 调用：                方法名称(实际参数列表);                2. Array:数组对象            1. 创建：                1. var arr = new Array(元素列表);                2. var arr = new Array(默认长度);                3. var arr = [元素列表];            2. 方法                join(参数):将数组中的元素按照指定的分隔符拼接为字符串                push()    向数组的末尾添加一个或更多元素，并返回新的长度。            3. 属性                length:数组的长度            4. 特点：                1. JS中，数组元素的类型可变的。                2. JS中，数组长度可变的。        3. Boolean        4. Date：日期对象            1. 创建：                var date = new Date();            2. 方法：                toLocaleString()：返回当前date对象对应的时间本地字符串格式                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差        5. Math：数学对象            1. 创建：                * 特点：Math对象不用创建，直接使用。  Math.方法名();            2. 方法：                random():返回 0 ~ 1 之间的随机数。 含0不含1                ceil(x)：对数进行上舍入。                floor(x)：对数进行下舍入。                round(x)：把数四舍五入为最接近的整数。            3. 属性：                PI        6. Number        7. String        8. RegExp：正则表达式对象            1. 正则表达式：定义字符串的组成规则。                1. 单个字符:[]                    如： [a] [ab] [a-zA-Z0-9_]                    * 特殊符号代表特殊含义的单个字符:                        \d:单个数字字符 [0-9]                        \w:单个单词字符[a-zA-Z0-9_]                2. 量词符号：                    ?：表示出现0次或1次                    *：表示出现0次或多次                    +：出现1次或多次                    &#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n                        * m如果缺省： &#123;,n&#125;:最多n次                        * n如果缺省：&#123;m,&#125; 最少m次                3. 开始结束符号                    * ^:开始                    * $:结束            2. 正则对象：                1. 创建                    1. var reg = new RegExp(&quot;正则表达式&quot;);                    2. var reg = /正则表达式/;                2. 方法                        1. test(参数):验证指定的字符串是否符合正则定义的规范            9. Global            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();            2. 方法：                encodeURI():url编码                decodeURI():url解码                encodeURIComponent():url编码,编码的字符更多                decodeURIComponent():url解码                parseInt():将字符串转为数字                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number                isNaN():判断一个值是否是NaN                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。            3. URL编码               传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2* BOM* DOM</code></pre><h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><pre><code>1. JavaScript：    1. ECMAScript：    2. BOM：    3. DOM：        1. 事件</code></pre><h2 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h2><pre><code>* 功能：控制html文档的内容* 获取页面标签(元素)对象：Element    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象* 操作Element对象：    1. 修改属性值：        1. 明确获取的对象是哪一个？        2. 查看API文档，找其中有哪些属性可以设置    2. 修改标签体内容：        * 属性：innerHTML        1. 获取元素对象        2. 使用innerHTML属性修改标签体内容</code></pre><h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2><pre><code>* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。    * 造句：  xxx被xxx,我就xxx        * 我方水晶被摧毁后，我就责备对友。        * 敌方水晶被摧毁后，我就夸奖自己。* 如何绑定事件    1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码        1. 事件：onclick--- 单击事件    2. 通过js获取元素对象，指定事件属性，设置一个函数    * 代码：        &lt;body&gt;            &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;  onclick=&quot;fun();&quot;&gt;            &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt;                        &lt;script&gt;                function fun()&#123;                    alert(&#39;我被点了&#39;);                    alert(&#39;我又被点了&#39;);                &#125;                            function fun2()&#123;                    alert(&#39;咋老点我？&#39;);                &#125;                            //1.获取light2对象                var light2 = document.getElementById(&quot;light2&quot;);                //2.绑定事件                light2.onclick = fun2;</code></pre><p>​                </p><pre><code>            &lt;/script&gt;        &lt;/body&gt;* 案例1：电灯开关    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;电灯开关&lt;/title&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt;        &lt;script&gt;        /*            分析：                1.获取图片对象                2.绑定单击事件                3.每次点击切换图片                    * 规则：                        * 如果灯是开的 on,切换图片为 off                        * 如果灯是关的 off,切换图片为 on                    * 使用标记flag来完成             */            //1.获取图片对象        var light = document.getElementById(&quot;light&quot;);            var flag = false;//代表灯是灭的。 off图片            //2.绑定单击事件        light.onclick = function()&#123;            if(flag)&#123;//判断如果灯是开的，则灭掉                light.src = &quot;img/off.gif&quot;;                flag = false;                &#125;else&#123;                //如果灯是灭的，则打开                    light.src = &quot;img/on.gif&quot;;                flag = true;            &#125;</code></pre><p>​        </p><pre><code>        &#125;            &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><pre><code>1. 概念：Browser Object Model 浏览器对象模型    * 将浏览器的各个组成部分封装成对象。2. 组成：    * Window：窗口对象    * Navigator：浏览器对象    * Screen：显示器屏幕对象    * History：历史记录对象    * Location：地址栏对象3. Window：窗口对象    1. 创建    2. 方法         1. 与弹出框有关的方法：            alert()    显示带有一段消息和一个确认按钮的警告框。            confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。                * 如果用户点击确定按钮，则方法返回true                * 如果用户点击取消按钮，则方法返回false            prompt()    显示可提示用户输入的对话框。                * 返回值：获取用户输入的值         2. 与打开关闭有关的方法：            close()    关闭浏览器窗口。                * 谁调用我 ，我关谁            open()    打开一个新的浏览器窗口                * 返回新的Window对象         3. 与定时器有关的方式            setTimeout()    在指定的毫秒数后调用函数或计算表达式。                * 参数：                    1. js代码或者方法对象                    2. 毫秒值                * 返回值：唯一标识，用于取消定时器            clearTimeout()    取消由 setTimeout() 方法设置的 timeout。            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。            clearInterval()    取消由 setInterval() 设置的 timeout。    3. 属性：        1. 获取其他BOM对象：            history            location            Navigator            Screen:        2. 获取DOM对象            document    4. 特点        * Window对象不需要创建可以直接使用 window使用。 window.方法名();        * window引用可以省略。  方法名();4. Location：地址栏对象    1. 创建(获取)：        1. window.location        2. location    2. 方法：        * reload()    重新加载当前文档。刷新    3. 属性        * href    设置或返回完整的 URL。5. History：历史记录对象    1. 创建(获取)：        1. window.history        2. history    2. 方法：        * back()    加载 history 列表中的前一个 URL。        * forward()    加载 history 列表中的下一个 URL。        * go(参数)    加载 history 列表中的某个具体页面。            * 参数：                * 正数：前进几个历史记录                * 负数：后退几个历史记录    3. 属性：        * length    返回当前窗口历史列表中的 URL 数量。</code></pre><h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><pre><code>* 概念： Document Object Model 文档对象模型    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作* W3C DOM 标准被分为 3 个不同的部分：    * 核心 DOM - 针对任何结构化文档的标准模型        * Document：文档对象        * Element：元素对象        * Attribute：属性对象        * Text：文本对象        * Comment:注释对象        * Node：节点对象，其他5个的父对象    * XML DOM - 针对 XML 文档的标准模型    * HTML DOM - 针对 HTML 文档的标准模型* 核心DOM模型：    * Document：文档对象        1. 创建(获取)：在html dom模型中可以使用window对象来获取            1. window.document            2. document        2. 方法：            1. 获取Element对象：                1. getElementById()    ： 根据id属性值获取元素对象。id属性值一般唯一                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组            2. 创建其他DOM对象：                createAttribute(name)                createComment()                createElement()                createTextNode()        3. 属性    * Element：元素对象        1. 获取/创建：通过document来获取和创建        2. 方法：            1. removeAttribute()：删除属性            2. setAttribute()：设置属性    * Node：节点对象，其他5个的父对象        * 特点：所有dom对象都可以被认为是一个节点        * 方法：            * CRUD dom树：                * appendChild()：向节点的子节点列表的结尾添加新的子节点。                * removeChild()    ：删除（并返回）当前节点的指定子节点。                * replaceChild()：用新节点替换一个子节点。        * 属性：            * parentNode 返回节点的父节点。* HTML DOM    1. 标签体的设置和获取：innerHTML    2. 使用html元素对象的属性    3. 控制元素样式        1. 使用元素的style属性来设置            如：                 //修改样式方式1                div1.style.border = &quot;1px solid red&quot;;                div1.style.width = &quot;200px&quot;;                //font-size--&gt; fontSize                div1.style.fontSize = &quot;20px&quot;;        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</code></pre><h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><pre><code>* 概念：某些组件被执行了某些操作后，触发某些代码的执行。        * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了    * 事件源：组件。如： 按钮 文本输入框...    * 监听器：代码。    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。* 常见的事件：    1. 点击事件：        1. onclick：单击事件        2. ondblclick：双击事件    2. 焦点事件        1. onblur：失去焦点        2. onfocus:元素获得焦点。    3. 加载事件：        1. onload：一张页面或一幅图像完成加载。    4. 鼠标事件：        1. onmousedown    鼠标按钮被按下。        2. onmouseup    鼠标按键被松开。        3. onmousemove    鼠标被移动。        4. onmouseover    鼠标移到某元素之上。        5. onmouseout    鼠标从某元素移开。</code></pre><p>​            </p><pre><code>    5. 键盘事件：        1. onkeydown    某个键盘按键被按下。            2. onkeyup        某个键盘按键被松开。        3. onkeypress    某个键盘按键被按下并松开。    6. 选择和改变        1. onchange    域的内容被改变。        2. onselect    文本被选中。    7. 表单事件：        1. onsubmit    确认按钮被点击。        2. onreset    重置按钮被点击。</code></pre><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2017/09/21/mysql/"/>
    <url>/2017/09/21/mysql/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h1><ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL</code></pre><p>​    </p><pre><code>4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。    3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。    2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */    3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !                    -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;                        SELECT * FROM student WHERE age &gt;= 20;                        -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;                        -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;                        -- 查询年龄大于等于20 小于等于30                        SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;                        -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);                        -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断                        SELECT * FROM student WHERE english IS NULL;                        -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;            -- 查询姓名第二个字是化的人                        SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;                        -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;</code></pre><p>​                </p><pre><code>            -- 查询姓名中包含德的人            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;</code></pre><h1 id="Mysql约束"><a href="#Mysql约束" class="headerlink" title="Mysql约束"></a>Mysql约束</h1><pre><code>1. DQL:查询语句    1. 排序查询    2. 聚合函数    3. 分组查询    4. 分页查询2. 约束3. 多表之间的关系4. 范式5. 数据库的备份和还原</code></pre><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count：计算个数        1. 一般选择非空的列：主键        2. count(*)    2. max：计算最大值    3. min：计算最小值    4. sum：计算和    5. avg：计算平均值    * 注意：聚合函数的计算，排除null值。        解决方案：            1. 选择不包含非空的列进行计算            2. IFNULL函数3. 分组查询:    1. 语法：group by 分组字段；    2. 注意：        1. 分组之后查询的字段：分组字段、聚合函数        2. where 和 having 的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。        -- 按照性别分组。分别查询男、女同学的平均分        SELECT sex , AVG(math) FROM student GROUP BY sex;                -- 按照性别分组。分别查询男、女同学的平均分,人数                SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;                --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;                --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;                SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</code></pre><p>​            </p><pre><code>4. 分页查询    1. 语法：limit 开始的索引,每页查询的条数;    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数        -- 每页显示3条记录         SELECT * FROM student LIMIT 0,3; -- 第1页                SELECT * FROM student LIMIT 3,3; -- 第2页                SELECT * FROM student LIMIT 6,3; -- 第3页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    * 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null，值不能为null    1. 创建表时添加约束        CREATE TABLE stu(            id INT,            NAME VARCHAR(20) NOT NULL -- name为非空        );    2. 创建表完后，添加非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20);</code></pre><p>​    </p><pre><code>* 唯一约束：unique，值不能重复    1. 创建表时，添加唯一约束        CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束                );        * 注意mysql中，唯一约束限定的列的值可以有多个null</code></pre><p>​        </p><pre><code>    2. 删除唯一约束            ALTER TABLE stu DROP INDEX phone_number;        3. 在创建表后，添加唯一约束        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 在创建表时，添加主键约束        create table stu(            id int primary key,-- 给id添加主键约束            name varchar(20)        );    3. 删除主键        -- 错误 alter table stu modify id int ;        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建完表后，添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长        2. 在创建表时，添加主键约束，并且完成主键自增长        create table stu(            id int primary key auto_increment,-- 给id添加主键约束            name varchar(20)        );</code></pre><p>​            </p><pre><code>        3. 删除自动增长        ALTER TABLE stu MODIFY id INT;        4. 添加自动增长        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。    1. 在创建表时，可以添加外键        * 语法：            create table 表名(                ....                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre><p>​        </p><pre><code>    4. 级联操作        1. 添加级联操作            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                     FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;        2. 分类：            1. 级联更新：ON UPDATE CASCADE             2. 级联删除：ON DELETE CASCADE </code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。    3. 案例        -- 创建旅游线路分类表 tab_category        -- cid 旅游线路分类主键，自动增长        -- cname 旅游线路分类名称非空，唯一，字符串 100        CREATE TABLE tab_category (            cid INT PRIMARY KEY AUTO_INCREMENT,            cname VARCHAR(100) NOT NULL UNIQUE        );                -- 创建旅游线路表 tab_route        /*        rid 旅游线路主键，自动增长        rname 旅游线路名称非空，唯一，字符串 100        price 价格        rdate 上架时间，日期类型        cid 外键，所属分类        */        CREATE TABLE tab_route(            rid INT PRIMARY KEY AUTO_INCREMENT,            rname VARCHAR(100) NOT NULL UNIQUE,            price DOUBLE,            rdate DATE,            cid INT,            FOREIGN KEY (cid) REFERENCES tab_category(cid)        );                /*创建用户表 tab_user        uid 用户主键，自增长        username 用户名长度 100，唯一，非空        password 密码长度 30，非空        name 真实姓名长度 100        birthday 生日        sex 性别，定长字符串 1        telephone 手机号，字符串 11        email 邮箱，字符串长度 100        */        CREATE TABLE tab_user (            uid INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(100) UNIQUE NOT NULL,            PASSWORD VARCHAR(30) NOT NULL,            NAME VARCHAR(100),            birthday DATE,            sex CHAR(1) DEFAULT &#39;男&#39;,            telephone VARCHAR(11),            email VARCHAR(100)        );                /*        创建收藏表 tab_favorite        rid 旅游线路 id，外键        date 收藏时间        uid 用户 id，外键        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次        */        CREATE TABLE tab_favorite (            rid INT, -- 线路id            DATE DATETIME,            uid INT, -- 用户id            -- 创建复合主键            PRIMARY KEY(rid,uid), -- 联合主键            FOREIGN KEY (rid) REFERENCES tab_route(rid),            FOREIGN KEY(uid) REFERENCES tab_user(uid)        );</code></pre><p>​        </p><pre><code>2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性                            3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：    * 语法：        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2. 图形化工具：</code></pre><h1 id="多表-amp-事务"><a href="#多表-amp-事务" class="headerlink" title="多表&amp;事务"></a>多表&amp;事务</h1><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：    select        列名列表    from        表名列表    where....* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)    );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);* 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;                        -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;                        SELECT                 t1.name, -- 员工表的姓名                t1.gender,-- 员工表的性别                t2.name -- 部门表的名称            FROM                emp t1,                dept t2            WHERE                 t1.`dept_id` = t2.`id`;</code></pre><p>​    </p><pre><code>        2. 显式内连接：            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;                    * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;            3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段    2. 外链接查询：        1. 左外连接：            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；            * 查询的是左表所有数据以及其交集部分。            * 例子：                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;        2. 右外连接：            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；            * 查询的是右表所有数据以及其交集部分。            * 例子：                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;    3. 子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 查询工资最高的员工信息            -- 1 查询最高的工资是多少 9000            SELECT MAX(salary) FROM emp;                        -- 2 查询员工信息，并且工资等于9000的            SELECT * FROM emp WHERE emp.`salary` = 9000;                        -- 一条sql就完成这个操作。子查询            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);        * 子查询不同情况            1. 子查询的结果是单行单列的：                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =                *                 -- 查询员工工资小于平均工资的人                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in来判断                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;                -- 子查询                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2                WHERE t1.id = t2.dept_id;                                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;    * 多表查询练习            -- 部门表            CREATE TABLE dept (              id INT PRIMARY KEY PRIMARY KEY, -- 部门id              dname VARCHAR(50), -- 部门名称              loc VARCHAR(50) -- 部门所在地            );                        -- 添加4个部门            INSERT INTO dept(id,dname,loc) VALUES             (10,&#39;教研部&#39;,&#39;北京&#39;),            (20,&#39;学工部&#39;,&#39;上海&#39;),            (30,&#39;销售部&#39;,&#39;广州&#39;),            (40,&#39;财务部&#39;,&#39;深圳&#39;);</code></pre><p>​<br>​                </p><pre><code>            -- 职务表，职务名称，职务描述            CREATE TABLE job (              id INT PRIMARY KEY,              jname VARCHAR(20),              description VARCHAR(50)            );                        -- 添加4个职务            INSERT INTO job (id, jname, description) VALUES            (1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;),            (2, &#39;经理&#39;, &#39;管理部门员工&#39;),            (3, &#39;销售员&#39;, &#39;向客人推销产品&#39;),            (4, &#39;文员&#39;, &#39;使用办公软件&#39;);</code></pre><p>​<br>​                </p><pre><code>            -- 员工表            CREATE TABLE emp (              id INT PRIMARY KEY, -- 员工id              ename VARCHAR(50), -- 员工姓名              job_id INT, -- 职务id              mgr INT , -- 上级领导              joindate DATE, -- 入职日期              salary DECIMAL(7,2), -- 工资              bonus DECIMAL(7,2), -- 奖金              dept_id INT, -- 所在部门编号              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)            );                        -- 添加员工            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES             (1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),            (1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),            (1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),            (1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),            (1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),            (1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),            (1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),            (1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),            (1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),            (1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),            (1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),            (1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),            (1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),            (1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);</code></pre><p>​<br>​                </p><pre><code>            -- 工资等级表            CREATE TABLE salarygrade (              grade INT PRIMARY KEY,   -- 级别              losalary INT,  -- 最低工资              hisalary INT -- 最高工资            );                        -- 添加5个工资等级            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES             (1,7000,12000),            (2,12010,14000),            (3,14010,20000),            (4,20010,30000),            (5,30010,99990);                        -- 需求：                        -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述            /*                分析：                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表                    2.查询条件 emp.job_id = job.id                        */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description` -- 职务描述            FROM                 emp t1, job t2            WHERE                 t1.`job_id` = t2.`id`;</code></pre><p>​<br>​                </p><pre><code>            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置            /*                分析：                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id            */                        SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description`, -- 职务描述                t3.`dname`, -- 部门名称                t3.`loc` -- 部门位置            FROM                 emp t1, job t2,dept t3            WHERE                 t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;                           -- 3.查询员工姓名，工资，工资等级            /*                分析：                    1.员工姓名，工资 emp  工资等级 salarygrade                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.ename ,                t1.`salary`,                t2.*            FROM emp t1, salarygrade t2            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;</code></pre><p>​<br>​                </p><pre><code>            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级            /*                分析：                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary                                    */            SELECT                 t1.`ename`,                t1.`salary`,                t2.`jname`,                t2.`description`,                t3.`dname`,                t3.`loc`,                t4.`grade`            FROM                 emp t1,job t2,dept t3,salarygrade t4            WHERE                 t1.`job_id` = t2.`id`                 AND t1.`dept_id` = t3.`id`                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;</code></pre><p>​<br>​                </p><pre><code>            -- 5.查询出部门编号、部门名称、部门位置、部门人数                        /*                分析：                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)                    3.使用子查询将第2步的查询结果和dept表进行关联查询                                */            SELECT                 t1.`id`,t1.`dname`,t1.`loc` , t2.total            FROM                 dept t1,                (SELECT                    dept_id,COUNT(id) total                FROM                     emp                GROUP BY dept_id) t2            WHERE t1.`id` = t2.dept_id;</code></pre><p>​                </p><pre><code>            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询                        /*                分析：                    1.姓名 emp， 直接上级的姓名 emp                        * emp表的id 和 mgr 是自关联                    2.条件 emp.id = emp.mgr                    3.查询左表的所有数据，和 交集数据                        * 使用左外连接查询                            */            /*            select                t1.ename,                t1.mgr,                t2.`id`,                t2.ename            from emp t1, emp t2            where t1.mgr = t2.`id`;                        */                        SELECT                 t1.ename,                t1.mgr,                t2.`id`,                t2.`ename`            FROM emp t1            LEFT JOIN emp t2            ON t1.`mgr` = t2.`id`;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍    1. 概念：        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。            2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;    3. 例子：        CREATE TABLE account (            id INT PRIMARY KEY AUTO_INCREMENT,            NAME VARCHAR(10),            balance DOUBLE        );        -- 添加数据        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);</code></pre><p>​            </p><pre><code>        SELECT * FROM account;        UPDATE account SET balance = 1000;        -- 张三给李四转账 500 元                -- 0. 开启事务        START TRANSACTION;        -- 1. 张三账户 -500                UPDATE account SET balance = balance - 500 WHERE NAME = &#39;zhangsan&#39;;        -- 2. 李四账户 +500        -- 出错了...        UPDATE account SET balance = balance + 500 WHERE NAME = &#39;lisi&#39;;                -- 发现执行没有问题，提交事务        COMMIT;                -- 发现出问题了，回滚事务        ROLLBACK;    4. MySQL数据库中事务默认自动提交                * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle 数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        2. 删除用户：            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        3. 修改用户密码：                        UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;                        SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;                        * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;            -- 给张三用户授予所有权限，在任意数据库任意表上                        GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;</code></pre><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><pre><code>1. JDBC基本概念2. 对JDBC中各个接口和类详解</code></pre><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static &#123;                        try &#123;                            java.sql.DriverManager.registerDriver(new Driver());                        &#125; catch (SQLException E) &#123;                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                        &#125;                    &#125;                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try &#123;                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0)&#123;                        System.out.println(&quot;添加成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;添加失败！&quot;);                    &#125;                        &#125; catch (ClassNotFoundException e) &#123;                    e.printStackTrace();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null)&#123;                        try &#123;                            stmt.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                            if(conn != null)&#123;                        try &#123;                            conn.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;                4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)                * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next())&#123;                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                        System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                &#125;        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125;                3. 实现方法 select * from emp;                        5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a            2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils &#123;    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static&#123;        //读取资源文件，获取值。        try &#123;            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><p>​    </p><pre><code>    /**     * 获取连接     * @return 连接对象     */    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url, user, password);    &#125;    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(Statement stmt,Connection conn)&#123;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><p>​    </p><pre><code>    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;        if( rs != null)&#123;            try &#123;                rs.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)                        );            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);        2. 代码实现：            public class JDBCDemo9 &#123;                public static void main(String[] args) &#123;                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag)&#123;                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;用户名或密码错误！&quot;);                    &#125;</code></pre><p>​                </p><pre><code>                &#125;</code></pre><p>​<br>​                </p><pre><code>                /**                 * 登录方法                 */                public boolean login(String username ,String password)&#123;                    if(username == null || password == null)&#123;                        return false;                    &#125;                    //连接数据库判断是否登录成功                    Connection conn = null;                    Statement stmt =  null;                    ResultSet rs = null;                    //1.获取连接                    try &#123;                        conn =  JDBCUtils.getConnection();                        //2.定义sql                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;                        //3.获取执行sql的对象                        stmt = conn.createStatement();                        //4.执行查询                        rs = stmt.executeQuery(sql);                        //5.判断                       /* if(rs.next())&#123;//如果有下一行，则返回true                            return true;                        &#125;else&#123;                            return false;                        &#125;*/                       return rs.next();//如果有下一行，则返回true                                &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;finally &#123;                        JDBCUtils.close(rs,stmt,conn);                    &#125;</code></pre><p>​                </p><pre><code>                    return false;                &#125;            &#125;</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()         * 当所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务4. 代码：    public class JDBCDemo10 &#123;        public static void main(String[] args) &#123;            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;                try &#123;                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                    //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                    pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                    pstmt2.executeUpdate();                //提交事务                conn.commit();            &#125; catch (Exception e) &#123;                //事务回滚                try &#123;                    if(conn != null) &#123;                        conn.rollback();                    &#125;                &#125; catch (SQLException e1) &#123;                    e1.printStackTrace();                &#125;                e.printStackTrace();            &#125;finally &#123;                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            &#125;</code></pre><p>​        </p><pre><code>        &#125;        &#125;</code></pre><p>​            </p><h1 id="JDBC连接池"><a href="#JDBC连接池" class="headerlink" title="JDBC连接池"></a>JDBC连接池</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils &#123;            //1.定义成员变量 DataSource            private static DataSource ds ;                    static&#123;                try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;                    /**             * 获取连接             */            public static Connection getConnection() throws SQLException &#123;                return ds.getConnection();            &#125;                    /**             * 释放资源             */            public static void close(Statement stmt,Connection conn)&#123;               /* if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                        if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;*/                       close(null,stmt,conn);            &#125;</code></pre><p>​            </p><pre><code>            public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;</code></pre><p>​            </p><pre><code>                if(rs != null)&#123;                    try &#123;                        rs.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;</code></pre><p>​            </p><pre><code>                if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                        if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;                    /**             * 获取连接池方法             */                    public static DataSource getDataSource()&#123;                return  ds;            &#125;                &#125;</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：                        import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;                        import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;                        public class JdbcTemplateDemo2 &#123;                            //Junit单元测试，可以让方法独立执行</code></pre><p>​                </p><pre><code>                //1. 获取JDBCTemplate对象                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                /**                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1()&#123;                                //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                &#125;                            /**                 * 2. 添加一条记录                 */                @Test                public void test2()&#123;                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                            &#125;                            /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3()&#123;                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                &#125;                            /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4()&#123;                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;                            &#125;                            /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                                for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;                        System.out.println(stringObjectMap);                    &#125;                &#125;                            /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                            @Test                public void test6()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;                                    @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                                        emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                                        return emp;                        &#125;                    &#125;);</code></pre><p>​                </p><pre><code>                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                            /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                            @Test                public void test6_2()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                            /**                 * 7. 查询总记录数                 */                            @Test                public void test7()&#123;                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                &#125;                        &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎08-网络</title>
    <link href="/2017/09/19/java%E5%9F%BA%E7%A4%8E08-%E7%BD%91%E7%BB%9C/"/>
    <url>/2017/09/19/java%E5%9F%BA%E7%A4%8E08-%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件</li></ul><ul><li><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li></ul><ul><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="/img/cphoto/net01.jpg"></p><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示</p></li></ul><p><img src="/img/cphoto/net02.jpg"></p><p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位 </p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p><img src="/img/cphoto/net03.jpg"></p><p> 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ipconfig<br></code></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ping 空格 IP地址<br>ping <span class="hljs-number">220.181</span><span class="hljs-number">.57</span><span class="hljs-number">.216</span><br></code></pre></td></tr></table></figure><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public void close()</code> ：关闭此套接字。</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p><ul><li>任何先前写出的数据将被发送，随后终止输出流。 </li></ul><h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li></ul><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure><h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="/img/cphoto/net04.jpg"></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p>服务端实现：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      <span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>        <span class="hljs-comment">//5.关闭资源.</span><br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br><span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br><span class="hljs-comment">// 2.获取流对象 . 输出流</span><br>OutputStream os = client.getOutputStream();<br><span class="hljs-comment">// 3.写出数据.</span><br>os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br><span class="hljs-comment">// 4. 关闭资源 .</span><br>os.close();<br>client.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      <span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>      <span class="hljs-comment">// =================回写数据=======================</span><br>      <span class="hljs-comment">// 5. 通过 socket 获取输出流</span><br>       OutputStream out = server.getOutputStream();<br>      <span class="hljs-comment">// 6. 回写数据</span><br>       out.write(<span class="hljs-string">&quot;我很好,谢谢你&quot;</span>.getBytes());<br>      <span class="hljs-comment">// 7.关闭资源.</span><br>      out.close();<br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br><span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br><span class="hljs-comment">// 2.通过Scoket,获取输出流对象 </span><br>OutputStream os = client.getOutputStream();<br><span class="hljs-comment">// 3.写出数据.</span><br>os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br>      <span class="hljs-comment">// ==============解析回写=========================</span><br>      <span class="hljs-comment">// 4. 通过Scoket,获取 输入流对象</span><br>      InputStream in = client.getInputStream();<br>      <span class="hljs-comment">// 5. 读取数据数据</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];<br>      <span class="hljs-keyword">int</span> len = in.read(b);<br>      System.out.println(<span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len));<br><span class="hljs-comment">// 6. 关闭资源 .</span><br>      in.close();<br>os.close();<br>client.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol><p><img src="/img/cphoto/net05.jpg">    </p><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>      ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>  <span class="hljs-comment">// 2. 建立连接 </span><br>        Socket accept = serverSocket.accept();<br>      <span class="hljs-comment">// 3. 创建流对象</span><br>      <span class="hljs-comment">// 3.1 获取输入流,读取文件数据</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>        <span class="hljs-comment">// 3.2 创建输出流,保存到本地 .</span><br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.jpg&quot;</span>));<br><span class="hljs-comment">// 4. 读写数据</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        <span class="hljs-comment">//5. 关闭 资源</span><br>        bos.close();<br>        bis.close();<br>        accept.close();<br>        System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUPload_Client</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件  </span><br>        BufferedInputStream bis  = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.jpg&quot;</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端 </span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream   bos   = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据. </span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ; <br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>            bos.flush();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;文件发送完毕&quot;</span>);<br>        <span class="hljs-comment">// 3.释放资源</span><br><br>        bos.close(); <br>        socket.close();<br>        bis.close(); <br>        System.out.println(<span class="hljs-string">&quot;文件上传完毕 &quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="hljs-string">&quot;.jpg&quot;</span>) <span class="hljs-comment">// 文件名称</span><br>BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次接收新的连接,创建一个Socket</span><br><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    <span class="hljs-comment">// accept 交给子线程处理.</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      ......<br>        InputStream bis = accept.getInputStream();<br>      ......<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>      <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          <span class="hljs-comment">/* </span><br><span class="hljs-comment">          3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                      bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    <span class="hljs-comment">//4. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                  e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol><p><img src="/img/cphoto/net06.jpg"></p><h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">          3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br>                ) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                        bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br><br>                    <span class="hljs-comment">// 4.=======信息回写===========================</span><br>                    System.out.println(<span class="hljs-string">&quot;back ........&quot;</span>);<br>                    OutputStream out = accept.getOutputStream();<br>                    out.write(<span class="hljs-string">&quot;上传成功&quot;</span>.getBytes());<br>                    out.close();<br>                    <span class="hljs-comment">//================================</span><br><br>                    <span class="hljs-comment">//5. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.jpg&quot;</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据.</span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ;<br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>      <span class="hljs-comment">// 关闭输出流,通知服务端,写出数据完毕</span><br>        socket.shutdownOutput();<br>        System.out.println(<span class="hljs-string">&quot;文件发送完毕&quot;</span>);<br>        <span class="hljs-comment">// 3. =====解析回写============</span><br>        InputStream in = socket.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] back = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">20</span>];<br>        in.read(back);<br>        System.out.println(<span class="hljs-keyword">new</span> String(back));<br>        in.close();<br>        <span class="hljs-comment">// ============================</span><br><br>        <span class="hljs-comment">// 4.释放资源</span><br>        socket.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li><p>准备页面数据，web文件夹。</p><p>复制到我们Module中，比如复制到day08中</p><p><img src="/img/cphoto/net07.jpg"></p></li><li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8000</span>);<br>    Socket socket = server.accept();<br>    InputStream in = socket.getInputStream();<br>       <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> len = in.read(bytes);<br>    System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,len));<br>    socket.close();<br>    server.close();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p><p><img src="/img/cphoto/net08.jpg"></p></li></ol><p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>BufferedReader readWb = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>String requst = readWb.readLine();<br><span class="hljs-comment">//取出请求资源的路径</span><br>String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-comment">//去掉web前面的/</span><br>String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>System.out.println(path);<br></code></pre></td></tr></table></figure><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端  启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 创建ServerSocket 对象</span><br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        Socket socket = server.accept();<br>        <span class="hljs-comment">// 转换流读取浏览器的请求消息</span><br>        BufferedReader readWb = <span class="hljs-keyword">new</span><br>        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        String requst = readWb.readLine();<br>        <span class="hljs-comment">// 取出请求资源的路径</span><br>        String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-comment">// 去掉web前面的/</span><br>        String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 读取客户端请求的资源文件</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>        <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// 字节输出流,将文件写会客户端</span><br>        OutputStream out = socket.getOutputStream();<br>        <span class="hljs-comment">// 写入HTTP协议响应头,固定写法</span><br>        out.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>        out.write(<span class="hljs-string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());<br>        <span class="hljs-comment">// 必须要写入空行,否则浏览器不解析</span><br>        out.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>        <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>            out.write(bytes,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fis.close();<br>        out.close();<br>        readWb.close();<br>        socket.close();<br>        server.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul><li><strong>火狐</strong></li></ul><p><img src="/img/cphoto/net09.jpg"></p><blockquote><p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p></blockquote><p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            Socket socket = server.accept();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Web(socket)).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Web</span><span class="hljs-params">(Socket socket)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.socket=socket;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>                BufferedReader readWb = <span class="hljs-keyword">new</span><br>                        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>                String requst = readWb.readLine();<br>                <span class="hljs-comment">//取出请求资源的路径</span><br>                String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br>                System.out.println(Arrays.toString(strArr));<br>                String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>                System.out.println(path);<br><br>                FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>                System.out.println(fis);<br>                <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>                <span class="hljs-comment">//向浏览器 回写数据</span><br>                OutputStream out = socket.getOutputStream();<br>                out.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>                out.write(<span class="hljs-string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());<br>                out.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>                <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>                    out.write(bytes,<span class="hljs-number">0</span>,len);<br>                &#125;<br>                fis.close();<br>                out.close();<br>                readWb.close();<br>                socket.close();<br>            &#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>图解：</p><h6 id><a href="#" class="headerlink" title></a><img src="/img/cphoto/net10.jpg"></h6><h1 id="第四章-函数式接口"><a href="#第四章-函数式接口" class="headerlink" title="第四章 函数式接口"></a>第四章 函数式接口</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>函数式接口在Java中是指：有且仅有一个抽象方法的接口。<br>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><blockquote><p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p></blockquote><h2 id="1-2-格式"><a href="#1-2-格式" class="headerlink" title="1.2 格式"></a>1.2 格式</h2><p>只要确保接口中有且仅有一个抽象方法即可：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">abstract</span> 返回值类型 方法名称(<span class="hljs-type">可选参数信息</span>);</span><br><span class="hljs-class">// 其他非抽象方法内容</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-3-FunctionalInterface注解"><a href="#1-3-FunctionalInterface注解" class="headerlink" title="1.3 @FunctionalInterface注解"></a>1.3 @FunctionalInterface注解</h2><p>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注<br>解可用于一个接口的定义上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注<br>意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h2 id="1-4-自定义函数式接口"><a href="#1-4-自定义函数式接口" class="headerlink" title="1.4 自定义函数式接口"></a>1.4 自定义函数式接口</h2><p>对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09FunctionalInterface</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义的函数式接口作为方法参数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doSomething</span>(<span class="hljs-params">MyFunctionalInterface inter</span>)</span> &#123;<br>   inter.myMethod(); <span class="hljs-comment">// 调用自定义的函数式接口方法</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 调用使用函数式接口的方法</span><br>        doSomething(() ‐&gt; System.out.println(<span class="hljs-string">&quot;Lambda执行啦！&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-函数式编程"><a href="#第五章-函数式编程" class="headerlink" title="第五章 函数式编程"></a>第五章 函数式编程</h1><p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。<br>下面我们做一个初探。</p><h2 id="2-1-Lambda的延迟执行"><a href="#2-1-Lambda的延迟执行" class="headerlink" title="2.1 Lambda的延迟执行"></a>2.1 Lambda的延迟执行</h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以<br>作为解决方案，提升性能。<br><em><strong>性能浪费的日志案例</strong></em><br>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。<br>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Logger</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, <span class="hljs-keyword">String</span> msg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(msg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>, msgA + msgB + msgC);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码存在问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方<br>法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p><blockquote><p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p></blockquote><p><strong>体验Lambda的更优写法</strong><br>使用Lambda必然需要一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageBuilder</span> </span>&#123;<br><span class="hljs-function">String <span class="hljs-title">buildMessage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后对 log 方法进行改造：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02LoggerLambda</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">buildMessage</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>, () ‐&gt; msgA + msgB + msgC );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p><p><strong>证明Lambda的延迟</strong><br>下面的代码可以通过结果进行验证：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03LoggerDelay</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">buildMessage</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>, () ‐&gt; &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Lambda执行！&quot;</span>);<br>            <span class="hljs-keyword">return</span> msgA + msgB + msgC;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。<br>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法<br>来完成。而是否调用其所在方法是在条件判断之后才执行的。</p><h2 id="2-2-使用Lambda作为参数和返回值"><a href="#2-2-使用Lambda作为参数和返回值" class="headerlink" title="2.2 使用Lambda作为参数和返回值"></a>2.2 使用Lambda作为参数和返回值</h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数<br>式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式<br>接口作为方法参数。</p><p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就<br>可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">startThread</span>(<span class="hljs-params">Runnable task</span>)</span> &#123;<br>    <span class="hljs-keyword">new</span> Thread(task).start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    startThread(() ‐&gt; System.out.println(<span class="hljs-string">&quot;线程任务执行！&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一<br>个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import java.util.Arrays;<br>import java.util.Comparator;<br>public <span class="hljs-keyword">class</span> Demo06Comparator &#123;<br>    <span class="hljs-keyword">private</span> static Comparator&lt;String&gt; <span class="hljs-keyword">new</span><span class="hljs-constructor">Comparator()</span> &#123;<br>    return (a, b) ‐&gt; b.length<span class="hljs-literal">()</span> ‐ a.length<span class="hljs-literal">()</span>;<br>    &#125;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        String<span class="hljs-literal">[]</span> <span class="hljs-built_in">array</span> = &#123; <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span> &#125;;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">array</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(<span class="hljs-built_in">array</span>, <span class="hljs-keyword">new</span><span class="hljs-constructor">Comparator()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">array</span>)</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中直接return一个Lambda表达式即可。</p><h1 id="第六章-常用函数式接口"><a href="#第六章-常用函数式接口" class="headerlink" title="第六章 常用函数式接口"></a>第六章 常用函数式接口</h1><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。<br>下面是最简单的几个接口及使用示例。</p><h2 id="3-1-Supplier接口"><a href="#3-1-Supplier接口" class="headerlink" title="3.1 Supplier接口"></a>3.1 Supplier接口</h2><p>java.util.function.Supplier<T> 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对<br>象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象<br>数据。</T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08Supplier</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getString</span>(<span class="hljs-params">Supplier&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">function</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>.get();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-built_in">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        System.out.println(getString(() ‐&gt; msgA + msgB));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-练习：求数组元素最大值"><a href="#3-2-练习：求数组元素最大值" class="headerlink" title="3.2 练习：求数组元素最大值"></a>3.2 练习：求数组元素最大值</h2><p><strong>题目</strong><br>使用 Supplier 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型请使用<br>java.lang.Integer 类。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Test</span> &#123;</span><br>    <span class="hljs-comment">//定一个方法,方法的参数传递Supplier,泛型使用Integer</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> sup.<span class="hljs-built_in">get</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">333</span>,<span class="hljs-number">23</span>&#125;;<br>        <span class="hljs-comment">//调用getMax方法,参数传递Lambda</span><br>        <span class="hljs-keyword">int</span> maxNum = <span class="hljs-built_in">getMax</span>(()‐&gt;&#123;<br>            <span class="hljs-comment">//计算数组的最大值</span><br>            <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;max)&#123;<br>                max = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>        &#125;);<br>        System.out.<span class="hljs-built_in">println</span>(maxNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-Consumer接口"><a href="#3-3-Consumer接口" class="headerlink" title="3.3 Consumer接口"></a>3.3 Consumer接口</h2><p>java.util.function.Consumer<T> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，<br>其数据类型由泛型决定。<br><strong>抽象方法：accept</strong><br>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。基本使用如：</T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Consumer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">consumeString</span>(<span class="hljs-params">Consumer&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">function</span></span>)</span> &#123;<br>    <span class="hljs-keyword">function</span>.accept(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    consumeString(s ‐&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，更好的写法是使用方法引用。<br><strong>默认方法：andThen</strong><br>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，<br>然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。下面是JDK的源代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">default Consumer&lt;T&gt; <span class="hljs-keyword">and</span><span class="hljs-constructor">Then(Consumer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">after</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>require<span class="hljs-constructor">NonNull(<span class="hljs-params">after</span>)</span>;<br>    return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注： java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出<br>NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote><p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组<br>合的情况：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConsumerAndThen</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeString</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">String</span>&gt; one, Consumer&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        one.<span class="hljs-built_in">andThen</span>(two).<span class="hljs-built_in">accept</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">consumeString</span>(<br>            s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s.<span class="hljs-built_in">toUpperCase</span>()),<br>            s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s.<span class="hljs-built_in">toLowerCase</span>()));<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的<br>组合。<br>3.4 练习：格式化打印信息<br>题目<br>下面的字符串数组当中存有多条信息，请按照格式“ 姓名：XX。性别：XX。 ”的格式将信息打印出来。要求将打印姓<br>名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实<br>例，将两个 Consumer 接口按照顺序“拼接”到一起。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">public<span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br>String[]<span class="hljs-built_in"> array </span>= &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>解答</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConsumer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span> &#125;;<br>        <span class="hljs-built_in">printInfo</span>(s ‐&gt; System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;姓名：&quot;</span> + s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>]),<br>        s ‐&gt; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;。性别：&quot;</span> + s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;。&quot;</span>),<br>        array);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">String</span>&gt; one, Consumer&lt;<span class="hljs-keyword">String</span>&gt; two, <span class="hljs-keyword">String</span>[] array)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> info : array) &#123;<br>        one.<span class="hljs-built_in">andThen</span>(two).<span class="hljs-built_in">accept</span>(info); <span class="hljs-comment">// 姓名：迪丽热巴。性别：女。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-Predicate接口"><a href="#3-5-Predicate接口" class="headerlink" title="3.5 Predicate接口"></a>3.5 Predicate接口</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<br>java.util.function.Predicate<T> 接口。<br><strong>抽象方法：test</strong><br>Predicate 接口中包含一个抽象方法： boolean test(T t) 。用于条件判断的场景：```</T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo15PredicateTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Predicate&lt;<span class="hljs-built_in">String</span>&gt; predicate</span>)</span> &#123;<br>        <span class="hljs-built_in">boolean</span> veryLong = predicate.test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    method(s ‐&gt; s.length() &gt; <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。<br><strong>默认方法：and</strong><br>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实<br>现“并且”的效果时，可以使用default方法 and 。其JDK源码为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;<br>    Objects<span class="hljs-selector-class">.requireNonNull</span>(other);<br>    return (t) ‐&gt; test(t) &amp;&amp; other<span class="hljs-selector-class">.test</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;<span class="hljs-keyword">String</span>&gt; one, Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isValid = one.<span class="hljs-built_in"><span class="hljs-keyword">and</span></span>(two).<span class="hljs-built_in">test</span>(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;W&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h2><p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。JDK源码为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">default Predicate&lt;<span class="hljs-built_in">T</span>&gt; <span class="hljs-built_in">or</span>(Predicate&lt;? super <span class="hljs-built_in">T</span>&gt; other) &#123;<br>    Objects.requireNonNull(other);<br>    return (<span class="hljs-built_in">t</span>) ‐&gt; test(<span class="hljs-built_in">t</span>) || other.test(<span class="hljs-built_in">t</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不<br>变：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;<span class="hljs-keyword">String</span>&gt; one, Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isValid = one.<span class="hljs-built_in"><span class="hljs-keyword">or</span></span>(two).<span class="hljs-built_in">test</span>(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;W&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>默认方法：negate</strong><br>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-function"><span class="hljs-title">negate</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> (t) ‐&gt; !test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前<br>调用 negate 方法，正如 and 和 or 方法一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo17PredicateNegate</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Predicate&lt;<span class="hljs-built_in">String</span>&gt; predicate</span>)</span> &#123;<br>        <span class="hljs-built_in">boolean</span> veryLong = predicate.negate().test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    method(s ‐&gt; s.length() &lt; <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-练习：集合信息筛选"><a href="#3-6-练习：集合信息筛选" class="headerlink" title="3.6 练习：集合信息筛选"></a>3.6 练习：集合信息筛选</h2><p><strong>题目</strong><br>数组当中有多条“姓名+性别”的信息如下，请通过 Predicate 接口的拼装将符合要求的字符串筛选到集合<br>ArrayList 中，需要同时满足两个条件：</p><ol><li>必须为女生；</li><li>姓名为4个字。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPredicate</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span>, <span class="hljs-string">&quot;赵丽颖,女&quot;</span> &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解答</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPredicate</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span>, <span class="hljs-string">&quot;赵丽颖,女&quot;</span> &#125;;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-built_in">filter</span>(array,<br>        s ‐&gt; <span class="hljs-string">&quot;女&quot;</span>.<span class="hljs-built_in">equals</span>(s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]),<br>        s ‐&gt; s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>() == <span class="hljs-number">4</span>);<br>        System.out.<span class="hljs-built_in">println</span>(list);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] array, Predicate&lt;<span class="hljs-keyword">String</span>&gt; one,</span></span><br><span class="hljs-params"><span class="hljs-function">        Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>            List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> info : array) &#123;<br>                <span class="hljs-keyword">if</span> (one.<span class="hljs-built_in"><span class="hljs-keyword">and</span></span>(two).<span class="hljs-built_in">test</span>(info)) &#123;<br>                    list.<span class="hljs-built_in">add</span>(info);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-7-Function接口"><a href="#3-7-Function接口" class="headerlink" title="3.7 Function接口"></a>3.7 Function接口</h2><p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，<br>后者称为后置条件。<br><strong>抽象方法：apply</strong><br>Function 接口中最主要的抽象方法为： R apply(T t) ，根据类型T的参数获取类型R的结果。<br>使用的场景例如：将 String 类型转换为 Integer 类型。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">function</span>.<span class="hljs-keyword">Function</span>;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo11FunctionApply &#123;<br>    private static <span class="hljs-type">void</span> <span class="hljs-keyword">method</span>(<span class="hljs-keyword">Function</span>&lt;String, <span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">function</span>) &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-keyword">function</span>.apply(&quot;10&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(num + <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-keyword">method</span>(s ‐&gt; <span class="hljs-type">Integer</span>.parseInt(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，最好是通过方法引用的写法。<br><strong>默认方法：andThen</strong><br>Function 接口中有一个默认的 andThen 方法，用来进行组合操作。JDK源代码如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">default &lt;V&gt; <span class="hljs-keyword">Function</span>&lt;T, V&gt; andThen(<span class="hljs-keyword">Function</span>&lt;? super R, ? extends V&gt; <span class="hljs-built_in">after</span>) &#123;<br>    Objects.requireNonNull(<span class="hljs-built_in">after</span>);<br>    <span class="hljs-keyword">return</span> (T t) ‐&gt; <span class="hljs-built_in">after</span>.<span class="hljs-built_in">apply</span>(<span class="hljs-built_in">apply</span>(t));<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">function</span>.<span class="hljs-keyword">Function</span>;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo12FunctionAndThen &#123;<br>    private static <span class="hljs-type">void</span> <span class="hljs-keyword">method</span>(<span class="hljs-keyword">Function</span>&lt;String, <span class="hljs-type">Integer</span>&gt; one, <span class="hljs-keyword">Function</span>&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt; two) &#123;<br>        <span class="hljs-type">int</span> num = one.andThen(two).apply(&quot;10&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(num + <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-keyword">method</span>(str‐&gt;<span class="hljs-type">Integer</span>.parseInt(str)+<span class="hljs-number">10</span>, i ‐&gt; i *= <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一<br>起。<br>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p><h2 id="3-8-练习：自定义函数模型拼接"><a href="#3-8-练习：自定义函数模型拼接" class="headerlink" title="3.8 练习：自定义函数模型拼接"></a>3.8 练习：自定义函数模型拼接</h2><p>题目<br>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：<br>String str = “赵丽颖,20”;</p><ol><li>将字符串截取数字年龄部分，得到字符串；</li><li>将上一步的字符串转换成为int类型的数字；</li><li>将上一步的int数字累加100，得到结果int数字。</li></ol><p>解答</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">public</span> class DemoFunction &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;赵丽颖,20&quot;</span>;<br>        <span class="hljs-built_in">int</span> age = getAgeNum(<span class="hljs-built_in">str</span>, s ‐&gt; s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>],<br>        s ‐&gt;Integer.parseInt(s),<br>        n ‐&gt; n += <span class="hljs-number">100</span>);<br>        System.out.<span class="hljs-built_in">println</span>(age);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> getAgeNum(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>, Function&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; one,<br>        Function&lt;<span class="hljs-keyword">String</span>, Integer&gt; two,<br>        Function&lt;Integer, Integer&gt; three) &#123;<br>        <span class="hljs-keyword">return</span> one.andThen(two).andThen(three).apply(<span class="hljs-built_in">str</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第七章-Stream流"><a href="#第七章-Stream流" class="headerlink" title="第七章 Stream流"></a>第七章 Stream流</h1><p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带<br>来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</p><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p><strong>传统集合的多步遍历代码</strong><br>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元<br>素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo01ForEach &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : list) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。<br><strong>循环遍历的弊端</strong><br>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行<br>了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p><ul><li><p>for循环的语法就是“怎么做”</p></li><li><p>for循环的循环体才是“做什么”</p><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。</p></li></ul><p>试想一下，如果希望对集合中的元素进行筛选过滤：</p><ol><li>将集合A根据条件一过滤为子集B；</li><li>然后再根据条件二过滤为子集C。</li></ol><p>那怎么办？在Java 8之前的做法可能为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo02NormalFilter &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>        List&lt;String&gt; zhangList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : list) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">name</span>.startsWith(&quot;张&quot;)) &#123;<br>            zhangList.<span class="hljs-keyword">add</span>(<span class="hljs-type">name</span>);<br>            &#125;<br>    &#125;<br>        List&lt;String&gt; shortList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : zhangList) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">name</span>.length() == <span class="hljs-number">3</span>) &#123;<br>                shortList.<span class="hljs-keyword">add</span>(<span class="hljs-type">name</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : shortList) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中含有三个循环，每一个作用不同：</p><ol><li>首先筛选所有姓张的人；</li><li>然后筛选名字有三个字的人；</li><li>最后进行对结果进行打印输出。<br>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</li></ol><p><strong>Stream的更优写法</strong><br>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo03StreamFilter &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>            list.stream()<br>                .<span class="hljs-keyword">filter</span>(s ‐&gt; s.startsWith(&quot;张&quot;))<br>                .<span class="hljs-keyword">filter</span>(s ‐&gt; s.length() == <span class="hljs-number">3</span>)<br>                .<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印。代码<br>中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h2 id="1-2-流式思想概述"><a href="#1-2-流式思想概述" class="headerlink" title="1.2 流式思想概述"></a>1.2 流式思想概述</h2><p>注意：请暂时忘记对传统IO流的固有印象！<br>整体来看，流式思想类似于工厂车间的“生产流水线”</p><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤<br>方案，然后再按照方案去执行它。<br><img src="/img/cphoto/flow01.jpg"></p><p>过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。<br>这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 count执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p><blockquote><p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源 流的来源。 可以是集合，数组 等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><p>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p></li><li><p>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭<br>代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</p></li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结  果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以  像链条一样排列，变成一个管道。</p><h2 id="1-3-获取流"><a href="#1-3-获取流" class="headerlink" title="1.3 获取流"></a>1.3 获取流</h2><p>java.util.stream.Stream<T> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）获取一个流非常简单，有以下几种常用的方式：</T></p><ul><li>所有的 Collection 集合都可以通过 stream 默认方法获取流；</li><li>Stream 接口的静态方法 of 可以获取数组对应的流。</li></ul><p><strong>根据Collection获取流</strong><br>首先， java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream1 = list.<span class="hljs-built_in">stream</span>();<br>        Set&lt;<span class="hljs-keyword">String</span>&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream2 = set.<span class="hljs-built_in">stream</span>();<br>        Vector&lt;<span class="hljs-keyword">String</span>&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream3 = vector.<span class="hljs-built_in">stream</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>根据Map获取流</strong><br>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        Map&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; keyStream = map.<span class="hljs-built_in">keySet</span>().<span class="hljs-built_in">stream</span>();<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; valueStream = map.<span class="hljs-built_in">values</span>().<span class="hljs-built_in">stream</span>();<br>        <span class="hljs-built_in">Stream</span>&lt;Map.Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt;&gt; entryStream = map.<span class="hljs-built_in">entrySet</span>().<span class="hljs-built_in">stream</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>根据数组获取流</strong><br>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法<br>of ，使用很简单：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张翠山&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;张一元&quot;</span> &#125;;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><ul><li><p>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方<br>法均为延迟方法。）</p></li><li><p>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调<br>用。本小节中，终结方法包括 count 和 forEach 方法。</p></li></ul><blockquote><p>备注：本小节之外的更多方法，请自行参考API文档。</p></blockquote><p><strong>逐一处理：forEach</strong><br>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。<br><strong>复习Consumer接口</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">java.util.function.Consumer&lt;<span class="hljs-built_in">T</span>&gt;接口是一个消费型接口。<br>Consumer接口中包含抽象方法void accept(<span class="hljs-built_in">T</span> <span class="hljs-built_in">t</span>)，意为消费一个指定泛型的数据。<br></code></pre></td></tr></table></figure><p><strong>基本使用：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamForEach</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        stream.forEach(name‐&gt; System.out.<span class="hljs-built_in">println</span>(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>过滤：filter</strong></p><p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Stream</span>&lt;<span class="hljs-type">T</span>&gt; filter(<span class="hljs-type">Predicate</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; predicate);<br></code></pre></td></tr></table></figure><p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><p><strong>复习Predicate接口</strong><br>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure><p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法<br>将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。<br><strong>基本使用</strong><br>Stream流中的 filter 方法基本使用的代码如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07StreamFilter</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。<br><strong>映射：map</strong><br>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-keyword">map</span>(<span class="hljs-built_in">Function</span>&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> R&gt; mapper);<br></code></pre></td></tr></table></figure><p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><p><strong>复习Function接口</strong><br>此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">R apply(<span class="hljs-built_in">T</span> <span class="hljs-built_in">t</span>);<br><br></code></pre></td></tr></table></figure><p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。<br><strong>基本使用</strong><br>Stream流中的 map 方法基本使用的代码如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08StreamMap</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;Integer&gt; result = original.<span class="hljs-built_in">map</span>(str‐&gt;Integer.<span class="hljs-built_in">parseInt</span>(str));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。<br><strong>统计个数：count</strong><br>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09StreamCount</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h2><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br><br></code></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10StreamLimit</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">limit</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>跳过前几个：skip</strong><br>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11StreamSkip</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">skip</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 1</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>组合：concat</strong><br>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="xml">static <span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> Stream<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> concat(Stream</span><span class="php"><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; a, Stream<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; b)</span><br><span class="php"></span><br></code></pre></td></tr></table></figure><blockquote><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p></blockquote><p>该方法的基本使用代码如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamConcat</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamA = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamB = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张翠山&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(streamA, streamB);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-5-练习：集合元素处理（传统方式）"><a href="#1-5-练习：集合元素处理（传统方式）" class="headerlink" title="1.5 练习：集合元素处理（传统方式）"></a>1.5 练习：集合元素处理（传统方式）</h2><p><strong>题目</strong><br>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以下若干操作步骤：</p><ol><li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li><li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li><li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li><li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li><li>将两个队伍合并为一个队伍；存储到一个新集合中。</li><li>根据姓名创建 Person 对象；存储到一个新集合中。</li><li>打印整个队伍的Person对象信息。</li></ol><p>两个队伍（集合）的代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> class DemoArrayListNames &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">//第一支队伍</span><br>        ArrayList&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;宋远桥&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;苏星河&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;石破天&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;石中玉&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;老子&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;庄子&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;洪七公&quot;</span>);<br>        <span class="hljs-comment">//第二支队伍</span><br>        ArrayList&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;古力娜扎&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;赵丽颖&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;尼古拉斯赵四&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张天爱&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张二狗&quot;</span>);<br>        <span class="hljs-comment">// ....</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而 Person 类的代码为：    </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解答<br>既然使用传统的for循环写法，那么：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoArrayListNames</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 第一个队伍只要名字为3个字的成员姓名；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; oneA = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">one</span>) &#123;<br>            <span class="hljs-keyword">if</span> (name.length() == <span class="hljs-number">3</span>) &#123;<br>            oneA.add(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 第一个队伍筛选之后只要前3个人；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; oneB = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        oneB.add(oneA.<span class="hljs-keyword">get</span>(i));<br>        &#125;<br>        <span class="hljs-comment">// 第二个队伍只要姓张的成员姓名；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; twoA = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">two</span>) &#123;<br>            <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)) &#123;<br>            twoA.add(name);<br>        &#125;<br>        &#125;<br>        <span class="hljs-comment">// 第二个队伍筛选之后不要前2个人；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; twoB = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">2</span>; i &lt; twoA.size(); i++) &#123;<br>        twoB.add(twoA.<span class="hljs-keyword">get</span>(i));<br>        &#125;<br>        <span class="hljs-comment">// 将两个队伍合并为一个队伍；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; totalNames = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        totalNames.addAll(oneB);<br>        totalNames.addAll(twoB);<br>        <span class="hljs-comment">// 根据姓名创建Person对象；</span><br>        List&lt;Person&gt; totalPersonList = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">totalNames</span>) &#123;<br>        totalPersonList.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name));<br>        &#125;<br>        <span class="hljs-comment">// 打印整个队伍的Person对象信息。</span><br>        <span class="hljs-keyword">for</span> (Person person : <span class="hljs-type">totalPersonList</span>) &#123;<br>        System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;石破天&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-6-练习：集合元素处理（Stream方式）"><a href="#1-6-练习：集合元素处理（Stream方式）" class="headerlink" title="1.6 练习：集合元素处理（Stream方式）"></a>1.6 练习：集合元素处理（Stream方式）</h2><p><strong>题目</strong><br>将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变， Person 类的定义也不变</p><p>解答</p><p>等效的Stream流式处理代码为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoStreamNames</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 第一个队伍只要名字为3个字的成员姓名；</span><br>        <span class="hljs-comment">// 第一个队伍筛选之后只要前3个人；</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamOne = one.<span class="hljs-built_in">stream</span>().<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">length</span>() == <span class="hljs-number">3</span>).<span class="hljs-built_in">limit</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 第二个队伍只要姓张的成员姓名；</span><br>        <span class="hljs-comment">// 第二个队伍筛选之后不要前2个人；</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamTwo = two.<span class="hljs-built_in">stream</span>().<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>)).<span class="hljs-built_in">skip</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 将两个队伍合并为一个队伍；</span><br>        <span class="hljs-comment">// 根据姓名创建Person对象；</span><br>        <span class="hljs-comment">// 打印整个队伍的Person对象信息。</span><br>        <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(streamOne, streamTwo).<span class="hljs-built_in">map</span>(Person::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行效果完全一样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;石破天&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="第八章-方法引用"><a href="#第八章-方法引用" class="headerlink" title="第八章 方法引用"></a>第八章 方法引用</h1><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑<br>一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p><h2 id="2-1-冗余的Lambda场景"><a href="#2-1-冗余的Lambda场景" class="headerlink" title="2.1 冗余的Lambda场景"></a>2.1 冗余的Lambda场景</h2><p>来看一个简单的函数式接口以应用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01PrintSimple</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>    data.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">printString</span>(s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 Printable 的具体操作方案为：拿到String（类型可推导，所以可省略）数据后，在控制台中输出它。</p><p>2## .2 问题分析<br>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out对象中的 println(String) 方法。既然Lambda希望做的事情就是调用 println(String) 方法，那何必自己手动调用呢？</p><h2 id="2-3-用方法引用改进代码"><a href="#2-3-用方法引用改进代码" class="headerlink" title="2.3 用方法引用改进代码"></a>2.3 用方法引用改进代码</h2><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02PrintRef</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>    data.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">printString</span>(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意其中的双冒号 :: 写法，这被称为“方法引用”，而双冒号是一种新的语法。</p><h2 id="2-4-方法引用符"><a href="#2-4-方法引用符" class="headerlink" title="2.4 方法引用符"></a>2.4 方法引用符</h2><p>双冒号 :: 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方<br>法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>例如上例中， System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于printString 方法的函数式接口参数，对比下面两种写法，完全等效：</p><ul><li>Lambda表达式写法： s -&gt; System.out.println(s);</li><li>方法引用写法： System.out::println</li></ul><p>1, 第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。<br> 2, 第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一  样，而第二种方法引用的写法复用了已有方案，更加简洁。<br>  注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p><p><strong>推导与省略</strong><br>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都<br>将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。<br>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。<br>下面这段代码将会调用 println 方法的不同重载形式，将函数式接口改为int类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PrintableInteger</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03PrintOverload</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInteger</span><span class="hljs-params">(PrintableInteger data)</span> </span>&#123;<br>        data.<span class="hljs-built_in">print</span>(<span class="hljs-number">1024</span>);<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>   <span class="hljs-built_in">printInteger</span>(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次方法引用将会自动匹配到 println(int) 的重载形式。</p><h2 id="2-5-通过对象名引用成员方法"><a href="#2-5-通过对象名引用成员方法" class="headerlink" title="2.5 通过对象名引用成员方法"></a>2.5 通过对象名引用成员方法</h2><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodRefObject</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printUpperCase</span><span class="hljs-params">(<span class="hljs-keyword">String</span> str)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(str.<span class="hljs-built_in">toUpperCase</span>());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>函数式接口仍然定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的Lambda的时候，已经具有了<br>MethodRefObject 类的对象实例，则可以通过对象名引用成员方法，代码为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04MethodRef</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printString</span>(<span class="hljs-params">Printable lambda</span>)</span> &#123;<br>    lambda.print(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        MethodRefObject obj = <span class="hljs-keyword">new</span> MethodRefObject();<br>        printString(obj::printUpperCase);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-通过类名称引用静态方法"><a href="#2-6-通过类名称引用静态方法" class="headerlink" title="2.6 通过类名称引用静态方法"></a>2.6 通过类名称引用静态方法</h2><p>由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calcable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第一种写法是使用Lambda表达式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05Lambda</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>   System.out.<span class="hljs-built_in">println</span>(lambda.<span class="hljs-built_in">calc</span>(num));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(‐<span class="hljs-number">10</span>, n ‐&gt; Math.<span class="hljs-built_in">abs</span>(n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是使用方法引用的更好写法是：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06MethodRef</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(lambda.<span class="hljs-built_in">calc</span>(num));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(‐<span class="hljs-number">10</span>, Math::abs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： n -&gt; Math.abs(n)</li><li>方法引用： Math::abs</li></ul><h2 id="2-7-通过super引用成员方法"><a href="#2-7-通过super引用成员方法" class="headerlink" title="2.7 通过super引用成员方法"></a>2.7 通过super引用成员方法</h2><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Greetable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后是父类 Human 的内容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是子类 Man 的内容，其中使用了Lambda的写法：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Man extends Human <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    @Override</span><br><span class="hljs-comment">    public void sayHello() &#123;</span><br><span class="hljs-comment">    System.out.println(&quot;大家好,我是Man!&quot;);</span><br><span class="hljs-comment">    &#125;</span><br>    <span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(Greetable g)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    g.greet();</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    //调用method方法,使用Lambda表达式</span></span><br><span class="hljs-comment"><span class="hljs-function">    method(()‐&gt;&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">        //创建Human对象,调用sayHello方法</span></span><br><span class="hljs-comment"><span class="hljs-function">        new Human().sayHello();</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span>);</span><br>    <span class="hljs-comment">//简化Lambda</span><br>    <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(()</span>‐&gt;<span class="hljs-title">new</span> <span class="hljs-title">Human</span><span class="hljs-params">()</span>.<span class="hljs-title">sayHello</span><span class="hljs-params">()</span>);</span><br>    <span class="hljs-comment">//使用super关键字代替父类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(()</span>‐&gt;<span class="hljs-title">super</span>.<span class="hljs-title">sayHello</span><span class="hljs-params">()</span>);</span><br>    &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Greetable g</span>)</span>&#123;<br>    g.greet();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>&#123;<br>    method(<span class="hljs-built_in">super</span>::sayHello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：<br>Lambda表达式： () -&gt; super.sayHello()<br>方法引用： super::sayHello</p><h2 id="2-8-通过this引用成员方法"><a href="#2-8-通过this引用成员方法" class="headerlink" title="2.8 通过this引用成员方法"></a>2.8 通过this引用成员方法</h2><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Richable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个丈夫 Husband 类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    marry(() ‐&gt; System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>开心方法 beHappy 调用了结婚方法 marry ，后者的参数为函数式接口 Richable ，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 Husband 丈夫类进行修改：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">buyHouse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    marry(() ‐&gt; <span class="hljs-built_in">this</span>.buyHouse());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">buyHouse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    marry(<span class="hljs-built_in">this</span>::buyHouse);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： () -&gt; this.buyHouse()</li><li>方法引用： this::buyHouse</li></ul><h2 id="2-9-类的构造器引用"><a href="#2-9-类的构造器引用" class="headerlink" title="2.9 类的构造器引用"></a>2.9 类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。首先是一个简单的 Person 类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是用来创建 Person 对象的函数式接口：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>Person buildPerson(<span class="hljs-keyword">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过Lambda表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Lambda</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, PersonBuilder builder</span>)</span> &#123;<br>    System.out.println(builder.buildPerson(name).getName());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="hljs-keyword">new</span> Person(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是通过构造器引用，有更好的写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConstructorRef</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, PersonBuilder builder</span>)</span> &#123;<br>    System.out.println(builder.buildPerson(name).getName());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-attr">Person</span>::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： name -&gt; new Person(name)</li><li>方法引用： Person::new</li></ul><h2 id="2-10-数组的构造器引用"><a href="#2-10-数组的构造器引用" class="headerlink" title="2.10 数组的构造器引用"></a>2.10 数组的构造器引用</h2><p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，<br>需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArrayBuilder</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] buildArray(<span class="hljs-keyword">int</span> length);<br>&#125;<br></code></pre></td></tr></table></figure><p>在应用该接口的时候，可以通过Lambda表达式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11ArrayInitRef</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">initArray</span>(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br>    <span class="hljs-keyword">return</span> builder.<span class="hljs-built_in">buildArray</span>(length);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-built_in">initArray</span>(<span class="hljs-number">10</span>, length ‐&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是更好的写法是使用数组的构造器引用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12ArrayInitRef</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">initArray</span>(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-built_in">buildArray</span>(length);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] array = <span class="hljs-built_in">initArray</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： length -&gt; new int[length]</li><li>方法引用： int[]::new</li></ul><h1 id="第九章-Junit反射注解"><a href="#第九章-Junit反射注解" class="headerlink" title="第九章 Junit反射注解"></a>第九章 Junit反射注解</h1><pre><code>1. Junit单元测试2. 反射3. 注解</code></pre><h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><pre><code>* 测试分类：    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。    2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试    * 步骤：        1. 定义一个测试类(测试用例)            * 建议：                * 测试类名：被测试的类名Test        CalculatorTest                * 包名：xxx.xxx.xx.test        cn.itcast.test        2. 定义测试方法：可以独立运行            * 建议：                * 方法名：test测试的方法名        testAdd()                  * 返回值：void                * 参数列表：空参        3. 给方法加@Test        4. 导入junit依赖环境    * 判定结果：        * 红色：失败        * 绿色：成功        * 一般我们会使用断言操作来处理结果            * Assert.assertEquals(期望的结果,运算的结果);    * 补充：        * @Before:            * 修饰的方法会在测试方法之前被自动执行        * @After:            * 修饰的方法会在测试方法执行之后自动被执行</code></pre><h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class：通过类名的属性class获取        * 多用于参数的传递    3. 对象.getClass()：getClass()方法在Object类中定义着。        * 多用于对象的获取字节码的方式    * 结论：        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFields() ：获取所有public修饰的成员变量            * Field getField(String name)   获取指定名称的 public修饰的成员变量            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符            * Field getDeclaredField(String name)          2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()              * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;?&gt;[] getDeclaredConstructors()          3. 获取成员方法们：            * Method[] getMethods()              * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)              * Method[] getDeclaredMethods()              * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)          4. 获取全类名                * String getName()  * Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)          2. 获取值            * get(Object obj)         3. 忽略访问权限修饰符的安全检查            * setAccessible(true):暴力反射* Constructor:构造方法    * 创建对象：        * T newInstance(Object... initargs)          * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)      * 获取方法名称：        * String getName:获取方法名* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        * 实现：            1. 配置文件            2. 反射        * 步骤：            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中            2. 在程序中加载读取配置文件            3. 使用反射技术来加载类文件进内存            4. 创建对象            5. 执行方法</code></pre><h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><pre><code>* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述：    * JDK1.5之后的新特性    * 说明程序的    * 使用注解：@注解名称</code></pre><p>​    </p><pre><code>* 作用分类：    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】* JDK中预定义的一些注解    * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的    * @Deprecated：该注解标注的内容，表示已过时    * @SuppressWarnings：压制警告        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)* 自定义注解    * 格式：        元注解        public @interface 注解名称&#123;            属性列表;        &#125;    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口        * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125;    * 属性：接口中的抽象方法        * 要求：            1. 属性的返回值类型有下列取值                * 基本数据类型                * String                * 枚举                * 注解                * 以上类型的数组            2. 定义了属性，在使用时需要给属性赋值                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。                3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略        * 元注解：用于描述注解的注解        * @Target：描述注解能够作用的位置            * ElementType取值：                * TYPE：可以作用于类上                * METHOD：可以作用于方法上                * FIELD：可以作用于成员变量上        * @Retention：描述注解被保留的阶段            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到        * @Documented：描述注解是否被抽取到api文档中        * @Inherited：描述注解是否被子类继承* 在程序使用(解析)注解：获取注解中定义的属性值    1. 获取注解定义的位置的对象  （Class，Method,Field）    2. 获取指定的注解        * getAnnotation(Class)        //其实就是在内存中生成了一个该注解接口的子类实现对象                public class ProImpl implements Pro&#123;                    public String className()&#123;                        return &quot;cn.itcast.annotation.Demo1&quot;;                    &#125;                    public String methodName()&#123;                        return &quot;show&quot;;                    &#125;                &#125;    3. 调用注解中的抽象方法获取配置的属性值* 案例：简单的测试框架* 小结：    1. 以后大多数时候，我们会使用注解，而不是自定义注解    2. 注解给谁用？        1. 编译器        2. 给解析程序用    3. 注解不是程序的一部分，可以理解为注解就是一个标签</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎07-文件类</title>
    <link href="/2017/09/18/java%E5%9F%BA%E7%A4%8E07-%E6%96%87%E4%BB%B6%E7%B1%BB/"/>
    <url>/2017/09/18/java%E5%9F%BA%E7%A4%8E07-%E6%96%87%E4%BB%B6%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-File类"><a href="#第一章-File类" class="headerlink" title="第一章 File类"></a>第一章 File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul><li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li></ul><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件路径名</span><br>String pathname = <span class="hljs-string">&quot;D:\\aaa.txt&quot;</span>;<br>File file1 = <span class="hljs-keyword">new</span> File(pathname); <br><br><span class="hljs-comment">// 文件路径名</span><br>String pathname2 = <span class="hljs-string">&quot;D:\\aaa\\bbb.txt&quot;</span>;<br>File file2 = <span class="hljs-keyword">new</span> File(pathname2); <br><br><span class="hljs-comment">// 通过父路径和子路径字符串</span><br> String parent = <span class="hljs-string">&quot;d:\\aaa&quot;</span>;<br> String child = <span class="hljs-string">&quot;bbb.txt&quot;</span>;<br> File file3 = <span class="hljs-keyword">new</span> File(parent, child);<br><br><span class="hljs-comment">// 通过父级File对象和子路径字符串</span><br>File parentDir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\aaa&quot;</span>);<br>String child = <span class="hljs-string">&quot;bbb.txt&quot;</span>;<br>File file4 = <span class="hljs-keyword">new</span> File(parentDir, child);<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileGet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/aaa/bbb.java&quot;</span>);     <br>        System.out.println(<span class="hljs-string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;文件构造路径:&quot;</span>+f.getPath());<br>        System.out.println(<span class="hljs-string">&quot;文件名称:&quot;</span>+f.getName());<br>        System.out.println(<span class="hljs-string">&quot;文件长度:&quot;</span>+f.length()+<span class="hljs-string">&quot;字节&quot;</span>);<br><br>        File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/aaa&quot;</span>);     <br>        System.out.println(<span class="hljs-string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;目录构造路径:&quot;</span>+f2.getPath());<br>        System.out.println(<span class="hljs-string">&quot;目录名称:&quot;</span>+f2.getName());<br>        System.out.println(<span class="hljs-string">&quot;目录长度:&quot;</span>+f2.length());<br>    &#125;<br>&#125;<br>输出结果：<br>文件绝对路径:d:\aaa\bbb.java<br>文件构造路径:d:\aaa\bbb.java<br>文件名称:bbb.java<br>文件长度:<span class="hljs-number">636</span>字节<br><br>目录绝对路径:d:\aaa<br>目录构造路径:d:\aaa<br>目录名称:aaa<br>目录长度:<span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilePath</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// D盘下的bbb.java文件</span><br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\bbb.java&quot;</span>);<br>        System.out.println(f.getAbsolutePath());<br>      <br><span class="hljs-comment">// 项目下的bbb.java文件</span><br>        File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;bbb.java&quot;</span>);<br>        System.out.println(f2.getAbsolutePath());<br>    &#125;<br>&#125;<br>输出结果：<br>D:\bbb.java<br>D:\idea_project_test4\bbb.java<br></code></pre></td></tr></table></figure><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileIs</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\aaa\\bbb.java&quot;</span>);<br>        File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 判断是否存在</span><br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());<br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());<br>      <span class="hljs-comment">// 判断是文件还是目录</span><br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());<br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());<br>    &#125;<br>&#125;<br>输出结果：<br>d:\aaa\bbb.java 是否存在:<span class="hljs-keyword">true</span><br>d:\aaa 是否存在:<span class="hljs-keyword">true</span><br>d:\aaa 文件?:<span class="hljs-keyword">false</span><br>d:\aaa 目录?:<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileCreateDelete</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 文件的创建</span><br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;aaa.txt&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f.exists()); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f.exists()); <span class="hljs-comment">// true</span><br><br>     <span class="hljs-comment">// 目录的创建</span><br>      File f2= <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDir&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f2.exists());<span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;是否创建:&quot;</span>+f2.mkdir());<span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f2.exists());<span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 创建多级目录</span><br>      File f3= <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDira\\newDirb&quot;</span>);<br>        System.out.println(f3.mkdir());<span class="hljs-comment">// false</span><br>        File f4= <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDira\\newDirb&quot;</span>);<br>        System.out.println(f4.mkdirs());<span class="hljs-comment">// true</span><br>      <br>      <span class="hljs-comment">// 文件的删除</span><br>       System.out.println(f.delete());<span class="hljs-comment">// true</span><br>      <br>      <span class="hljs-comment">// 目录的删除</span><br>        System.out.println(f2.delete());<span class="hljs-comment">// true</span><br>        System.out.println(f4.delete());<span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li></ul><ul><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\java_code&quot;</span>);<br>      <br>      <span class="hljs-comment">//获取当前目录下的文件以及文件夹的名称。</span><br>String[] names = dir.list();<br><span class="hljs-keyword">for</span>(String name : names)&#123;<br>System.out.println(name);<br>&#125;<br>        <span class="hljs-comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span><br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            System.out.println(file);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h1 id="第二章-递归"><a href="#第二章-递归" class="headerlink" title="第二章 递归"></a>第二章 递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法,禁止递归</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01DiGui</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// a();</span><br>b(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 3.构造方法,禁止递归</span><br><span class="hljs-comment"> * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo01DiGui</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//Demo01DiGui();</span><br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span><br><span class="hljs-comment"> * 4993</span><br><span class="hljs-comment"> * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>System.out.println(i);<br><span class="hljs-comment">//添加一个递归结束的条件,i==5000的时候结束</span><br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">5000</span>)&#123;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//结束方法</span><br>&#125;<br>b(++i);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span><br><span class="hljs-comment"> * java.lang.StackOverflowError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;a方法&quot;</span>);<br>a();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p><p><strong>实现代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//计算1~num的和，使用递归完成</span><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;<br>      <span class="hljs-comment">// 调用求和的方法</span><br><span class="hljs-keyword">int</span> sum = getSum(num);<br>      <span class="hljs-comment">// 输出结果</span><br>System.out.println(sum);<br><br>&#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    通过递归算法实现.</span><br><span class="hljs-comment">    参数列表:int </span><br><span class="hljs-comment">    返回值类型: int </span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>      <span class="hljs-comment">/* </span><br><span class="hljs-comment">         num为1时,方法返回1,</span><br><span class="hljs-comment">         相当于是方法的出口,num总有是1的情况</span><br><span class="hljs-comment">      */</span><br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">          num不为1时,方法返回 num +(num-1)的累和</span><br><span class="hljs-comment">          递归调用getSum方法</span><br><span class="hljs-comment">        */</span><br><span class="hljs-keyword">return</span> num + getSum(num-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="/img/cphoto/file02.jpg"></p><blockquote><p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p></blockquote><h2 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h2><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">n的阶乘：n! = n * (n-<span class="hljs-number">1</span>) *...* <span class="hljs-number">3</span> * <span class="hljs-number">2</span> * <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">推理得出：<span class="hljs-built_in">n</span>! = <span class="hljs-built_in">n</span> * (<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)!<br></code></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo</span> </span>&#123;<br>  <span class="hljs-comment">//计算n的阶乘，使用递归完成</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;<br>      <span class="hljs-comment">// 调用求阶乘的方法</span><br>        <span class="hljs-keyword">int</span> value = getValue(n);<br>      <span class="hljs-comment">// 输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;阶乘为:&quot;</span>+ value);<br>    &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    通过递归算法实现.</span><br><span class="hljs-comment">    参数列表:int </span><br><span class="hljs-comment">    返回值类型: int </span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-comment">// 1的阶乘为1</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        n不为1时,方法返回 n! = n*(n-1)!</span><br><span class="hljs-comment">          递归调用getValue方法</span><br><span class="hljs-comment">      */</span><br>        <span class="hljs-keyword">return</span> n * getValue(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 创建File对象</span><br>        File dir  = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 调用打印目录方法</span><br>        printDir(dir);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">printDir</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>      <span class="hljs-comment">// 获取子文件和目录</span><br>        File[] files = dir.listFiles();<br>      <span class="hljs-comment">// 循环打印</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        判断:</span><br><span class="hljs-comment">        当是文件时,打印绝对路径.</span><br><span class="hljs-comment">        当是目录时,继续调用打印目录的方法,形成递归调用.</span><br><span class="hljs-comment">      */</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>    <span class="hljs-comment">// 判断</span><br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>              <span class="hljs-comment">// 是文件,输出文件绝对路径</span><br>                System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 是目录,输出目录绝对路径</span><br>                System.out.println(<span class="hljs-string">&quot;目录:&quot;</span>+file.getAbsolutePath());<br>              <span class="hljs-comment">// 继续遍历,调用printDir,形成递归</span><br>                printDir(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h2><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p><p><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建File对象</span><br>        File dir  = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 调用打印目录方法</span><br>        printDir(dir);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>      <span class="hljs-comment">// 获取子文件和目录</span><br>        File[] files = dir.listFiles();<br>      <br>      <span class="hljs-comment">// 循环打印</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>              <span class="hljs-comment">// 是文件，判断文件名并输出文件绝对路径</span><br>                <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 是目录，继续遍历,形成递归</span><br>                printDir(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-文件过滤器优化"><a href="#3-2-文件过滤器优化" class="headerlink" title="3.2 文件过滤器优化"></a>3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p><p><code>boolean accept(File pathname)  </code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>        printDir2(dir);<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir2</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>      <span class="hljs-comment">// 匿名内部类方式,创建过滤器子类对象</span><br>        File[] files = dir.listFiles(<span class="hljs-keyword">new</span> FileFilter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File pathname)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> pathname.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)||pathname.isDirectory();<br>            &#125;<br>        &#125;);<br>      <span class="hljs-comment">// 循环打印</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                printDir2(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;      <br></code></pre></td></tr></table></figure><h2 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p><p>lambda格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">()-&gt;&#123; &#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir3</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>  <span class="hljs-comment">// lambda的改写</span><br>    File[] files = dir.listFiles(f -&gt;&#123; <br>      <span class="hljs-keyword">return</span> f.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>) || f.isDirectory(); <br>    &#125;);<br>  <br><span class="hljs-comment">// 循环打印</span><br>    <span class="hljs-keyword">for</span> (File file : files) &#123;<br>        <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        printDir3(file);<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章-IO概述"><a href="#第四章-IO概述" class="headerlink" title="第四章 IO概述"></a>第四章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p><h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="1-3-顶级父类们"><a href="#1-3-顶级父类们" class="headerlink" title="1.3 顶级父类们"></a>1.3 顶级父类们</h2><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br><strong>InputStream</strong></td><td align="center">字节输出流<br><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br><strong>Reader</strong></td><td align="center">字符输出流<br><strong>Writer</strong></td></tr></tbody></table><h1 id="第五章-字节流"><a href="#第五章-字节流" class="headerlink" title="第五章 字节流"></a>第五章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p><p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileOutputStreamConstructor</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 写出数据</span><br>      fos.write(<span class="hljs-number">97</span>); <span class="hljs-comment">// 写出第1个字节</span><br>      fos.write(<span class="hljs-number">98</span>); <span class="hljs-comment">// 写出第2个字节</span><br>      fos.write(<span class="hljs-number">99</span>); <span class="hljs-comment">// 写出第3个字节</span><br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>abc<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;黑马程序员&quot;</span>.getBytes();<br>      <span class="hljs-comment">// 写出字节数组数据</span><br>      fos.write(b);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑马程序员<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br>        fos.write(b,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>cd<br></code></pre></td></tr></table></figure><h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>，<span class="hljs-keyword">true</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br>        fos.write(b);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>文件操作前：cd<br>文件操作后：cdabcde<br></code></pre></td></tr></table></figure><h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p><p>以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);  <br>      <span class="hljs-comment">// 定义字节数组</span><br>      <span class="hljs-keyword">byte</span>[] words = &#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>&#125;;<br>      <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>          <span class="hljs-comment">// 写出一个字节</span><br>            fos.write(words[i]);<br>          <span class="hljs-comment">// 写出一个换行, 换行符号转成数组写出</span><br>            fos.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>        &#125;<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>a<br>b<br>c<br>d<br>e<br></code></pre></td></tr></table></figure><blockquote><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileInputStreamConstructor</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileInputStream fos = <span class="hljs-keyword">new</span> FileInputStream(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileInputStream fos = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 读取数据，返回一个字节</span><br>        <span class="hljs-keyword">int</span> read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>      <span class="hljs-comment">// 读取到末尾,返回-1</span><br>       read = fis.read();<br>        System.out.println( read);<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>循环改进读取方式，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存数据</span><br>        <span class="hljs-keyword">int</span> b ；<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((b = fis.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println((<span class="hljs-keyword">char</span>)b);<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然读取了一个字节，但是会自动提升为int类型。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象.</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>); <span class="hljs-comment">// 文件中为abcde</span><br>      <span class="hljs-comment">// 定义变量，作为有效个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字节数组，作为装字节数据的容器   </span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> (( len= fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-comment">// 每次读取后,把数组变成字符串打印</span><br>            System.out.println(<span class="hljs-keyword">new</span> String(b));<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>ab<br>cd<br>ed<br></code></pre></td></tr></table></figure><p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象.</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>); <span class="hljs-comment">// 文件中为abcde</span><br>      <span class="hljs-comment">// 定义变量，作为有效个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字节数组，作为装字节数据的容器   </span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> (( len= fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span><br>            System.out.println(<span class="hljs-keyword">new</span> String(b，<span class="hljs-number">0</span>，len));<span class="hljs-comment">//  len 每次读取的有效字节个数</span><br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>ab<br>cd<br>e<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote><h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="/img/cphoto/file01.jpg"></p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Copy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 指定数据源</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\test.jpg&quot;</span>);<br>        <span class="hljs-comment">// 1.2 指定目的地</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test_copy.jpg&quot;</span>);<br><br>        <span class="hljs-comment">// 2.读写数据</span><br>        <span class="hljs-comment">// 2.1 定义数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">// 2.2 定义长度</span><br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-comment">// 2.3 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 2.4 写出数据</span><br>            fos.write(b, <span class="hljs-number">0</span> , len);<br>        &#125;<br><br>        <span class="hljs-comment">// 3.关闭资源</span><br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>流的关闭原则：先开后关，后开先关。</p></blockquote><h1 id="第六章-字符流"><a href="#第六章-字符流" class="headerlink" title="第六章 字符流"></a>第六章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>小贴士：</p><ol><li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p><p>idea中UTF-8</p></li><li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p></li></ol></blockquote><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileReaderConstructor</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存数据</span><br>        <span class="hljs-keyword">int</span> b ；<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((b = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println((<span class="hljs-keyword">char</span>)b);<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑<br>马<br>程<br>序<br>员<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p></blockquote><ol start="2"><li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存有效字符个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字符数组，作为装字符数据的容器</span><br>         <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(cbuf));<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑马<br>程序<br>员序<br></code></pre></td></tr></table></figure><p>获取有效的字符改进，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存有效字符个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字符数组，作为装字符数据的容器</span><br>        <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(cbuf,<span class="hljs-number">0</span>,len));<br>        &#125;<br>    <span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>黑马<br>程序<br>员<br></code></pre></td></tr></table></figure><h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf) </code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str) </code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush() </code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。 </li></ul><h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileWriterConstructor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 写出数据</span><br>      fw.write(<span class="hljs-number">97</span>); <span class="hljs-comment">// 写出第1个字符</span><br>      fw.write(<span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">// 写出第2个字符</span><br>      fw.write(<span class="hljs-string">&#x27;C&#x27;</span>); <span class="hljs-comment">// 写出第3个字符</span><br>      fw.write(<span class="hljs-number">30000</span>); <span class="hljs-comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span><br>      <br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        【注意】关闭资源时,与FileOutputStream不同。</span><br><span class="hljs-comment">       如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// fw.close();</span><br>    &#125;<br>&#125;<br>输出结果：<br>abC田<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li></ol></blockquote><h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);<br>        <span class="hljs-comment">// 写出数据，通过flush</span><br>        fw.write(<span class="hljs-string">&#x27;刷&#x27;</span>); <span class="hljs-comment">// 写出第1个字符</span><br>        fw.flush();<br>        fw.write(<span class="hljs-string">&#x27;新&#x27;</span>); <span class="hljs-comment">// 继续写出第2个字符，写出成功</span><br>        fw.flush();<br>      <br>      <span class="hljs-comment">// 写出数据，通过close</span><br>        fw.write(<span class="hljs-string">&#x27;关&#x27;</span>); <span class="hljs-comment">// 写出第1个字符</span><br>        fw.close();<br>        fw.write(<span class="hljs-string">&#x27;闭&#x27;</span>); <span class="hljs-comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol><li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">char</span>[] chars = <span class="hljs-string">&quot;黑马程序员&quot;</span>.toCharArray();<br>      <br>      <span class="hljs-comment">// 写出字符数组</span><br>      fw.write(chars); <span class="hljs-comment">// 黑马程序员</span><br>        <br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span><br>        fw.write(b,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 程序</span><br>      <br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串</span><br>      String msg = <span class="hljs-string">&quot;黑马程序员&quot;</span>;<br>      <br>      <span class="hljs-comment">// 写出字符数组</span><br>      fw.write(msg); <span class="hljs-comment">//黑马程序员</span><br>      <br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span><br>        fw.write(msg,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// 程序</span><br>      <br>        <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象，可以续写数据</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>，<span class="hljs-keyword">true</span>);     <br>      <span class="hljs-comment">// 写出字符串</span><br>        fw.write(<span class="hljs-string">&quot;黑马&quot;</span>);<br>      <span class="hljs-comment">// 写出换行</span><br>      fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>      <span class="hljs-comment">// 写出字符串</span><br>  fw.write(<span class="hljs-string">&quot;程序员&quot;</span>);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fw.close();<br>    &#125;<br>&#125;<br>输出结果:<br>黑马<br>程序员<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p><p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p></blockquote><h1 id="第七章-IO异常的处理"><a href="#第七章-IO异常的处理" class="headerlink" title="第七章 IO异常的处理"></a>第七章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleException1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 声明变量</span><br>        FileWriter fw = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建流对象</span><br>            fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(<span class="hljs-string">&quot;黑马程序员&quot;</span>); <span class="hljs-comment">//黑马程序员</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fw != <span class="hljs-keyword">null</span>) &#123;<br>                    fw.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (创建流对象语句，如果多个,使用<span class="hljs-string">&#x27;;&#x27;</span>隔开) &#123;<br><span class="hljs-comment">// 读写数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleException2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> ( FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>); ) &#123;<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(<span class="hljs-string">&quot;黑马程序员&quot;</span>); <span class="hljs-comment">//黑马程序员</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p><p>改进前格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被final修饰的对象</span><br><span class="hljs-keyword">final</span> Resource resource1 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// 普通对象</span><br>Resource resource2 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource2&quot;</span>);<br><span class="hljs-comment">// 引入方式：创建新的变量保存</span><br><span class="hljs-keyword">try</span> (Resource r1 = resource1;<br>     Resource r2 = resource2) &#123;<br>     <span class="hljs-comment">// 使用对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>改进后格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被final修饰的对象</span><br><span class="hljs-keyword">final</span> Resource resource1 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// 普通对象</span><br>Resource resource2 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource2&quot;</span>);<br><br><span class="hljs-comment">// 引入方式：直接引入</span><br><span class="hljs-keyword">try</span> (resource1; resource2) &#123;<br>     <span class="hljs-comment">// 使用对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>改进后，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">final</span>  FileReader fr  = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;in.txt&quot;</span>);<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;out.txt&quot;</span>);<br>       <span class="hljs-comment">// 引入到try中</span><br>        <span class="hljs-keyword">try</span> (fr; fw) &#123;<br>          <span class="hljs-comment">// 定义变量</span><br>            <span class="hljs-keyword">int</span> b;<br>          <span class="hljs-comment">// 读取数据</span><br>          <span class="hljs-keyword">while</span> ((b = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(b);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第八章-属性集"><a href="#第八章-属性集" class="headerlink" title="第八章 属性集"></a>第八章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public Properties()</code> :创建一个空的属性列表。</li></ul><h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 创建属性集对象</span><br>        Properties properties = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">// 添加键值对元素</span><br>        properties.setProperty(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-string">&quot;a.txt&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;length&quot;</span>, <span class="hljs-string">&quot;209385038&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;location&quot;</span>, <span class="hljs-string">&quot;D:\\a.txt&quot;</span>);<br>        <span class="hljs-comment">// 打印属性集对象</span><br>        System.out.println(properties);<br>        <span class="hljs-comment">// 通过键,获取属性值</span><br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;filename&quot;</span>));<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;length&quot;</span>));<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;location&quot;</span>));<br><br>        <span class="hljs-comment">// 遍历属性集,获取所有键的集合</span><br>        Set&lt;String&gt; strings = properties.stringPropertyNames();<br>        <span class="hljs-comment">// 打印键值对</span><br>        <span class="hljs-keyword">for</span> (String key : strings ) &#123;<br>          System.out.println(key+<span class="hljs-string">&quot; -- &quot;</span>+properties.getProperty(key));<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>&#123;filename=a.txt, length=<span class="hljs-number">209385038</span>, location=D:\a.txt&#125;<br>a.txt<br><span class="hljs-number">209385038</span><br>D:\a.txt<br>filename -- a.txt<br>length -- <span class="hljs-number">209385038</span><br>location -- D:\a.txt<br></code></pre></td></tr></table></figure><h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul><li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li></ul><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">filename</span>=a.txt<br><span class="hljs-attr">length</span>=<span class="hljs-number">209385038</span><br><span class="hljs-attr">location</span>=D:\a.txt<br></code></pre></td></tr></table></figure><p>加载代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 创建属性集对象</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">// 加载文本中信息到属性集</span><br>        pro.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>));<br>        <span class="hljs-comment">// 遍历集合并打印</span><br>        Set&lt;String&gt; strings = pro.stringPropertyNames();<br>        <span class="hljs-keyword">for</span> (String key : strings ) &#123;<br>          System.out.println(key+<span class="hljs-string">&quot; -- &quot;</span>+pro.getProperty(key));<br>        &#125;<br>     &#125;<br>&#125;<br>输出结果：<br>filename -- a.txt<br>length -- <span class="hljs-number">209385038</span><br>location -- D:\a.txt<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote><h1 id="第九章-缓冲流"><a href="#第九章-缓冲流" class="headerlink" title="第九章 缓冲流"></a>第九章 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p><h2 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节缓冲输入流</span><br>BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;bis.txt&quot;</span>));<br><span class="hljs-comment">// 创建字节缓冲输出流</span><br>BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;bos.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p><ol><li>基本流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 记录开始时间</span><br>      <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jdk9.exe&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.exe&quot;</span>)<br>        )&#123;<br>        <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-keyword">int</span> b;<br>            <span class="hljs-keyword">while</span> ((b = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br>十几分钟过去了...<br></code></pre></td></tr></table></figure><ol start="2"><li>缓冲流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 记录开始时间</span><br>      <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jdk9.exe&quot;</span>));<br>     BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.exe&quot;</span>));<br>        )&#123;<br>        <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-keyword">int</span> b;<br>            <span class="hljs-keyword">while</span> ((b = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br>缓冲流复制时间:<span class="hljs-number">8016</span> 毫秒<br></code></pre></td></tr></table></figure><p>如何更快呢？</p><p>使用数组的方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>      <span class="hljs-comment">// 记录开始时间</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jdk9.exe&quot;</span>));<br> BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.exe&quot;</span>));<br>        )&#123;<br>          <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-keyword">int</span> len;<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8</span>*<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span> ((len = bis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(bytes, <span class="hljs-number">0</span> , len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br>缓冲流使用数组复制时间:<span class="hljs-number">666</span> 毫秒<br></code></pre></td></tr></table></figure><h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字符缓冲输入流</span><br>BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;br.txt&quot;</span>));<br><span class="hljs-comment">// 创建字符缓冲输出流</span><br>BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;bw.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><p><code>readLine</code>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">// 创建流对象</span><br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;in.txt&quot;</span>));<br><span class="hljs-comment">// 定义字符串,保存读取的一行文字</span><br>        String line  = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-comment">// 循环读取,读取到最后返回null</span><br>        <span class="hljs-keyword">while</span> ((line = br.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(line);<br>            System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        &#125;<br><span class="hljs-comment">// 释放资源</span><br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>newLine</code>方法演示，代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedWriterDemo</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException  </span>&#123;<br>      <span class="hljs-comment">// 创建流对象</span><br>BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;out.txt&quot;</span>));<br>      <span class="hljs-comment">// 写出数据</span><br>        bw.write(<span class="hljs-string">&quot;黑马&quot;</span>);<br>      <span class="hljs-comment">// 写出换行</span><br>        bw.newLine();<br>        bw.write(<span class="hljs-string">&quot;程序&quot;</span>);<br>        bw.newLine();<br>        bw.write(<span class="hljs-string">&quot;员&quot;</span>);<br>        bw.newLine();<br><span class="hljs-comment">// 释放资源</span><br>        bw.close();<br>    &#125;<br>&#125;<br>输出效果:<br>黑马<br>程序<br>员<br></code></pre></td></tr></table></figure><h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。<br>8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。<br>4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。<br>2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。<br>1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>9.今当远离，临表涕零，不知所言。<br>6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。<br>7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。<br>5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。<br></code></pre></td></tr></table></figure><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>逐行读取文本信息。</li><li>解析文本信息到集合中。</li><li>遍历集合，按顺序，写出文本信息。</li></ol><h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 创建map集合,保存文本数据,键为序号,值为文字</span><br>        HashMap&lt;String, String&gt; lineMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 创建流对象</span><br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;in.txt&quot;</span>));<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;out.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 读取数据</span><br>        String line  = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 解析文本</span><br>            String[] split = line.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>            <span class="hljs-comment">// 保存到集合</span><br>            lineMap.put(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 释放资源</span><br>        br.close();<br><br>        <span class="hljs-comment">// 遍历map集合</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= lineMap.size(); i++) &#123;<br>            String key = String.valueOf(i);<br>            <span class="hljs-comment">// 获取map中文本</span><br>            String value = lineMap.get(key);<br>          <span class="hljs-comment">// 写出拼接文本</span><br>            bw.write(key+<span class="hljs-string">&quot;.&quot;</span>+value);<br>          <span class="hljs-comment">// 写出换行</span><br>            bw.newLine();<br>        &#125;<br><span class="hljs-comment">// 释放资源</span><br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十章-转换流"><a href="#第十章-转换流" class="headerlink" title="第十章 转换流"></a>第十章 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</p><p><img src="/img/cphoto/file03.jpg"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;E:\\File_GBK.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> read;<br>        <span class="hljs-keyword">while</span> ((read = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read);<br>        &#125;<br>        fileReader.close();<br>    &#125;<br>&#125;<br>输出结果：<br>���<br></code></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ </p><h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;in.txt&quot;</span>));<br>InputStreamReader isr2 = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;in.txt&quot;</span>) , <span class="hljs-string">&quot;GBK&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 定义文件路径,文件为gbk编码</span><br>        String FileName = <span class="hljs-string">&quot;E:\\file_gbk.txt&quot;</span>;<br>      <span class="hljs-comment">// 创建流对象,默认UTF8编码</span><br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(FileName));<br>      <span class="hljs-comment">// 创建流对象,指定GBK编码</span><br>        InputStreamReader isr2 = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(FileName) , <span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-comment">// 定义变量,保存字符</span><br>        <span class="hljs-keyword">int</span> read;<br>      <span class="hljs-comment">// 使用默认编码字符流读取,乱码</span><br>        <span class="hljs-keyword">while</span> ((read = isr.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read); <span class="hljs-comment">// ��Һ�</span><br>        &#125;<br>        isr.close();<br>      <br>      <span class="hljs-comment">// 使用指定编码字符流读取,正常解析</span><br>        <span class="hljs-keyword">while</span> ((read = isr2.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read);<span class="hljs-comment">// 大家好</span><br>        &#125;<br>        isr2.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">OutputStreamWriter isr = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;out.txt&quot;</span>));<br>OutputStreamWriter isr2 = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;out.txt&quot;</span>) , <span class="hljs-string">&quot;GBK&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 定义文件路径</span><br>        String FileName = <span class="hljs-string">&quot;E:\\out.txt&quot;</span>;<br>      <span class="hljs-comment">// 创建流对象,默认UTF8编码</span><br>        OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName));<br>        <span class="hljs-comment">// 写出数据</span><br>      osw.write(<span class="hljs-string">&quot;你好&quot;</span>); <span class="hljs-comment">// 保存为6个字节</span><br>        osw.close();<br>      <br><span class="hljs-comment">// 定义文件路径</span><br>String FileName2 = <span class="hljs-string">&quot;E:\\out2.txt&quot;</span>;<br>     <span class="hljs-comment">// 创建流对象,指定GBK编码</span><br>        OutputStreamWriter osw2 = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName2),<span class="hljs-string">&quot;GBK&quot;</span>);<br>        <span class="hljs-comment">// 写出数据</span><br>      osw2.write(<span class="hljs-string">&quot;你好&quot;</span>);<span class="hljs-comment">// 保存为4个字节</span><br>        osw2.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong></p><p><img src="/img/cphoto/file04.jpg"></p><h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>指定GBK编码的转换流，读取文本文件。</li><li>使用UTF-8编码的转换流，写出文本文件。</li></ol><h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <br>    <span class="hljs-comment">// 1.定义文件路径</span><br>     String srcFile = <span class="hljs-string">&quot;file_gbk.txt&quot;</span>;<br>        String destFile = <span class="hljs-string">&quot;file_utf8.txt&quot;</span>;<br><span class="hljs-comment">// 2.创建流对象</span><br>    <span class="hljs-comment">// 2.1 转换输入流,指定GBK编码</span><br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(srcFile) , <span class="hljs-string">&quot;GBK&quot;</span>);<br>    <span class="hljs-comment">// 2.2 转换输出流,默认utf8编码</span><br>        OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(destFile));<br><span class="hljs-comment">// 3.读写数据</span><br>    <span class="hljs-comment">// 3.1 定义数组</span><br>        <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">// 3.2 定义长度</span><br>        <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-comment">// 3.3 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = isr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 循环写出</span><br>          osw.write(cbuf,<span class="hljs-number">0</span>,len);<br>        &#125;<br>    <span class="hljs-comment">// 4.释放资源</span><br>        osw.close();<br>        isr.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十一章-序列化"><a href="#第十一章-序列化" class="headerlink" title="第十一章 序列化"></a>第十一章 序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： </p><p><img src="/img/cphoto/file05.jpg"></p><h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fileOut = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;employee.txt&quot;</span>);<br>ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(fileOut);<br></code></pre></td></tr></table></figure><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><ul><li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String address;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// transient瞬态修饰成员,不会被序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addressCheck</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Address  check : &quot;</span> + name + <span class="hljs-string">&quot; -- &quot;</span> + address);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializeDemo</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span>   </span>&#123;<br>    Employee e = <span class="hljs-keyword">new</span> Employee();<br>    e.name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    e.address = <span class="hljs-string">&quot;beiqinglu&quot;</span>;<br>    e.age = <span class="hljs-number">20</span>; <br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 创建序列化流对象</span><br>          ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;employee.txt&quot;</span>));<br>        <span class="hljs-comment">// 写出对象</span><br>        out.writeObject(e);<br>        <span class="hljs-comment">// 释放资源</span><br>        out.close();<br>        fileOut.close();<br>        System.out.println(<span class="hljs-string">&quot;Serialized data is saved&quot;</span>); <span class="hljs-comment">// 姓名，地址被序列化，年龄没有被序列化。</span><br>        &#125; <span class="hljs-keyword">catch</span>(IOException i)   &#123;<br>            i.printStackTrace();<br>        &#125;<br>   &#125;<br>&#125;<br>输出结果：<br>Serialized data is saved<br></code></pre></td></tr></table></figure><h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h3 id="构造方法-10"><a href="#构造方法-10" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li></ul><h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeserializeDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span>   </span>&#123;<br>        Employee e = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">// 创建反序列化流</span><br>             FileInputStream fileIn = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;employee.txt&quot;</span>);<br>             ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(fileIn);<br>             <span class="hljs-comment">// 读取一个对象</span><br>             e = (Employee) in.readObject();<br>             <span class="hljs-comment">// 释放资源</span><br>             in.close();<br>             fileIn.close();<br>        &#125;<span class="hljs-keyword">catch</span>(IOException i) &#123;<br>             <span class="hljs-comment">// 捕获其他异常</span><br>             i.printStackTrace();<br>             <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException c)  &#123;<br>        <span class="hljs-comment">// 捕获类找不到异常</span><br>             System.out.println(<span class="hljs-string">&quot;Employee class not found&quot;</span>);<br>             c.printStackTrace();<br>             <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 无异常,直接打印输出</span><br>        System.out.println(<span class="hljs-string">&quot;Name: &quot;</span> + e.name);<span class="hljs-comment">// zhangsan</span><br>        System.out.println(<span class="hljs-string">&quot;Address: &quot;</span> + e.address); <span class="hljs-comment">// beiqinglu</span><br>        System.out.println(<span class="hljs-string">&quot;age: &quot;</span> + e.age); <span class="hljs-comment">// 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>     <span class="hljs-comment">// 加入序列版本号</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>     <span class="hljs-keyword">public</span> String name;<br>     <span class="hljs-keyword">public</span> String address;<br>     <span class="hljs-comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> eid; <br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addressCheck</span><span class="hljs-params">()</span> </span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;Address  check : &quot;</span> + name + <span class="hljs-string">&quot; -- &quot;</span> + address);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h3 id="案例实现-3"><a href="#案例实现-3" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 创建 学生对象</span><br>Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;老王&quot;</span>, <span class="hljs-string">&quot;laow&quot;</span>);<br>Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;老张&quot;</span>, <span class="hljs-string">&quot;laoz&quot;</span>);<br>Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;老李&quot;</span>, <span class="hljs-string">&quot;laol&quot;</span>);<br><br>ArrayList&lt;Student&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>arrayList.add(student);<br>arrayList.add(student2);<br>arrayList.add(student3);<br><span class="hljs-comment">// 序列化操作</span><br><span class="hljs-comment">// serializ(arrayList);</span><br><br><span class="hljs-comment">// 反序列化  </span><br>ObjectInputStream ois  = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br><span class="hljs-comment">// 读取对象,强转为ArrayList类型</span><br>ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++ )&#123;<br>          Student s = list.get(i);<br>        System.out.println(s.getName()+<span class="hljs-string">&quot;--&quot;</span>+ s.getPwd());<br>      &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serializ</span><span class="hljs-params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 创建 序列化流 </span><br>ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br><span class="hljs-comment">// 写出对象</span><br>oos.writeObject(arrayList);<br><span class="hljs-comment">// 释放资源</span><br>oos.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十二章-打印流"><a href="#第十二章-打印流" class="headerlink" title="第十二章 打印流"></a>第十二章 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-11"><a href="#构造方法-11" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">&quot;ps.txt&quot;</span>)；<br></code></pre></td></tr></table></figure><h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">// 调用系统的打印流,控制台直接输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>      <br><span class="hljs-comment">// 创建打印流,指定文件的名称</span><br>        PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">&quot;ps.txt&quot;</span>);<br>      <br>      <span class="hljs-comment">// 设置系统的打印流流向,输出到ps.txt</span><br>        System.setOut(ps);<br>      <span class="hljs-comment">// 调用系统的打印流,ps.txt中输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎06-线程</title>
    <link href="/2017/09/17/java%E5%9F%BA%E7%A4%8E06-%E7%BA%BF%E7%A8%8B/"/>
    <url>/2017/09/17/java%E5%9F%BA%E7%A4%8E06-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-线程"><a href="#第一章-线程" class="headerlink" title="第一章 线程"></a>第一章 线程</h1><h2 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1.1 多线程原理"></a>1.1 多线程原理</h2><p>多线程程序的执行流程。<br>代码如下：<br>自定义线程类：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyThread extends Thread&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 利用继承中的特点</span><br><span class="hljs-comment">    * 将线程名称传递 进行设置</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">public</span> MyThread(String <span class="hljs-type">name</span>)&#123;<br>        super(<span class="hljs-type">name</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 重写run方法</span><br><span class="hljs-comment">    * 定义线程要执行的代码</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> run()&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            //getName()方法 来自父亲<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getName()+i);<br>        &#125;<br>    &#125;<br>&#125;<br>=======================================<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;这里是main线程&quot;);<br>MyThread mt = <span class="hljs-built_in">new</span> MyThread(&quot;小强&quot;);<br>mt.<span class="hljs-keyword">start</span>();//开启了一个新的线程<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;旺财:&quot;+i);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/threads01.jpg"></p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。<br>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。<br>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：<br>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p><p><img src="/img/cphoto/threads02.jpg"></p><p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p><h2 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1.2 Thread类"></a>1.2 Thread类</h2><p>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了 java.lang.Thread 类，<br>API中该类中定义了有关线程的一些方法，具体如下：<br>构造方法：</p><ul><li><p>public Thread() :分配一个新的线程对象。</p></li><li><p>public Thread(String name) :分配一个指定名字的新的线程对象。</p></li><li><p>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。</p></li><li><p>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</p></li></ul><p>常用方法：</p><ul><li><p>public String getName() :获取当前线程名称。</p></li><li><p>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</p></li><li><p>  public void run() :此线程要执行的任务在此处定义代码。</p></li><li><p>  public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</p></li><li><p>  public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</p></li></ul><p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。</p><h2 id="1-3-创建线程方式二"><a href="#1-3-创建线程方式二" class="headerlink" title="1.3 创建线程方式二"></a>1.3 创建线程方式二</h2><p>采用 java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。<br>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li><li>调用线程对象的start()方法来启动线程。<br>代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)&#123;<br> System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建自定义类对象 线程任务对象</span><br>        MyRunnable mr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyRunnable</span>();<br>        <span class="hljs-comment">//创建线程对象</span><br>        Thread t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(mr, <span class="hljs-string">&quot;小强&quot;</span>);<br>        t.<span class="hljs-built_in">start</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;旺财 &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。<br>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread<br>对象的start()方法来运行多线程代码。<br>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程<br>编程的基础。<br>tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p><h2 id="1-4-Thread和Runnable的区别"><a href="#1-4-Thread和Runnable的区别" class="headerlink" title="1.4 Thread和Runnable的区别"></a>1.4 Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>适合多个相同的程序代码的线程去共享同一个资源。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li></ol><p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p><h2 id="1-5-匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"><a href="#1-5-匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。" class="headerlink" title="1.5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"></a>1.5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</h2><p>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoNameInnerClassThread</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// new Runnable()&#123;</span><br>        <span class="hljs-comment">// public void run()&#123;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; 20; i++) &#123;</span><br>        <span class="hljs-comment">// System.out.println(&quot;张宇:&quot;+i);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// &#125;; //‐‐‐这个整体 相当于new MyRunnable()</span><br>        Runnable r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>()&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;张宇:&quot;</span>+i);<br>       &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(r).<span class="hljs-built_in">start</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;费玉清:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="第二章-线程安全"><a href="#第二章-线程安全" class="headerlink" title="第二章 线程安全"></a>第二章 线程安全</h1><h2 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2.1 线程安全"></a>2.1 线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>我们通过一个案例，演示线程的安全问题：电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个<br>(本场电影只能卖100张票)。<br>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p><p>模拟票：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Ticket implements Runnable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> ticket = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有票 可以卖</span><br>        <span class="hljs-comment">//出票操作</span><br>        <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>    &#125;<br>        <span class="hljs-comment">//获取当前线程对象的名字</span><br>        String name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(name + <span class="hljs-string">&quot;正在卖:&quot;</span> + ticket‐‐);<br>        &#125;<br>    &#125;<br>    &#125;<br>&#125;<br><br>public <span class="hljs-keyword">class</span> Demo &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">//创建线程任务对象</span><br>        Ticket ticket = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Ticket()</span>;<br>        <span class="hljs-comment">//创建三个窗口对象</span><br>        Thread t1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">ticket</span>, <span class="hljs-string">&quot;窗口1&quot;</span>)</span>;<br>        Thread t2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">ticket</span>, <span class="hljs-string">&quot;窗口2&quot;</span>)</span>;<br>        Thread t3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">ticket</span>, <span class="hljs-string">&quot;窗口3&quot;</span>)</span>;<br>        <span class="hljs-comment">//同时卖票</span><br>        t1.start<span class="hljs-literal">()</span>;<br>        t2.start<span class="hljs-literal">()</span>;<br>        t3.start<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果中有一部分这样现象：</p><p><img src="/img/cphoto/threads03.jpg"></p><p>发现程序出现了两个问题：</p><ol><li><p>相同的票数,比如5这张票被卖了两回。</p></li><li><p>不存在的票，比如0票与-1票，是不存在的。</p></li></ol><p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></blockquote><p>2.2 线程同步<br>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。<br>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。</p><p>根据案例简述</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">窗口<span class="hljs-number">1</span>线程进入操作的时候，窗口<span class="hljs-number">2</span>和窗口<span class="hljs-number">3</span>线程只能在外等着，窗口<span class="hljs-number">1</span>操作结束，窗口<span class="hljs-number">1</span>和窗口<span class="hljs-number">2</span>和窗口<span class="hljs-number">3</span>才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺<span class="hljs-meta">CPU</span>资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。<br><br></code></pre></td></tr></table></figure><p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。<br>那么怎么去使用呢？有三种方式完成同步操作：</p><ol><li>同步代码块。</li><li>同步方法。</li><li>锁机制。</li></ol><h2 id="2-3-同步代码块"><a href="#2-3-同步代码块" class="headerlink" title="2.3 同步代码块"></a>2.3 同步代码块</h2><ul><li>同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(同步锁)</span></span>&#123;<br><span class="hljs-comment">//需要同步操作的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>同步锁</strong>:<br>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p><ol><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。</li></ol><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Ticket implements Runnable&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> ticket = <span class="hljs-number">100</span>;<br>    Object lock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            synchronized (lock) &#123;<br>            <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>                <span class="hljs-comment">//出票操作</span><br>                <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>            <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">50</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取当前线程对象的名字</span><br>            String name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>            &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-同步方法"><a href="#2-4-同步方法" class="headerlink" title="2.4 同步方法"></a>2.4 同步方法</h2><ul><li>同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> synchronized void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">可能会产生线程安全问题的代码</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>       sellTicket();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 锁对象 是 谁调用这个方法 就是谁</span><br><span class="hljs-comment">    * 隐含 锁对象 就是 this</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sellTicket</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>        <span class="hljs-comment">//出票操作</span><br>        <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>       e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//获取当前线程对象的名字</span><br>        String name = Thread.currentThread().getName();<br>        System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-Lock锁"><a href="#2-5-Lock锁" class="headerlink" title="2.5 Lock锁"></a>2.5 Lock锁</h2><p>java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,<br>同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。<br>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li>public void lock() :加同步锁。</li><li>public void unlock() :释放同步锁。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Ticket implements Runnable&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> ticket = <span class="hljs-number">100</span>;<br>    Lock lock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantLock()</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            lock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>            <span class="hljs-comment">//出票操作</span><br>            <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">50</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取当前线程对象的名字</span><br>            String name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>        &#125;<br>    lock.unlock<span class="hljs-literal">()</span>;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="第三章-线程状态"><a href="#第三章-线程状态" class="headerlink" title="第三章 线程状态"></a>第三章 线程状态</h1><p>3.1 线程状态概述<br>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：<br>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。还没调用start方法。</td></tr><tr><td>Runnable(可运行)</td><td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td></tr><tr><td>TimedWaiting(计时等待</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr><tr><td></td><td></td></tr></tbody></table><p>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。</p><h2 id="3-2-Timed-Waiting（计时等待）"><a href="#3-2-Timed-Waiting（计时等待）" class="headerlink" title="3.2 Timed Waiting（计时等待）"></a>3.2 Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？<br>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。<br>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。<br>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i) % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;‐‐‐‐‐‐‐&quot;</span> + i);<br>        &#125;<br>        System.out.<span class="hljs-built_in">print</span>(i);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>            System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; 线程睡眠1秒！\n&quot;</span>);<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>        e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyThread</span>().<span class="hljs-built_in">start</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</li></ol><blockquote><p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p></blockquote><p>Timed Waiting 线程状态图：</p><p><img src="/img/cphoto/threads04.jpg"></p><h2 id="3-3-BLOCKED（锁阻塞）"><a href="#3-3-BLOCKED（锁阻塞）" class="headerlink" title="3.3 BLOCKED（锁阻塞）"></a>3.3 BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。<br>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。<br>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。</p><p><img src="/img/cphoto/threads05.jpg"></p><h2 id="3-4-Waiting（无限等待）"><a href="#3-4-Waiting（无限等待）" class="headerlink" title="3.4 Waiting（无限等待）"></a>3.4 Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来学习一下：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> WaitingTest &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><span class="hljs-comment">// 演示waiting</span><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-keyword">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (obj)&#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;=== 获取到锁对</span><br><span class="hljs-string">象，调用wait方法，进入waiting状态，释放锁对象&quot;</span>);<br>obj.wait(); <span class="hljs-comment">//无限等待</span><br><span class="hljs-comment">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() + <span class="hljs-string">&quot;=== 从waiting状</span><br><span class="hljs-string">态醒来，获取到锁对象，继续执行了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;,<span class="hljs-string">&quot;等待线程&quot;</span>).start();<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-keyword">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>        <span class="hljs-comment">// while (true)&#123; //每隔3秒 唤醒一次</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;‐‐‐‐‐ 等待3秒钟&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>        System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;‐‐‐‐‐ 获取到锁对</span><br><span class="hljs-string">        象,调用notify方法，释放锁对象&quot;</span>);<br>        obj.notify();<br>        &#125;<br>        &#125;<br>        <span class="hljs-comment">// &#125;</span><br>        &#125;,<span class="hljs-string">&quot;唤醒线程&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。<br>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。<br>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了<br>notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。<br>Waiting 线程状态图</p><p><img src="/img/cphoto/threads06.jpg"></p><h2 id="3-5-补充知识点"><a href="#3-5-补充知识点" class="headerlink" title="3.5 补充知识点"></a>3.5 补充知识点</h2><p>到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图：</p><p><img src="/img/cphoto/threads07.jpg"></p><blockquote><p>一条有意思的tips:<br>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p></blockquote><h1 id="第四章-等待唤醒机制"><a href="#第四章-等待唤醒机制" class="headerlink" title="第四章 等待唤醒机制"></a>第四章 等待唤醒机制</h1><h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p><p><img src="/img/cphoto/threada01.jpg"></p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p><p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="hljs-keyword">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="hljs-keyword">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="hljs-keyword">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。<br></code></pre></td></tr></table></figure><p><strong>代码演示：</strong></p><p>包子资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>     String  pier ;<br>     String  xianer ;<br>     <span class="hljs-keyword">boolean</span>  flag = <span class="hljs-keyword">false</span> ;<span class="hljs-comment">//包子资源 是否存在  包子资源状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>吃货线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChiHuo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> BaoZi bz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChiHuo</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (bz)&#123;<br>                <span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">false</span>)&#123;<span class="hljs-comment">//没包子</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        bz.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="hljs-string">&quot;包子&quot;</span>);<br>                bz.flag = <span class="hljs-keyword">false</span>;<br>                bz.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>包子铺线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BaoZi bz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//造包子</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-comment">//同步</span><br>            <span class="hljs-keyword">synchronized</span> (bz)&#123;<br>                <span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">true</span>)&#123;<span class="hljs-comment">//包子资源  存在</span><br>                    <span class="hljs-keyword">try</span> &#123;<br><br>                        bz.wait();<br><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 没有包子  造包子</span><br>                System.out.println(<span class="hljs-string">&quot;包子铺开始做包子&quot;</span>);<br>                <span class="hljs-keyword">if</span>(count%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 冰皮  五仁</span><br>                    bz.pier = <span class="hljs-string">&quot;冰皮&quot;</span>;<br>                    bz.xianer = <span class="hljs-string">&quot;五仁&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 薄皮  牛肉大葱</span><br>                    bz.pier = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>                    bz.xianer = <span class="hljs-string">&quot;牛肉大葱&quot;</span>;<br>                &#125;<br>                count++;<br><br>                bz.flag=<span class="hljs-keyword">true</span>;<br>                System.out.println(<span class="hljs-string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);<br>                System.out.println(<span class="hljs-string">&quot;吃货来吃吧&quot;</span>);<br>                <span class="hljs-comment">//唤醒等待线程 （吃货）</span><br>                bz.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//等待唤醒案例</span><br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>        ChiHuo ch = <span class="hljs-keyword">new</span> ChiHuo(<span class="hljs-string">&quot;吃货&quot;</span>,bz);<br>        BaoZiPu bzp = <span class="hljs-keyword">new</span> BaoZiPu(<span class="hljs-string">&quot;包子铺&quot;</span>,bz);<br><br>        ch.start();<br>        bzp.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">包子铺开始做包子<br>包子造好了：冰皮五仁<br>吃货来吃吧<br>吃货正在吃冰皮五仁包子<br>包子铺开始做包子<br>包子造好了：薄皮牛肉大葱<br>吃货来吃吧<br>吃货正在吃薄皮牛肉大葱包子<br>包子铺开始做包子<br>包子造好了：冰皮五仁<br>吃货来吃吧<br>吃货正在吃冰皮五仁包子<br></code></pre></td></tr></table></figure><h1 id="第五章-线程池"><a href="#第五章-线程池" class="headerlink" title="第五章 线程池"></a>第五章 线程池</h1><h2 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p><h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul><li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p><p><img src="/img/cphoto/threada02.jpg"></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我要一个教练&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程池测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建线程池对象</span><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<span class="hljs-comment">//包含2个线程对象</span><br>        <span class="hljs-comment">// 创建Runnable实例对象</span><br>        MyRunnable r = <span class="hljs-keyword">new</span> MyRunnable();<br><br>        <span class="hljs-comment">//自己创建线程对象的方式</span><br>        <span class="hljs-comment">// Thread t = new Thread(r);</span><br>        <span class="hljs-comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span><br><br>        <span class="hljs-comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span><br>        service.submit(r);<br>        <span class="hljs-comment">// 再获取个线程对象，调用MyRunnable中的run()</span><br>        service.submit(r);<br>        service.submit(r);<br>        <span class="hljs-comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span><br>        <span class="hljs-comment">// 将使用完的线程又归还到了线程池中</span><br>        <span class="hljs-comment">// 关闭线程池</span><br>        <span class="hljs-comment">//service.shutdown();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-Lambda表达式"><a href="#第六章-Lambda表达式" class="headerlink" title="第六章 Lambda表达式"></a>第六章 Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Runnable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 匿名内部类</span><br>Runnable task = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 覆盖重写抽象方法</span><br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;;<br><span class="hljs-keyword">new</span> Thread(task).start(); <span class="hljs-comment">// 启动线程</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02LambdaRunnable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="hljs-comment">// 启动线程</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)<br></code></pre></td></tr></table></figure><p>为了理解Lambda的语义，我们需要从传统的代码起步。</p><h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code></li></ul><p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03ThreadInitParam</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Runnable task = <span class="hljs-keyword">new</span> RunnableImpl();<br><span class="hljs-keyword">new</span> Thread(task).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04ThreadNameless</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p><ul><li><code>public abstract void run();</code></li></ul><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul><h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(参数类型 参数名称)</span> -&gt;</span> &#123; 代码语句 &#125;<br></code></pre></td></tr></table></figure><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cook</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeFood</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05InvokeCook</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeCook</span><span class="hljs-params">(Cook cook)</span> </span>&#123;<br>        cook.makeFood();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    invokeCook(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;吃饭啦！&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p></blockquote><h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">需求:<br>    使用数组存储多个<span class="hljs-keyword">Person</span>对象<br>    对数组中的<span class="hljs-keyword">Person</span>对象使用Arrays的sort方法通过年龄进行升序排序<br></code></pre></td></tr></table></figure><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-comment">// 省略构造器、toString方法与Getter Setter </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06Comparator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 本来年龄乱序的对象数组</span><br>        Person[] array = &#123;<br>        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-number">19</span>),<br>        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">18</span>),<br>       <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;马尔扎哈&quot;</span>, <span class="hljs-number">20</span>) &#125;;<br><br>      <span class="hljs-comment">// 匿名内部类</span><br>        Comparator&lt;Person&gt; comp = <span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>            &#125;<br>        &#125;;<br>        Arrays.sort(array, comp); <span class="hljs-comment">// 第二个参数为排序规则，即Comparator接口实例</span><br><br>        <span class="hljs-keyword">for</span> (Person person : array) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p><ul><li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li><li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li><li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>实际上，<strong>只有参数和方法体才是关键</strong>。</li></ul><h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07ComparatorLambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] array = &#123;<br>          <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-number">19</span>),<br>          <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">18</span>),<br>          <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;马尔扎哈&quot;</span>, <span class="hljs-number">20</span>) &#125;;<br><br>        Arrays.sort(array, (Person a, Person b) -&gt; &#123;<br>          <span class="hljs-keyword">return</span> a.getAge() - b.getAge();<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Person person : array) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08InvokeCalc</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeCalc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, Calculator calculator)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculator.calc(a, b);<br>        System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    invokeCalc(<span class="hljs-number">120</span>, <span class="hljs-number">130</span>, (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; &#123;<br>      <span class="hljs-keyword">return</span> a + b;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p></blockquote><h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  invokeCalc(<span class="hljs-number">120</span>, <span class="hljs-number">130</span>, (a, b) -&gt; a + b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><blockquote><p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p></blockquote><h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09InvokeCook</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeCook</span><span class="hljs-params">(Cook cook)</span> </span>&#123;<br>        cook.makeFood();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  invokeCook(() -&gt; System.out.println(<span class="hljs-string">&quot;吃饭啦！&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎05-数据结构</title>
    <link href="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><img src="/img/cphoto/stack01.jpg" alt="栈图"></p></li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。<ul><li><img src="/img/cphoto/queue01.jpg" alt="队列图"></li></ul></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p> 查找元素快：通过索引，可以快速访问指定位置的元素</p></li><li><p> 增删元素慢</p></li><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。<br><img src="/img/cphoto/arrays01.jpg" alt="队列图"></p></li><li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p></li></ul><p><img src="/img/cphoto/arrays02.jpg" alt="队列图"></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了<br><img src="/img/cphoto/linklist01.jpg" alt="队列图"></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li> 增加元素：只需要修改连接下个元素的地址即可。<br><img src="/img/cphoto/linklist02.jpg" alt="队列图"></li><li>删除元素：只需要修改连接下个元素的地址即可。</li></ul></li><li><p> <img src="/img/cphoto/linklist03.jpg" alt="队列图"></p></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><ul><li> <img src="/img/cphoto/tree01.jpg" alt="队列图"></li></ul><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li>节点可以是红色的或者黑色的</li></ol><ol start="2"><li>根节点是黑色的</li></ol><ol start="3"><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><p>红黑树的特点:</p><p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p><p> <a href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树详细</a></p><h1 id="第七章-List集合"><a href="#第七章-List集合" class="headerlink" title="第七章 List集合"></a>第七章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><blockquote><p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p></blockquote><h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建List集合对象</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <br>    <span class="hljs-comment">// 往 尾部添加 指定元素</span><br>    list.add(<span class="hljs-string">&quot;图图&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;小美&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;不高兴&quot;</span>);<br>    <br>    System.out.println(list);<br>    <span class="hljs-comment">// add(int index,String s) 往指定位置添加</span><br>    list.add(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;没头脑&quot;</span>);<br>    <br>    System.out.println(list);<br>    <span class="hljs-comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span><br>    <span class="hljs-comment">// 删除索引位置为2的元素 </span><br>    System.out.println(<span class="hljs-string">&quot;删除索引位置为2的元素&quot;</span>);<br>    System.out.println(list.remove(<span class="hljs-number">2</span>));<br>    <br>    System.out.println(list);<br>    <br>    <span class="hljs-comment">// String set(int index,String s)</span><br>    <span class="hljs-comment">// 在指定位置 进行 元素替代（改） </span><br>    <span class="hljs-comment">// 修改指定位置元素</span><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;三毛&quot;</span>);<br>    System.out.println(list);<br>    <br>    <span class="hljs-comment">// String get(int index)  获取指定位置元素</span><br>    <br>    <span class="hljs-comment">// 跟size() 方法一起用  来 遍历的 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>    System.out.println(list.get(i));<br>    &#125;<br>    <span class="hljs-comment">//还可以使用增强for</span><br>    <span class="hljs-keyword">for</span> (String string : list) &#123;<br>System.out.println(string);<br>&#125;  <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第八章-List的子类"><a href="#第八章-List的子类" class="headerlink" title="第八章 List的子类"></a>第八章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="/img/cphoto/linkedlist01.jpg"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LinkedList&lt;String&gt; link = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>        <span class="hljs-comment">//添加元素</span><br>        link.addFirst(<span class="hljs-string">&quot;abc1&quot;</span>);<br>        link.addFirst(<span class="hljs-string">&quot;abc2&quot;</span>);<br>        link.addFirst(<span class="hljs-string">&quot;abc3&quot;</span>);<br>        System.out.println(link);<br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(link.getFirst());<br>        System.out.println(link.getLast());<br>        <span class="hljs-comment">// 删除元素</span><br>        System.out.println(link.removeFirst());<br>        System.out.println(link.removeLast());<br><br>        <span class="hljs-keyword">while</span> (!link.isEmpty()) &#123; <span class="hljs-comment">//判断集合是否为空</span><br>            System.out.println(link.pop()); <span class="hljs-comment">//弹出集合中的栈顶元素</span><br>        &#125;<br><br>        System.out.println(link);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSetDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建 Set集合</span><br>        HashSet&lt;String&gt;  set = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br><br>        <span class="hljs-comment">//添加元素</span><br>        set.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;cba&quot;</span>));<br>        set.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;bac&quot;</span>); <br>        set.add(<span class="hljs-string">&quot;cba&quot;</span>);  <br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (String name : set) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下，说明集合中不能存储重复元素：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cba</span><br><span class="hljs-attribute">abc</span><br><span class="hljs-attribute">bac</span><br></code></pre></td></tr></table></figure><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<br><img src="/img/cphoto/hashset01.jpg"></p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="/img/cphoto/linkedlist02.jpg"></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><p>创建自定义Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Student student = (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp;<br>               Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSetDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建集合对象   该集合中存储 Student类型对象</span><br>        HashSet&lt;Student&gt; stuSet = <span class="hljs-keyword">new</span> HashSet&lt;Student&gt;();<br>        <span class="hljs-comment">//存储 </span><br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;于谦&quot;</span>, <span class="hljs-number">43</span>);<br>        stuSet.add(stu);<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-number">44</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;于谦&quot;</span>, <span class="hljs-number">43</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;郭麒麟&quot;</span>, <span class="hljs-number">23</span>));<br>        stuSet.add(stu);<br><br>        <span class="hljs-keyword">for</span> (Student stu2 : stuSet) &#123;<br>            System.out.println(stu2);<br>        &#125;<br>    &#125;<br>&#125;<br>执行结果：<br>Student [name=郭德纲, age=<span class="hljs-number">44</span>]<br>Student [name=于谦, age=<span class="hljs-number">43</span>]<br>Student [name=郭麒麟, age=<span class="hljs-number">23</span>]<br></code></pre></td></tr></table></figure><h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashSetDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;();<br>set.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>set.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>set.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>set.add(<span class="hljs-string">&quot;bbc&quot;</span>);<br>        Iterator&lt;String&gt; it = set.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>System.out.println(it.next());<br>&#125;<br>&#125;<br>&#125;<br>结果：<br>  bbb<br>  aaa<br>  abc<br>  bbc<br></code></pre></td></tr></table></figure><h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">修饰符 返回值类型 方法名(参数类型... 形参名)</span><span class="hljs-template-variable">&#123;  &#125;</span><br></code></pre></td></tr></table></figure><p>其实这个书写完全等价与</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">修饰符 返回值类型 方法名(参数类型<span class="hljs-selector-attr">[]</span> 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeArgs</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">62</span>, <span class="hljs-number">431</span>, <span class="hljs-number">2</span> &#125;;<br>        <span class="hljs-keyword">int</span> sum = getSum(arr);<br>        System.out.println(sum);<br>        <span class="hljs-comment">//  6  7  2 12 2121</span><br>        <span class="hljs-comment">// 求 这几个元素和 6  7  2 12 2121</span><br>        <span class="hljs-keyword">int</span> sum2 = getSum(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2121</span>);<br>        System.out.println(sum2);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 完成数组  所有元素的求和 原始写法</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">      public static int getSum(int[] arr)&#123;</span><br><span class="hljs-comment">        int sum = 0;</span><br><span class="hljs-comment">        for(int a : arr)&#123;</span><br><span class="hljs-comment">            sum += a;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        return sum;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//可变参数写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a : arr) &#123;<br>            sum += a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-comment">//原来写法</span><br>        <span class="hljs-comment">//list.add(12);</span><br>        <span class="hljs-comment">//list.add(14);</span><br>        <span class="hljs-comment">//list.add(15);</span><br>        <span class="hljs-comment">//list.add(1000);</span><br>        <span class="hljs-comment">//采用工具类 完成 往集合中添加元素  </span><br>        Collections.addAll(list, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>，<span class="hljs-number">2</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">//排序方法 </span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br>结果：<br>[<span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>]<br></code></pre></td></tr></table></figure><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt;  list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;cba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;aba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;sba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;nba&quot;</span>);<br>        <span class="hljs-comment">//排序方法</span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[aba, cba, nba, sba]<br></code></pre></td></tr></table></figure><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p>public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; )`方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</T></T></p><ul><li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;cba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;aba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;sba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;nba&quot;</span>);<br>        <span class="hljs-comment">//排序方法  按照第一个单词的降序</span><br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o2.charAt(<span class="hljs-number">0</span>) - o1.charAt(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[sba, nba, cba, aba]<br></code></pre></td></tr></table></figure><h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>               <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>               <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>               <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建四个学生对象 存储到集合中</span><br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br><br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;ace&quot;</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mark&quot;</span>,<span class="hljs-number">16</span>));<br><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          让学生 按照年龄排序 升序</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span><br><br><br>        <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>            System.out.println(student);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br>    ....<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age-o.age;<span class="hljs-comment">//升序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次测试，代码就OK 了效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Student&#123;name=<span class="hljs-string">&#x27;jack&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;abc&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;mark&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;ace&#x27;</span>, age=<span class="hljs-number">17</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;rose&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o2.getAge()-o1.getAge();<span class="hljs-comment">//以学生的年龄降序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ace&#x27;</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mark&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></td></tr></table></figure><p>如果想要规则更多一些，可以参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>                <span class="hljs-comment">// 年龄降序</span><br>                <span class="hljs-keyword">int</span> result = o2.getAge()-o1.getAge();<span class="hljs-comment">//年龄降序</span><br><br>                <span class="hljs-keyword">if</span>(result==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span><br>                    result = o1.getName().charAt(<span class="hljs-number">0</span>)-o2.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ace&#x27;</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mark&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-Map集合"><a href="#第六章-Map集合" class="headerlink" title="第六章 Map集合"></a>第六章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="/img/cphoto/map01.jpg"></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建 map对象</span><br>        HashMap&lt;String, String&gt;  map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br><br>        <span class="hljs-comment">//添加元素到集合</span><br>        map.put(<span class="hljs-string">&quot;黄晓明&quot;</span>, <span class="hljs-string">&quot;杨颖&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;文章&quot;</span>, <span class="hljs-string">&quot;马伊琍&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<br>        System.out.println(map);<br><br>        <span class="hljs-comment">//String remove(String key)</span><br>        System.out.println(map.remove(<span class="hljs-string">&quot;邓超&quot;</span>));<br>        System.out.println(map);<br><br>        <span class="hljs-comment">// 想要查看 黄晓明的媳妇 是谁</span><br>        System.out.println(map.get(<span class="hljs-string">&quot;黄晓明&quot;</span>));<br>        System.out.println(map.get(<span class="hljs-string">&quot;邓超&quot;</span>));    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapDemo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建Map集合对象 </span><br>        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>        <span class="hljs-comment">//添加元素到集合 </span><br>        map.put(<span class="hljs-string">&quot;胡歌&quot;</span>, <span class="hljs-string">&quot;霍建华&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-string">&quot;于谦&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;薛之谦&quot;</span>, <span class="hljs-string">&quot;大张伟&quot;</span>);<br><br>        <span class="hljs-comment">//获取所有的键  获取键集</span><br>        Set&lt;String&gt; keys = map.keySet();<br>        <span class="hljs-comment">// 遍历键集 得到 每一个键</span><br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>          <span class="hljs-comment">//key  就是键</span><br>            <span class="hljs-comment">//获取对应值</span><br>            String value = map.get(key);<br>            System.out.println(key+<span class="hljs-string">&quot;的CP是：&quot;</span>+value);<br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历图解：</p><p><img src="/img/cphoto/map02.jpg"></p><h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p> 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p> 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p> 通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapDemo02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建Map集合对象 </span><br>        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>        <span class="hljs-comment">// 添加元素到集合 </span><br>        map.put(<span class="hljs-string">&quot;胡歌&quot;</span>, <span class="hljs-string">&quot;霍建华&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-string">&quot;于谦&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;薛之谦&quot;</span>, <span class="hljs-string">&quot;大张伟&quot;</span>);<br><br>        <span class="hljs-comment">// 获取 所有的 entry对象  entrySet</span><br>        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();<br><br>        <span class="hljs-comment">// 遍历得到每一个entry对象</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;<br>           <span class="hljs-comment">// 解析 </span><br>            String key = entry.getKey();<br>            String value = entry.getValue();  <br>            System.out.println(key+<span class="hljs-string">&quot;的CP是:&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历图解：</p><p><img src="/img/cphoto/map03.jpg"></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Student student = (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMapTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1,创建Hashmap集合对象。</span><br>        Map&lt;Student,String&gt;map = <span class="hljs-keyword">new</span> HashMap&lt;Student,String&gt;();<br>        <span class="hljs-comment">//2,添加元素。</span><br>        map.put(newStudent(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">28</span>), <span class="hljs-string">&quot;上海&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">22</span>), <span class="hljs-string">&quot;北京&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;zhaoliu&quot;</span>,<span class="hljs-number">24</span>), <span class="hljs-string">&quot;成都&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;zhouqi&quot;</span>,<span class="hljs-number">25</span>), <span class="hljs-string">&quot;广州&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">22</span>), <span class="hljs-string">&quot;南京&quot;</span>);<br>        <br>        <span class="hljs-comment">//3,取出元素。键找值方式</span><br>        Set&lt;Student&gt;keySet = map.keySet();<br>        <span class="hljs-keyword">for</span>(Student key: keySet)&#123;<br>            Stringvalue = map.get(key);<br>            System.out.println(key.toString()+<span class="hljs-string">&quot;.....&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMapDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LinkedHashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;李晨&quot;</span>, <span class="hljs-string">&quot;范冰冰&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-string">&quot;朱丽倩&quot;</span>);<br>        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;  &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">邓超  孙俪<br>李晨  范冰冰<br>刘德华  朱丽倩<br></code></pre></td></tr></table></figure><h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li> 获取一个字符串对象</li><li> 创建一个Map集合，键代表字符，值代表次数。</li><li> 遍历字符串得到每个字符。</li><li> 判断Map中是否有该键。</li><li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li> 打印最终结果</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//友情提示</span><br>        System.out.println(<span class="hljs-string">&quot;请录入一个字符串:&quot;</span>);<br>        String line = <span class="hljs-keyword">new</span> Scanner(System.in).nextLine();<br>        <span class="hljs-comment">// 定义 每个字符出现次数的方法</span><br>        findChar(line);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findChar</span><span class="hljs-params">(String line)</span> </span>&#123;<br>        <span class="hljs-comment">//1:创建一个集合 存储  字符 以及其出现的次数</span><br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        <span class="hljs-comment">//2:遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; line.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = line.charAt(i);<br>            <span class="hljs-comment">//判断 该字符 是否在键集中</span><br>            <span class="hljs-keyword">if</span> (!map.containsKey(c)) &#123;<span class="hljs-comment">//说明这个字符没有出现过</span><br>                <span class="hljs-comment">//那就是第一次</span><br>                map.put(c, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//先获取之前的次数</span><br>                Integer count = map.get(c);<br>                <span class="hljs-comment">//count++;</span><br>                <span class="hljs-comment">//再次存入  更新</span><br>                map.put(c, ++count);<br>            &#125;<br>        &#125;<br>        System.out.println(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第七章-补充知识点"><a href="#第七章-补充知识点" class="headerlink" title="第七章 补充知识点"></a>第七章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;def&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;ghi&quot;</span>);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloJDK9</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        Set&lt;String&gt; str1=Set.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);  <br>        <span class="hljs-comment">//str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span><br>        System.out.println(str1);  <br>        Map&lt;String,Integer&gt; str2=Map.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);  <br>        System.out.println(str2);  <br>        List&lt;String&gt; str3=List.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);  <br>        System.out.println(str3);  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><p>需要注意以下两点：</p><blockquote><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p><p>2:返回的集合是不可变的；</p></blockquote><h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p><ol><li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序     </p><p><img src="/img/cphoto/debug01.jpg"></p></li><li><p>点击Debug运行模式       </p><p><img src="/img/cphoto/debug02.jpg"></p><p>​                                                                                                                                                                      </p></li><li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p><p><img src="/img/cphoto/debug03.jpg"></p></li><li><p>Debug调试窗口介绍</p><p><img src="/img/cphoto/debug04.jpg"></p></li><li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p><p><img src="/img/cphoto/debug05.jpg"></p></li><li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p><p><img src="/img/cphoto/debug04.jpg"></p></li><li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p><p><img src="/img/cphoto/debug07.jpg"></p><p>回车之后效果：</p><p><img src="/img/cphoto/debug08.jpg"></p><p> 调试界面效果：</p><p><img src="/img/cphoto/debug09.jpg"></p></li><li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p><p><img src="/img/cphoto/debug10.jpg"></p></li><li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p><p><img src="/img/cphoto/debug11.jpg"></p></li><li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p><p><img src="/img/cphoto/debug12.jpg"></p></li><li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p><p><img src="/img/cphoto/debug13.jpg"></p></li><li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p><p><img src="/img/cphoto/debug14.jpg"></p></li><li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p><p><img src="/img/cphoto/debug15.jpg"></p></li><li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p><p><img src="/img/cphoto/debug16.jpg"></p></li></ol><h1 id="第八章-模拟斗地主洗牌发牌"><a href="#第八章-模拟斗地主洗牌发牌" class="headerlink" title="第八章  模拟斗地主洗牌发牌"></a>第八章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%96%97%E5%9C%B0%E4%B8%BB.png"></p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol><li> 准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li> 洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li> 发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li> 看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png"></p><h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 1组装54张扑克牌</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 1.1 创建Map集合存储</span><br>        HashMap&lt;Integer, String&gt; pokerMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();<br>        <span class="hljs-comment">// 1.2 创建 花色集合 与 数字集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 1.3 存储 花色 与数字</span><br>        Collections.addAll(colors, <span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        Collections.addAll(numbers, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">// 设置 存储编号变量</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        pokerMap.put(count++, <span class="hljs-string">&quot;大王&quot;</span>);<br>        pokerMap.put(count++, <span class="hljs-string">&quot;小王&quot;</span>);<br>        <span class="hljs-comment">// 1.4 创建牌 存储到map集合中</span><br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                String card = color + number;<br>                pokerMap.put(count++, card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 2 将54张牌顺序打乱</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 取出编号 集合</span><br>        Set&lt;Integer&gt; numberSet = pokerMap.keySet();<br>        <span class="hljs-comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span><br>        ArrayList&lt;Integer&gt; numberList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        numberList.addAll(numberSet);<br><br>        <span class="hljs-comment">// 打乱顺序</span><br>        Collections.shuffle(numberList);<br><br>        <span class="hljs-comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span><br>        <span class="hljs-comment">// 3.1 发牌的编号</span><br>        <span class="hljs-comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span><br>        ArrayList&lt;Integer&gt; noP1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP3 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; dipaiNo = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 3.2发牌的编号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numberList.size(); i++) &#123;<br>            <span class="hljs-comment">// 获取该编号</span><br>            Integer no = numberList.get(i);<br>            <span class="hljs-comment">// 发牌</span><br>            <span class="hljs-comment">// 留出底牌</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">51</span>) &#123;<br>                dipaiNo.add(no);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                    noP1.add(no);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>                    noP2.add(no);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    noP3.add(no);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span><br>        <span class="hljs-comment">// 4.1 对手中编号进行排序</span><br>        Collections.sort(noP1);<br>        Collections.sort(noP2);<br>        Collections.sort(noP3);<br>        Collections.sort(dipaiNo);<br><br>        <span class="hljs-comment">// 4.2 进行牌面的转换</span><br>        <span class="hljs-comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 4.3转换</span><br>        <span class="hljs-keyword">for</span> (Integer i : noP1) &#123;<br>            <span class="hljs-comment">// 4.4 根据编号找到 牌面 pokerMap</span><br>            String card = pokerMap.get(i);<br>            <span class="hljs-comment">// 添加到对应的 牌面集合中</span><br>            player1.add(card);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Integer i : noP2) &#123;<br>            String card = pokerMap.get(i);<br>            player2.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : noP3) &#123;<br>            String card = pokerMap.get(i);<br>            player3.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : dipaiNo) &#123;<br>            String card = pokerMap.get(i);<br>            dipai.add(card);<br>        &#125;<br><br>        <span class="hljs-comment">//4.5 查看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;石破天：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;鸠摩智：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-1-案例介绍-1"><a href="#3-1-案例介绍-1" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/img/cphoto/doudizhu01.jpg"></p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="3-2-案例需求分析-1"><a href="#3-2-案例需求分析-1" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol><li> 准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li> 洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li> 发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li> 看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="/img/cphoto/doudizhu02.jpg"></p><h2 id="3-3-实现代码步骤-1"><a href="#3-3-实现代码步骤-1" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 1组装54张扑克牌</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 1.1 创建Map集合存储</span><br>        HashMap&lt;Integer, String&gt; pokerMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();<br>        <span class="hljs-comment">// 1.2 创建 花色集合 与 数字集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 1.3 存储 花色 与数字</span><br>        Collections.addAll(colors, <span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        Collections.addAll(numbers, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">// 设置 存储编号变量</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        pokerMap.put(count++, <span class="hljs-string">&quot;大王&quot;</span>);<br>        pokerMap.put(count++, <span class="hljs-string">&quot;小王&quot;</span>);<br>        <span class="hljs-comment">// 1.4 创建牌 存储到map集合中</span><br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                String card = color + number;<br>                pokerMap.put(count++, card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 2 将54张牌顺序打乱</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 取出编号 集合</span><br>        Set&lt;Integer&gt; numberSet = pokerMap.keySet();<br>        <span class="hljs-comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span><br>        ArrayList&lt;Integer&gt; numberList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        numberList.addAll(numberSet);<br><br>        <span class="hljs-comment">// 打乱顺序</span><br>        Collections.shuffle(numberList);<br><br>        <span class="hljs-comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span><br>        <span class="hljs-comment">// 3.1 发牌的编号</span><br>        <span class="hljs-comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span><br>        ArrayList&lt;Integer&gt; noP1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP3 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; dipaiNo = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 3.2发牌的编号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numberList.size(); i++) &#123;<br>            <span class="hljs-comment">// 获取该编号</span><br>            Integer no = numberList.get(i);<br>            <span class="hljs-comment">// 发牌</span><br>            <span class="hljs-comment">// 留出底牌</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">51</span>) &#123;<br>                dipaiNo.add(no);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                    noP1.add(no);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>                    noP2.add(no);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    noP3.add(no);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span><br>        <span class="hljs-comment">// 4.1 对手中编号进行排序</span><br>        Collections.sort(noP1);<br>        Collections.sort(noP2);<br>        Collections.sort(noP3);<br>        Collections.sort(dipaiNo);<br><br>        <span class="hljs-comment">// 4.2 进行牌面的转换</span><br>        <span class="hljs-comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 4.3转换</span><br>        <span class="hljs-keyword">for</span> (Integer i : noP1) &#123;<br>            <span class="hljs-comment">// 4.4 根据编号找到 牌面 pokerMap</span><br>            String card = pokerMap.get(i);<br>            <span class="hljs-comment">// 添加到对应的 牌面集合中</span><br>            player1.add(card);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Integer i : noP2) &#123;<br>            String card = pokerMap.get(i);<br>            player2.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : noP3) &#123;<br>            String card = pokerMap.get(i);<br>            player3.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : dipaiNo) &#123;<br>            String card = pokerMap.get(i);<br>            dipai.add(card);<br>        &#125;<br><br>        <span class="hljs-comment">//4.5 查看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;石破天：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;鸠摩智：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章    异常"></a>第九章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="/img/cphoto/throw01.jpg"></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p><p><img src="/img/cphoto/throw02.jpg"></p><h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p> <img src="/img/cphoto/throw03.jpg"></p><h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p> 工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayTools</span> </span>&#123;<br>    <span class="hljs-comment">// 对给定的数组通过给定的角标获取元素。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> element = arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span> &#125;;<br>        intnum = ArrayTools.getElement(arr, <span class="hljs-number">4</span>)<br>        System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序执行过程图解：</p><p> <img src="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png"></p><h1 id="第十章-异常的处理"><a href="#第十章-异常的处理" class="headerlink" title="第十章 异常的处理"></a>第十章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1     抛出异常throw"></a>2.1     抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type"></span>异常类名(参数);<br></code></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;要访问的arr数组不存在&quot;</span>);<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);<br></code></pre></td></tr></table></figure><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个数组 </span><br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-comment">//根据索引找对应的元素 </span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">int</span> element = getElement(arr, index);<br><br>        System.out.println(element);<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 根据 索引找到数组中对应的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> index)</span></span>&#123; <br>       <span class="hljs-comment">//判断  索引是否越界</span><br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length-<span class="hljs-number">1</span>)&#123;<br>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span><br><span class="hljs-comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;哥们，角标越界了~~~&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> element = arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p></blockquote><h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p><ul><li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li></ul><p>查看源码发现这里对为null的进行了抛出异常操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">requireNonNull</span><span class="hljs-params">(T obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">修饰符 返回值类型 方法名(参数) <span class="hljs-keyword">throws</span> 异常类名<span class="hljs-number">1</span>,异常类名<span class="hljs-number">2</span>…&#123;   &#125;<br></code></pre></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span><span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;b.txt&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型  e)&#123;<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意:try和catch都不能单独使用,必须连用。</p></blockquote><p>演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span><br>            read(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<span class="hljs-comment">// 括号中需要定义什么呢？</span><br>          <span class="hljs-comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span><br>            System.out.println(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何获取异常信息：</p><p>Throwable类中定义了一些查看方法:</p><ul><li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li></ul><ul><li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li><li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li></ul><p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p><h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>什么时候的代码必须最终执行？</p><p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意:finally不能单独使用。</p></blockquote><p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p><p>finally代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            <span class="hljs-comment">//抓取到的是编译期异常  抛出去的是运行期 </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p></blockquote><h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul><li><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型A  e)&#123;  当<span class="hljs-keyword">try</span>中出现A类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型B  e)&#123;  当<span class="hljs-keyword">try</span>中出现B类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote></li><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul><h1 id="第十一章-自定义异常"><a href="#第十一章-自定义异常" class="headerlink" title="第十一章 自定义异常"></a>第十一章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p><p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p><p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义异常类.</p><p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li></ol><h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>首先定义一个登陆异常类RegisterException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 业务逻辑异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空参构造</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 表示异常提示</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-comment">// 模拟数据库中已存在账号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] names = &#123;<span class="hljs-string">&quot;bill&quot;</span>,<span class="hljs-string">&quot;hill&quot;</span>,<span class="hljs-string">&quot;jill&quot;</span>&#125;;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     <br>        <span class="hljs-comment">//调用方法</span><br>        <span class="hljs-keyword">try</span>&#123;<br>              <span class="hljs-comment">// 可能出现异常的代码</span><br>            checkUsername(<span class="hljs-string">&quot;nill&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;注册成功&quot;</span>);<span class="hljs-comment">//如果没有异常就是注册成功</span><br>        &#125;<span class="hljs-keyword">catch</span>(RegisterException e)&#123;<br>            <span class="hljs-comment">//处理异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断当前注册账号是否存在</span><br>    <span class="hljs-comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkUsername</span><span class="hljs-params">(String uname)</span> <span class="hljs-keyword">throws</span> LoginException</span>&#123;<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-keyword">if</span>(name.equals(uname))&#123;<span class="hljs-comment">//如果名字在这里面 就抛出登陆异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RegisterException(<span class="hljs-string">&quot;亲&quot;</span>+name+<span class="hljs-string">&quot;已经被注册了！&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十二章-多线程"><a href="#第十二章-多线程" class="headerlink" title="第十二章 多线程"></a>第十二章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p><p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p><h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src="/img/cphoto/thread01.jpg"></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p></li></ul><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src="/img/cphoto/thread02.jpg"></p><p><strong>线程</strong></p><p><img src="/img/cphoto/thread03.jpg"></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p><img src="/img/cphoto/thread04.jpg"></p><ul><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p><p><img src="/img/cphoto/thread05.jpg"></p></li></ul></li></ul><h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建自定义线程对象</span><br>MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;新的线程！&quot;</span>);<br><span class="hljs-comment">//开启新线程</span><br>mt.start();<br><span class="hljs-comment">//在主方法中执行for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;main线程！&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-comment">//定义指定线程名称的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-comment">//调用父类的String参数的构造方法，指定线程的名称</span><br><span class="hljs-keyword">super</span>(name);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重写run方法，完成该线程执行的逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>System.out.println(getName()+<span class="hljs-string">&quot;：正在执行！&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础04-Collection泛型</title>
    <link href="/2017/09/11/java%E5%9F%BA%E7%A1%8004-Collection%E6%B3%9B%E5%9E%8B/"/>
    <url>/2017/09/11/java%E5%9F%BA%E7%A1%8004-Collection%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-泛型"><a href="#第一章-泛型" class="headerlink" title="第一章 泛型"></a>第一章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>Iterator it = coll.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br><span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>String str = (String) it.next();<br>System.out.println(str.length());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        <span class="hljs-comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span><br>        <span class="hljs-comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String str = it.next();<br>            <span class="hljs-comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span><br>            System.out.println(str.length());<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></code></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123; &#125;<br>   ....<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">MVP</span>&gt; </span>&#123;<br><span class="hljs-comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br><span class="hljs-keyword">private</span> MVP mvp;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMVP</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mvp = mvp;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MVP <span class="hljs-title">getMVP</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericClassDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>         <span class="hljs-comment">// 创建一个泛型为String的类</span><br>         MyGenericClass&lt;String&gt; my = <span class="hljs-keyword">new</span> MyGenericClass&lt;String&gt;();    <br>         <span class="hljs-comment">// 调用setMVP</span><br>         my.setMVP(<span class="hljs-string">&quot;大胡子登登&quot;</span>);<br>         <span class="hljs-comment">// 调用getMVP</span><br>         String mvp = my.getMVP();<br>         System.out.println(mvp);<br>         <span class="hljs-comment">//创建一个泛型为Integer的类</span><br>         MyGenericClass&lt;Integer&gt; my2 = <span class="hljs-keyword">new</span> MyGenericClass&lt;Integer&gt;(); <br>         my2.setMVP(<span class="hljs-number">123</span>);     <br>         Integer mvp2 = my2.getMVP();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">修饰符 <span class="hljs-attribute">&lt;代表泛型的变量&gt;</span> 返回值类型 方法名(参数)&#123;  &#125;<br></code></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethod</span> </span>&#123;  <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>    System.out.println(mvp.getClass());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function">MVP <span class="hljs-title">show2</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        MyGenericMethod mm = <span class="hljs-keyword">new</span> MyGenericMethod();<br>        <span class="hljs-comment">// 演示看方法提示</span><br>        mm.show(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        mm.show(<span class="hljs-number">123</span>);<br>        mm.show(<span class="hljs-number">12.45</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;<br></code></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span></span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;<br>        <span class="hljs-comment">// 省略...</span><br>    &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp2</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-comment">// 省略...</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyImp2&lt;String&gt;  my = <span class="hljs-keyword">new</span> MyImp2&lt;String&gt;();  <br>        my.add(<span class="hljs-string">&quot;aa&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Intger&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list1);<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    getElement(list2);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">//？代表可以接收任意类型</span><br></code></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</String></Object></p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-Collection集合"><a href="#第二章-Collection集合" class="headerlink" title="第二章 Collection集合"></a>第二章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</E></p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1Collection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建集合对象 </span><br>    <span class="hljs-comment">// 使用多态形式</span><br>    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-comment">// 使用方法</span><br>    <span class="hljs-comment">// 添加功能  boolean  add(String s)</span><br>    coll.add(<span class="hljs-string">&quot;小李广&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;扫地僧&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;石破天&quot;</span>);<br>    System.out.println(coll);<br><br>    <span class="hljs-comment">// boolean contains(E e) 判断o是否在集合中存在</span><br>    System.out.println(<span class="hljs-string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="hljs-string">&quot;扫地僧&quot;</span>));<br><br>    <span class="hljs-comment">//boolean remove(E e) 删除在集合中的o元素</span><br>    System.out.println(<span class="hljs-string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="hljs-string">&quot;石破天&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作之后集合中元素:&quot;</span>+coll);<br>    <br>    <span class="hljs-comment">// size() 集合中有几个元素</span><br>System.out.println(<span class="hljs-string">&quot;集合中有&quot;</span>+coll.size()+<span class="hljs-string">&quot;个元素&quot;</span>);<br><br><span class="hljs-comment">// Object[] toArray()转换成一个Object数组</span><br>    Object[] objects = coll.toArray();<br>    <span class="hljs-comment">// 遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;<br>System.out.println(objects[i]);<br>&#125;<br><br><span class="hljs-comment">// void  clear() 清空集合</span><br>coll.clear();<br>System.out.println(<span class="hljs-string">&quot;集合中内容为：&quot;</span>+coll);<br><span class="hljs-comment">// boolean  isEmpty()  判断是否为空</span><br>System.out.println(coll.isEmpty());  <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h1 id="第三章-Iterator迭代器"><a href="#第三章-Iterator迭代器" class="headerlink" title="第三章 Iterator迭代器"></a>第三章 Iterator迭代器</h1><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用多态方式 创建对象</span><br>        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 添加元素到集合</span><br>        coll.add(<span class="hljs-string">&quot;串串星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;吐槽星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;汪星人&quot;</span>);<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span><br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-comment">//  泛型指的是 迭代出 元素的数据类型</span><br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123; <span class="hljs-comment">//判断是否有迭代元素</span><br>            String s = it.next();<span class="hljs-comment">//获取迭代出的元素</span><br>            System.out.println(s);<br>        &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; <br>  <span class="hljs-comment">//写操作代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBForDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">87</span>&#125;;<br>       <span class="hljs-comment">//使用增强for遍历数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr)&#123;<span class="hljs-comment">//a代表数组中的每个元素</span><br>System.out.println(a);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBFor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <br>    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    coll.add(<span class="hljs-string">&quot;小河神&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;老河神&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;神婆&quot;</span>);<br>    <span class="hljs-comment">//使用增强for遍历</span><br>    <span class="hljs-keyword">for</span>(String s :coll)&#123;<span class="hljs-comment">//接收变量s代表 代表被遍历到的集合元素</span><br>    System.out.println(s);<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</String></p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p></li></ul><ul><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 1: 准备牌操作</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//1.1 创建牌盒 将来存储牌面的 </span><br>        ArrayList&lt;String&gt; pokerBox = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        <span class="hljs-comment">//1.2 创建花色集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.3 创建数字集合</span><br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.4 分别给花色 以及 数字集合添加元素</span><br>        colors.add(<span class="hljs-string">&quot;♥&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♦&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♠&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♣&quot;</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>            numbers.add(i+<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        numbers.add(<span class="hljs-string">&quot;J&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;Q&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;K&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-comment">//1.5 创造牌  拼接牌操作</span><br>        <span class="hljs-comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span><br>        <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>            <span class="hljs-comment">//color每一个花色 </span><br>            <span class="hljs-comment">//遍历数字集合</span><br>            <span class="hljs-keyword">for</span>(String number : numbers)&#123;<br>                <span class="hljs-comment">//结合</span><br>                String card = color+number;<br>                <span class="hljs-comment">//存储到牌盒中</span><br>                pokerBox.add(card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//1.6大王小王</span><br>        pokerBox.add(<span class="hljs-string">&quot;小☺&quot;</span>);<br>        pokerBox.add(<span class="hljs-string">&quot;大☠&quot;</span>);  <br>        <span class="hljs-comment">// System.out.println(pokerBox);</span><br>        <span class="hljs-comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span><br>        <span class="hljs-comment">// Collections类  工具类  都是 静态方法</span><br>        <span class="hljs-comment">// shuffer方法   </span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * static void shuffle(List&lt;?&gt; list) </span><br><span class="hljs-comment">         *     使用默认随机源对指定列表进行置换。 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//2:洗牌</span><br>        Collections.shuffle(pokerBox);<br>        <span class="hljs-comment">//3 发牌</span><br>        <span class="hljs-comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br><br>        <span class="hljs-comment">//遍历 牌盒  必须知道索引   </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;pokerBox.size();i++)&#123;<br>            <span class="hljs-comment">//获取 牌面</span><br>            String card = pokerBox.get(i);<br>            <span class="hljs-comment">//留出三张底牌 存到 底牌集合中</span><br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">51</span>)&#123;<span class="hljs-comment">//存到底牌集合中</span><br>                dipai.add(card);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//玩家1   %3  ==0</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                  player1.add(card);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//玩家2</span><br>                  player2.add(card);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//玩家3</span><br>                  player3.add(card);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//看看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;田伯光：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;绿竹翁：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);  <br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础03-Object类</title>
    <link href="/2017/09/07/java%E5%9F%BA%E7%A4%8E03/"/>
    <url>/2017/09/07/java%E5%9F%BA%E7%A4%8E03/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> /*<span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span>*/ </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> + <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 省略构造器与Getter Setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。</p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果对象地址一样，则认为相同</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 如果参数为空，或者类型信息不一样，则认为不同</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 转换为当前类型</span><br>        Person person = (Person) o;<br>        <span class="hljs-comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成</p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Date</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建日期对象，把当前的时间</span><br>        System.out.println(<span class="hljs-keyword">new</span> Date()); <span class="hljs-comment">// Tue Jan 16 14:37:35 CST 2018</span><br>        <span class="hljs-comment">// 创建日期对象，把当前的毫秒值转成日期对象</span><br>        System.out.println(<span class="hljs-keyword">new</span> Date(<span class="hljs-number">0L</span>)); <span class="hljs-comment">// Thu Jan 01 08:00:00 CST 1970</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02SimpleDateFormat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 对应的日期格式如：2018-01-16 15:06:38</span><br>        DateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把Date对象转换成String</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03DateFormatMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        <span class="hljs-comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span><br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        String str = df.format(date);<br>        System.out.println(str); <span class="hljs-comment">// 2008年1月23日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把String转换成Date对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04DateFormatMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        String str = <span class="hljs-string">&quot;2018年12月11日&quot;</span>;<br>        Date date = df.parse(str);<br>        System.out.println(date); <span class="hljs-comment">// Tue Dec 11 00:00:00 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06CalendarInit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalendarUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建Calendar对象</span><br>        Calendar cal = Calendar.getInstance();<br>        <span class="hljs-comment">// 设置年 </span><br>        <span class="hljs-keyword">int</span> year = cal.get(Calendar.YEAR);<br>        <span class="hljs-comment">// 设置月</span><br>        <span class="hljs-keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 设置日</span><br>        <span class="hljs-keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        cal.set(Calendar.YEAR, <span class="hljs-number">2020</span>);<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2020年1月17日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2018年1月17日</span><br>        <span class="hljs-comment">// 使用add方法</span><br>        cal.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">2</span>); <span class="hljs-comment">// 加2天</span><br>        cal.add(Calendar.YEAR, -<span class="hljs-number">3</span>); <span class="hljs-comment">// 减3年</span><br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2015年1月18日; </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        Date date = cal.getTime();<br>        System.out.println(date); <span class="hljs-comment">// Tue Jan 16 16:03:09 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">//获取当前时间毫秒值</span><br>        System.out.println(System.currentTimeMillis()); <span class="hljs-comment">// 1516090531144</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTest1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;共耗时毫秒：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11SystemArrayCopy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] src = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>        System.arraycopy( src, <span class="hljs-number">0</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">/*代码运行后：两个数组中的元素发生了变化</span><br><span class="hljs-comment">         src数组元素[1,2,3,4,5]</span><br><span class="hljs-comment">         dest数组元素[1,2,3,9,10]</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        s += <span class="hljs-string">&quot;World&quot;</span>;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。(默认16字符空间，超过自动扩充)</p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuilder sb1 = <span class="hljs-keyword">new</span> StringBuilder();<br>        System.out.println(sb1); <span class="hljs-comment">// (空白)</span><br>        <span class="hljs-comment">// 使用带参构造</span><br>        StringBuilder sb2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        System.out.println(sb2); <span class="hljs-comment">// itcast</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02StringBuilder</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建对象</span><br>StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-comment">//public StringBuilder append(任意类型)</span><br>StringBuilder builder2 = builder.append(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">//对比一下</span><br>System.out.println(<span class="hljs-string">&quot;builder:&quot;</span>+builder);<br>System.out.println(<span class="hljs-string">&quot;builder2:&quot;</span>+builder2);<br>System.out.println(builder == builder2); <span class="hljs-comment">//true</span><br>    <span class="hljs-comment">// 可以添加 任何类型</span><br>builder.append(<span class="hljs-string">&quot;hello&quot;</span>);<br>builder.append(<span class="hljs-string">&quot;world&quot;</span>);<br>builder.append(<span class="hljs-keyword">true</span>);<br>builder.append(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span><br>        <span class="hljs-comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span><br><span class="hljs-comment">//链式编程</span><br>builder.append(<span class="hljs-string">&quot;hello&quot;</span>).append(<span class="hljs-string">&quot;world&quot;</span>).append(<span class="hljs-keyword">true</span>).append(<span class="hljs-number">100</span>);<br>System.out.println(<span class="hljs-string">&quot;builder:&quot;</span>+builder);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16StringBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 链式创建</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>).append(<span class="hljs-string">&quot;World&quot;</span>).append(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-comment">// 调用方法</span><br>        String str = sb.toString();<br>        System.out.println(str); <span class="hljs-comment">// HelloWorldJava</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure><h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure><h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">基本类型直接与””相连接即可；如：<span class="hljs-number">34</span>+<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>String转换成对应的基本类型 </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo18WrapperParse</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num = Integer.parseInt(<span class="hljs-string">&quot;100&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎02-面向对象</title>
    <link href="/2017/09/03/java%E5%9F%BA%E7%A4%8E02/"/>
    <url>/2017/09/03/java%E5%9F%BA%E7%A4%8E02/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述类事物。<br>属性：就是该事物的状态信息。<br>行为：就是该事物能够做什么。<br>对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为</p><h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><p>类是对一类事物的描述，是抽象的。<br>对象是一类事物的实例，是具体的。<br>类是对象的模板，对象是类的实体。</p><h2 id="对象的使用格式"><a href="#对象的使用格式" class="headerlink" title="对象的使用格式"></a>对象的使用格式</h2><p>创建对象：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">类名 对象名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>类名();<br></code></pre></td></tr></table></figure><p>使用对象访问类中的成员:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">对象名.成员变量；<br>对象名.成员方法<span class="hljs-comment">()</span>；<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/object01.jpg" alt="对象内存图"></p><h2 id="两个对象，调用同一方法内存图"><a href="#两个对象，调用同一方法内存图" class="headerlink" title="两个对象，调用同一方法内存图"></a>两个对象，调用同一方法内存图</h2><p><img src="/img/cphoto/obj02.jpg" alt="对象内存图"></p><h2 id="一个引用，作为参数传递到方法中内存图"><a href="#一个引用，作为参数传递到方法中内存图" class="headerlink" title="一个引用，作为参数传递到方法中内存图"></a>一个引用，作为参数传递到方法中内存图</h2><p><img src="/img/cphoto/obj03.jpg" alt="对象内存图"></p><h2 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h2><p>在类中的位置不同 重点</p><ul><li>成员变量：类中，方法外<br>局部变量：方法中或者方法声明上(形式参数)</li></ul><p>作用范围不一样 重点</p><ul><li>成员变量：类中<br>局部变量：方法中</li></ul><p>初始化值的不同 重点</p><ul><li>成员变量：有默认值<br>局部变量：没有默认值。必须先定义，赋值，最后使用</li></ul><p>在内存中的位置不同 了解</p><ul><li>成员变量：堆内存<br>局部变量：栈内存</li></ul><p>生命周期不同 了解</p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li></ul><h2 id="封装概述"><a href="#封装概述" class="headerlink" title="封装概述"></a>封装概述</h2><p>将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</p><h2 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a>封装步骤</h2><p>使用 private 关键字来修饰成员变量。</p><p>对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。</p><h2 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h2><ol><li>private是一个权限修饰符，代表最小权限。</li><li>可以修饰成员变量和成员方法。</li><li>被private修饰后的成员变量和成员方法，只在本类中才能访问。</li></ol><p>private的使用格式</p><p>private 数据类型 变量名 ；</p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>his代表所在类的当前对象的引用（地址值），即对象自己的引用。<br>记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">修饰符 构造方法名(参数列表)&#123;<br><span class="hljs-regexp">//</span> 方法体<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> &#123;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-comment">// 无参数构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-comment">// 有参数构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name,<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">public class ClassName&#123;<br><span class="hljs-regexp">//</span>成员变量<br><span class="hljs-regexp">//</span>构造方法<br><span class="hljs-regexp">//</span>无参构造方法【必须】<br><span class="hljs-regexp">//</span>有参构造方法【建议】<br><span class="hljs-regexp">//</span>成员方法<br><span class="hljs-regexp">//g</span>etXxx()<br><span class="hljs-regexp">//</span>setXxx()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Scanner sc = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br><span class="hljs-built_in">int</span> i = sc.next<span class="hljs-constructor">Int()</span>;<br></code></pre></td></tr></table></figure><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。<br>匿名对象 ：没有变量名的对象</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type"></span>类名(参数列表)；<br></code></pre></td></tr></table></figure><p>一个匿名对象，只能使用一次</p><p>一旦调用两次方法，就是创建了两个对象，造成浪费，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br><span class="hljs-comment">// 普通方式</span><br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>input(sc);<br><span class="hljs-comment">//匿名对象作为方法接收的参数</span><br>input(<span class="hljs-keyword">new</span> Scanner(System.in));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">input</span>(<span class="hljs-params">Scanner sc</span>)</span>&#123;<br>System.out.println(sc);<br>&#125;<br></code></pre></td></tr></table></figure><p>作为返回值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">ass Test2 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br><span class="hljs-comment">// 普通方式</span><br>Scanner sc = getScanner();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Scanner <span class="hljs-function"><span class="hljs-title">getScanner</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//普通方式</span><br><span class="hljs-comment">//Scanner sc = new Scanner(System.in);</span><br><span class="hljs-comment">//return sc;</span><br><span class="hljs-comment">//匿名对象作为方法返回值</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Scanner(System.in);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>用于生成伪随机数</p><p>创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Random r = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;<br><span class="hljs-built_in">int</span> i = r.next<span class="hljs-constructor">Int()</span>;<br></code></pre></td></tr></table></figure><p>获取1-n之间的随机数，包含n</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> n = <span class="hljs-number">50</span>;<br><span class="hljs-comment">// 创建对象</span><br>Random r = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;<br><span class="hljs-comment">// 获取随机数</span><br><span class="hljs-built_in">int</span> number = r.next<span class="hljs-constructor">Int(<span class="hljs-params">n</span>)</span> + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 输出随机数</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;number:&quot;</span> + number);<br><br></code></pre></td></tr></table></figure><h2 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h2><p>存储对象数据,如果是对象数组,而数组的长度是固定的，无法适应数据变化的需<br>求,为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据</p><p>java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。</p><p>java.util.ArrayList <E> ：该类需要 import导入使后使用。<br><E> ，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。如ArrayList<String>，ArrayList<Student></Student></String></E></E></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ArrayList&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br><span class="hljs-comment">//在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写</span><br>ArrayList&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>对于元素的操作,基本体现在——增、删、查。常用的方法有：<br>public boolean add(E e) ：将指定的元素添加到此集合的尾部。<br>public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。<br>public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。<br>public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</p><h2 id="ArrayList对象只能存储基本数据类型的包装类"><a href="#ArrayList对象只能存储基本数据类型的包装类" class="headerlink" title="ArrayList对象只能存储基本数据类型的包装类"></a>ArrayList对象只能存储基本数据类型的包装类</h2><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 <int> 不能写，但是存储基本数据类型对应的<br>包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写</int></p><table><thead><tr><th>基本类型</th><th>基本类型包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>只有 Integer 和 Character 需要特殊记忆，其他基本类型只是首字母大写即可。</p><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>字符串不变：字符串的值在创建后不能被更改。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>s1 += <span class="hljs-string">&quot;d&quot;</span>;<br>System.out.println(s1); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-regexp">//</span> 内存中有<span class="hljs-string">&quot;abc&quot;</span>，<span class="hljs-string">&quot;abcd&quot;</span>两个对象，s1从指向<span class="hljs-string">&quot;abc&quot;</span>，改变指向，指向了<span class="hljs-string">&quot;abcd&quot;</span>。<br></code></pre></td></tr></table></figure><p>因为String对象是不可变的，所以它们可以被共享。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String s1 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>String s2 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>// 内存中只有一个<span class="hljs-string">&quot;abc&quot;</span>对象被创建，同时被s1和s2共享。<br></code></pre></td></tr></table></figure><p>“abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing">例如：<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br>相当于：<br><span class="hljs-built_in">char</span> data[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(data);<br><span class="hljs-comment">// String底层是靠字符数组实现的。</span><br><br></code></pre></td></tr></table></figure><h2 id="String构造方法"><a href="#String构造方法" class="headerlink" title="String构造方法"></a>String构造方法</h2><ul><li>public String() ：初始化新创建的 String对象，以使其表示空字符序列。</li><li>public String(char[] value) ：通过当前参数中的字符数组来构造新的String。</li><li>public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 无参构造</span><br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>（）；<br><span class="hljs-comment">// 通过字符数组构造</span><br><span class="hljs-built_in">char</span> chars[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(chars);<br><span class="hljs-comment">// 通过字节数组构造</span><br><span class="hljs-built_in">byte</span> bytes[] = &#123; <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span> &#125;;<br><span class="hljs-keyword">String</span> str3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(bytes);<br></code></pre></td></tr></table></figure><h2 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h2><ul><li>public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。</li><li>public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 创建字符串对象</span><br>String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;hello&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;HELLO&quot;</span>;<br><span class="hljs-comment">// boolean equals(Object obj):比较字符串的内容是否相同</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals(s3)); <span class="hljs-comment">// false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-params">s2</span>)</span>); <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-params">s3</span>)</span>); <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="String功能的方法"><a href="#String功能的方法" class="headerlink" title="String功能的方法"></a>String功能的方法</h2><ul><li><p>public int length () ：返回此字符串的长度。</p></li><li><p>public String concat (String str) ：将指定的字符串连接到该字符串的末尾。</p></li><li><p>public char charAt (int index) ：返回指定索引处的 char值。</p></li><li><p>public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。</p></li><li><p>public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</p></li><li><p>public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</p></li></ul>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//创建字符串对象<br>String s = &quot;helloworld&quot;;<br>// <span class="hljs-type">int</span> length():获取字符串的长度，其实也就是字符个数<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.length());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// String concat (String str):将将指定的字符串连接到该字符串的末尾.<br>String s = &quot;helloworld&quot;;<br>String s2 = s.concat(&quot;**hello clyde&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s2);// helloworld**hello clyde<br><br>// <span class="hljs-type">char</span> charAt(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>):获取指定索引处的字符<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.charAt(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.charAt(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// <span class="hljs-type">int</span> indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐<span class="hljs-number">1</span><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.indexOf(&quot;l&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.indexOf(&quot;owo&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.indexOf(&quot;ld&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// String substring(<span class="hljs-type">int</span> <span class="hljs-keyword">start</span>):从<span class="hljs-keyword">start</span>开始截取字符串到字符串结尾<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">5</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// String substring(<span class="hljs-type">int</span> <span class="hljs-keyword">start</span>,<span class="hljs-type">int</span> <span class="hljs-keyword">end</span>):从<span class="hljs-keyword">start</span>到<span class="hljs-keyword">end</span>截取字符串。含<span class="hljs-keyword">start</span>，不含<span class="hljs-keyword">end</span>。<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">0</span>, s.length()));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>));<br></code></pre></td></tr></table></figure><h2 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h2><ul><li>public char[] toCharArray () ：将此字符串转换为新的字符数组。</li><li>public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li><li>public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//创建字符串对象</span><br>String s = <span class="hljs-string">&quot;abcde&quot;</span>;<br><span class="hljs-comment">// char[] toCharArray():把字符串转换为字符数组</span><br><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> chs = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; chs.length; x++) &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(chs<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>);<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// byte[] getBytes ():把字符串转换为字节数组</span><br>byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = s.get<span class="hljs-constructor">Bytes()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-built_in">bytes</span>.length; x++) &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-built_in">bytes</span><span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>);<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// 替换字母hel为大写HEL</span><br>String str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>String replace = str.replace(<span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;HEL&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(replace); <span class="hljs-comment">// HELlo world</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="分割功能的方法"><a href="#分割功能的方法" class="headerlink" title="分割功能的方法"></a>分割功能的方法</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas">//创建字符串对象<br>String s = <span class="hljs-string">&quot;aa|bb|cc&quot;</span>;<br>String[] strArray = s.split(<span class="hljs-string">&quot;|&quot;</span>); // [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;cc&quot;</span>]<br>for(int <span class="hljs-meta">x</span> = 0; <span class="hljs-meta">x</span> &lt; strArray.<span class="hljs-meta">length</span>; <span class="hljs-meta">x</span>++) &#123;<br>System.<span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span>strArray[<span class="hljs-meta">x</span>]); // aa bb cc<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>定义一个方法，把数组{1,2,3}按照指定个格式拼接成一个字符串。格式参照如下：[word1#word2#word3]</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个int类型的数组</span><br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-comment">//调用方法</span><br>    <span class="hljs-keyword">String</span> s = <span class="hljs-built_in">arrayToString</span>(arr);<br>    <span class="hljs-comment">//输出结果</span><br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;s:&quot;</span> + s);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 写方法实现把数组中的元素按照指定的格式拼接成一个字符串</span><br><span class="hljs-comment">* 两个明确：</span><br><span class="hljs-comment">* 返回值类型：String</span><br><span class="hljs-comment">* 参数列表：int[] arr</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">arrayToString</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建字符串s</span><br>    <span class="hljs-keyword">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;[&quot;</span>);<br>    <span class="hljs-comment">// 遍历数组，并拼接字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; arr.length; x++) &#123;<br>        <span class="hljs-keyword">if</span> (x == arr.length ‐ <span class="hljs-number">1</span>) &#123;<br>             s = s.<span class="hljs-built_in">concat</span>(arr[x] + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>             s = s.<span class="hljs-built_in">concat</span>(arr[x] + <span class="hljs-string">&quot;#&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="统计字符个数"><a href="#统计字符个数" class="headerlink" title="统计字符个数"></a>统计字符个数</h2><p>键盘录入一个字符，统计字符串中大小写字母及数字字符个数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//键盘录入一个字符串数据</span><br>Scanner sc = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;请输入一个字符串数据：&quot;</span>);<br>String s = sc.next<span class="hljs-constructor">Line()</span>;<br><span class="hljs-comment">//定义三个统计变量，初始化值都是0</span><br><span class="hljs-built_in">int</span> bigCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> smallCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> numberCount = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//遍历字符串，得到每一个字符</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>; x&lt;s.length<span class="hljs-literal">()</span>; x++) &#123;<br>    <span class="hljs-built_in">char</span> ch = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">x</span>)</span>;<br>    <span class="hljs-comment">//拿字符进行判断</span><br>    <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-character">&#x27;A&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-character">&#x27;Z&#x27;</span>) &#123;<br>        bigCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-character">&#x27;a&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-character">&#x27;z&#x27;</span>) &#123;<br>        smallCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-character">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-character">&#x27;9&#x27;</span>) &#123;<br>        numberCount++;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;该字符&quot;</span>+ch+<span class="hljs-string">&quot;非法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;大写字符：&quot;</span>+bigCount+<span class="hljs-string">&quot;个&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;小写字符：&quot;</span>+smallCount+<span class="hljs-string">&quot;个&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;数字字符：&quot;</span>+numberCount+<span class="hljs-string">&quot;个&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了</p><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。<br>类变量：使用 static关键字修饰的成员变量。<br>格式:</p><figure class="highlight plaintext"><figcaption><span>int numberID；</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs static">static 数据类型 变量名；<br>static int numberID；<br></code></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要<br>创建类的对象。调用方式非常简单。<br>类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">修饰符 static 返回值类型 方法名 (参数列表)&#123;<br><span class="hljs-comment">// 执行语句</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">=================================</span><br>public static void showNum() &#123;<br><span class="hljs-code">System.out.println(&quot;num:&quot; + numberOfStudent);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h3><p>被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 访问类变量</span><br>类名.类变量名；<br><span class="hljs-comment">// 调用静态方法</span><br>类名.静态方法名(参数)；<br>===================================<br><span class="hljs-comment">// 访问类变量</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Student</span>.</span></span>numberOfStudent);<br><span class="hljs-comment">// 调用静态方法</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Student</span>.</span></span>show<span class="hljs-constructor">Num()</span>;<br></code></pre></td></tr></table></figure><h2 id="静态原理图解"><a href="#静态原理图解" class="headerlink" title="静态原理图解"></a>静态原理图解</h2><p>static 修饰的内容：</p><ul><li>是随着类的加载而加载的，且只加载一次。</li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</li><li>它优先于对象存在，所以，可以被所有对象共享。</li></ul><p><img src="/img/cphoto/static01.jpg" alt="对象内存图"></p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>静态代码块：定义在成员位置，使用static修饰的代码块{ }。</p><ul><li>位置：类中方法外。</li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">static &#123;<br><span class="hljs-comment">// 执行语句</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">========================================</span><br>static &#123;<br><span class="hljs-comment">// 给类变量赋值</span><br>number = 2;<br>list = new ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 添加元素到集合中</span><br>list.add(&quot;张三&quot;);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。</p></blockquote><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法</p><h3 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h3><ul><li>public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 定义int 数组</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">4</span>,<span class="hljs-number">657</span>,<span class="hljs-number">8</span>,<span class="hljs-number">69</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// 打印数组,输出地址值</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arr); <span class="hljs-comment">// [I@2ac1fdc4</span><br><span class="hljs-comment">// 数组内容转为字符串</span><br>String s = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>;<br><span class="hljs-comment">// 打印字符串,输出内容</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s); <span class="hljs-comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span><br><br></code></pre></td></tr></table></figure><ul><li>public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 定义int 数组</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">24</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">48</span>, <span class="hljs-number">4</span>, <span class="hljs-number">46</span>, <span class="hljs-number">35</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;排序前:&quot;</span>+ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>); <span class="hljs-comment">// 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6,2]</span><br><span class="hljs-comment">// 升序排序</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(arr);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;排序后:&quot;</span>+ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>);<span class="hljs-comment">// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]</span><br></code></pre></td></tr></table></figure><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p><h3 id="基本运算的方法"><a href="#基本运算的方法" class="headerlink" title="基本运算的方法"></a>基本运算的方法</h3><p>public static double abs(double a) ：返回 double 值的绝对值</p><p>public static double ceil(double a) ：返回大于等于参数的最小的整数。</p><p>public static double floor(double a) ：返回小于等于参数最大的整数。</p><p>public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">double</span> d<span class="hljs-number">1</span> = Math.abs(‐<span class="hljs-number">5</span>); //d<span class="hljs-number">1</span>的值为<span class="hljs-number">5</span><br><span class="hljs-attribute">double</span> d<span class="hljs-number">3</span> = Math.ceil(<span class="hljs-number">5</span>.<span class="hljs-number">1</span>); //d<span class="hljs-number">3</span>的值为 <span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">double</span> d<span class="hljs-number">1</span> = Math.floor(<span class="hljs-number">3</span>.<span class="hljs-number">3</span>); //d<span class="hljs-number">1</span>的值为<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">long</span> d<span class="hljs-number">1</span> = Math.round(<span class="hljs-number">5</span>.<span class="hljs-number">5</span>); //d<span class="hljs-number">1</span>的值为<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</p><ul><li>提高代码的复用性。</li><li>类与类之间产生了关系，是多态的前提</li></ul><h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><p>通过 extends 关键字，可以声明一个子类继承另外一个父类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">父类</span> </span>&#123;<br>...<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="父子类成员变量重名–-super关键字"><a href="#父子类成员变量重名–-super关键字" class="headerlink" title="父子类成员变量重名–(super关键字)"></a>父子类成员变量重名–(super关键字)</h2><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-comment">// Zi中的成员变量</span><br>    int num = <span class="hljs-number">6</span>;<br>    public void show() &#123;<br>        <span class="hljs-comment">//访问父类中的num</span><br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + <span class="hljs-keyword">super</span>.num);<br>        <span class="hljs-comment">//访问子类中的num</span><br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + <span class="hljs-keyword">this</span>.num);<br>    &#125;<br>&#125;<br>演示结果：<br><span class="hljs-type">Fu</span> num = <span class="hljs-number">5</span><br><span class="hljs-type">Zi</span> num = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><blockquote><p>Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。</p></blockquote><h2 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h2><p>方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fu show&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-comment">//子类重写了父类的show方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Zi show&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo05</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Zi z = <span class="hljs-keyword">new</span> Zi();<br>        <span class="hljs-comment">// 子类中有show方法，只执行重写后的show方法</span><br>        z.show(); <span class="hljs-comment">// Zi show</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。</p><p>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</p><p>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</p></blockquote><h2 id="继承后的特点——构造方法"><a href="#继承后的特点——构造方法" class="headerlink" title="继承后的特点——构造方法"></a>继承后的特点——构造方法</h2><p>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</p><ul><li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> int n;<br>    <span class="hljs-type">Fu</span>()&#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Fu()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-type">Zi</span>()&#123;<br>    <span class="hljs-comment">// super（），调用父类构造方法</span><br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Zi（）&quot;</span>);<br>    &#125;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo07</span></span>&#123;<br>    public static void main (<span class="hljs-type">String</span> args[])&#123;<br>    <span class="hljs-type">Zi</span> zi = <span class="hljs-keyword">new</span> <span class="hljs-type">Zi</span>();<br>&#125;<br>&#125;<br>输出结果：<br><span class="hljs-type">Fu</span>（）<br><span class="hljs-type">Zi</span>（）<br></code></pre></td></tr></table></figure><h2 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h2><h3 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h3><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法</p><p><img src="/img/cphoto/super01.jpg"></p><p>super和this的含义</p><ul><li>super ：代表父类的存储空间标识(可以理解为父亲的引用)。</li><li>this ：代表当前对象的引用(谁调用就代表谁)。</li></ul><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>​     Java只支持单继承，不支持多继承。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//一个类只能有一个父类，不可以有多个父类。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125; <span class="hljs-comment">//ok</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A，B</span>... <span class="hljs-comment">//error</span></span><br></code></pre></td></tr></table></figure><p>Java支持多层继承(继承体系)。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>顶层父类是Object类。所有的类默认继承Object，作为父类</p></blockquote><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">修饰符 abstract 返回值类型 方法名 (参数列表)；</span><br><span class="hljs-section">========================================</span><br>public abstract void run()；<br></code></pre></td></tr></table></figure><p>抽象类<br>如果一个类包含抽象方法，那么该类必须是抽象类。</p><ul><li>抽象方法 ： 没有方法体的方法。</li><li>抽象类：包含抽象方法的类</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">abstract class 类名字 &#123;<br><span class="hljs-section">&#125;</span><br><span class="hljs-section">=========================================</span><br>public abstract class Animal &#123;<br><span class="hljs-code">public abstract void run()；</span><br>&#125;<br></code></pre></td></tr></table></figure><p>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ul><li><p>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<br>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<br>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></li><li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。<br>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。<br>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><blockquote><p>引用数据类型：数组，类，接口。<br>接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">public interface 接口名称 &#123;<br><span class="hljs-regexp">//</span> 抽象方法<br><span class="hljs-regexp">//</span> 默认方法<br><span class="hljs-regexp">//</span> 静态方法<br><span class="hljs-regexp">//</span> 私有方法<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口含有抽象方法"><a href="#接口含有抽象方法" class="headerlink" title="接口含有抽象方法"></a>接口含有抽象方法</h2><p>抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口含有默认方法和静态方法"><a href="#接口含有默认方法和静态方法" class="headerlink" title="接口含有默认方法和静态方法"></a>接口含有默认方法和静态方法</h2><p>默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。<br>静态方法：使用 static 修饰，供接口直接调用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> InterFaceName &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method2</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口含有私有方法和私有静态方法"><a href="#接口含有私有方法和私有静态方法" class="headerlink" title="接口含有私有方法和私有静态方法"></a>接口含有私有方法和私有静态方法</h2><p>私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口基本的实现"><a href="#接口基本的实现" class="headerlink" title="接口基本的实现"></a>接口基本的实现</h2><p>类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类<br>似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。<br>非抽象子类实现接口：</p><ol><li>必须重写接口中所有抽象方法。</li><li>继承了接口的默认方法，即可以直接调用，也可以重写。</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口名 </span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【可选】</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>    <span class="hljs-comment">// 定义抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃东西&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;晚上睡&quot;</span>);<br>    &#125;<br>&#125;<br>=====================================<br><span class="hljs-comment">// 创建子类对象</span><br>Animal a = <span class="hljs-keyword">new</span> Animal();<br><span class="hljs-comment">// 调用实现后的方法</span><br>a.eat();<br>a.sleep();<br></code></pre></td></tr></table></figure><h2 id="接口默认方法的使用"><a href="#接口默认方法的使用" class="headerlink" title="接口默认方法的使用"></a>接口默认方法的使用</h2><p>可以继承，可以重写，二选一，但是只能通过实现类的对象来调用</p><p>定义接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span>&#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">LiveAble</span></span> </span>&#123;<br><span class="hljs-comment">// 继承，什么都不用写，直接调用</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">LiveAble</span></span> </span>&#123;<br><span class="hljs-comment">//重写</span><br>    @Override<br>    <span class="hljs-keyword">public</span> void fly() &#123;<br>    System.out.println(<span class="hljs-string">&quot;自由自在的飞&quot;</span>);<br>    &#125;<br>&#125;<br>=========================================<br><span class="hljs-comment">// 创建子类对象</span><br>Animal a = <span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>();<br><span class="hljs-comment">// 调用默认方法</span><br>a.fly();<br></code></pre></td></tr></table></figure><h2 id="静态方法的使用"><a href="#静态方法的使用" class="headerlink" title="静态方法的使用"></a>静态方法的使用</h2><p>静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用</p><p>定义接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">public class Animal implements LiveAble &#123;<br><span class="hljs-comment">// 无法重写静态方法</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">=========================================</span><br><span class="hljs-comment">// Animal.run(); // 【错误】无法继承方法,也无法调用</span><br>LiveAble.run(); <br><br></code></pre></td></tr></table></figure><h2 id="私有方法的使用"><a href="#私有方法的使用" class="headerlink" title="私有方法的使用"></a>私有方法的使用</h2><p>私有方法：只有默认方法可以调用。<br>私有静态方法：默认方法和静态方法可以调用</p><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。同学们在已学技术的基础上，可以自行测试。</p><h2 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h2><p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 [<span class="hljs-keyword"><span class="hljs-keyword">extends</span> </span>父类名] <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口名1,接口名2,接口名3...</span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【不重名时可选】</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象方法-1"><a href="#抽象方法-1" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showB</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br>=========================================<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showA</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;showA&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showB</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;showB&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;show&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">methodA</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">methodB</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">A,<span class="hljs-symbol">B</span></span>&#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> method() &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><p>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法</p><h2 id="优先级的问题"><a href="#优先级的问题" class="headerlink" title="优先级的问题"></a>优先级的问题</h2><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p><p>定义接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AAAAAAAAAAAA&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义父类</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;DDDDDDDDDDDD&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义子类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span> <span class="hljs-title">implements</span> <span class="hljs-title">A</span> </span>&#123;<br><span class="hljs-comment">// 未重写methodA方法</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        c.methodA();<br>    &#125;<br>&#125;<br>输出结果:<br>DDDDDDDDDDDD?<br></code></pre></td></tr></table></figure><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;AAAAAAAAAAAAAAAAAAA&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;BBBBBBBBBBBBBBBBBBB&quot;</span>);<br>    &#125;<br>&#125;<br>=====================<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;DDDDDDDDDDDDDD&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>子接口-&gt;重写默认方法时，default关键字可以保留。<br>子类    -&gt; 重写默认方法时，default关键字不可以保留。</p></blockquote><h2 id="接口其它"><a href="#接口其它" class="headerlink" title="接口其它"></a>接口其它</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。</li><li>接口中，没有构造方法，不能创建对象。</li><li>接口中，没有静态代码块。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是继封装、继承之后，面向对象的第三大特性</p><p>指同一行为，具有多个不同表现形式</p><h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">父类类型 变量名 = new 子类对象；<br><span class="hljs-section">变量名.方法名();</span><br><span class="hljs-section">======================================</span><br>Fu f = new Zi();<br>f.method();<br></code></pre></td></tr></table></figure><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p><p>定义父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义子类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    public void eat() &#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    public void eat() &#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);<br>    &#125;<br>&#125;<br>=======================================<br><span class="hljs-comment">// 多态形式，创建对象</span><br><span class="hljs-type">Animal</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<br><span class="hljs-comment">// 调用的是 Cat 的 eat</span><br>a1.eat();<br><span class="hljs-comment">// 多态形式，创建对象</span><br><span class="hljs-type">Animal</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>();<br><span class="hljs-comment">// 调用的是 Dog 的 eat</span><br>a2.eat();<br></code></pre></td></tr></table></figure><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 多态形式，创建对象</span><br>Cat c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>();<br>Dog d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br><span class="hljs-comment">// 调用showCatEat</span><br><span class="hljs-built_in">showCatEat</span>(c);<br><span class="hljs-built_in">showDogEat</span>(d);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代</span><br><span class="hljs-comment">而执行效果一致</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">showAnimalEat</span>(c);<br><span class="hljs-built_in">showAnimalEat</span>(d);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showCatEat</span> <span class="hljs-params">(Cat c)</span></span>&#123;<br>c.<span class="hljs-built_in">eat</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDogEat</span> <span class="hljs-params">(Dog d)</span></span>&#123;<br>d.<span class="hljs-built_in">eat</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showAnimalEat</span> <span class="hljs-params">(Animal a)</span></span>&#123;<br>a.<span class="hljs-built_in">eat</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</li><li>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</li><li>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</li></ul><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的</p><p>当父类引用指向一个子类对象时，便是向上转型。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">父类类型 变量名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>子类类型();<br>如：Animal a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<br></code></pre></td></tr></table></figure><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>主要是向上转型会导致创建对象无法使用子类特有方法,需要向下转型进行调用</p><p>向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的</p><p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">子类类型 变量名 = <span class="hljs-comment">(子类类型)</span> 父类变量名;<br>如:Cat c =<span class="hljs-comment">(Cat)</span> a;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">catchMouse</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);<br>    &#125;<br>&#125;<br>=======================================<br><span class="hljs-comment">// 向上转型</span><br>Animal a = <span class="hljs-keyword">new</span> Cat();<br>a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><span class="hljs-comment">// 向下转型</span><br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<span class="hljs-comment">//防止向下转型失败,进行对象判断</span><br>    Cat c = (Cat)a;<br>    c.catchMouse(); <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final： 不可改变。可以用于修饰类、方法和变量。<br>类：被修饰的类，不能被继承。<br>方法：被修饰的方法，不能被重写。<br>变量：被修饰的变量，不能被重新赋值。</p><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>重写被 final 修饰的方法，编译时就会报错</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br><span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><p>局部变量——基本类型</p><p>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 声明变量，使用final修饰<br>final int a;<br><span class="hljs-regexp">//</span> 第一次赋值<br>a = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 第二次赋值<br>a = <span class="hljs-number">20</span>; <span class="hljs-regexp">//</span> 报错,不可重新赋值<br></code></pre></td></tr></table></figure><p>下面代码能通过编译,因为每次循环都会新建一个新的final局部变量</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> c = i;<br>    System.<span class="hljs-keyword">out</span>.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>被final修饰的常量名称，一般都有书写规范，所有字母都大写</p><p>成员变量涉及到初始化的问题，初始化方式有两种</p><p>显示初始化</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> USERNAME = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br></code></pre></td></tr></table></figure><p>构造方法初始化</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> USERNAME ;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">String</span> username, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.USERNAME = username;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，<br>public：公共的。<br>protected：受保护的<br>default：默认的<br>private：私有的</p><table><thead><tr><th align="left"></th><th align="center">public</th><th align="center">protected</th><th align="center">default（空的）</th><th>private</th></tr></thead><tbody><tr><td align="left">同一类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td>√</td></tr><tr><td align="left">同一包中(子类与无关类)</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td></td></tr><tr><td align="left">不同包的子类</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td></td></tr><tr><td align="left">不同包中的无关类</td><td align="center">√</td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><p>public具有最大权限。private则是最小权限。</p><p>不加权限修饰符，其访问能力与default修饰符相同</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用 private ，隐藏细节。</li><li>构造方法使用 public ，方便创建对象。</li><li>成员方法使用 public ，方便调用方法</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 外部类 </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内部类可以直接访问外部类的成员，包括私有成员。</li><li>外部类要访问内部类的成员，必须要建立内部类的对象。</li><li>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">外部类名.内部类名 对象名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>外部类型().<span class="hljs-keyword">new</span> <span class="hljs-type"></span>内部类型()；<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> live = <span class="hljs-literal">true</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heart</span> &#123;</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jump</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 直接访问外部类成员</span><br>            <span class="hljs-keyword">if</span> (live) &#123;<br>                  System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;心脏在跳动&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                  System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;心脏不跳了&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLive</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> live;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLive</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> live)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.live = live;<br>    &#125;<br>&#125;<br>==========================================<br><span class="hljs-comment">// 创建外部类对象</span><br>Person p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br><span class="hljs-comment">// 创建内部类对象</span><br>Heart heart = p.<span class="hljs-keyword">new</span> <span class="hljs-built_in">Heart</span>();<br><span class="hljs-comment">// 调用内部类方法</span><br>heart.<span class="hljs-built_in">jump</span>();<br><span class="hljs-comment">// 调用外部类方法</span><br>p.<span class="hljs-built_in">setLive</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 调用内部类方法</span><br>heart.<span class="hljs-built_in">jump</span>();<br></code></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，使用一个接口时得做如下几步:</p><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><p>匿名内部类是为了调用快速方法，把以上四步简化成一步</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyAble</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">void</span> fly();<br>&#125;<br>=========================================<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.等号右边:定义并创建该接口的子类对象</span><br><span class="hljs-comment">    2.等号左边:是多态,接口类型引用指向子类对象</span><br><span class="hljs-comment">    */</span><br>    FlyAble f = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FlyAble</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>        &#125;<br>    &#125;;<br>        <span class="hljs-comment">// 将f传递给showFly方法中</span><br>        showFly(f);<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">showFly</span>(<span class="hljs-params">FlyAble f</span>)</span> &#123;<br>    f.fly();<br>    &#125;<br>=========================================<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建匿名内部类,直接传递给showFly(FlyAble f)</span><br><span class="hljs-comment">    */</span><br>    showFly( <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FlyAble</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>    &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">showFly</span>(<span class="hljs-params">FlyAble f</span>)</span> &#123;<br>f.fly();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="interface作为成员变量"><a href="#interface作为成员变量" class="headerlink" title="interface作为成员变量"></a>interface作为成员变量</h2><p>接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role 中，可以增加接口作为成员变量，来设置不同的技能。</p><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 法术攻击</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FaShuSkill</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">faShuAttack</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义角色类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;<br>    FaShuSkill fs;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setFaShuSkill</span>(<span class="hljs-params">FaShuSkill fs</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.fs = fs;<br>    &#125;<br>    <span class="hljs-comment">// 法术攻击</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">faShuSkillAttack</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;发动法术攻击:&quot;</span>);<br>        fs.faShuAttack();<br>        System.out.println(<span class="hljs-string">&quot;攻击完毕&quot;</span>);<br>    &#125;<br>&#125;<br>======================================<br><span class="hljs-comment">// 创建游戏角色</span><br>Role role = <span class="hljs-keyword">new</span> Role();<br><span class="hljs-comment">// 设置角色法术技能</span><br>role.setFaShuSkill(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FaShuSkill</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">faShuAttack</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;纵横天下&quot;</span>);<br>&#125;<br>&#125;);<br><span class="hljs-comment">// 发动法术攻击</span><br>role.faShuSkillAttack();<br><span class="hljs-comment">// 更换技能</span><br>role.setFaShuSkill(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FaShuSkill</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">faShuAttack</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;逆转乾坤&quot;</span>);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 发动法术攻击</span><br>role.faShuSkillAttack();<br>&#125;<br>&#125;<br>输出结果:<br>发动法术攻击:纵横天下<br>攻击完毕<br>发动法术攻击:逆转乾坤<br>攻击完毕<br></code></pre></td></tr></table></figure><p>我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎01-基本入门</title>
    <link href="/2017/09/01/java%E5%9F%BA%E7%A1%8001/"/>
    <url>/2017/09/01/java%E5%9F%BA%E7%A1%8001/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>生活采用十进制数，而计算机中全部采用二进制数表示，它只包含 0、1两个数，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特） </p><h3 id="十进制数据转成二进制数据"><a href="#十进制数据转成二进制数据" class="headerlink" title="十进制数据转成二进制数据:"></a>十进制数据转成二进制数据:</h3><p>使用除以2获取余数的方式  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">6/<span class="hljs-attribute">2</span>=3---&gt;0<br>3/<span class="hljs-attribute">2</span>=1---&gt;1<br>1/<span class="hljs-attribute">2</span>=0---&gt;1<br>由此获得110<br></code></pre></td></tr></table></figure><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">二进制1001011转换十进制数<br>1 <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span> 1<br>64<span class="hljs-number"> 32 </span>16<span class="hljs-number"> 8 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 2 </span> 1<br>将有1的所有十进制数加起来<br>64+8+2+1=75<br></code></pre></td></tr></table></figure><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性， 我们可以查看文件的字节大小。 8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。</p><p> 8 bit = 1 B </p><p>1024 B =1 KB </p><p>1024 KB =1 MB </p><p>1024 MB =1 GB </p><p>1024 GB = 1 TB</p><h2 id="cmd命令"><a href="#cmd命令" class="headerlink" title="cmd命令"></a>cmd命令</h2><table><thead><tr><th>盘符切换命令</th><th>盘符名:  //例如d:</th></tr></thead><tbody><tr><td>查看当前文件夹</td><td>dir</td></tr><tr><td>进入文件夹命令</td><td>cd 文件夹名</td></tr><tr><td>退出文件夹命令</td><td>cd..</td></tr><tr><td>退出到磁盘根目录</td><td>cd\</td></tr><tr><td>清屏</td><td>cls</td></tr><tr><td>查看IP地址</td><td>ipconfig</td></tr><tr><td>ping网络</td><td>ping IP地址</td></tr><tr><td>telnet测试连通性</td><td>telnet  IP地址</td></tr></tbody></table><p>其它</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>记事本</td><td>notepad</td></tr><tr><td>计算器</td><td>calc</td></tr><tr><td>打开typora</td><td>安装typora后,typora</td></tr><tr><td>打开vscode</td><td>code</td></tr><tr><td>打开服务</td><td>services.msc</td></tr><tr><td>打开控制面板</td><td>control</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="jdk环境变量配置"><a href="#jdk环境变量配置" class="headerlink" title="jdk环境变量配置"></a>jdk环境变量配置</h2><p>安装jdk,jdk安装路径建议不要默认,修改在c盘默认路径java文件夹,默认路径带空格,会导致一些框架引用jdk配置出现问题</p><p>打开环境变量</p><blockquote><p>计算机(右键-属性)-&gt;高级系统设置-&gt;环境变量</p></blockquote><p>新建配置</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">JAV<span class="hljs-built_in">A_HOME</span><br>jdk安装路径<br></code></pre></td></tr></table></figure><p>在path路径添加配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">JAVA_HOME</span></span>%\bin; <br></code></pre></td></tr></table></figure><p>cmd命令行输入测试是否成功</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br>javac<br></code></pre></td></tr></table></figure><h2 id="java运行流程"><a href="#java运行流程" class="headerlink" title="java运行流程"></a>java运行流程</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">javac hello.java <span class="hljs-regexp">//</span>编译器将Java文件编译字节码文件,生成hello.class<br><br>Java hello <span class="hljs-regexp">//</span>运行生成的hello.class<br><br></code></pre></td></tr></table></figure><h2 id="单行注释和多行注释"><a href="#单行注释和多行注释" class="headerlink" title="单行注释和多行注释"></a>单行注释和多行注释</h2><p>单行注释以 //开头 换行结束 多行注释以 /<em>开头 以</em>/结束</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>命名规则： 硬性要求 </p><ul><li>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 </li><li>标识符不能以数字开头。 </li><li>标识符不能是关键字。 </li></ul><p>命名规范： 软性建议 </p><ul><li><p>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</p></li><li><p>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</p></li><li><p>变量名规范：全部小写。</p></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>字节型  byte 1个字节 -128<del>127<br>短整型  short 2个字节 -32768</del>32767<br>整型  int（默认） 4个字节 -231次方<del>2的31次方-1<br>长整型  long 8个字节 -2的63次方</del>2的63次方-1<br>单精度浮点数  float 4个字节 1.4013E-45<del>3.4028E+38<br>双精度浮点数  double（默认） 8个字节 4.9E-324</del>1.7977E+308<br>字符型  char 2个字节 0-65535<br>布尔类型  boolean 1个字节 true，false</p><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型 。</p><p>byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。<br>当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-built_in">byte</span> b = <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>// <span class="hljs-built_in">byte</span> x = b + i<span class="hljs-comment">; // 报错</span><br>//<span class="hljs-keyword">int</span>类型和<span class="hljs-built_in">byte</span>类型运算，结果是<span class="hljs-keyword">int</span>类型<br><span class="hljs-keyword">int</span> j = b + i<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。可以理解为 double 是8升的水壶， int 是4升的水壶，不能把大水壶中的水直接放进小水壶去。想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。<br>强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。<br>比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。</p><p>数据类型 变量名 = （数据类型）被转数据值；</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// <span class="hljs-keyword">double</span>类型数据强制转成<span class="hljs-built_in">int</span>类型，直接去掉小数点。<br><span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)<span class="hljs-number">1.5</span>;<br><br></code></pre></td></tr></table></figure><p>浮点转成整数，直接取消小数点，可能造成数据损失精度。<br>int 强制转成 short 砍掉2个字节，可能造成数据丢失。</p><h2 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h2><p>在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。<br>编码表 ：就是将人类的文字和一个十进制数进行对应起来组成一张表格。</p><h3 id="ASCII可显示字符"><a href="#ASCII可显示字符" class="headerlink" title="ASCII可显示字符"></a>ASCII可显示字符</h3><p>字符 数值<br>0 48<br>9 57<br>A 65<br>Z 90<br>a 97<br>z 122</p><h2 id="算数运算符包括："><a href="#算数运算符包括：" class="headerlink" title="算数运算符包括："></a>算数运算符包括：</h2><ul><li>加法运算，字符串连接运算</li></ul><ul><li>减法运算</li></ul><ul><li>乘法运算<br>/ 除法运算<br>% 取模运算，两个数字相除取余数</li></ul><p>++ 、 – 自增自减运算</p><h2 id="赋值运算符包括："><a href="#赋值运算符包括：" class="headerlink" title="赋值运算符包括："></a>赋值运算符包括：</h2><p>= 等于号<br>+= 加等于<br>-= 减等于<br>*= 乘等于<br>/= 除等于<br>%= 取模等</p><h2 id="比较运算符包括："><a href="#比较运算符包括：" class="headerlink" title="比较运算符包括："></a>比较运算符包括：</h2><p>== 比较符号两边数据是否相等，相等结果是true。<br>&lt; 比较符号左边的数据是否小于右边的数据，如果小于结果是true。</p><blockquote><p>比较符号左边的数据是否大于右边的数据，如果大于结果是true。<br>&lt;= 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。<br>= 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。<br>！= 不等于符号 ，如果符号两边的数据不相等，结果是true。</p></blockquote><h2 id="逻辑运算符包括："><a href="#逻辑运算符包括：" class="headerlink" title="逻辑运算符包括："></a>逻辑运算符包括：</h2><p>&amp;&amp; 短路与</p><ol><li>两边都是true，结果是true</li><li>一边是false，结果是false<br>短路特点：符号左边是false，右边不再运算<br>|| 短路或</li><li>两边都是false，结果是false</li><li>一边是true，结果是true<br>短路特点： 符号左边是true，右边不再运算<br>！ 取反</li><li>! true 结果是false</li><li>! false结果是true</li></ol><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>数据类型 变量名 = 布尔类型表达式？结果1：结果2</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">修饰符 返回值类型 方法名 （参数列表）｛<br>代码...<br><span class="hljs-keyword">return</span> ;<br>｝<br></code></pre></td></tr></table></figure><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">//调用定义的方法method</span><br><span class="hljs-comment">method();</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">//定义方法，被main方法调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">System.out.println(&quot;自己定义的方法，需要被main调用运行&quot;);</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><h2 id="方法定义注意事项："><a href="#方法定义注意事项：" class="headerlink" title="方法定义注意事项："></a>方法定义注意事项：</h2><ul><li>方法必须定义在一类中方法外</li><li>方法不能定义在另一个方法的里面</li></ul><h2 id="JShell脚本工具"><a href="#JShell脚本工具" class="headerlink" title="JShell脚本工具"></a>JShell脚本工具</h2><p>JShell是JDK9的新特性<br>当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这个时候可以使用JShell工具。<br>启动JShell工具，在DOS命令行直接输入JShell命令。<br>JShell工具，只适合片段代码的测试，开发更多内容，建议编写在方法中。</p><h2 id="if语句第一种格式：-if"><a href="#if语句第一种格式：-if" class="headerlink" title="if语句第一种格式： if"></a>if语句第一种格式： if</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(关系表达式)｛<br>语句体<span class="hljs-comment">;</span><br>｝<br></code></pre></td></tr></table></figure><h2 id="if语句第二种格式：-if…else"><a href="#if语句第二种格式：-if…else" class="headerlink" title="if语句第二种格式： if…else"></a>if语句第二种格式： if…else</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(关系表达式) &#123;<br>语句体<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;else &#123;<br>语句体<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if语句第三种格式：-if…else-if-…else"><a href="#if语句第三种格式：-if…else-if-…else" class="headerlink" title="if语句第三种格式： if…else if …else"></a>if语句第三种格式： if…else if …else</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">1</span>) &#123;<br>执行语句<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(判断条件<span class="hljs-number">2</span>)</span> </span>&#123;<br>执行语句<span class="hljs-number">2</span>;<br>&#125;<br>...<br>&#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(判断条件n)</span> </span>&#123;<br>执行语句n;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>执行语句n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch语句格式："><a href="#switch语句格式：" class="headerlink" title="switch语句格式："></a>switch语句格式：</h2><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(表达式) &#123;<br><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:<br>语句体<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:<br>语句体<span class="hljs-number">2</span>;<br><span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">default</span>:<br>语句体n+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for循环语句格式："><a href="#for循环语句格式：" class="headerlink" title="for循环语句格式："></a>for循环语句格式：</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(初始化表达式①; 布尔表达式②; 步进表达式④)</span></span>&#123;<br>循环体③<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="while循环语句格式："><a href="#while循环语句格式：" class="headerlink" title="while循环语句格式："></a>while循环语句格式：</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">初始化表达式①<br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(布尔表达式②)</span></span>&#123;<br>循环体③<br>步进表达式④<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="do…while循环格式"><a href="#do…while循环格式" class="headerlink" title="do…while循环格式"></a>do…while循环格式</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">初始化表达式①<br><span class="hljs-keyword">do</span>&#123;<br>循环体③<br>步进表达式④<br>&#125;<span class="hljs-keyword">while</span><span class="hljs-comment">(布尔表达式②)</span>;<br><br></code></pre></td></tr></table></figure><h2 id="for-和-while-的小区别："><a href="#for-和-while-的小区别：" class="headerlink" title="for 和 while 的小区别："></a>for 和 while 的小区别：</h2><ul><li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消<br>失，能够提高内存的使用效率。</li><li>在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</li></ul><h2 id="idea快捷键-功能"><a href="#idea快捷键-功能" class="headerlink" title="idea快捷键 功能"></a>idea快捷键 功能</h2><p>Alt+Enter 导入包，自动修正代码<br>Ctrl+Y 删除光标所在行<br>Ctrl+D 复制光标所在行的内容，插入光标位置下面<br>Ctrl+Alt+L 格式化代码<br>Ctrl+/ 单行注释<br>Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释<br>Alt+Ins 自动生成代码，toString，get，set等方法<br>Alt+Shift+上下箭头 移动当前代码行</p><h2 id="容器概念"><a href="#容器概念" class="headerlink" title="容器概念"></a>容器概念</h2><p>容器：是将多个数据存储到一起，每个数据称为该容器的元素。</p><h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">数组存储的数据类型[] 数组名字 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>数组存储的数据类型[长度];<br></code></pre></td></tr></table></figure><ul><li>数组定义格式详解：</li><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</li><li>[] : 表示数组。</li><li>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</li><li>new：关键字，创建数组使用的关键字。</li><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</li><li>[长度]：数组的长度，表示数组容器中可以存储多少个元素。</li><li>注意：数组有定长特性，长度一旦指定，不可更改。和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span>[] arr = new int[<span class="hljs-number">3</span>];<br><span class="hljs-attribute">int</span>[] arr = new int[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">数据类型[] 数组名 = </span><span class="hljs-template-variable">&#123;元素1,元素2,元素3...&#125;</span><span class="xml">;</span><br><span class="xml">int[] arr = </span><span class="hljs-template-variable">&#123;1,2,3,4,5&#125;</span><span class="xml">;</span><br></code></pre></td></tr></table></figure><p>数组的长度属性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//打印数组的属性，输出结果是5</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arr.length);<br></code></pre></td></tr></table></figure><p>索引访问数组中的元素：</p><ul><li>数组名[索引]=数值，为数组中的元素赋值</li><li>变量=数组名[索引]，获取出数组中的元素<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//定义存储int类型数组，赋值元素1，2，3，4，5</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//为0索引元素赋值为6</span><br>arr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">6</span>;<br><span class="hljs-comment">//获取数组0索引上的元素</span><br><span class="hljs-built_in">int</span> i = arr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i);<br><span class="hljs-comment">//直接输出数组0索引元素</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);<br></code></pre></td></tr></table></figure><h2 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h2>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。<br>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。<h2 id="JVM的内存划分："><a href="#JVM的内存划分：" class="headerlink" title="JVM的内存划分："></a>JVM的内存划分：</h2>寄存器         //给CPU使用，和我们开发无关。<br>本地方法栈 //JVM在使用操作系统功能的时候使用，和我们开发无关。<br>方法区         //存储可以运行的class文件。<br>堆内存         //存储对象或者数组，new来创建的，都存储在堆内存。<br>方法栈         //方法运行时使用的内存，比如main方法运行，进入方法栈中执行。<h3 id="一个内存"><a href="#一个内存" class="headerlink" title="一个内存"></a>一个内存</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>System.out.<span class="hljs-built_in">println</span>(arr);<span class="hljs-comment">//[I@5f150435</span><br>&#125;<br></code></pre></td></tr></table></figure>以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。<br>输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素<br><img src="/img/cphoto/array01.jpg" alt="array内存图"><h3 id="两个内存"><a href="#两个内存" class="headerlink" title="两个内存"></a>两个内存</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>System.out.<span class="hljs-built_in">println</span>(arr);<br>System.out.<span class="hljs-built_in">println</span>(arr2);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/cphoto/array02.jpg" alt="array内存图"></li></ul><h3 id="两个变量指向一个数组"><a href="#两个变量指向一个数组" class="headerlink" title="两个变量指向一个数组"></a>两个变量指向一个数组</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-comment">// 定义数组，存储3个元素</span><br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-comment">//数组索引进行赋值</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br><span class="hljs-comment">//输出3个索引上的元素值</span><br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">0</span>]);<br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">1</span>]);<br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">//定义数组变量arr2，将arr的地址赋值给arr2</span><br><span class="hljs-keyword">int</span>[] arr2 = arr;<br>arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;<br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/array03.jpg" alt="array内存图"></p><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><p>创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 rrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p><h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><p>arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p><p><img src="/img/cphoto/array04.jpg" alt="array内存图"></p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>System.<span class="hljs-keyword">out</span>.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">循环中定义变量min=0最小索引</span><br><span class="hljs-comment">max=arr.length‐1最大索引</span><br><span class="hljs-comment">min++,max‐‐</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">max</span> = arr.<span class="hljs-built_in">length</span> ‐ <span class="hljs-number">1</span>; <span class="hljs-built_in">min</span> &lt;= <span class="hljs-built_in">max</span>; <span class="hljs-built_in">min</span>++, <span class="hljs-built_in">max</span>‐‐) &#123;<br>    <span class="hljs-comment">//利用第三方变量完成数组中的元素交换</span><br>    <span class="hljs-type">int</span> temp = arr[<span class="hljs-built_in">min</span>];<br>    arr[<span class="hljs-built_in">min</span>] = arr[<span class="hljs-built_in">max</span>];<br>    arr[<span class="hljs-built_in">max</span>] = temp;<br>&#125;<br><span class="hljs-comment">// 反转后，遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>System.<span class="hljs-keyword">out</span>.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组作为方法参数"><a href="#数组作为方法参数" class="headerlink" title="数组作为方法参数"></a>数组作为方法参数</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span> &#125;;<br>        <span class="hljs-comment">//调用方法，传递数组</span><br>        <span class="hljs-built_in">printArray</span>(arr);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">创建方法，方法接收数组类型的参数</span><br><span class="hljs-comment">进行数组的遍历</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>System.out.<span class="hljs-built_in">println</span>(arr[i]);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/array05.jpg" alt="array内存图"></p><h3 id="方法的参数类型区别"><a href="#方法的参数类型区别" class="headerlink" title="方法的参数类型区别"></a>方法的参数类型区别</h3><p> 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo插入图片的配置</title>
    <link href="/2017/06/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2017/06/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="在blog的目录下安装插件"><a href="#在blog的目录下安装插件" class="headerlink" title="在blog的目录下安装插件"></a>在blog的目录下安装插件</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><h2 id="在配置文件-config-yml-找到-post-asset-folder-设置true"><a href="#在配置文件-config-yml-找到-post-asset-folder-设置true" class="headerlink" title="在配置文件_config.yml,找到 post_asset_folder,设置true"></a>在配置文件_config.yml,找到 post_asset_folder,设置true</h2><h2 id="将该目录下替换为后面的代码"><a href="#将该目录下替换为后面的代码" class="headerlink" title="将该目录下替换为后面的代码"></a>将该目录下替换为后面的代码</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/node_modules/</span>hexo-asset-image/index.js<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.config;<br>  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;<br>        <span class="hljs-keyword">var</span> link = data.permalink;<br>    <span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>       <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>       <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br>    <span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.substring(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;<br>        <span class="hljs-attr">ignoreWhitespace</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">xmlMode</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">lowerCaseTags</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br>            <span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br>            <span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;<br>               !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;<br>              <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>              <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>              <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)<br>                srcArray.shift();<br>              src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);<br>              $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);<br>              <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br>            <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));<br>        &#125;<br>      &#125;);<br>      data[key] = $.html();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>第四步：现在就可以插入图片了，比如hexo new post photo之后<br> 就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br> 在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[这是代替图片的文字，随便写]</span>(head.jpeg)<br></code></pre></td></tr></table></figure><h2 id="Fluid主题下直接使用静态图片"><a href="#Fluid主题下直接使用静态图片" class="headerlink" title="Fluid主题下直接使用静态图片"></a>Fluid主题下直接使用静态图片</h2><p>将图片放置在</p><blockquote><p>blog/themes/Fluid/source/img/</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![图片](<span class="hljs-regexp">/img/</span>pp.jpg)<br></code></pre></td></tr></table></figure><p><img src="/img/pp.jpg" alt="图片"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASCII编码</title>
    <link href="/2017/06/05/ASCII%E7%BC%96%E7%A0%81%E8%A1%A8/"/>
    <url>/2017/06/05/ASCII%E7%BC%96%E7%A0%81%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>图形</th></tr></thead><tbody><tr><td>0010 0000</td><td>32</td><td>20</td><td>（空格）(␠)</td></tr><tr><td>0010 0001</td><td>33</td><td>21</td><td>!</td></tr><tr><td>0010 0010</td><td>34</td><td>22</td><td>“</td></tr><tr><td>0010 0011</td><td>35</td><td>23</td><td>#</td></tr><tr><td>0010 0100</td><td>36</td><td>24</td><td>$</td></tr><tr><td>0010 0101</td><td>37</td><td>25</td><td>%</td></tr><tr><td>0010 0110</td><td>38</td><td>26</td><td>&amp;</td></tr><tr><td>0010 0111</td><td>39</td><td>27</td><td>‘</td></tr><tr><td>0010 1000</td><td>40</td><td>28</td><td>(</td></tr><tr><td>0010 1001</td><td>41</td><td>29</td><td>)</td></tr><tr><td>0010 1010</td><td>42</td><td>2A</td><td>*</td></tr><tr><td>0010 1011</td><td>43</td><td>2B</td><td>+</td></tr><tr><td>0010 1100</td><td>44</td><td>2C</td><td>,</td></tr><tr><td>0010 1101</td><td>45</td><td>2D</td><td>-</td></tr><tr><td>0010 1110</td><td>46</td><td>2E</td><td>.</td></tr><tr><td>0010 1111</td><td>47</td><td>2F</td><td>/</td></tr><tr><td>0011 0000</td><td>48</td><td>30</td><td>0</td></tr><tr><td>0011 0001</td><td>49</td><td>31</td><td>1</td></tr><tr><td>0011 0010</td><td>50</td><td>32</td><td>2</td></tr><tr><td>0011 0011</td><td>51</td><td>33</td><td>3</td></tr><tr><td>0011 0100</td><td>52</td><td>34</td><td>4</td></tr><tr><td>0011 0101</td><td>53</td><td>35</td><td>5</td></tr><tr><td>0011 0110</td><td>54</td><td>36</td><td>6</td></tr><tr><td>0011 0111</td><td>55</td><td>37</td><td>7</td></tr><tr><td>0011 1000</td><td>56</td><td>38</td><td>8</td></tr><tr><td>0011 1001</td><td>57</td><td>39</td><td>9</td></tr><tr><td>0011 1010</td><td>58</td><td>3A</td><td>:</td></tr><tr><td>0011 1011</td><td>59</td><td>3B</td><td>;</td></tr><tr><td>0011 1100</td><td>60</td><td>3C</td><td>&lt;</td></tr><tr><td>0011 1101</td><td>61</td><td>3D</td><td>=</td></tr><tr><td>0011 1110</td><td>62</td><td>3E</td><td>&gt;</td></tr><tr><td>0011 1111</td><td>63</td><td>3F</td><td>?</td></tr></tbody></table><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>图形</th></tr></thead><tbody><tr><td>0100 0000</td><td>64</td><td>40</td><td>@</td></tr><tr><td>0100 0001</td><td>65</td><td>41</td><td>A</td></tr><tr><td>0100 0010</td><td>66</td><td>42</td><td>B</td></tr><tr><td>0100 0011</td><td>67</td><td>43</td><td>C</td></tr><tr><td>0100 0100</td><td>68</td><td>44</td><td>D</td></tr><tr><td>0100 0101</td><td>69</td><td>45</td><td>E</td></tr><tr><td>0100 0110</td><td>70</td><td>46</td><td>F</td></tr><tr><td>0100 0111</td><td>71</td><td>47</td><td>G</td></tr><tr><td>0100 1000</td><td>72</td><td>48</td><td>H</td></tr><tr><td>0100 1001</td><td>73</td><td>49</td><td>I</td></tr><tr><td>0100 1010</td><td>74</td><td>4A</td><td>J</td></tr><tr><td>0100 1011</td><td>75</td><td>4B</td><td>K</td></tr><tr><td>0100 1100</td><td>76</td><td>4C</td><td>L</td></tr><tr><td>0100 1101</td><td>77</td><td>4D</td><td>M</td></tr><tr><td>0100 1110</td><td>78</td><td>4E</td><td>N</td></tr><tr><td>0100 1111</td><td>79</td><td>4F</td><td>O</td></tr><tr><td>0101 0000</td><td>80</td><td>50</td><td>P</td></tr><tr><td>0101 0001</td><td>81</td><td>51</td><td>Q</td></tr><tr><td>0101 0010</td><td>82</td><td>52</td><td>R</td></tr><tr><td>0101 0011</td><td>83</td><td>53</td><td>S</td></tr><tr><td>0101 0100</td><td>84</td><td>54</td><td>T</td></tr><tr><td>0101 0101</td><td>85</td><td>55</td><td>U</td></tr><tr><td>0101 0110</td><td>86</td><td>56</td><td>V</td></tr><tr><td>0101 0111</td><td>87</td><td>57</td><td>W</td></tr><tr><td>0101 1000</td><td>88</td><td>58</td><td>X</td></tr><tr><td>0101 1001</td><td>89</td><td>59</td><td>Y</td></tr><tr><td>0101 1010</td><td>90</td><td>5A</td><td>Z</td></tr><tr><td>0101 1011</td><td>91</td><td>5B</td><td>[</td></tr><tr><td>0101 1100</td><td>92</td><td>5C</td><td>\</td></tr><tr><td>0101 1101</td><td>93</td><td>5D</td><td>]</td></tr><tr><td>0101 1110</td><td>94</td><td>5E</td><td>^</td></tr><tr><td>0101 1111</td><td>95</td><td>5F</td><td>_</td></tr></tbody></table><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>图形</th></tr></thead><tbody><tr><td>0110 0000</td><td>96</td><td>60</td><td>`</td></tr><tr><td>0110 0001</td><td>97</td><td>61</td><td>a</td></tr><tr><td>0110 0010</td><td>98</td><td>62</td><td>b</td></tr><tr><td>0110 0011</td><td>99</td><td>63</td><td>c</td></tr><tr><td>0110 0100</td><td>100</td><td>64</td><td>d</td></tr><tr><td>0110 0101</td><td>101</td><td>65</td><td>e</td></tr><tr><td>0110 0110</td><td>102</td><td>66</td><td>f</td></tr><tr><td>0110 0111</td><td>103</td><td>67</td><td>g</td></tr><tr><td>0110 1000</td><td>104</td><td>68</td><td>h</td></tr><tr><td>0110 1001</td><td>105</td><td>69</td><td>i</td></tr><tr><td>0110 1010</td><td>106</td><td>6A</td><td>j</td></tr><tr><td>0110 1011</td><td>107</td><td>6B</td><td>k</td></tr><tr><td>0110 1100</td><td>108</td><td>6C</td><td>l</td></tr><tr><td>0110 1101</td><td>109</td><td>6D</td><td>m</td></tr><tr><td>0110 1110</td><td>110</td><td>6E</td><td>n</td></tr><tr><td>0110 1111</td><td>111</td><td>6F</td><td>o</td></tr><tr><td>0111 0000</td><td>112</td><td>70</td><td>p</td></tr><tr><td>0111 0001</td><td>113</td><td>71</td><td>q</td></tr><tr><td>0111 0010</td><td>114</td><td>72</td><td>r</td></tr><tr><td>0111 0011</td><td>115</td><td>73</td><td>s</td></tr><tr><td>0111 0100</td><td>116</td><td>74</td><td>t</td></tr><tr><td>0111 0101</td><td>117</td><td>75</td><td>u</td></tr><tr><td>0111 0110</td><td>118</td><td>76</td><td>v</td></tr><tr><td>0111 0111</td><td>119</td><td>77</td><td>w</td></tr><tr><td>0111 1000</td><td>120</td><td>78</td><td>x</td></tr><tr><td>0111 1001</td><td>121</td><td>79</td><td>y</td></tr><tr><td>0111 1010</td><td>122</td><td>7A</td><td>z</td></tr><tr><td>0111 1011</td><td>123</td><td>7B</td><td>{</td></tr><tr><td>0111 1100</td><td>124</td><td>7C</td><td>|</td></tr><tr><td>0111 1101</td><td>125</td><td>7D</td><td>}</td></tr><tr><td>0111 1110</td><td>126</td><td>7E</td><td>~</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ASCII编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章头示意</title>
    <link href="/2017/06/02/hexo%E6%96%87%E7%AB%A0%E5%A4%B4%E7%A4%BA%E6%84%8F/"/>
    <url>/2017/06/02/hexo%E6%96%87%E7%AB%A0%E5%A4%B4%E7%A4%BA%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本文章头写法"><a href="#基本文章头写法" class="headerlink" title="基本文章头写法"></a>基本文章头写法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">title: hexo文章和mrkdown使用笔记   <span class="hljs-regexp">//</span>标题<br>date: <span class="hljs-number">2018</span>-<span class="hljs-number">06</span>-<span class="hljs-number">01</span> <span class="hljs-number">11</span>:<span class="hljs-number">53</span>:<span class="hljs-number">40</span>    <span class="hljs-regexp">//</span>时间<br>tags: hexo      <span class="hljs-regexp">//</span>标签<br>author: clyde   <span class="hljs-regexp">//</span>作者<br>index_img: <span class="hljs-regexp">/img/</span>pp.jpg   <span class="hljs-regexp">//</span>封面图片<br>banner_img: <span class="hljs-regexp">/img/</span>pp.jpg  <span class="hljs-regexp">//</span>文章头部图片<br>categories: web<span class="hljs-regexp">//</span>分类<br></code></pre></td></tr></table></figure><h2 id="排序-置顶"><a href="#排序-置顶" class="headerlink" title="排序,置顶"></a>排序,置顶</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sticky: <span class="hljs-number">4</span>   <span class="hljs-regexp">//</span>排序,将这个设置很大可以做出置顶效果<br></code></pre></td></tr></table></figure><h2 id="多标签用法"><a href="#多标签用法" class="headerlink" title="多标签用法"></a>多标签用法</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span> [tag1, tag2, tag3, ...]<br>//下面这种方式对hexo版本有限制<br><span class="hljs-keyword">tags:</span><br>- tags1<br>- tags2<br>- ...<br></code></pre></td></tr></table></figure><h1 id="这是一个好用的尺子工具-绿色-无需安装"><a href="#这是一个好用的尺子工具-绿色-无需安装" class="headerlink" title="这是一个好用的尺子工具,绿色,无需安装"></a>这是一个好用的尺子工具,绿色,无需安装</h1><p><a href="/add/capture.zip">尺子工具</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章和mrkdown使用笔记</title>
    <link href="/2017/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2017/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h3><hr><h3 id="2-标题"><a href="#2-标题" class="headerlink" title="2#标题"></a>2#标题</h3><h3 id="3-标题"><a href="#3-标题" class="headerlink" title="3#标题"></a>3#标题</h3><blockquote><p>左竖线<br>  jkjkj<br>dfd<br>  <groupId>com.clyde</groupId><br>   <artifactId>documentproject01</artifactId><br>  <version>1.0-SNAPSHOT</version></p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/F502513A43624EA2B0CABECB87458E06?method=download&shareKey=b71b33f21f65f970e83136b29cac5ac5" alt="外链图片"></p><p>这是测试文章</p><blockquote><p>github创建仓库,在issue中拖入图片,下方文档中就有md格式图片链接<br><img src="https://user-images.githubusercontent.com/32689857/120270452-34d68600-c2dc-11eb-84f0-134ab94b9b39.png" alt="github图床图片"></p></blockquote><h3 id="分割线"><a href="#分割线" class="headerlink" title="*分割线"></a>*分割线</h3><hr><hr><hr><hr><h3 id="斜体粗体"><a href="#斜体粗体" class="headerlink" title="*斜体粗体"></a>*斜体粗体</h3><p><em>jhhh</em>  </p><p><em>zhegeshi</em></p><h3 id="后面空两行或者隔一行来换行"><a href="#后面空两行或者隔一行来换行" class="headerlink" title="*后面空两行或者隔一行来换行"></a>*后面空两行或者隔一行来换行</h3><p><strong>及健康健康</strong><br><strong>即将开机</strong></p><h3 id="删除线-下划线"><a href="#删除线-下划线" class="headerlink" title="*删除线,下划线"></a>*删除线,下划线</h3><p><del>寄几个</del></p><p><u>即将开机公开</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="*脚注"></a>*脚注</h3><p>这个是脚注[^rrr]</p><h3 id="列表"><a href="#列表" class="headerlink" title="*列表"></a>*列表</h3><p>列表1:<br>    - aaaa<br>    - bbb<br>    - cccc</p><h3 id="区块"><a href="#区块" class="headerlink" title="*区块"></a>*区块</h3><blockquote><p>aaa<br>jkjk<br>jkjk<br>kjkj<br>jkjijkj</p></blockquote><h3 id="表格"><a href="#表格" class="headerlink" title="*表格"></a>*表格</h3><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><pre><code class=" mermaid">graph TD开始 --&gt; 结束</code></pre><pre><code class=" mermaid">sequenceDiagram    Alice-&gt;&gt;John: Hello John, how are you?    John--&gt;&gt;Alice: Great!</code></pre><pre><code class=" mermaid">flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">代码分割块<br>代码分割块<br>代码分割块代码分割块<br>代码分割块代码分割块<br>代码分割块代码分割块代码分割块<br>代码分割块代码分割块代码分割块<br>代码分割块代码分割块代码分割块代码分割块<br>代码分割块代码分割块代码分割块代码分割块<br><br></code></pre></td></tr></table></figure><p><img src="/img/pp.jpg" alt="jijkl"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=46303362&cid=81124889&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><br>视频分割<hr><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=838863398&bvid=BV1F54y1S7WT&cid=209620845&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea快捷键</title>
    <link href="/2017/01/01/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2017/01/01/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>idea标签页切换:alt+左右键</p><p>idea多项目多窗口切换</p><p>windows下:<br>    * ctrl+alt+[<br>    * ctrl+alt+]</p><p>mac下:<br>    * cmd+`</p><ol><li><p>删除光标所在行代码</p><p>idea快捷键： Ctrl+X</p><p>eclipse快捷键： Ctrl+D</p></li><li><p>复制光标所在行代码，或者鼠标选中的代码<br> idea快捷键： Ctrl+D<br> eclipse快捷键： Ctrl+Alt+上下键</p></li><li><p>切换代码大小写<br> idea： Ctrl+Shift+U<br> eclipse： Ctrl+Shift+X（大写） Ctrl+Shift+Y（小写）</p></li><li><p>关闭当前代码窗<br> idea： Ctrl+F4<br> eclipse： Ctrl+W</p></li><li><p>快速定位到上一次编辑的位置<br> idea： Ctrl+Alt+左右键<br> eclipse：Ctrl+Q</p></li><li><p>快速搜索类和接口<br> idea：Ctrl+Shift+R<br> eclipse：Ctrl+Shift+R</p></li><li><p>切换上一次的浏览栏<br> idea：Alt+左右键<br> eclipse：Alt+左右键</p></li><li><p>生成get，set方法<br> idea快捷键： Alt+insert<br> eclipse快捷键： Shift+Alt+S</p></li><li><p>格式化代码<br> idea：先Ctrl+A选择全部代码 然后 Ctrl+Alt+L<br> eclipse：先Ctrl+A选择全部代码 然后 Ctrl+I格式化代码</p></li><li><p>下上移动正行代码<br>idea：Shift+Ctrl+上下键<br>eclipse：Ctrl+Alt+上下键</p></li><li><p>接口快速进入实现方法<br>idea：鼠标放在接口方法上，然后快捷键 Ctrl+Alt+B 进入实现方法<br>eclipse：鼠标放在接口方法上，然后快捷Ctrl+鼠标右键，显示出来实现方法，点击进入</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Idea快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
