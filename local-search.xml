<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>coding部署博客流程</title>
    <link href="/2021/06/08/coding%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/06/08/coding%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo部署到coding的步骤"><a href="#Hexo部署到coding的步骤" class="headerlink" title="Hexo部署到coding的步骤"></a>Hexo部署到coding的步骤</h1><p>起因:我的博客系统一开始是部署在github pages和gitee pages中的,但因为换主题的缘故,所以在gitee上将项目删除进行重新配置,但因为gitee进行改造,导致竟然无法再次部署上去了,github上面因为国内网络原因,经常有登不上,各种加载慢的问题,所以找了几个代码管理平台,发现coding这个平台能用</p><p><img src="/img/web/gitee01.jpg"></p><h2 id="1-注册coding"><a href="#1-注册coding" class="headerlink" title="1) 注册coding"></a>1) 注册coding</h2><p>打开官网,照步骤进行注册即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>coding.net/<br></code></pre></td></tr></table></figure><h2 id="2-登录-创建项目"><a href="#2-登录-创建项目" class="headerlink" title="2) 登录,创建项目"></a>2) 登录,创建项目</h2><p>选DevOps</p><p><img src="/img/web/coding01.jpg"></p><p>coding这边项目这些没有什么讲究,随意即可</p><h2 id="3-修改hexo配置文件-编译hexo-push到coding新建项目上"><a href="#3-修改hexo配置文件-编译hexo-push到coding新建项目上" class="headerlink" title="3) 修改hexo配置文件,编译hexo,push到coding新建项目上"></a>3) 修改hexo配置文件,编译hexo,push到coding新建项目上</h2><h2 id="4-进行代码托管"><a href="#4-进行代码托管" class="headerlink" title="4) 进行代码托管"></a>4) 进行代码托管</h2><p>选择持续部署-&gt;网站托管</p><p><img src="/img/web/coding02.jpg"></p><p>首次使用需要选择第一个的腾讯云,进行实名腾讯云绑定和实名验证,使用腾讯云不需要去买腾讯云的云服务器和其它服务</p><p>(结合手机微信,输入姓名,身份证号后可以立刻验证成功)</p><p><img src="/img/web/coding03.jpg"></p><p>验证后完成后就可以部署,输入项目名,选择仓库,最后可以选择香港服务器,这样不用备案,广东地区测试网络还行</p><h2 id="5-计费标准"><a href="#5-计费标准" class="headerlink" title="5)计费标准"></a>5)计费标准</h2><p><font color="red" size="4">注意:coding这边首次部署静态项目,因为用了腾讯云的服务,首6个月免费,后面收费,按照官方文档,收费标准就博客这种访问量,一个月需要的最多可能也就一元以内</font></p><p>计费标准说明网页:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>help.coding.net<span class="hljs-regexp">/docs/</span>pages/price.html<span class="hljs-comment">#2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git提交不区分大小写&amp;Hexo博客重新部署</title>
    <link href="/2020/12/25/Git%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99&amp;Hexo%E5%8D%9A%E5%AE%A2%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/12/25/Git%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99&amp;Hexo%E5%8D%9A%E5%AE%A2%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="部署完成后发现分类功能本地4000端口正常但部署github上的发生page-not-found"><a href="#部署完成后发现分类功能本地4000端口正常但部署github上的发生page-not-found" class="headerlink" title="部署完成后发现分类功能本地4000端口正常但部署github上的发生page not found"></a>部署完成后发现分类功能本地4000端口正常但部署github上的发生page not found</h2><h3 id="1-本地项目配置区分大小写"><a href="#1-本地项目配置区分大小写" class="headerlink" title="1.本地项目配置区分大小写"></a>1.本地项目配置区分大小写</h3><p>在网上找了一下,原因是git提交的时候不区分大小写导致,所以需要在这个目录下<code>blog\.deploy_git\.git\config</code>进行修改</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ignorecase</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="2-全局开启"><a href="#2-全局开启" class="headerlink" title="2.全局开启"></a>2.全局开启</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.ignorecase <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="3-查看-找到core-ignorecase-false说明全局配置成功"><a href="#3-查看-找到core-ignorecase-false说明全局配置成功" class="headerlink" title="3.查看,找到core.ignorecase=false说明全局配置成功"></a>3.查看,找到core.ignorecase=false说明全局配置成功</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><h2 id="修改完成后-如果直接提交-会导致有有大写小写文件共存情况-所以需要清空github仓库重新部署-因为之前有过gitee直接删库导致gitee维护期间无法重新部署的情况-下面使用git命令进行操作"><a href="#修改完成后-如果直接提交-会导致有有大写小写文件共存情况-所以需要清空github仓库重新部署-因为之前有过gitee直接删库导致gitee维护期间无法重新部署的情况-下面使用git命令进行操作" class="headerlink" title="修改完成后,如果直接提交,会导致有有大写小写文件共存情况,所以需要清空github仓库重新部署,因为之前有过gitee直接删库导致gitee维护期间无法重新部署的情况,下面使用git命令进行操作"></a>修改完成后,如果直接提交,会导致有有大写小写文件共存情况,所以需要清空github仓库重新部署,因为之前有过gitee直接删库导致gitee维护期间无法重新部署的情况,下面使用git命令进行操作</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git rm *<br>git commit -m <span class="hljs-string">&quot;clean all files&quot;</span><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><p>操作后上github查看仓库,仓库已经被清空,然后就可以在本地路径执行hexo命令重新部署</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>清除缓存<br>hexo clean<br><span class="hljs-regexp">//</span>编译<br>hexo g<br><span class="hljs-regexp">//</span>部署<br>hexo d<br><span class="hljs-regexp">//</span>编译部署可以简写<br>hexo d -g<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dotNet卸载后无法进入桌面&amp;亚洲问题</title>
    <link href="/2020/12/25/dotNet%E5%8D%B8%E8%BD%BD%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2&amp;%E4%BA%9A%E6%B4%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/25/dotNet%E5%8D%B8%E8%BD%BD%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2&amp;%E4%BA%9A%E6%B4%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>远程给客户部署公司旧版本的ERP系统,但由于客户装的windows server版本安装.net4.6.2一直出问题,而我们公司这个ERP的报表插件没法在.net4.5上使用,照网上各种方法都尝试了,但依旧无法安装上,提示亚洲报错,照着一份教程卸载.net4.5后无法进入桌面</p><p>出去洗把脸后,找到下面方法抢救回来</p><p>Dism命令</p><p>核心模式core 变回完整模式 Full，用dism命令，具体命令如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">dism <span class="hljs-regexp">/online /</span>enable-feature <span class="hljs-regexp">/all /</span>featurename:servercore-fullserver <span class="hljs-regexp">/featurename:server-gui-shell /</span>featurename:server-gui-mgmt<br></code></pre></td></tr></table></figure><p>切记：每个“/”前有空格，否则会报错；还有enable-feature后面的 “all”必须加上，否则也会报错。</p><p>完成模式Full，切换为核心模式，可以使用“删除角色和功能”来卸载“用户界面和基础结构”功能，也可以通过命令来卸载，命令如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">dism <span class="hljs-regexp">/online /</span>disable-feature <span class="hljs-regexp">/all /</span>featurename:servercore-fullserver<br></code></pre></td></tr></table></figure><p>最后: 回到桌面依旧.net4.6.2无法 安装,更高版本也是一样出错,在微软.net论坛看到微软官方的人回应.net安装报亚洲问题是一些版本windows的问题,最后和客户沟通,部署的这台机器是新机器,所以建议那边安装windows server2016,然后就非常顺利,半小时内部署完成</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dotNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树笔记</title>
    <link href="/2019/05/01/rbtree%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/05/01/rbtree%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/cphoto/rbtree01.jpg" alt="红黑树笔记图"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习03-HTML&amp;CSS代码规范</title>
    <link href="/2019/05/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A003-HTML&amp;CSS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/2019/05/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A003-HTML&amp;CSS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><h4 id="HTML规范"><a href="#HTML规范" class="headerlink" title="HTML规范"></a>HTML规范</h4><p>基于 <a href="http://www.w3.org/">W3C</a>、<a href="https://developer.apple.com/">苹果开发者</a> 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。</p><h4 id="图片规范"><a href="#图片规范" class="headerlink" title="图片规范"></a>图片规范</h4><p>了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。</p><h4 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h4><p>统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>从 <code>目录</code>、<code>图片</code>、<code>HTML/CSS文件</code>、<code>ClassName</code> 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。</p><h2 id="2-HTML-规范"><a href="#2-HTML-规范" class="headerlink" title="2. HTML 规范"></a>2. HTML 规范</h2><h3 id="DOCTYPE-声明"><a href="#DOCTYPE-声明" class="headerlink" title="DOCTYPE 声明"></a>DOCTYPE 声明</h3><p>HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>HTML5标准模版</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>HTML5标准模版<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="页面语言lang"><a href="#页面语言lang" class="headerlink" title="页面语言lang"></a>页面语言lang</h3><p>推荐使用属性值 <code>cmn-Hans-CN</code>（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 <code>zh-CN</code> 属性值</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;html <span class="hljs-attribute">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>更多地区语言参考：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">zh-SG</span> 中文 (简体, 新加坡)   对应 <span class="hljs-selector-tag">cmn-Hans-SG</span> 普通话 (简体, 新加坡)<br><span class="hljs-selector-tag">zh-HK</span> 中文 (繁体, 香港)     对应 <span class="hljs-selector-tag">cmn-Hant-HK</span> 普通话 (繁体, 香港)<br><span class="hljs-selector-tag">zh-MO</span> 中文 (繁体, 澳门)     对应 <span class="hljs-selector-tag">cmn-Hant-MO</span> 普通话 (繁体, 澳门)<br><span class="hljs-selector-tag">zh-TW</span> 中文 (繁体, 台湾)     对应 <span class="hljs-selector-tag">cmn-Hant-TW</span> 普通话 (繁体, 台湾)<br></code></pre></td></tr></table></figure><h3 id="charset-字符集合"><a href="#charset-字符集合" class="headerlink" title="charset 字符集合"></a>charset 字符集合</h3><p>一般情况下统一使用 “UTF-8” 编码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>由于历史原因，有些业务可能会使用 “GBK” 编码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;GBK&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 <a href="http://www.ietf.org/rfc/rfc3629">IETF对UTF-8的定义</a>，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。</p><h3 id="书写风格"><a href="#书写风格" class="headerlink" title="书写风格"></a>书写风格</h3><h4 id="HTML代码大小写"><a href="#HTML代码大小写" class="headerlink" title="HTML代码大小写"></a>HTML代码大小写</h4><p>HTML标签名、类名、标签属性和大部分属性值统一用小写</p><p><em>推荐：</em></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;DEMO&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>&lt;<span class="hljs-keyword">DIV</span> <span class="hljs-keyword">CLASS</span>=<span class="hljs-string">&quot;DEMO&quot;</span>&gt;&lt;/<span class="hljs-keyword">DIV</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含</p><p><em>推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><ul><li>元素属性值使用双引号语法</li><li>元素属性值可以写上的都写上</li></ul><p><em>推荐：</em></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot;&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;radio&quot; <span class="hljs-type">name</span>=&quot;name&quot; checked=&quot;checked&quot; &gt;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-type">text</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;text&#x27;</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;radio&quot; <span class="hljs-type">name</span>=&quot;name&quot; checked &gt;<br></code></pre></td></tr></table></figure><h3 id="特殊字符引用"><a href="#特殊字符引用" class="headerlink" title="特殊字符引用"></a>特殊字符引用</h3><p>文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。</p><p>在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</p><p><em>推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>more<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>more&gt;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="代码缩进"><a href="#代码缩进" class="headerlink" title="代码缩进"></a>代码缩进</h3><p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">jdc</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">a</span> <span class="hljs-symbol">href</span>=&quot;#&quot;&gt;&lt;/<span class="hljs-symbol">a</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="代码嵌套"><a href="#代码嵌套" class="headerlink" title="代码嵌套"></a>代码嵌套</h3><p>元素嵌套规范，每个块状元素独立一行，内联元素可选</p><p><em>推荐：</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;div&gt;</span><br>    <span class="hljs-section">&lt;h1&gt;</span><span class="hljs-section">&lt;/h1&gt;</span><br>    <span class="hljs-section">&lt;p&gt;</span><span class="hljs-section">&lt;/p&gt;</span><br><span class="hljs-section">&lt;/div&gt;</span><br><span class="hljs-section">&lt;p&gt;</span><span class="hljs-section">&lt;span&gt;</span><span class="hljs-section">&lt;/span&gt;</span><span class="hljs-section">&lt;span&gt;</span><span class="hljs-section">&lt;/span&gt;</span><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;div&gt;</span><br>    <span class="hljs-section">&lt;h1&gt;</span><span class="hljs-section">&lt;/h1&gt;</span><span class="hljs-section">&lt;p&gt;</span><span class="hljs-section">&lt;/p&gt;</span><br><span class="hljs-section">&lt;/div&gt;</span><br><span class="hljs-section">&lt;p&gt;</span> <br>    <span class="hljs-section">&lt;span&gt;</span><span class="hljs-section">&lt;/span&gt;</span><br>    <span class="hljs-section">&lt;span&gt;</span><span class="hljs-section">&lt;/span&gt;</span><br><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><p>段落元素与标题元素只能嵌套内联元素</p><p><em>推荐：</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;h1&gt;</span><span class="hljs-section">&lt;span&gt;</span><span class="hljs-section">&lt;/span&gt;</span><span class="hljs-section">&lt;/h1&gt;</span><br><span class="hljs-section">&lt;p&gt;</span><span class="hljs-section">&lt;span&gt;</span><span class="hljs-section">&lt;/span&gt;</span><span class="hljs-section">&lt;span&gt;</span><span class="hljs-section">&lt;/span&gt;</span><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;h1&gt;</span><span class="hljs-section">&lt;div&gt;</span><span class="hljs-section">&lt;/div&gt;</span><span class="hljs-section">&lt;/h1&gt;</span><br><span class="hljs-section">&lt;p&gt;</span><span class="hljs-section">&lt;div&gt;</span><span class="hljs-section">&lt;/div&gt;</span><span class="hljs-section">&lt;div&gt;</span><span class="hljs-section">&lt;/div&gt;</span><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-图片规范"><a href="#3-图片规范" class="headerlink" title="3. 图片规范"></a>3. 图片规范</h2><h3 id="内容图"><a href="#内容图" class="headerlink" title="内容图"></a>内容图</h3><p>内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大</p><ul><li>优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式</li><li>尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大</li><li><strong>PC平台单张的图片的大小不应大于 200KB。</strong></li></ul><h3 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h3><p>背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片</p><ul><li>PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率</li><li>图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式</li><li>图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式</li><li>图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式</li><li>条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式</li></ul><h2 id="4-CSS规范"><a href="#4-CSS规范" class="headerlink" title="4. CSS规范"></a>4. CSS规范</h2><h3 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h3><p>样式书写一般有两种：一种是紧凑格式 (Compact)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span>&#123; <span class="hljs-attribute">display</span>: block;<span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;&#125;<br></code></pre></td></tr></table></figure><p>一种是展开格式（Expanded）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>团队约定</strong></p><p>统一使用展开格式书写样式</p><h3 id="代码大小写"><a href="#代码大小写" class="headerlink" title="代码大小写"></a>代码大小写</h3><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 推荐 */</span><br><span class="hljs-selector-class">.jdc</span>&#123;<br><span class="hljs-attribute">display</span>:block;<br>&#125;<br><br><span class="hljs-comment">/* 不推荐 */</span><br><span class="hljs-selector-class">.JDC</span>&#123;<br><span class="hljs-attribute">DISPLAY</span>:BLOCK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>尽量少用通用选择器 <code>*</code></li><li>不使用 ID 选择器</li><li>不使用无具体语义定义的标签选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 推荐 */</span><br><span class="hljs-selector-class">.jdc</span> &#123;&#125;<br><span class="hljs-selector-class">.jdc</span> <span class="hljs-selector-tag">li</span> &#123;&#125;<br><span class="hljs-selector-class">.jdc</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">p</span>&#123;&#125;<br><br><span class="hljs-comment">/* 不推荐 */</span><br>*&#123;&#125;<br><span class="hljs-selector-id">#jdc</span> &#123;&#125;<br><span class="hljs-selector-class">.jdc</span> <span class="hljs-selector-tag">div</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="代码缩进-1"><a href="#代码缩进-1" class="headerlink" title="代码缩进"></a>代码缩进</h3><p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>每个属性声明末尾都要加分号；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码易读性"><a href="#代码易读性" class="headerlink" title="代码易读性"></a>代码易读性</h3><p>左括号与类名之间一个空格，冒号与属性值之间一个空格</p><p><em>推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123; <br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span>&#123; <br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>逗号分隔的取值，逗号之后一个空格</p><p><em>推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">#333</span>, <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">#333</span>,<span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为单个css选择器或新申明开启新行</p><p><em>推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span>, <br><span class="hljs-selector-class">.jdc_logo</span>, <br><span class="hljs-selector-class">.jdc_hd</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0</span>;<br>&#125;<br><span class="hljs-selector-class">.nav</span>&#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span>,jdc_logo,<span class="hljs-selector-class">.jdc_hd</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0</span>;<br>&#125;<span class="hljs-selector-class">.nav</span>&#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0</p><p><em>推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>( <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.5</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>属性值十六进制数值能用简写的尽量用简写</p><p><em>推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不要为 <code>0</code> 指明单位</p><p><em>推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性值引号"><a href="#属性值引号" class="headerlink" title="属性值引号"></a>属性值引号</h3><p>css属性值需要用到引号时，统一使用单引号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 推荐 */</span><br><span class="hljs-selector-class">.jdc</span> &#123; <br><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Hiragino Sans GB&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* 不推荐 */</span><br><span class="hljs-selector-class">.jdc</span> &#123; <br><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Hiragino Sans GB&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性书写顺序"><a href="#属性书写顺序" class="headerlink" title="属性书写顺序"></a>属性书写顺序</h3><p>建议遵循以下顺序：</p><ol><li>布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li><li>自身属性：width / height / margin / padding / border / background</li><li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li><li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jdc</span> &#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">font-family</span>: Arial, <span class="hljs-string">&#x27;Helvetica Neue&#x27;</span>, Helvetica, sans-serif;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">5</span>);<br>    -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -o-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -ms-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.mozilla.org/css/base/content.css">mozilla官方属性顺序推荐</a></p><h2 id="命名规范-1"><a href="#命名规范-1" class="headerlink" title="命名规范"></a>命名规范</h2><p>由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。</p><h3 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h3><ul><li>项目文件夹：pinyougou</li><li>样式文件夹：css</li><li>脚本文件夹：js</li><li>样式类图片文件夹：img</li><li>产品类图片文件夹： upload</li><li>字体类文件夹： fonts</li></ul><h3 id="ClassName命名"><a href="#ClassName命名" class="headerlink" title="ClassName命名"></a>ClassName命名</h3><p>ClassName的命名应该尽量精短、明确，必须以<strong>字母开头命名</strong>，且<strong>全部字母为小写</strong>，单词之间<strong>统一使用下划线</strong> “_” 连接</p><p>.nav_top</p><h4 id="常用命名推荐"><a href="#常用命名推荐" class="headerlink" title="常用命名推荐"></a>常用命名推荐</h4><p><strong>注意</strong>：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;ad&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>这种广告的英文或拼音类名不应该出现</p><p>另外，<strong>敏感不和谐字眼</strong>也不应该出现，如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;fuck&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;jer&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;sm&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;gcd&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt; <br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;ass&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt; <br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;KMT&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt; <br>...<br></code></pre></td></tr></table></figure><table><thead><tr><th>ClassName</th><th>含义</th></tr></thead><tbody><tr><td>about</td><td>关于</td></tr><tr><td>account</td><td>账户</td></tr><tr><td>arrow</td><td>箭头图标</td></tr><tr><td>article</td><td>文章</td></tr><tr><td>aside</td><td>边栏</td></tr><tr><td>audio</td><td>音频</td></tr><tr><td>avatar</td><td>头像</td></tr><tr><td>bg,background</td><td>背景</td></tr><tr><td>bar</td><td>栏（工具类）</td></tr><tr><td>branding</td><td>品牌化</td></tr><tr><td>crumb,breadcrumbs</td><td>面包屑</td></tr><tr><td>btn,button</td><td>按钮</td></tr><tr><td>caption</td><td>标题，说明</td></tr><tr><td>category</td><td>分类</td></tr><tr><td>chart</td><td>图表</td></tr><tr><td>clearfix</td><td>清除浮动</td></tr><tr><td>close</td><td>关闭</td></tr><tr><td>col,column</td><td>列</td></tr><tr><td>comment</td><td>评论</td></tr><tr><td>community</td><td>社区</td></tr><tr><td>container</td><td>容器</td></tr><tr><td>content</td><td>内容</td></tr><tr><td>copyright</td><td>版权</td></tr><tr><td>current</td><td>当前态，选中态</td></tr><tr><td>default</td><td>默认</td></tr><tr><td>description</td><td>描述</td></tr><tr><td>details</td><td>细节</td></tr><tr><td>disabled</td><td>不可用</td></tr><tr><td>entry</td><td>文章，博文</td></tr><tr><td>error</td><td>错误</td></tr><tr><td>even</td><td>偶数，常用于多行列表或表格中</td></tr><tr><td>fail</td><td>失败（提示）</td></tr><tr><td>feature</td><td>专题</td></tr><tr><td>fewer</td><td>收起</td></tr><tr><td>field</td><td>用于表单的输入区域</td></tr><tr><td>figure</td><td>图</td></tr><tr><td>filter</td><td>筛选</td></tr><tr><td>first</td><td>第一个，常用于列表中</td></tr><tr><td>footer</td><td>页脚</td></tr><tr><td>forum</td><td>论坛</td></tr><tr><td>gallery</td><td>画廊</td></tr><tr><td>group</td><td>模块，清除浮动</td></tr><tr><td>header</td><td>页头</td></tr><tr><td>help</td><td>帮助</td></tr><tr><td>hide</td><td>隐藏</td></tr><tr><td>hightlight</td><td>高亮</td></tr><tr><td>home</td><td>主页</td></tr><tr><td>icon</td><td>图标</td></tr><tr><td>info,information</td><td>信息</td></tr><tr><td>last</td><td>最后一个，常用于列表中</td></tr><tr><td>links</td><td>链接</td></tr><tr><td>login</td><td>登录</td></tr><tr><td>logout</td><td>退出</td></tr><tr><td>logo</td><td>标志</td></tr><tr><td>main</td><td>主体</td></tr><tr><td>menu</td><td>菜单</td></tr><tr><td>meta</td><td>作者、更新时间等信息栏，一般位于标题之下</td></tr><tr><td>module</td><td>模块</td></tr><tr><td>more</td><td>更多（展开）</td></tr><tr><td>msg,message</td><td>消息</td></tr><tr><td>nav,navigation</td><td>导航</td></tr><tr><td>next</td><td>下一页</td></tr><tr><td>nub</td><td>小块</td></tr><tr><td>odd</td><td>奇数，常用于多行列表或表格中</td></tr><tr><td>off</td><td>鼠标离开</td></tr><tr><td>on</td><td>鼠标移过</td></tr><tr><td>output</td><td>输出</td></tr><tr><td>pagination</td><td>分页</td></tr><tr><td>pop,popup</td><td>弹窗</td></tr><tr><td>preview</td><td>预览</td></tr><tr><td>previous</td><td>上一页</td></tr><tr><td>primary</td><td>主要</td></tr><tr><td>progress</td><td>进度条</td></tr><tr><td>promotion</td><td>促销</td></tr><tr><td>rcommd,recommendations</td><td>推荐</td></tr><tr><td>reg,register</td><td>注册</td></tr><tr><td>save</td><td>保存</td></tr><tr><td>search</td><td>搜索</td></tr><tr><td>secondary</td><td>次要</td></tr><tr><td>section</td><td>区块</td></tr><tr><td>selected</td><td>已选</td></tr><tr><td>share</td><td>分享</td></tr><tr><td>show</td><td>显示</td></tr><tr><td>sidebar</td><td>边栏，侧栏</td></tr><tr><td>slide</td><td>幻灯片，图片切换</td></tr><tr><td>sort</td><td>排序</td></tr><tr><td>sub</td><td>次级的，子级的</td></tr><tr><td>submit</td><td>提交</td></tr><tr><td>subscribe</td><td>订阅</td></tr><tr><td>subtitle</td><td>副标题</td></tr><tr><td>success</td><td>成功（提示）</td></tr><tr><td>summary</td><td>摘要</td></tr><tr><td>tab</td><td>标签页</td></tr><tr><td>table</td><td>表格</td></tr><tr><td>txt,text</td><td>文本</td></tr><tr><td>thumbnail</td><td>缩略图</td></tr><tr><td>time</td><td>时间</td></tr><tr><td>tips</td><td>提示</td></tr><tr><td>title</td><td>标题</td></tr><tr><td>video</td><td>视频</td></tr><tr><td>wrap</td><td>容器，包，一般用于最外层</td></tr><tr><td>wrapper</td><td>容器，包，一般用于最外层</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习10-JavaScript高级</title>
    <link href="/2017/12/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A010-JavaScript%E9%AB%98%E7%BA%A7/"/>
    <url>/2017/12/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A010-JavaScript%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript高级第01天笔记"><a href="#JavaScript高级第01天笔记" class="headerlink" title="JavaScript高级第01天笔记"></a>JavaScript高级第01天笔记</h1><h2 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1.面向过程与面向对象"></a>1.面向过程与面向对象</h2><h3 id="1-1面向过程"><a href="#1-1面向过程" class="headerlink" title="1.1面向过程"></a>1.1面向过程</h3><ul><li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</li></ul><h3 id="1-2面向对象"><a href="#1-2面向对象" class="headerlink" title="1.2面向对象"></a>1.2面向对象</h3><ul><li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</li></ul><h3 id="1-3面向过程与面向对象对比"><a href="#1-3面向过程与面向对象对比" class="headerlink" title="1.3面向过程与面向对象对比"></a>1.3面向过程与面向对象对比</h3><table><thead><tr><th></th><th>面向过程</th><th>面向对象</th></tr></thead><tbody><tr><td>优点</td><td>性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</td><td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td></tr><tr><td>缺点</td><td>不易维护、不易复用、不易扩展</td><td>性能比面向过程低</td></tr></tbody></table><h2 id="2-对象与类"><a href="#2-对象与类" class="headerlink" title="2.对象与类"></a>2.对象与类</h2><h3 id="2-1对象"><a href="#2-1对象" class="headerlink" title="2.1对象"></a>2.1对象</h3><p>对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物</p><ul><li>属性：事物的特征，在对象中用属性来表示（常用名词）</li><li>方法：事物的行为，在对象中用方法来表示（常用动词）</li></ul><h4 id="2-1-1创建对象"><a href="#2-1-1创建对象" class="headerlink" title="2.1.1创建对象"></a>2.1.1创建对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//以下代码是对对象的复习</span><br><span class="hljs-comment">//字面量创建对象</span><br><span class="hljs-keyword">var</span> ldh = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;刘德华&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(ldh);<br><br><span class="hljs-comment">//构造函数创建对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br> &#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">//实例化对象</span><br><span class="hljs-built_in">console</span>.log(ldh);<br></code></pre></td></tr></table></figure><p>如上两行代码运行结果为:<img src="/img/webimg/js01/img3.png"></p><h3 id="2-2类"><a href="#2-2类" class="headerlink" title="2.2类"></a>2.2类</h3><ul><li>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象</li></ul><h4 id="2-2-1创建类"><a href="#2-2-1创建类" class="headerlink" title="2.2.1创建类"></a>2.2.1创建类</h4><ol><li>语法:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//步骤1 使用class关键字</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span> </span>&#123;<br>  <span class="hljs-comment">// class body</span><br>&#125;     <br><span class="hljs-comment">//步骤2使用定义的类创建实例  注意new关键字</span><br><span class="hljs-keyword">var</span> xx = <span class="hljs-keyword">new</span> name();     <br></code></pre></td></tr></table></figure><ol start="2"><li>示例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class  创建一个 明星类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br>  <span class="hljs-comment">// 类的共有属性放到 constructor 里面</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br>&#125;<br>  <span class="hljs-comment">// 2. 利用类创建对象 new</span><br>  <span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br>  <span class="hljs-built_in">console</span>.log(ldh);<br></code></pre></td></tr></table></figure><p>以上代码运行结果: </p><p><img src="/img/webimg/js01/img4.png"></p><p>通过结果我们可以看出,运行结果和使用构造函数方式一样</p><h4 id="2-2-2类创建添加属性和方法"><a href="#2-2-2类创建添加属性和方法" class="headerlink" title="2.2.2类创建添加属性和方法"></a>2.2.2类创建添加属性和方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 1. 创建类 class  创建一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br>    <span class="hljs-comment">// 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">uname, age</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.uname = uname;<br>      <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<span class="hljs-comment">//-------------------------------------------&gt;注意,方法与方法之间不需要添加逗号</span><br>    <span class="hljs-function"><span class="hljs-title">sing</span>(<span class="hljs-params">song</span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.uname + <span class="hljs-string">&#x27;唱&#x27;</span> + song);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 2. 利用类创建对象 new</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh); <span class="hljs-comment">// Star &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span><br>ldh.sing(<span class="hljs-string">&#x27;冰雨&#x27;</span>); <span class="hljs-comment">// 刘德华唱冰雨</span><br></code></pre></td></tr></table></figure><p> 以上代码运行结果:</p><p><img src="/img/webimg/js01/img5.png"></p><p><strong>注意哟:</strong></p><ol><li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li><li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li><li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</li><li>多个函数方法之间不需要添加逗号分隔</li><li>生成实例 new 不能省略</li><li>语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</li></ol><h4 id="2-2-3类的继承"><a href="#2-2-3类的继承" class="headerlink" title="2.2.3类的继承"></a>2.2.3类的继承</h4><ol><li>语法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;   <br>&#125; <br><br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Son</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;  <br>&#125;       <br></code></pre></td></tr></table></figure><ol start="2"><li>示例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">surname</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.surname= surname;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你的姓是&#x27;</span> + <span class="hljs-built_in">this</span>.surname);<br>       &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;  <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span><br>&#125;<br><span class="hljs-keyword">var</span> damao= <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;刘&#x27;</span>);<br>damao.say();      <span class="hljs-comment">//结果为 你的姓是刘</span><br></code></pre></td></tr></table></figure><p>以上代码运行结果:</p><p><img src="/img/webimg/js01/img6.png"></p><ul><li><p>子类使用super关键字访问父类的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义了父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.x = x;<br>   <span class="hljs-built_in">this</span>.y = y;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>&#125;<br> &#125;<br><span class="hljs-comment">//子元素继承父类</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">//使用super调用了父类中的构造函数</span><br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    son.sum(); <span class="hljs-comment">//结果为3</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong> </p><ol><li><p>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</p></li><li><p>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</p></li><li><p>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 父类有加法方法</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.x = x;<br>   <span class="hljs-built_in">this</span>.y = y;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>   &#125;<br> &#125;<br> <span class="hljs-comment">// 子类继承父类加法方法 同时 扩展减法方法</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br>   <span class="hljs-comment">// 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错</span><br>   <span class="hljs-built_in">super</span>(x, y);<br>   <span class="hljs-built_in">this</span>.x = x;<br>   <span class="hljs-built_in">this</span>.y = y;<br><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">subtract</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x - <span class="hljs-built_in">this</span>.y);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>son.subtract(); <span class="hljs-comment">//2</span><br>son.sum();<span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure><p>以上代码运行结果为:</p><p><img src="/img/webimg/js01/img7.png"></p></li><li><p>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</p><ol><li>constructor中的this指向的是new出来的实例对象 </li><li>自定义的方法,一般也指向的new出来的实例对象</li><li>绑定事件之后this指向的就是触发事件的事件源</li></ol></li><li><p>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象<img src="/img/webimg/js01/img2.png"></p><h2 id><a href="#" class="headerlink" title></a><img src="/img/webimg/js01/img1.png"></h2></li></ol></li></ul><h2 id="3-面向对象版tab-栏切换"><a href="#3-面向对象版tab-栏切换" class="headerlink" title="3.面向对象版tab 栏切换"></a>3.面向对象版tab 栏切换</h2><h3 id="3-1功能需求"><a href="#3-1功能需求" class="headerlink" title="3.1功能需求"></a>3.1功能需求</h3><ol><li>点击 tab栏,可以切换效果.</li><li>点击 + 号, 可以添加 tab 项和内容项.</li><li>点击 x 号, 可以删除当前的tab项和内容项.</li><li>双击tab项文字或者内容项文字可以修改里面的文字内容</li></ol><h3 id="3-2案例准备"><a href="#3-2案例准备" class="headerlink" title="3.2案例准备"></a>3.2案例准备</h3><ol><li>获取到标题元素</li><li>获取到内容元素</li><li>获取到删除的小按钮 x号</li><li>新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改)</li><li>时刻注意this的指向问题</li></ol><h3 id="3-3切换"><a href="#3-3切换" class="headerlink" title="3.3切换"></a>3.3切换</h3><ul><li><p>为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.lis[i].index = i;<br><span class="hljs-built_in">this</span>.lis[i].onclick = <span class="hljs-built_in">this</span>.toggleTab;<br></code></pre></td></tr></table></figure></li><li><p>使用排他,实现只有一个元素的显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">toggleTab</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">//将所有的标题与内容类样式全部移除</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.lis.length; i++) &#123;<br>    <span class="hljs-built_in">this</span>.lis[i].className = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.sections[i].className = <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>  <span class="hljs-comment">//为当前的标题添加激活样式</span><br>    <span class="hljs-built_in">this</span>.className = <span class="hljs-string">&#x27;liactive&#x27;</span>;<br>   <span class="hljs-comment">//为当前的内容添加激活样式</span><br>    that.sections[<span class="hljs-built_in">this</span>.index].className = <span class="hljs-string">&#x27;conactive&#x27;</span>;<br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4添加"><a href="#3-4添加" class="headerlink" title="3.4添加"></a>3.4添加</h3><ul><li><p>为添加按钮+ 绑定点击事件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.add.onclick = <span class="hljs-built_in">this</span>.addTab;<br></code></pre></td></tr></table></figure></li><li><p>实现标题与内容的添加,做好排他处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">addTab</span>(<span class="hljs-params"></span>)</span> &#123;<br>    that.clearClass();<br>    <span class="hljs-comment">// (1) 创建li元素和section元素 </span><br>    <span class="hljs-keyword">var</span> random = <span class="hljs-built_in">Math</span>.random();<br>    <span class="hljs-keyword">var</span> li = <span class="hljs-string">&#x27;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#x27;</span>;<br>    <span class="hljs-keyword">var</span> section = <span class="hljs-string">&#x27;&lt;section class=&quot;conactive&quot;&gt;测试 &#x27;</span> + random + <span class="hljs-string">&#x27;&lt;/section&gt;&#x27;</span>;<br>    <span class="hljs-comment">// (2) 把这两个元素追加到对应的父元素里面</span><br>    that.ul.insertAdjacentHTML(<span class="hljs-string">&#x27;beforeend&#x27;</span>, li);<br>    that.fsection.insertAdjacentHTML(<span class="hljs-string">&#x27;beforeend&#x27;</span>, section);<br>    that.init();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-5删除"><a href="#3-5删除" class="headerlink" title="3.5删除"></a>3.5删除</h3><ul><li><p>为元素的删除按钮x绑定点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.remove[i].onclick = <span class="hljs-built_in">this</span>.removeTab;<br></code></pre></td></tr></table></figure></li><li><p>获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">removeTab</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    e.stopPropagation(); <span class="hljs-comment">// 阻止冒泡 防止触发li 的切换点击事件</span><br>    <span class="hljs-keyword">var</span> index = <span class="hljs-built_in">this</span>.parentNode.index;<br>    <span class="hljs-built_in">console</span>.log(index);<br>    <span class="hljs-comment">// 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素</span><br>    that.lis[index].remove();<br>    that.sections[index].remove();<br>    that.init();<br>    <span class="hljs-comment">// 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.liactive&#x27;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态</span><br>    index--;<br>    <span class="hljs-comment">// 手动调用我们的点击事件  不需要鼠标触发</span><br>    that.lis[index] &amp;&amp; that.lis[index].click();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-6编辑"><a href="#3-6编辑" class="headerlink" title="3.6编辑"></a>3.6编辑</h3><ul><li><p>为元素(标题与内容)绑定双击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.spans[i].ondblclick = <span class="hljs-built_in">this</span>.editTab;<br><span class="hljs-built_in">this</span>.sections[i].ondblclick = <span class="hljs-built_in">this</span>.editTab;<br></code></pre></td></tr></table></figure></li><li><p>在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">editTab</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">var</span> str = <span class="hljs-built_in">this</span>.innerHTML;<br>    <span class="hljs-comment">// 双击禁止选定文字</span><br>    <span class="hljs-built_in">window</span>.getSelection ? <span class="hljs-built_in">window</span>.getSelection().removeAllRanges() :     <span class="hljs-built_in">document</span>.selection.empty();<br>    <span class="hljs-comment">// alert(11);</span><br>      <span class="hljs-built_in">this</span>.innerHTML = <span class="hljs-string">&#x27;&lt;input type=&quot;text&quot; /&gt;&#x27;</span>;<br>      <span class="hljs-keyword">var</span> input = <span class="hljs-built_in">this</span>.children[<span class="hljs-number">0</span>];<br>      input.value = str;<br>      input.select(); <span class="hljs-comment">// 文本框里面的文字处于选定状态</span><br>      <span class="hljs-comment">// 当我们离开文本框就把文本框里面的值给span </span><br>      input.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">this</span>.parentNode.innerHTML = <span class="hljs-built_in">this</span>.value;<br>      &#125;;<br>      <span class="hljs-comment">// 按下回车也可以把文本框里面的值给span</span><br>      input.onkeyup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">13</span>) &#123;<br>      <span class="hljs-comment">// 手动调用表单失去焦点事件  不需要鼠标离开操作</span><br>      <span class="hljs-built_in">this</span>.blur();<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="JavaScript高级第02天笔记"><a href="#JavaScript高级第02天笔记" class="headerlink" title="JavaScript高级第02天笔记"></a>JavaScript高级第02天笔记</h1><h2 id="1-构造函数和原型"><a href="#1-构造函数和原型" class="headerlink" title="1.构造函数和原型"></a>1.构造函数和原型</h2><h3 id="1-1对象的三种创建方式–复习"><a href="#1-1对象的三种创建方式–复习" class="headerlink" title="1.1对象的三种创建方式–复习"></a>1.1对象的三种创建方式–复习</h3><ol><li><p>字面量方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br></code></pre></td></tr></table></figure></li><li><p>new关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure></li><li><p>构造函数方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2静态成员和实例成员"><a href="#1-2静态成员和实例成员" class="headerlink" title="1.2静态成员和实例成员"></a>1.2静态成员和实例成员</h3><h4 id="1-2-1实例成员"><a href="#1-2-1实例成员" class="headerlink" title="1.2.1实例成员"></a>1.2.1实例成员</h4><p>实例成员就是构造函数内部通过this添加的成员 如下列代码中uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.uname = uname;<br>     <span class="hljs-built_in">this</span>.age = age;<br>     <span class="hljs-built_in">this</span>.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh.uname);<span class="hljs-comment">//实例成员只能通过实例化的对象来访问</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2静态成员"><a href="#1-2-2静态成员" class="headerlink" title="1.2.2静态成员"></a>1.2.2静态成员</h4><p>静态成员 在构造函数本身上添加的成员  如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.uname = uname;<br>     <span class="hljs-built_in">this</span>.age = age;<br>     <span class="hljs-built_in">this</span>.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>    &#125;<br>&#125;<br>Star.sex = <span class="hljs-string">&#x27;男&#x27;</span>;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(Star.sex);<span class="hljs-comment">//静态成员只能通过构造函数来访问</span><br></code></pre></td></tr></table></figure><h3 id="1-3构造函数的问题"><a href="#1-3构造函数的问题" class="headerlink" title="1.3构造函数的问题"></a>1.3构造函数的问题</h3><p>构造函数方法很好用，但是存在浪费内存的问题。</p><p><img src="/img/webimg/js02/img1.png"></p><h3 id="1-4构造函数原型prototype"><a href="#1-4构造函数原型prototype" class="headerlink" title="1.4构造函数原型prototype"></a>1.4构造函数原型prototype</h3><p>构造函数通过原型分配的函数是所有对象所共享的。</p><p>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.uname = uname;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Star.prototype.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">var</span> zxy = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;张学友&#x27;</span>, <span class="hljs-number">19</span>);<br>ldh.sing();<span class="hljs-comment">//我会唱歌</span><br>zxy.sing();<span class="hljs-comment">//我会唱歌</span><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js02/img7.png"></p><h3 id="1-5对象原型"><a href="#1-5对象原型" class="headerlink" title="1.5对象原型"></a>1.5对象原型</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。<br>__proto__对象原型和原型对象 prototype 是等价的<br>__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype<br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js02/img2.png"></p><p><img src="/img/webimg/js02/img3.png"></p><h3 id="1-6constructor构造函数"><a href="#1-6constructor构造函数" class="headerlink" title="1.6constructor构造函数"></a>1.6constructor构造函数</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。<br>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。<br>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。<br></code></pre></td></tr></table></figure><p>如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.uname = uname;<br>     <span class="hljs-built_in">this</span>.age = age;<br> &#125;<br> <span class="hljs-comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数</span><br> Star.prototype = &#123;<br> <span class="hljs-comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span><br>   <span class="hljs-attr">constructor</span>: Star, <span class="hljs-comment">// 手动设置指回原来的构造函数</span><br>   <span class="hljs-attr">sing</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>   &#125;,<br>   <span class="hljs-attr">movie</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会演电影&#x27;</span>);<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> zxy = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;张学友&#x27;</span>, <span class="hljs-number">19</span>);<br><span class="hljs-built_in">console</span>.log(zxy)<br></code></pre></td></tr></table></figure><p>以上代码运行结果,设置constructor属性如图:</p><p><img src="/img/webimg/js02/img8.png">如果未设置constructor属性,如图:</p><p><img src="/img/webimg/js02/img9.png"></p><h3 id="1-7原型链"><a href="#1-7原型链" class="headerlink" title="1.7原型链"></a>1.7原型链</h3><p>​    每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。</p><p><img src="/img/webimg/js02/img5.png"></p><h3 id="1-8构造函数实例和原型对象三角关系"><a href="#1-8构造函数实例和原型对象三角关系" class="headerlink" title="1.8构造函数实例和原型对象三角关系"></a>1.8构造函数实例和原型对象三角关系</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span>构造函数的prototype属性指向了构造函数原型对象<br><span class="hljs-number">2.</span>实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象<br><span class="hljs-number">3.</span>构造函数的原型对象的<span class="hljs-title">constructor</span>属性指向了构造函数,实例对象的原型的<span class="hljs-title">constructor</span>属性也指向了构造函数<br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js02/img4.png"></p><h3 id="1-9原型链和成员的查找机制"><a href="#1-9原型链和成员的查找机制" class="headerlink" title="1.9原型链和成员的查找机制"></a>1.9原型链和成员的查找机制</h3><p>任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。<br>如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。<br>如果还没有就查找原型对象的原型（Object的原型对象）。<br>依此类推一直找到 Object 为止（null）。<br>__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。<br></code></pre></td></tr></table></figure><h3 id="1-10原型对象中this指向"><a href="#1-10原型对象中this指向" class="headerlink" title="1.10原型对象中this指向"></a>1.10原型对象中this指向</h3><p>构造函数中的this和原型对象的this,都指向我们new出来的实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.uname = uname;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">var</span> that;<br>Star.prototype.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>    that = <span class="hljs-built_in">this</span>;<br>&#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 1. 在构造函数中,里面this指向的是对象实例 ldh</span><br><span class="hljs-built_in">console</span>.log(that === ldh);<span class="hljs-comment">//true</span><br><span class="hljs-comment">// 2.原型对象函数里面的this 指向的是 实例对象 ldh</span><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js02/img6.png"></p><h3 id="1-11通过原型为数组扩展内置方法"><a href="#1-11通过原型为数组扩展内置方法" class="headerlink" title="1.11通过原型为数组扩展内置方法"></a>1.11通过原型为数组扩展内置方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>  sum += <span class="hljs-built_in">this</span>[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;;<br><span class="hljs-comment">//此时数组对象中已经存在sum()方法了  可以始终 数组.sum()进行数据的求</span><br></code></pre></td></tr></table></figure><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h2><h3 id="2-1call"><a href="#2-1call" class="headerlink" title="2.1call()"></a>2.1call()</h3><ul><li>call()可以调用函数</li><li>call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向,参数2,参数3..使用逗号隔开连接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>     <span class="hljs-built_in">console</span>.log(x + y);<br>&#125;<br>  <span class="hljs-keyword">var</span> o = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy&#x27;</span><br>  &#125;;<br>  fn.call(o, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//调用了函数此时的this指向了对象o,</span><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js02/img10.png"></p><h3 id="2-2子构造函数继承父构造函数中的属性"><a href="#2-2子构造函数继承父构造函数中的属性" class="headerlink" title="2.2子构造函数继承父构造函数中的属性"></a>2.2子构造函数继承父构造函数中的属性</h3><ol><li>先定义一个父构造函数</li><li>再定义一个子构造函数</li><li>子构造函数继承父构造函数的属性(使用call方法)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 1. 父构造函数</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>   <span class="hljs-comment">// this 指向父构造函数的对象实例</span><br>   <span class="hljs-built_in">this</span>.uname = uname;<br>   <span class="hljs-built_in">this</span>.age = age;<br> &#125;<br>  <span class="hljs-comment">// 2 .子构造函数 </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">uname, age, score</span>) </span>&#123;<br>  <span class="hljs-comment">// this 指向子构造函数的对象实例</span><br>  <span class="hljs-number">3.</span>使用call方式实现子继承父的属性<br>  Father.call(<span class="hljs-built_in">this</span>, uname, age);<br>  <span class="hljs-built_in">this</span>.score = score;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">console</span>.log(son);<br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js02/img11.png"></p><h3 id="2-3借用原型对象继承方法"><a href="#2-3借用原型对象继承方法" class="headerlink" title="2.3借用原型对象继承方法"></a>2.3借用原型对象继承方法</h3><ol><li>先定义一个父构造函数</li><li>再定义一个子构造函数</li><li>子构造函数继承父构造函数的属性(使用call方法)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 父构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>  <span class="hljs-comment">// this 指向父构造函数的对象实例</span><br>  <span class="hljs-built_in">this</span>.uname = uname;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Father.prototype.money = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">100000</span>);<br> &#125;;<br> <span class="hljs-comment">// 2 .子构造函数 </span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">uname, age, score</span>) </span>&#123;<br>      <span class="hljs-comment">// this 指向子构造函数的对象实例</span><br>      Father.call(<span class="hljs-built_in">this</span>, uname, age);<br>      <span class="hljs-built_in">this</span>.score = score;<br>  &#125;<br><span class="hljs-comment">// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化</span><br>  Son.prototype = <span class="hljs-keyword">new</span> Father();<br>  <span class="hljs-comment">// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数</span><br>  Son.prototype.constructor = Son;<br>  <span class="hljs-comment">// 这个是子构造函数专门的方法</span><br>  Son.prototype.exam = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;孩子要考试&#x27;</span>);<br><br>  &#125;<br>  <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">console</span>.log(son);<br></code></pre></td></tr></table></figure><p>如上代码结果如图:</p><p><img src="/img/webimg/js02/img12.png"></p><h2 id="3-ES5新增方法"><a href="#3-ES5新增方法" class="headerlink" title="3.ES5新增方法"></a>3.ES5新增方法</h2><h3 id="3-1数组方法forEach遍历数组"><a href="#3-1数组方法forEach遍历数组" class="headerlink" title="3.1数组方法forEach遍历数组"></a>3.1数组方法forEach遍历数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array</span>) </span>&#123;<br>      <span class="hljs-comment">//参数一是:数组元素</span><br>      <span class="hljs-comment">//参数二是:数组元素的索引</span><br>      <span class="hljs-comment">//参数三是:当前的数组</span><br>&#125;)<br> <span class="hljs-comment">//相当于数组遍历的 for循环 没有返回值</span><br></code></pre></td></tr></table></figure><h3 id="3-2数组方法filter过滤数组"><a href="#3-2数组方法filter过滤数组" class="headerlink" title="3.2数组方法filter过滤数组"></a>3.2数组方法filter过滤数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>, <span class="hljs-number">66</span>, <span class="hljs-number">4</span>, <span class="hljs-number">88</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];<br><span class="hljs-keyword">var</span> newArr = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index,array</span>) </span>&#123;<br> <span class="hljs-comment">//参数一是:数组元素</span><br>   <span class="hljs-comment">//参数二是:数组元素的索引</span><br>   <span class="hljs-comment">//参数三是:当前的数组</span><br>   <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">20</span>;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(newArr);<span class="hljs-comment">//[66,88] //返回值是一个新数组</span><br></code></pre></td></tr></table></figure><h3 id="3-3数组方法some"><a href="#3-3数组方法some" class="headerlink" title="3.3数组方法some"></a>3.3数组方法some</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">some 查找数组中是否有满足条件的元素 <br> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">4</span>];<br> <span class="hljs-keyword">var</span> flag = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,array</span>) </span>&#123;<br>    <span class="hljs-comment">//参数一是:数组元素</span><br>     <span class="hljs-comment">//参数二是:数组元素的索引</span><br>     <span class="hljs-comment">//参数三是:当前的数组</span><br>     <span class="hljs-keyword">return</span> value &lt; <span class="hljs-number">3</span>;<br>  &#125;);<br><span class="hljs-built_in">console</span>.log(flag);<span class="hljs-comment">//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环</span><br></code></pre></td></tr></table></figure><h3 id="3-4筛选商品案例"><a href="#3-4筛选商品案例" class="headerlink" title="3.4筛选商品案例"></a>3.4筛选商品案例</h3><ol><li><p>定义数组对象数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [&#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;小米&#x27;</span>,<br>            <span class="hljs-attr">price</span>: <span class="hljs-number">3999</span><br>        &#125;, &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;oppo&#x27;</span>,<br>            <span class="hljs-attr">price</span>: <span class="hljs-number">999</span><br>        &#125;, &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,<br>            <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;荣耀&#x27;</span>,<br>            <span class="hljs-attr">price</span>: <span class="hljs-number">1299</span><br>        &#125;, &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>,<br>            <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;华为&#x27;</span>,<br>            <span class="hljs-attr">price</span>: <span class="hljs-number">1999</span><br>        &#125;, ];<br></code></pre></td></tr></table></figure></li><li><p>使用forEach遍历数据并渲染到页面中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> tr = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;tr&#x27;</span>);<br>  tr.innerHTML = <span class="hljs-string">&#x27;&lt;td&gt;&#x27;</span> + value.id + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span> + value.pname + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span> + value.price + <span class="hljs-string">&#x27;&lt;/td&gt;&#x27;</span>;<br>  tbody.appendChild(tr);<br> &#125;);<br></code></pre></td></tr></table></figure></li><li><p>根据价格筛选数据</p><ol><li><p>获取到搜索按钮并为其绑定点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">search_price.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>使用filter将用户输入的价格信息筛选出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">search_price.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> newDate = data.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-comment">//start.value是开始区间</span><br>        <span class="hljs-comment">//end.value是结束的区间</span><br>      <span class="hljs-keyword">return</span> value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value;<br>      &#125;);<br>      <span class="hljs-built_in">console</span>.log(newDate);<br> &#125;);<br></code></pre></td></tr></table></figure></li><li><p>将筛选出来的数据重新渲染到表格中</p><ol><li><p>将渲染数据的逻辑封装到一个函数中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDate</span>(<span class="hljs-params">mydata</span>) </span>&#123;<br>      <span class="hljs-comment">// 先清空原来tbody 里面的数据</span><br>  tbody.innerHTML = <span class="hljs-string">&#x27;&#x27;</span>;<br>  mydata.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> tr = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;tr&#x27;</span>);<br>    tr.innerHTML = <span class="hljs-string">&#x27;&lt;td&gt;&#x27;</span> + value.id + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span> + value.pname + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span> + value.price + <span class="hljs-string">&#x27;&lt;/td&gt;&#x27;</span>;<br>      tbody.appendChild(tr);<br>  &#125;);<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>将筛选之后的数据重新渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"> search_price.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">var</span> newDate = data.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value;<br>     &#125;);<br>     <span class="hljs-built_in">console</span>.log(newDate);<br>     <span class="hljs-comment">// 把筛选完之后的对象渲染到页面中</span><br>     setDate(newDate);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol></li><li><p>根据商品名称筛选</p><ol><li><p>获取用户输入的商品名称</p></li><li><p>为查询按钮绑定点击事件,将输入的商品名称与这个数据进行筛选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"> search_pro.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">var</span> arr = [];<br>     data.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>       <span class="hljs-keyword">if</span> (value.pname === product.value) &#123;<br>         <span class="hljs-comment">// console.log(value);</span><br>         arr.push(value);<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// return 后面必须写true  </span><br>       &#125;<br>     &#125;);<br>     <span class="hljs-comment">// 把拿到的数据渲染到页面中</span><br>     setDate(arr);<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="3-5some和forEach区别"><a href="#3-5some和forEach区别" class="headerlink" title="3.5some和forEach区别"></a>3.5some和forEach区别</h3><ul><li>如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高</li><li>在forEach 里面 return 不会终止迭代</li></ul><h3 id="3-6trim方法去除字符串两端的空格"><a href="#3-6trim方法去除字符串两端的空格" class="headerlink" title="3.6trim方法去除字符串两端的空格"></a>3.6trim方法去除字符串两端的空格</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;   hello   &#x27;</span><br><span class="hljs-built_in">console</span>.log(str.trim()）  <span class="hljs-comment">//hello 去除两端空格</span><br><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&#x27;   he l l o   &#x27;</span><br><span class="hljs-built_in">console</span>.log(str.trim()）  <span class="hljs-comment">//he l l o  去除两端空格</span><br></code></pre></td></tr></table></figure><h3 id="3-7获取对象的属性名"><a href="#3-7获取对象的属性名" class="headerlink" title="3.7获取对象的属性名"></a>3.7获取对象的属性名</h3><p>Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> obj = &#123;<br>     <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>     <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;小米&#x27;</span>,<br>     <span class="hljs-attr">price</span>: <span class="hljs-number">1999</span>,<br>     <span class="hljs-attr">num</span>: <span class="hljs-number">2000</span><br>&#125;;<br><span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Object</span>.keys(obj)<br><span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">//[id，pname,price,num]</span><br></code></pre></td></tr></table></figure><h3 id="3-8Object-defineProperty"><a href="#3-8Object-defineProperty" class="headerlink" title="3.8Object.defineProperty"></a>3.8Object.defineProperty</h3><p>Object.defineProperty设置或修改对象中的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(对象，修改或新增的属性名，&#123;<br><span class="hljs-attr">value</span>:修改或新增的属性的值,<br><span class="hljs-attr">writable</span>:<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>,<span class="hljs-comment">//如果值为false 不允许修改这个属性值</span><br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">//enumerable 如果值为false 则不允许遍历</span><br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>  <span class="hljs-comment">//configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性</span><br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="JavaScript高级第03天笔记"><a href="#JavaScript高级第03天笔记" class="headerlink" title="JavaScript高级第03天笔记"></a>JavaScript高级第03天笔记</h1><h2 id="1-函数的定义和调用"><a href="#1-函数的定义和调用" class="headerlink" title="1.函数的定义和调用"></a>1.函数的定义和调用</h2><h3 id="1-1函数的定义方式"><a href="#1-1函数的定义方式" class="headerlink" title="1.1函数的定义方式"></a>1.1函数的定义方式</h3><ol><li><p>方式1 函数声明方式 function 关键字 (命名函数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式2 函数表达式(匿名函数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式3 new Function() </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;console.log(a + b)&#x27;</span>);<br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;参数1&#x27;</span>,<span class="hljs-string">&#x27;参数2&#x27;</span>..., <span class="hljs-string">&#x27;函数体&#x27;</span>)<br>注意<br><span class="hljs-comment">/*Function 里面参数都必须是字符串格式</span><br><span class="hljs-comment">第三种方式执行效率低，也不方便书写，因此较少使用</span><br><span class="hljs-comment">所有函数都是 Function 的实例(对象)  </span><br><span class="hljs-comment">函数也属于对象</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2函数的调用"><a href="#1-2函数的调用" class="headerlink" title="1.2函数的调用"></a>1.2函数的调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 1. 普通函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;人生的巅峰&#x27;</span>);<br>&#125;<br> fn(); <br><span class="hljs-comment">/* 2. 对象的方法 */</span><br><span class="hljs-keyword">var</span> o = &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;人生的巅峰&#x27;</span>);<br>  &#125;<br>&#125;<br>o.sayHi();<br><span class="hljs-comment">/* 3. 构造函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">new</span> Star();<br><span class="hljs-comment">/* 4. 绑定事件函数*/</span><br> btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;   <span class="hljs-comment">// 点击了按钮就可以调用这个函数</span><br><span class="hljs-comment">/* 5. 定时器函数*/</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-number">1000</span>);  这个函数是定时器自动<span class="hljs-number">1</span>秒钟调用一次<br><span class="hljs-comment">/* 6. 立即执行函数(自调用函数)*/</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;人生的巅峰&#x27;</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="2-this"><a href="#2-this" class="headerlink" title="2.this"></a>2.this</h2><h3 id="2-1函数内部的this指向"><a href="#2-1函数内部的this指向" class="headerlink" title="2.1函数内部的this指向"></a>2.1函数内部的this指向</h3><p>这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同</p><p>一般指向我们的调用者.</p><p><img src="/img/webimg/js03/img1.png"></p><h3 id="2-2改变函数内部-this-指向"><a href="#2-2改变函数内部-this-指向" class="headerlink" title="2.2改变函数内部 this 指向"></a>2.2改变函数内部 this 指向</h3><h4 id="2-2-1-call方法"><a href="#2-2-1-call方法" class="headerlink" title="2.2.1 call方法"></a>2.2.1 call方法</h4><p>call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向</p><p>应用场景:  经常做继承. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy&#x27;</span><br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-built_in">console</span>.log(a+b)<br>&#125;;<br>fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">// 此时的this指向的是window 运行结果为3</span><br>fn.call(o,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3</span><br></code></pre></td></tr></table></figure><p>以上代码运行结果为:</p><p><img src="/img/webimg/js03/img4.png"></p><h4 id="2-2-2-apply方法"><a href="#2-2-2-apply方法" class="headerlink" title="2.2.2 apply方法"></a>2.2.2 apply方法</h4><p>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</p><p>应用场景:  经常跟数组有关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy&#x27;</span><br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-built_in">console</span>.log(a+b)<br>&#125;;<br>fn()<span class="hljs-comment">// 此时的this指向的是window 运行结果为3</span><br>fn.apply(o,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<span class="hljs-comment">//此时的this指向的是对象o,参数使用数组传递 运行结果为3</span><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js03/img4.png"></p><h4 id="2-2-3-bind方法"><a href="#2-2-3-bind方法" class="headerlink" title="2.2.3 bind方法"></a>2.2.3 bind方法</h4><p>bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数</p><p>如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind</p><p>应用场景:不调用函数,但是还想改变this指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> o = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy&#x27;</span><br> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br><span class="hljs-built_in">console</span>.log(a + b);<br>&#125;;<br><span class="hljs-keyword">var</span> f = fn.bind(o, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//此处的f是bind返回的新函数</span><br>f();<span class="hljs-comment">//调用新函数  this指向的是对象o 参数使用逗号隔开</span><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js03/img5.png"></p><h4 id="2-2-4-call、apply、bind三者的异同"><a href="#2-2-4-call、apply、bind三者的异同" class="headerlink" title="2.2.4 call、apply、bind三者的异同"></a>2.2.4 call、apply、bind三者的异同</h4><ul><li>共同点 : 都可以改变this指向</li><li>不同点:<ul><li>call 和 apply  会调用函数, 并且改变函数内部this指向.</li><li>call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递</li><li>bind  不会调用函数, 可以改变函数内部this指向.</li></ul></li></ul><ul><li>应用场景<ol><li>call 经常做继承. </li><li>apply经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值</li><li>bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. </li></ol></li></ul><h2 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3.严格模式"></a>3.严格模式</h2><h3 id="3-1什么是严格模式"><a href="#3-1什么是严格模式" class="headerlink" title="3.1什么是严格模式"></a>3.1什么是严格模式</h3><p>JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。</p><p>严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p><p>严格模式对正常的 JavaScript 语义做了一些更改： </p><p>1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。</p><p>2.消除代码运行的一些不安全之处，保证代码运行的安全。</p><p>3.提高编译器效率，增加运行速度。</p><p>4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名</p><h3 id="3-2开启严格模式"><a href="#3-2开启严格模式" class="headerlink" title="3.2开启严格模式"></a>3.2开启严格模式</h3><p>严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。</p><ul><li><p>情况一 :为脚本开启严格模式</p><ul><li><p>有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他<br>script 脚本文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">//在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式</span><br><span class="hljs-meta">　　　　&quot;use strict&quot;</span>;<br>       <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>　　　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;)();<br><span class="hljs-comment">//或者 </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta"></span></span></span><br><span class="hljs-meta"><span class="javascript"><span class="xml">  　&quot;use strict&quot;</span>; <span class="hljs-comment">//当前script标签开启了严格模式</span></span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">//当前script标签未开启严格模式</span></span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>情况二: 为函数开启严格模式</p><ul><li><p>要给某个函数开启严格模式，需要把“use strict”;  (或 ‘use strict’; ) 声明放在函数体所有语句之前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">　　&quot;use strict&quot;</span>;<br>　　<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>;<br>&#125; <br><span class="hljs-comment">//当前fn函数开启了严格模式</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-3严格模式中的变化"><a href="#3-3严格模式中的变化" class="headerlink" title="3.3严格模式中的变化"></a>3.3严格模式中的变化</h3><p>严格模式对 Javascript 的语法和行为，都做了一些改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span><br>num = <span class="hljs-number">10</span> <br><span class="hljs-built_in">console</span>.log(num)<span class="hljs-comment">//严格模式后使用未声明的变量</span><br>--------------------------------------------------------------------------------<br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">delete</span> num2;<span class="hljs-comment">//严格模式不允许删除变量</span><br>--------------------------------------------------------------------------------<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 严格模式下全局作用域中函数中的 this 是 undefined</span><br>&#125;<br>fn();  <br>---------------------------------------------------------------------------------<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-built_in">this</span>.sex = <span class="hljs-string">&#x27;男&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// Star();严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错.</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star();<br><span class="hljs-built_in">console</span>.log(ldh.sex);<br>----------------------------------------------------------------------------------<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//严格模式下，定时器 this 还是指向 window</span><br>&#125;, <span class="hljs-number">2000</span>);  <br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">更多严格模式要求参考</a></p><h2 id="4-高阶函数"><a href="#4-高阶函数" class="headerlink" title="4.高阶函数"></a>4.高阶函数</h2><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p><p><img src="/img/webimg/js03/img2.png"></p><p>此时fn 就是一个高阶函数</p><p>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。</p><p>同理函数也可以作为返回值传递回来</p><h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5.闭包"></a>5.闭包</h2><h3 id="5-1变量的作用域复习"><a href="#5-1变量的作用域复习" class="headerlink" title="5.1变量的作用域复习"></a>5.1变量的作用域复习</h3><p>变量根据作用域的不同分为两种：全局变量和局部变量。</p><ol><li>函数内部可以使用全局变量。</li><li>函数外部不可以使用局部变量。</li><li>当函数执行完毕，本作用域内的局部变量会销毁。</li></ol><h3 id="5-2什么是闭包"><a href="#5-2什么是闭包" class="headerlink" title="5.2什么是闭包"></a>5.2什么是闭包</h3><p>闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 </p><p><img src="/img/webimg/js03/img3.png"></p><h3 id="5-3闭包的作用"><a href="#5-3闭包的作用" class="headerlink" title="5.3闭包的作用"></a>5.3闭包的作用</h3><p>作用：延伸变量的作用范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-built_in">console</span>.log(num);<br> &#125;<br>    <span class="hljs-keyword">return</span> fun;<br> &#125;<br><span class="hljs-keyword">var</span> f = fn();<br>f();<br></code></pre></td></tr></table></figure><h3 id="5-4闭包的案例"><a href="#5-4闭包的案例" class="headerlink" title="5.4闭包的案例"></a>5.4闭包的案例</h3><ol><li>利用闭包的方式得到当前li 的索引号</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br><span class="hljs-comment">// 利用for循环创建了4个立即执行函数</span><br><span class="hljs-comment">// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>    lis[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(i);<br>    &#125;<br> &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>闭包应用-3秒钟之后,打印所有li元素的内容</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br>   (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(lis[i].innerHTML);<br>     &#125;, <span class="hljs-number">3000</span>)<br>   &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>闭包应用-计算打车价格 </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*需求分析</span><br><span class="hljs-comment">打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格</span><br><span class="hljs-comment">如果有拥堵情况,总价格多收取10块钱拥堵费*/</span><br><br> <span class="hljs-keyword">var</span> car = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">var</span> start = <span class="hljs-number">13</span>; <span class="hljs-comment">// 起步价  局部变量</span><br>     <span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总价  局部变量</span><br>     <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-comment">// 正常的总价</span><br>       <span class="hljs-attr">price</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>         <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>           total = start;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>           total = start + (n - <span class="hljs-number">3</span>) * <span class="hljs-number">5</span><br>         &#125;<br>         <span class="hljs-keyword">return</span> total;<br>       &#125;,<br>       <span class="hljs-comment">// 拥堵之后的费用</span><br>       <span class="hljs-attr">yd</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flag</span>) </span>&#123;<br>         <span class="hljs-keyword">return</span> flag ? total + <span class="hljs-number">10</span> : total;<br>       &#125;<br>&#125;<br> &#125;)();<br><span class="hljs-built_in">console</span>.log(car.price(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 23</span><br><span class="hljs-built_in">console</span>.log(car.yd(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// 33</span><br></code></pre></td></tr></table></figure><h3 id="5-5案例"><a href="#5-5案例" class="headerlink" title="5.5案例"></a>5.5案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br>   <span class="hljs-keyword">var</span> object = &#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;My Object&quot;</span>,<br>     <span class="hljs-attr">getNameFunc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>     &#125;;<br>   &#125;<br> &#125;;<br><span class="hljs-built_in">console</span>.log(object.getNameFunc()())<br>-----------------------------------------------------------------------------------<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;　　<br>  <span class="hljs-keyword">var</span> object = &#123;　　　　<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;My Object&quot;</span>,<br>    <span class="hljs-attr">getNameFunc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> that.name;<br>    &#125;;<br>  &#125;<br>&#125;;<br><span class="hljs-built_in">console</span>.log(object.getNameFunc()())<br>       <br></code></pre></td></tr></table></figure><h2 id="6-递归"><a href="#6-递归" class="headerlink" title="6.递归"></a>6.递归</h2><h3 id="6-1什么是递归"><a href="#6-1什么是递归" class="headerlink" title="6.1什么是递归"></a>6.1什么是递归</h3><p><strong>递归：</strong>如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数</p><p><strong>注意：</strong>递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。</p><h3 id="6-2利用递归求1-n的阶乘"><a href="#6-2利用递归求1-n的阶乘" class="headerlink" title="6.2利用递归求1~n的阶乘"></a>6.2利用递归求1~n的阶乘</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">n</span>) </span>&#123;<br>     <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//结束条件</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> n * fn(n - <span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js03/img6.png"></p><h3 id="6-3利用递归求斐波那契数列"><a href="#6-3利用递归求斐波那契数列" class="headerlink" title="6.3利用递归求斐波那契数列"></a>6.3利用递归求斐波那契数列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...</span><br><span class="hljs-comment">// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值</span><br><span class="hljs-comment">// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fb</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span> || n === <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> fb(n - <span class="hljs-number">1</span>) + fb(n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(fb(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h3 id="6-4利用递归遍历数据"><a href="#6-4利用递归遍历数据" class="headerlink" title="6.4利用递归遍历数据"></a>6.4利用递归遍历数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 我们想要做输入id号,就可以返回的数据对象</span><br> <span class="hljs-keyword">var</span> data = [&#123;<br>   <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;家电&#x27;</span>,<br>   <span class="hljs-attr">goods</span>: [&#123;<br>     <span class="hljs-attr">id</span>: <span class="hljs-number">11</span>,<br>     <span class="hljs-attr">gname</span>: <span class="hljs-string">&#x27;冰箱&#x27;</span>,<br>     <span class="hljs-attr">goods</span>: [&#123;<br>       <span class="hljs-attr">id</span>: <span class="hljs-number">111</span>,<br>       <span class="hljs-attr">gname</span>: <span class="hljs-string">&#x27;海尔&#x27;</span><br>     &#125;, &#123;<br>       <span class="hljs-attr">id</span>: <span class="hljs-number">112</span>,<br>       <span class="hljs-attr">gname</span>: <span class="hljs-string">&#x27;美的&#x27;</span><br>     &#125;,<br><br>            ]<br><br>   &#125;, &#123;<br>     <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>,<br>     <span class="hljs-attr">gname</span>: <span class="hljs-string">&#x27;洗衣机&#x27;</span><br>   &#125;]<br> &#125;, &#123;<br>   <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;服饰&#x27;</span><br>&#125;];<br><span class="hljs-comment">//1.利用 forEach 去遍历里面的每一个对象</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getID</span>(<span class="hljs-params">json, id</span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> o = &#123;&#125;;<br>   json.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>     <span class="hljs-comment">// console.log(item); // 2个数组元素</span><br>     <span class="hljs-keyword">if</span> (item.id == id) &#123;<br>       <span class="hljs-comment">// console.log(item);</span><br>       o = item;<br>       <span class="hljs-keyword">return</span> o;<br>       <span class="hljs-comment">// 2. 我们想要得里层的数据 11 12 可以利用递归函数</span><br>       <span class="hljs-comment">// 里面应该有goods这个数组并且数组的长度不为 0 </span><br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.goods &amp;&amp; item.goods.length &gt; <span class="hljs-number">0</span>) &#123;<br>       o = getID(item.goods, id);<br>     &#125;<br>   &#125;);<br>   <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JavaScript高级第04天笔记"><a href="#JavaScript高级第04天笔记" class="headerlink" title="JavaScript高级第04天笔记"></a>JavaScript高级第04天笔记</h1><h2 id="1-正则表达式概述"><a href="#1-正则表达式概述" class="headerlink" title="1.正则表达式概述"></a>1.正则表达式概述</h2><h3 id="1-1什么是正则表达式"><a href="#1-1什么是正则表达式" class="headerlink" title="1.1什么是正则表达式"></a>1.1什么是正则表达式</h3><p>正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。</p><p>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。</p><p>其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。</p><h3 id="1-2-正则表达式的特点"><a href="#1-2-正则表达式的特点" class="headerlink" title="1.2 正则表达式的特点"></a>1.2 正则表达式的特点</h3><ol><li>灵活性、逻辑性和功能性非常的强。</li><li>可以迅速地用极简单的方式达到字符串的复杂控制。</li><li>对于刚接触的人来说，比较晦涩难懂。比如：^\w+([-+.]\w+)*@\w+([-.]\w+)<em>.\w+([-.]\w+)</em>$</li><li>实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式.   比如用户名:   /^[a-z0-9_-]{3,16}$/</li></ol><h2 id="2-正则表达式在js中的使用"><a href="#2-正则表达式在js中的使用" class="headerlink" title="2.正则表达式在js中的使用"></a>2.正则表达式在js中的使用</h2><h3 id="2-1正则表达式的创建"><a href="#2-1正则表达式的创建" class="headerlink" title="2.1正则表达式的创建"></a>2.1正则表达式的创建</h3><p>在 JavaScript 中，可以通过两种方式创建一个正则表达式。</p><p>方式一：通过调用RegExp对象的构造函数创建 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> regexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/123/</span>);<br><span class="hljs-built_in">console</span>.log(regexp);<br></code></pre></td></tr></table></figure><p>方式二：利用字面量创建 正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/123/</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2测试正则表达式"><a href="#2-2测试正则表达式" class="headerlink" title="2.2测试正则表达式"></a>2.2测试正则表达式</h3><p>test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/123/</span>;<br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-number">123</span>));<span class="hljs-comment">//匹配字符中是否出现123  出现结果为true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;abc&#x27;</span>));<span class="hljs-comment">//匹配字符中是否出现123 未出现结果为false</span><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js04/img4.png"></p><h2 id="3-正则表达式中的特殊字符"><a href="#3-正则表达式中的特殊字符" class="headerlink" title="3.正则表达式中的特殊字符"></a>3.正则表达式中的特殊字符</h2><h3 id="3-1正则表达式的组成"><a href="#3-1正则表达式的组成" class="headerlink" title="3.1正则表达式的组成"></a>3.1正则表达式的组成</h3><p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。</p><p>特殊字符非常多，可以参考： </p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN</a></p><p>jQuery 手册：正则表达式部分</p><p>[正则测试工具]( &lt;<a href="http://tool.oschina.net/regex">http://tool.oschina.net/regex</a>)</p><h3 id="3-2边界符"><a href="#3-2边界符" class="headerlink" title="3.2边界符"></a>3.2边界符</h3><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p><table><thead><tr><th>边界符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示匹配行首的文本（以谁开始）</td></tr><tr><td>$</td><td>表示匹配行尾的文本（以谁结束）</td></tr></tbody></table><p>如果 ^和 $ 在一起，表示必须是精确匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/abc/</span>; <span class="hljs-comment">// 正则表达式里面不需要加引号 不管是数字型还是字符串型</span><br><span class="hljs-comment">// /abc/ 只要包含有abc这个字符串返回的都是true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;abc&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;abcd&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;aabcd&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------&#x27;</span>);<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^abc/</span>;<br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;abcd&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;aabcd&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------&#x27;</span>);<br><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/^abc$/</span>; <span class="hljs-comment">// 精确匹配 要求必须是 abc字符串才符合规范</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abcd&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;aabcd&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abcabc&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="3-3字符类"><a href="#3-3字符类" class="headerlink" title="3.3字符类"></a>3.3字符类</h3><p>字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</p><h4 id="3-3-1-方括号"><a href="#3-3-1-方括号" class="headerlink" title="3.3.1 [] 方括号"></a>3.3.1 [] 方括号</h4><p>表示有一系列字符可供选择，只要匹配其中一个就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/[abc]/</span>; <span class="hljs-comment">// 只要包含有a 或者 包含有b 或者包含有c 都返回为true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;andy&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;baby&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;color&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;red&#x27;</span>));<span class="hljs-comment">//false</span><br><span class="hljs-keyword">var</span> rg1 = <span class="hljs-regexp">/^[abc]$/</span>; <span class="hljs-comment">// 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;aa&#x27;</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;b&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;c&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>));<span class="hljs-comment">//true</span><br>----------------------------------------------------------------------------------<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-z]$/</span> <span class="hljs-comment">//26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围  </span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;z&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;A&#x27;</span>));<span class="hljs-comment">//false</span><br>-----------------------------------------------------------------------------------<br><span class="hljs-comment">//字符组合</span><br><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/^[a-zA-Z0-9]$/</span>; <span class="hljs-comment">// 26个英文字母(大写和小写都可以)任何一个字母返回 true  </span><br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。</span><br><span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/^[^a-zA-Z0-9]$/</span>;<br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;B&#x27;</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-number">8</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;!&#x27;</span>));<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2量词符"><a href="#3-3-2量词符" class="headerlink" title="3.3.2量词符"></a>3.3.2量词符</h4><p>量词符用来设定某个模式出现的次数。</p><table><thead><tr><th>量词</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复0次或更多次</td></tr><tr><td>+</td><td>重复1次或更多次</td></tr><tr><td>?</td><td>重复0次或1次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h4 id="3-3-3用户名表单验证"><a href="#3-3-3用户名表单验证" class="headerlink" title="3.3.3用户名表单验证"></a>3.3.3用户名表单验证</h4><p>功能需求:</p><ol><li>如果用户名输入合法, 则后面提示信息为:  用户名合法,并且颜色为绿色</li><li>如果用户名输入不合法, 则后面提示信息为:  用户名不符合规范, 并且颜色为红色</li></ol><p><img src="/img/webimg/js04/img2.png"></p><p><img src="/img/webimg/js04/img1.png"></p><p>分析:</p><ol><li>用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为6~16位.</li><li>首先准备好这种正则表达式模式/$[a-zA-Z0-9-_]{6,16}^/</li><li>当表单失去焦点就开始验证. </li><li>如果符合正则规范, 则让后面的span标签添加 right类.</li><li>如果不符合正则规范, 则让后面的span标签添加 wrong类.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;uname&quot;</span>&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>请输入用户名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"> <span class="hljs-comment">//  量词是设定某个模式出现的次数</span></span></span><br><span class="javascript"><span class="xml"> <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z0-9_-]&#123;6,16&#125;$/</span>; <span class="hljs-comment">// 这个模式用户只能输入英文字母 数字 下划线 中划线</span></span></span><br><span class="javascript"><span class="xml"> <span class="hljs-keyword">var</span> uname = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.uname&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"> <span class="hljs-keyword">var</span> span = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;span&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"> uname.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-keyword">if</span> (reg.test(<span class="hljs-built_in">this</span>.value)) &#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;正确的&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">   span.className = <span class="hljs-string">&#x27;right&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">   span.innerHTML = <span class="hljs-string">&#x27;用户名格式输入正确&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">   &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;错误的&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">   span.className = <span class="hljs-string">&#x27;wrong&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">   span.innerHTML = <span class="hljs-string">&#x27;用户名格式输入不正确&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">   &#125;</span></span><br><span class="javascript"><span class="xml"> &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="3-3-4-括号总结"><a href="#3-3-4-括号总结" class="headerlink" title="3.3.4 括号总结"></a>3.3.4 括号总结</h4><p>1.大括号  量词符.  里面表示重复次数</p><p>2.中括号 字符集合。匹配方括号中的任意字符. </p><p>3.小括号表示优先级</p><p><a href="https://c.runoob.com/">正则表达式在线测试</a></p><h3 id="3-4预定义类"><a href="#3-4预定义类" class="headerlink" title="3.4预定义类"></a>3.4预定义类</h3><p>预定义类指的是某些常见模式的简写方式.</p><p><img src="/img/webimg/js04/img3.png"></p><p><strong>案例:验证座机号码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;$/</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\d&#123;3,4&#125;-\d&#123;7,8&#125;$/</span>;<br></code></pre></td></tr></table></figure><p><strong>表单验证案例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//手机号验证:/^1[3|4|5|7|8][0-9]&#123;9&#125;$/;</span><br><span class="hljs-comment">//验证通过与不通过更换元素的类名与元素中的内容</span><br> <span class="hljs-keyword">if</span> (reg.test(<span class="hljs-built_in">this</span>.value)) &#123;<br>    <span class="hljs-comment">// console.log(&#x27;正确的&#x27;);</span><br>    <span class="hljs-built_in">this</span>.nextElementSibling.className = <span class="hljs-string">&#x27;success&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.nextElementSibling.innerHTML = <span class="hljs-string">&#x27;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#x27;</span>;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// console.log(&#x27;不正确&#x27;);</span><br>      <span class="hljs-built_in">this</span>.nextElementSibling.className = <span class="hljs-string">&#x27;error&#x27;</span>;<br>      <span class="hljs-built_in">this</span>.nextElementSibling.innerHTML = <span class="hljs-string">&#x27;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt;格式不正确,请从新输入 &#x27;</span>;<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//QQ号验证: /^[1-9]\d&#123;4,&#125;$/; </span><br><span class="hljs-comment">//昵称验证:/^[\u4e00-\u9fa5]&#123;2,8&#125;$/</span><br><span class="hljs-comment">//验证通过与不通过更换元素的类名与元素中的内容 ,将上一步的匹配代码进行封装,多次调用即可</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">regexp</span>(<span class="hljs-params">ele, reg</span>) </span>&#123;<br>    ele.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (reg.test(<span class="hljs-built_in">this</span>.value)) &#123;<br>        <span class="hljs-comment">// console.log(&#x27;正确的&#x27;);</span><br>        <span class="hljs-built_in">this</span>.nextElementSibling.className = <span class="hljs-string">&#x27;success&#x27;</span>;<br>        <span class="hljs-built_in">this</span>.nextElementSibling.innerHTML = <span class="hljs-string">&#x27;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#x27;</span>;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">// console.log(&#x27;不正确&#x27;);</span><br>     <span class="hljs-built_in">this</span>.nextElementSibling.className = <span class="hljs-string">&#x27;error&#x27;</span>;<br>     <span class="hljs-built_in">this</span>.nextElementSibling.innerHTML = <span class="hljs-string">&#x27;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 格式不正确,请从新输入 &#x27;</span>;<br>            &#125;<br>        &#125;<br> &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//密码验证:/^[a-zA-Z0-9_-]&#123;6,16&#125;$/</span><br><span class="hljs-comment">//再次输入密码只需匹配与上次输入的密码值 是否一致</span><br></code></pre></td></tr></table></figure><h3 id="3-5正则替换replace"><a href="#3-5正则替换replace" class="headerlink" title="3.5正则替换replace"></a>3.5正则替换replace</h3><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;andy和red&#x27;</span>;<br><span class="hljs-keyword">var</span> newStr = str.replace(<span class="hljs-string">&#x27;andy&#x27;</span>, <span class="hljs-string">&#x27;baby&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(newStr)<span class="hljs-comment">//baby和red</span><br><span class="hljs-comment">//等同于 此处的andy可以写在正则表达式内</span><br><span class="hljs-keyword">var</span> newStr2 = str.replace(<span class="hljs-regexp">/andy/</span>, <span class="hljs-string">&#x27;baby&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(newStr2)<span class="hljs-comment">//baby和red</span><br><span class="hljs-comment">//全部替换</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcabc&#x27;</span><br><span class="hljs-keyword">var</span> nStr = str.replace(<span class="hljs-regexp">/a/</span>,<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(nStr) <span class="hljs-comment">//哈哈bcabc</span><br><span class="hljs-comment">//全部替换g</span><br><span class="hljs-keyword">var</span> nStr = str.replace(<span class="hljs-regexp">/a/</span>a,<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(nStr) <span class="hljs-comment">//哈哈bc哈哈bc</span><br><span class="hljs-comment">//忽略大小写i</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;aAbcAba&#x27;</span>;<br><span class="hljs-keyword">var</span> newStr = str.replace(<span class="hljs-regexp">/a/gi</span>,<span class="hljs-string">&#x27;哈哈&#x27;</span>)<span class="hljs-comment">//&quot;哈哈哈哈bc哈哈b哈哈&quot;</span><br></code></pre></td></tr></table></figure><p><strong>案例:过滤敏感词汇</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;textarea name=<span class="hljs-string">&quot;&quot;</span> id=<span class="hljs-string">&quot;message&quot;</span>&gt;&lt;<span class="hljs-regexp">/textarea&gt; &lt;button&gt;提交&lt;/</span>button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;textarea&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    div.innerHTML = text.value.replace(<span class="hljs-regexp">/激情|gay/g</span>, <span class="hljs-string">&#x27;**&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>能够说出使用let关键字声明变量的特点</li><li>能够使用解构赋值从数组中提取值</li><li>能够说出箭头函数拥有的特性</li><li>能够使用剩余参数接收剩余的函数参数</li><li>能够使用拓展运算符拆分数组</li><li>能够说出模板字符串拥有的特性</li></ul><h2 id="ES6相关概念（★★）"><a href="#ES6相关概念（★★）" class="headerlink" title="ES6相关概念（★★）"></a>ES6相关概念（★★）</h2><h3 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h3><p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。</p><p><img src="/img/webimg/js05/es-version.png"></p><h3 id="为什么使用-ES6"><a href="#为什么使用-ES6" class="headerlink" title="为什么使用 ES6 ?"></a>为什么使用 ES6 ?</h3><p>每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。</p><ul><li>变量提升特性增加了程序运行时的不可预测性</li><li>语法过于松散，实现相同的功能，不同的人可能会写出不同的代码</li></ul><h2 id="ES6新增语法"><a href="#ES6新增语法" class="headerlink" title="ES6新增语法"></a>ES6新增语法</h2><h3 id="let（★★★）"><a href="#let（★★★）" class="headerlink" title="let（★★★）"></a>let（★★★）</h3><p>ES6中新增了用于声明变量的关键字</p><h4 id="let声明的变量只在所处于的块级有效"><a href="#let声明的变量只在所处于的块级有效" class="headerlink" title="let声明的变量只在所处于的块级有效"></a>let声明的变量只在所处于的块级有效</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br>     <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br> &#125;<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// a is not defined </span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>利用let声明的变量会绑定在这个块级作用域，不会受外界的影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br>    tmp = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>    <span class="hljs-keyword">let</span> tmp; <br>&#125; <br></code></pre></td></tr></table></figure><h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i); <br>    &#125;<br>&#125;<br>arr[<span class="hljs-number">0</span>]();<br>arr[<span class="hljs-number">1</span>]();<br><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js05/let%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598.png"></p><p><strong>经典面试题图解：</strong>此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i); <br>    &#125;<br>&#125;<br>arr[<span class="hljs-number">0</span>]();<br>arr[<span class="hljs-number">1</span>]();<br><br></code></pre></td></tr></table></figure><p><img src="/img/webimg/js05/let%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%25982.png"></p><p><strong>经典面试题图解：</strong>此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>let关键字就是用来声明变量的</li><li>使用let关键字声明的变量具有块级作用域</li><li>在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的</li><li>防止循环变量变成全局变量</li><li>使用let关键字声明的变量没有变量提升</li><li>使用let关键字声明的变量具有暂时性死区特性</li></ul><h3 id="const（★★★）"><a href="#const（★★★）" class="headerlink" title="const（★★★）"></a>const（★★★）</h3><p>声明常量，常量就是值（内存地址）不能变化的量</p><h4 id="具有块级作用域"><a href="#具有块级作用域" class="headerlink" title="具有块级作用域"></a>具有块级作用域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br>     <span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br> &#125;<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span><br></code></pre></td></tr></table></figure><h4 id="声明常量时必须赋值"><a href="#声明常量时必须赋值" class="headerlink" title="声明常量时必须赋值"></a>声明常量时必须赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PI; <span class="hljs-comment">// Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><h4 id="常量赋值后，值不能修改"><a href="#常量赋值后，值不能修改" class="headerlink" title="常量赋值后，值不能修改"></a>常量赋值后，值不能修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;<br>PI = <span class="hljs-number">100</span>; <span class="hljs-comment">// Assignment to constant variable.</span><br><br><span class="hljs-keyword">const</span> ary = [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>];<br>ary[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>ary[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(ary); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]; </span><br>ary = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]; <span class="hljs-comment">// Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>const声明的变量是一个常量</li><li>既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值</li><li>声明 const时候必须要给定值</li></ul><h3 id="let、const、var-的区别"><a href="#let、const、var-的区别" class="headerlink" title="let、const、var 的区别"></a>let、const、var 的区别</h3><ul><li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</li><li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</li><li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</li></ul><p><img src="/img/webimg/js05/var&let&const%2525E5%25258C%2525BA%2525E5%252588%2525AB.png"></p><h3 id="解构赋值（★★★）"><a href="#解构赋值（★★★）" class="headerlink" title="解构赋值（★★★）"></a>解构赋值（★★★）</h3><p>ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</p><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//1</span><br> <span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">//2</span><br> <span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">//3</span><br><span class="hljs-comment">//如果解构不成功，变量的值为undefined</span><br></code></pre></td></tr></table></figure><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;; <br><span class="hljs-keyword">let</span> &#123; name, age &#125; = person;<br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// &#x27;zhangsan&#x27; </span><br><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// 20</span><br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge&#125; = person; <span class="hljs-comment">// myName myAge 属于别名</span><br><span class="hljs-built_in">console</span>.log(myName); <span class="hljs-comment">// &#x27;zhangsan&#x27; </span><br><span class="hljs-built_in">console</span>.log(myAge); <span class="hljs-comment">// 20</span><br><br></code></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>解构赋值就是把数据结构分解，然后给变量进行赋值</li><li>如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined</li><li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开</li><li>利用解构赋值能够让我们方便的去取对象中的属性跟方法</li></ul><h3 id="箭头函数（★★★）"><a href="#箭头函数（★★★）" class="headerlink" title="箭头函数（★★★）"></a>箭头函数（★★★）</h3><p>ES6中新增的定义函数的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">() =&gt; &#123;&#125; <span class="hljs-comment">//()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体</span><br><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;&#125;<span class="hljs-comment">//代表把一个函数赋值给fn</span><br></code></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;<br><span class="hljs-comment">//es6写法</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2; <br><br></code></pre></td></tr></table></figure><p>如果形参只有一个，可以省略小括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">v</span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> v;<br> &#125; <br><span class="hljs-comment">//es6写法</span><br> <span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;<br><br></code></pre></td></tr></table></figure><p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>&#125; <br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"></span>) </span>&#123; <br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//this 指向 是obj对象</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象</span><br>     &#125; <br> &#125; <br> <span class="hljs-keyword">const</span> resFn = fn.call(obj); <br> resFn();<br><br></code></pre></td></tr></table></figure><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li>箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁</li><li>箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br><span class="hljs-attr">say</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>alert(<span class="hljs-built_in">this</span>.age)<br>&#125;<br>&#125;<br><br>obj.say();<span class="hljs-comment">//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域</span><br></code></pre></td></tr></table></figure><h3 id="剩余参数（★★）"><a href="#剩余参数（★★）" class="headerlink" title="剩余参数（★★）"></a>剩余参数（★★）</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">first, ...args</span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(first); <span class="hljs-comment">// 10</span><br>     <span class="hljs-built_in">console</span>.log(args); <span class="hljs-comment">// [20, 30] </span><br> &#125;<br> sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br><br></code></pre></td></tr></table></figure><h4 id="剩余参数和解构配合使用"><a href="#剩余参数和解构配合使用" class="headerlink" title="剩余参数和解构配合使用"></a>剩余参数和解构配合使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> students = [<span class="hljs-string">&#x27;wangwu&#x27;</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>];<br><span class="hljs-keyword">let</span> [s1, ...s2] = students; <br><span class="hljs-built_in">console</span>.log(s1);  <span class="hljs-comment">// &#x27;wangwu&#x27; </span><br><span class="hljs-built_in">console</span>.log(s2);  <span class="hljs-comment">// [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span><br><br></code></pre></td></tr></table></figure><h2 id="ES6-的内置对象扩展"><a href="#ES6-的内置对象扩展" class="headerlink" title="ES6 的内置对象扩展"></a>ES6 的内置对象扩展</h2><h3 id="Array-的扩展方法（★★）"><a href="#Array-的扩展方法（★★）" class="headerlink" title="Array 的扩展方法（★★）"></a>Array 的扩展方法（★★）</h3><h4 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h4><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>...ary  <span class="hljs-comment">// 1, 2, 3</span><br><span class="hljs-built_in">console</span>.log(...ary);    <span class="hljs-comment">// 1 2 3,相当于下面的代码</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h5 id="扩展运算符可以应用于合并数组"><a href="#扩展运算符可以应用于合并数组" class="headerlink" title="扩展运算符可以应用于合并数组"></a>扩展运算符可以应用于合并数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法一 </span><br> <span class="hljs-keyword">let</span> ary1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> <span class="hljs-keyword">let</span> ary2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br> <span class="hljs-keyword">let</span> ary3 = [...ary1, ...ary2];<br> <span class="hljs-comment">// 方法二 </span><br> ary1.push(...ary2);<br></code></pre></td></tr></table></figure><h5 id="将类数组或可遍历对象转换为真正的数组"><a href="#将类数组或可遍历对象转换为真正的数组" class="headerlink" title="将类数组或可遍历对象转换为真正的数组"></a>将类数组或可遍历对象转换为真正的数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oDivs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>); <br>oDivs = [...oDivs];<br></code></pre></td></tr></table></figure><h4 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h4><p>将伪数组或可遍历对象转换为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个集合</span><br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span><br>&#125;; <br><span class="hljs-comment">//转成数组</span><br><span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123; <br>    <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;length&quot;</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">let</span> newAry = <span class="hljs-built_in">Array</span>.from(arrayLike, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item *<span class="hljs-number">2</span>)<span class="hljs-comment">//[2,4]</span><br><br></code></pre></td></tr></table></figure><p>注意：如果是对象，那么属性需要写对应的索引</p><h4 id="实例方法：find"><a href="#实例方法：find" class="headerlink" title="实例方法：find()"></a>实例方法：find()</h4><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [&#123;<br>     <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span><br> &#125;, &#123; <br>     <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;李四&#x27;</span><br> &#125;]; <br> <span class="hljs-keyword">let</span> target = ary.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item.id == <span class="hljs-number">2</span>);<span class="hljs-comment">//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个</span><br><br></code></pre></td></tr></table></figure><h4 id="实例方法：findIndex"><a href="#实例方法：findIndex" class="headerlink" title="实例方法：findIndex()"></a>实例方法：findIndex()</h4><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">let</span> index = ary.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>); <br><span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a>实例方法：includes()</h4><p>判断某个数组是否包含给定的值，返回布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true </span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><h3 id="String-的扩展方法"><a href="#String-的扩展方法" class="headerlink" title="String 的扩展方法"></a>String 的扩展方法</h3><h4 id="模板字符串（★★★）"><a href="#模板字符串（★★★）" class="headerlink" title="模板字符串（★★★）"></a>模板字符串（★★★）</h4><p>ES6新增的创建字符串的方式，使用反引号定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">`zhangsan`</span>;<br><br></code></pre></td></tr></table></figure><h5 id="模板字符串中可以解析变量"><a href="#模板字符串中可以解析变量" class="headerlink" title="模板字符串中可以解析变量"></a>模板字符串中可以解析变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;张三&#x27;</span>; <br><span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`hello,my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>; <span class="hljs-comment">// hello, my name is zhangsan</span><br></code></pre></td></tr></table></figure><h5 id="模板字符串中可以换行"><a href="#模板字符串中可以换行" class="headerlink" title="模板字符串中可以换行"></a>模板字符串中可以换行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = &#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span> <br>&#125; <br><span class="hljs-keyword">let</span> html = <span class="hljs-string">` &lt;div&gt;</span><br><span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span><br><span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span><br><span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span><br><span class="hljs-string">&lt;/div&gt; `</span>;<br><br></code></pre></td></tr></table></figure><h5 id="在模板字符串中可以调用函数"><a href="#在模板字符串中可以调用函数" class="headerlink" title="在模板字符串中可以调用函数"></a>在模板字符串中可以调用函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;哈哈哈哈 追不到我吧 我就是这么强大&#x27;</span>;<br> &#125;; <br> <span class="hljs-keyword">let</span> greet = <span class="hljs-string">`<span class="hljs-subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>;<br> <span class="hljs-built_in">console</span>.log(greet); <span class="hljs-comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span><br><br></code></pre></td></tr></table></figure><h4 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith() 和 endsWith()"></a>实例方法：startsWith() 和 endsWith()</h4><ul><li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li><li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>str.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true </span><br>str.endsWith(<span class="hljs-string">&#x27;!&#x27;</span>)       <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><h4 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h4><p>repeat方法表示将原字符串重复n次，返回一个新字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>)      <span class="hljs-comment">// &quot;xxx&quot; </span><br><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>)  <span class="hljs-comment">// &quot;hellohello&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Set-数据结构（★★）"><a href="#Set-数据结构（★★）" class="headerlink" title="Set 数据结构（★★）"></a>Set 数据结构（★★）</h3><p>ES6 提供了新的数据结构  Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成  Set  数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br></code></pre></td></tr></table></figure><p>Set函数可以接受一个数组作为参数，用来初始化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]);<span class="hljs-comment">//&#123;1, 2, 3, 4&#125;</span><br><br></code></pre></td></tr></table></figure><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>); <span class="hljs-comment">// 向 set 结构中添加值 </span><br>s.delete(<span class="hljs-number">2</span>)             <span class="hljs-comment">// 删除 set 结构中的2值   </span><br>s.has(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 表示 set 结构中是否有1这个值 返回布尔值 </span><br>s.clear()               <span class="hljs-comment">// 清除 set 结构中的所有值</span><br><span class="hljs-comment">//注意：删除的是元素的值，不是代表的索引</span><br></code></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">s.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github博客配置多域名</title>
    <link href="/2017/12/26/Github%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%9A%E5%9F%9F%E5%90%8D/"/>
    <url>/2017/12/26/Github%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%9A%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为手头有两个域名一个是一直在用的,另一个是在bluehost图便宜买的,本着不浪费的原则,打算都指向自己的博客</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lyoric<span class="hljs-selector-class">.com</span><br>lyoric.site<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>说白点就是在github上再创建一个pages,然后重定向到原来的博客</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>github新建仓库,要是公开状态</p></li><li><p>新建_config.yml,这个设置是让github能识别出该项目是pages项目</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"># Site<br><span class="hljs-symbol">title:</span> Clyde<br><span class="hljs-symbol">subtitle:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">description:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">keywords:</span><br><span class="hljs-symbol">author:</span> <span class="hljs-comment">&#x27;Clyde&#x27;</span><br><span class="hljs-symbol">language:</span> zh-CN<br><span class="hljs-symbol">timezone:</span> <span class="hljs-comment">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>新建404.html文件,用于重定向</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>clyde<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-keyword">var</span> domain = <span class="hljs-string">&quot;www.lyoric.com&quot;</span>;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> current = <span class="hljs-built_in">window</span>.location.href;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> target = current.substring(current.indexOf(<span class="hljs-string">&#x27;/&#x27;</span>, current.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">3</span>));</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;//&quot;</span> + domain + target;</span><br><span class="javascript">        location.href = <span class="hljs-string">&quot;//&quot;</span> + domain + target;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        跳转中....<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>新建CNAME文件,注意没有后缀,用于配置域名</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">lyoric.site<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置完成后需要去Settings检查pages是否已经配置成功,如果配置成功,在最上方会显示</p><p><code>Your site is published at http://lyoric.site/</code></p><p>否则的话就要检查下_config.yml文件是否有问题</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习06-移动端rem布局</title>
    <link href="/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A006-%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E4%B9%8Brem%E5%B8%83%E5%B1%80/"/>
    <url>/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A006-%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E4%B9%8Brem%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="移动端rem布局"><a href="#移动端rem布局" class="headerlink" title="移动端rem布局"></a>移动端rem布局</h1><h3 id="rem基础"><a href="#rem基础" class="headerlink" title="rem基础"></a>rem基础</h3><h4 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a>rem单位</h4><p>rem (root em)是一个相对单位，类似于em，em是父元素字体大小。</p><p>不同的是rem的基准是相对于html元素的字体大小。</p><p>比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 根html 为 12px */</span><br><span class="hljs-selector-tag">html</span> &#123;<br>   <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br><span class="hljs-comment">/* 此时 div 的字体大小就是 24px */</span>       <br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。</p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><h4 id="什么是媒体查询"><a href="#什么是媒体查询" class="headerlink" title="什么是媒体查询"></a>什么是媒体查询</h4><p>媒体查询（Media Query）是CSS3新语法。</p><ul><li>使用 @media查询，可以针对不同的媒体类型定义不同的样式</li><li>@media 可以针对不同的屏幕尺寸设置不同的样式</li><li>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 </li><li>目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询</li></ul><h4 id="媒体查询语法规范"><a href="#媒体查询语法规范" class="headerlink" title="媒体查询语法规范"></a>媒体查询语法规范</h4><ul><li>用 @media开头 注意@符号</li><li>mediatype  媒体类型</li><li>关键字 and  not  only</li><li>media feature 媒体特性必须有小括号包含</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">@media media<span class="hljs-keyword">type</span> and|not|only (media feature) &#123;<br>    <span class="hljs-type">CSS</span>-<span class="hljs-type">Code</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>mediatype 查询类型</li></ol><p>​       将不同的终端设备划分成不同的类型，称为媒体类型</p><p><img src="/img/web/rem01.jpg"></p><ol start="2"><li>关键字</li></ol><p>​       关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</p><ul><li>and：可以将多个媒体特性连接到一起，相当于“且”的意思。</li><li>not：排除某个媒体类型，相当于“非”的意思，可以省略。</li><li>only：指定某个特定的媒体类型，可以省略。    </li></ul><ol start="3"><li><p>媒体特性</p><p>每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。</p><p>注意他们要加小括号包含</p><p><img src="/img/web/rem02.jpg"></p></li><li><p>媒体查询书写规则</p><p>注意： 为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁</p><p><img src="/img/web/rem03.jpg"></p></li></ol><h3 id="less-基础"><a href="#less-基础" class="headerlink" title="less 基础"></a>less 基础</h3><h4 id="维护css弊端"><a href="#维护css弊端" class="headerlink" title="维护css弊端"></a>维护css弊端</h4><p>CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。</p><ul><li>CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。</li><li>不方便维护及扩展，不利于复用。</li><li>CSS 没有很好的计算能力</li><li>非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 </li></ul><h4 id="Less-介绍"><a href="#Less-介绍" class="headerlink" title="Less 介绍"></a>Less 介绍</h4><p>Less（LeanerStyle Sheets 的缩写）是一门 CSS扩展语言，也成为CSS预处理器。</p><p>做为 CSS的一种形式的扩展，它并没有减少CSS的功能，而是在现有的CSS语法上，为CSS加入程序式语言的特性。</p><p>它在CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。</p><p>Less中文网址：<a href="http://lesscss.cn/">http://</a><a href="http://lesscss.cn/">less</a><a href="http://lesscss.cn/">css.cn/</a></p><p>常见的CSS预处理器：Sass、Less、Stylus</p><p>一句话：Less是一门 CSS 预处理语言，它扩展了CSS的动态特性。</p><p>Less安装</p><p>①安装nodejs，可选择版本(8.0)，网址：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p>②检查是否安装成功，使用cmd命令（win10是window+r 打开运行输入cmd）  —输入“node –v”查看版本即可</p><p>③基于nodejs在线安装Less，使用cmd命令“npm install -g less”即可</p><p>④检查是否安装成功，使用cmd命令“ lessc -v ”查看版本即可</p><p>Less 使用之变量</p><p>变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-meta">@变量名:值;</span><br></code></pre></td></tr></table></figure><ul><li>必须有@为前缀</li><li>不能包含特殊字符</li><li>不能以数字开头</li><li>大小写敏感</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@color:</span> pink;<br></code></pre></td></tr></table></figure><p>Less 编译 vocode Less 插件</p><p>Easy LESS 插件用来把less文件编译为css文件</p><p>安装完毕插件，重新加载下 vscode。</p><p>只要保存一下Less文件，会自动生成CSS文件。</p><p><img src="/img/web/rem04.jpg"></p><p>Less 嵌套</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 将css改为less</span><br><span class="hljs-selector-id">#header</span> <span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#header</span> &#123;<br>    <span class="hljs-selector-class">.logo</span> &#123;<br>       <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果遇见 （交集|伪类|伪元素选择器） ，利用&amp;进行连接</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br><span class="hljs-selector-tag">a</span>&#123;<br>  &amp;<span class="hljs-selector-pseudo">:hover</span>&#123;<br>      <span class="hljs-attribute">color</span>:red;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Less 运算</p><p>任何数字、颜色或者变量都可以参与运算。就是Less提供了加（+）、减（-）、乘（*）、除（/）算术运算。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/*Less 里面写*/</span><br><span class="hljs-variable">@witdh:</span> <span class="hljs-number">10px</span> + <span class="hljs-number">5</span>;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-variable">@witdh</span> solid red;<br>&#125;<br><span class="hljs-comment">/*生成的css*/</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid red;<br>&#125;<br><span class="hljs-comment">/*Less 甚至还可以这样 */</span><br><span class="hljs-attribute">width</span>: (<span class="hljs-variable">@width</span> + <span class="hljs-number">5</span>) * <span class="hljs-number">2</span>;<br><br></code></pre></td></tr></table></figure><ul><li>乘号（*）和除号（/）的写法  </li><li>运算符中间左右有个空格隔开 1px + 5</li><li>对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 </li><li>如果两个值之间只有一个值有单位，则运算结果就取该单位</li></ul><h3 id="rem适配方案"><a href="#rem适配方案" class="headerlink" title="rem适配方案"></a>rem适配方案</h3><p>1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。</p><p>2.使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。</p><p>技术方案：</p><p>1.less+rem+媒体查询</p><p>2.lflexible.js+rem</p><p>总结： </p><p>两种方案现在都存在。</p><p>方案2 更简单，现阶段大家无需了解里面的js代码。</p><h4 id="rem实际开发适配方案1"><a href="#rem实际开发适配方案1" class="headerlink" title="rem实际开发适配方案1"></a>rem实际开发适配方案1</h4><p>①假设设计稿是750px</p><p>②假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份）</p><p>③每一份作为html字体大小，这里就是50px</p><p>④那么在320px设备的时候，字体大小为320/15就是  21.33px</p><p>⑤用我们页面元素的大小除以不同的 html字体大小会发现他们比例还是相同的</p><p>⑥比如我们以750为标准设计稿</p><p>⑦一个100<em>100像素的页面元素在  750屏幕下，  就是 100/ 50  转换为rem  是  2rem</em>2rem  比例是1比1</p><p>⑧320屏幕下，  html字体大小为21.33   则 2rem=  42.66px  此时宽和高都是 42.66  但是宽和高的比例还是 1比1</p><p>⑨但是已经能实现不同屏幕下  页面元素盒子等比例缩放的效果</p><p>总结：</p><p>①最后的公式：页面元素的rem值 =  页面元素值（px） /  （屏幕宽度  /  划分的份数）</p><p>②屏幕宽度/划分的份数就是 htmlfont-size 的大小</p><p>③或者：页面元素的rem值 =  页面元素值（px） /  html font-size 字体大小</p><h3 id="苏宁首页"><a href="#苏宁首页" class="headerlink" title="苏宁首页"></a>苏宁首页</h3><p>苏宁首页地址 ：<a href="m.suning.com">苏宁首页</a></p><p>1、 技术选型</p><p>方案：我们采取单独制作移动页面方案</p><p>技术：布局采取rem适配布局（less + rem  + 媒体查询）</p><p>设计图： 本设计图采用 750px 设计尺寸</p><p>2、搭建文件结构</p><p><img src="/img/web/rem05.jpg"></p><p>3、设置视口标签以及引入初始化样式</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, user-scalable=no,         initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;<br><br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;css/normalize.css&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>4、设置公共common.less文件</p><ul><li>新建common.less    设置好最常见的屏幕尺寸，利用媒体查询设置不同的html字体大小，因为除了首页其他页面也需要</li><li>我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px</li><li>划分的份数我们定为 15等份</li><li>因为我们pc端也可以打开我们苏宁移动端首页，我们默认html字体大小为 50px，注意这句话写到最上面</li></ul><h3 id="rem-适配方案2"><a href="#rem-适配方案2" class="headerlink" title="rem 适配方案2"></a>rem 适配方案2</h3><p>手机淘宝团队出的简洁高效 移动端适配库</p><p>我们再也不需要在写不同屏幕的媒体查询，因为里面js做了处理</p><p>它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的。</p><p>我们要做的，就是确定好我们当前设备的html 文字大小就可以了</p><p>比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以</p><p>里面页面元素rem值： 页面元素的px 值 /  75  </p><p>剩余的，让flexible.js来去算</p><p>github地址：<a href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible">https://github.com/amfe/lib-flexible</a></p><p>总结：</p><p>因为flexible是默认将屏幕分为10等分</p><p>但是当屏幕大于750的时候希望不要再去重置html字体了</p><p>所以要自己通过媒体查询设置一下</p><p>并且要把权重提到最高</p><p>VSCode  px 转换rem 插件 cssrem </p><p>因为cssrem中css自动转化为rem是参照默认插件的16转换的所以需要自己配置</p><p><img src="/img/web/rem06.jpg"></p><p><img src="/img/web/rem07.jpg"></p><h1 id="移动端WEB开发之响应式布局"><a href="#移动端WEB开发之响应式布局" class="headerlink" title="移动端WEB开发之响应式布局"></a>移动端WEB开发之响应式布局</h1><h3 id="1-0-响应式开发原理"><a href="#1-0-响应式开发原理" class="headerlink" title="1.0 响应式开发原理"></a>1.0 响应式开发原理</h3><h4 id="1-1-响应式开发原理"><a href="#1-1-响应式开发原理" class="headerlink" title="1.1 响应式开发原理"></a>1.1 响应式开发原理</h4><p>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。</p><p>设备的划分情况：</p><ul><li>小于768的为超小屏幕（手机）</li><li>768~992之间的为小屏设备（平板）</li><li>992~1200的中等屏幕（桌面显示器）</li><li>大于1200的宽屏设备（大桌面显示器）</li></ul><h4 id="1-2-响应式布局容器"><a href="#1-2-响应式布局容器" class="headerlink" title="1.2 响应式布局容器"></a>1.2 响应式布局容器</h4><p>响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。</p><p>原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</p><p>父容器版心的尺寸划分</p><ul><li>超小屏幕（手机，小于 768px）：设置宽度为 100%</li><li>小屏幕（平板，大于等于 768px）：设置宽度为 750px</li><li>中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px</li><li>大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px </li></ul><p>但是我们也可以根据实际情况自己定义划分</p><h3 id="2-0-bootstrap的介绍"><a href="#2-0-bootstrap的介绍" class="headerlink" title="2.0 bootstrap的介绍"></a>2.0 bootstrap的介绍</h3><h4 id="2-1Bootstrap简介"><a href="#2-1Bootstrap简介" class="headerlink" title="2.1Bootstrap简介"></a>2.1Bootstrap简介</h4><p>Bootstrap 来自 Twitter（推特），是目前最受欢迎的前端框架。Bootstrap 是基于HTML、CSS 和 JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。</p><p><a href="lhttp://www.bootcss.com/">中文网</a>  <a href="lhttp://getbootstrap.com/">官网</a>  <a href="http://bootstrap.css88.com/">推荐网站</a></p><p>框架：顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。</p><h4 id="2-2-bootstrap优点"><a href="#2-2-bootstrap优点" class="headerlink" title="2.2 bootstrap优点"></a>2.2 bootstrap优点</h4><ul><li>标准化的html+css编码规范</li><li>提供了一套简洁、直观、强悍的组件</li><li>有自己的生态圈，不断的更新迭代</li><li>让开发更简单，提高了开发的效率</li></ul><h4 id="2-3-版本简介"><a href="#2-3-版本简介" class="headerlink" title="2.3 版本简介"></a>2.3 版本简介</h4><p>2.x.x：停止维护,兼容性好,代码不够简洁，功能不够完善。</p><p>3.x.x：目前使用最多,稳定,但是放弃了IE6-IE7。对 IE8 支持但是界面效果不好,偏向用于开发响应式布局、移动设备优先的WEB 项目。</p><p>4.x.x：最新版，目前还不是很流行</p><h4 id="2-4bootstrap基本使用"><a href="#2-4bootstrap基本使用" class="headerlink" title="2.4bootstrap基本使用"></a>2.4bootstrap基本使用</h4><p>在现阶段我们还没有接触JS相关课程，所以我们只考虑使用它的样式库。</p><p>Bootstrap 使用四步曲： </p><ol><li><p>创建文件夹结构  </p><p><img src="/img/web/rem08.jpg"></p></li><li><p>创建 html 骨架结构 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Bootstrap 101 Template<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;</span><br>    <span class="hljs-comment">&lt;!-- WARNING: Respond.js doesn&#x27;t work if you view the page via file:// --&gt;</span><br>    <span class="hljs-comment">&lt;!--[if lt IE 9]&gt;</span><br><span class="hljs-comment">      &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-comment">      &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-comment">    &lt;![endif]--&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好，世界！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- jQuery (necessary for Bootstrap&#x27;s JavaScript plugins) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>引入相关样式文件  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Bootstrap 核心样式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;bootstrap/css/bootstrap.min.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>书写内容 </p><p>直接拿Bootstrap 预先定义好的样式来使用</p><p>修改Bootstrap 原来的样式，注意权重问题</p><p>学好Bootstrap 的关键在于知道它定义了哪些样式，以及这些样式能实现什么样的效果</p></li></ol><h4 id="2-5-bootstrap布局容器"><a href="#2-5-bootstrap布局容器" class="headerlink" title="2.5 bootstrap布局容器"></a>2.5 bootstrap布局容器</h4><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 或者.container-fluid 容器，它提供了两个作此用处的类。</p><p>.container</p><ul><li>响应式布局的容器  固定宽度</li><li>大屏 ( &gt;=1200px)  宽度定为 1170px</li><li>中屏 ( &gt;=992px)   宽度定为  970px</li><li>小屏 ( &gt;=768px)   宽度定为  750px</li><li>超小屏  (100%) </li></ul><p>.container-fluid</p><ul><li>流式布局容器 百分百宽度</li><li>占据全部视口（viewport）的容器。</li></ul><h4 id="2-6-bootstrap栅格系统"><a href="#2-6-bootstrap栅格系统" class="headerlink" title="2.6 bootstrap栅格系统"></a>2.6 bootstrap栅格系统</h4><p>Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p><p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。</p><ul><li>按照不同屏幕划分为1~12 等份</li><li>行（row） 可以去除父容器作用15px的边距</li><li>xs-extra small：超小； sm-small：小；  md-medium：中等； lg-large：大；</li><li>列（column）大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列</li><li>每一列默认有左右15像素的 padding</li><li>可以同时为一列指定多个设备的类名，以便划分不同份数  例如 class=”col-md-4 col-sm-6”</li></ul><p>栅格嵌套</p><p>栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若干份小列。我们可以通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-*<br>元素内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 列嵌套 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-6&quot;</span>&gt;</span>小列<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-6&quot;</span>&gt;</span>小列<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>列偏移</p><p>使用 .col-md-offset-* 类可以将列向右侧偏移。这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距（margin）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 列偏移 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-lg-4&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-lg-4 col-lg-offset-4&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>列排序</p><p>通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列（column）的顺序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 列排序 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-lg-4 col-lg-push-8&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-lg-8 col-lg-pull-4&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>响应式工具</p><p>为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。</p><p><img src="/img/web/rem09.jpg"></p><h3 id="3-0-阿里百秀案例制作"><a href="#3-0-阿里百秀案例制作" class="headerlink" title="3.0 阿里百秀案例制作"></a>3.0 阿里百秀案例制作</h3><h4 id="3-1-技术选型"><a href="#3-1-技术选型" class="headerlink" title="3.1 技术选型"></a>3.1 技术选型</h4><p>方案：我们采取响应式页面开发方案</p><p>技术：bootstrap框架</p><p>设计图： 本设计图采用 1280px 设计尺寸</p><p>项目结构搭建</p><p>Bootstrap 使用四步曲： </p><ol><li><p>创建文件夹结构  </p></li><li><p>创建 html 骨架结构  </p></li><li><p>引入相关样式文件  </p></li><li><p>书写内容 </p></li></ol><p>container宽度修改</p><p>因为本效果图采取 1280的宽度， 而Bootstrap 里面 container宽度 最大为 1170px，因此我们需要手动改下container宽度</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* 利用媒体查询修改 container宽度适合效果图宽度  */</span><br> <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1280px</span>) &#123; <br>   <span class="hljs-selector-class">.container</span> &#123; <br><span class="hljs-attribute">width</span>: <span class="hljs-number">1280px</span>; <br>    &#125; <br>  &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习09-JQuery</title>
    <link href="/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A009-JQuery/"/>
    <url>/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A009-JQuery/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="day01-jQuery"><a href="#day01-jQuery" class="headerlink" title="day01 - jQuery"></a>day01 - jQuery</h1><blockquote><p>学习目标：</p><p>能够说出什么是 jQuery<br>能够说出 jQuery 的优点<br>能够简单使用 jQuery<br>能够说出 DOM 对象和 jQuery 对象的区别<br>能够写出常用的 jQuery 选择器<br>能够操作 jQuery 样式<br>能够写出常用的 jQuery 动画 </p></blockquote><h2 id="1-1-jQuery-介绍"><a href="#1-1-jQuery-介绍" class="headerlink" title="1.1. jQuery 介绍"></a>1.1. jQuery 介绍</h2><h3 id="1-1-1-JavaScript-库"><a href="#1-1-1-JavaScript-库" class="headerlink" title="1.1.1 JavaScript 库"></a>1.1.1 JavaScript 库</h3><p>​    JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。</p><blockquote><p>简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。</p><p>比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。</p></blockquote><p>​    常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。</p><h3 id="1-1-2-jQuery的概念"><a href="#1-1-2-jQuery的概念" class="headerlink" title="1.1.2 jQuery的概念"></a>1.1.2 jQuery的概念</h3><p>​    jQuery总体概况如下 :</p><ul><li><p>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</p></li><li><p>j 就是 JavaScript；   Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。</p></li><li><p>jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</p></li><li><p>学习jQuery本质： 就是学习调用这些函数（方法）。</p></li><li><p>jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。</p><p><img src="/img/webimg/jQuery%E6%A6%82%E8%BF%B0.jpg" alt="jQuery概述"></p></li></ul><h3 id="1-1-3-jQuery的优点"><a href="#1-1-3-jQuery的优点" class="headerlink" title="1.1.3 jQuery的优点"></a>1.1.3 jQuery的优点</h3><ol><li>轻量级。核心文件才几十kb，不会影响页面加载速度。</li><li>跨浏览器兼容，基本兼容了现在主流的浏览器。</li><li>链式编程、隐式迭代。</li><li>对事件、样式、动画支持，大大简化了DOM操作。</li><li>支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。</li><li>免费、开源。</li></ol><h2 id="1-2-jQuery-的基本使用"><a href="#1-2-jQuery-的基本使用" class="headerlink" title="1.2. jQuery 的基本使用"></a>1.2. jQuery 的基本使用</h2><h3 id="1-2-1-jQuery-的下载"><a href="#1-2-1-jQuery-的下载" class="headerlink" title="1.2.1 jQuery 的下载"></a>1.2.1 jQuery 的下载</h3><p>​    jQuery的官网地址： <a href="https://jquery.com/%EF%BC%8C%E5%AE%98%E7%BD%91%E5%8D%B3%E5%8F%AF%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E3%80%82">https://jquery.com/，官网即可下载最新版本。</a></p><blockquote><p> 各个版本的下载：<a href="https://code.jquery.com/">https://code.jquery.com/</a></p></blockquote><p>​    版本介绍：</p><blockquote><p>1x ：兼容 IE 678 等低版本浏览器， 官网不再更新</p><p>2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新</p><p>3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</p></blockquote><h3 id="1-2-2-体验jQuery"><a href="#1-2-2-体验jQuery" class="headerlink" title="1.2.2. 体验jQuery"></a>1.2.2. 体验jQuery</h3><p>​    步骤：</p><ul><li>引入jQuery文件。</li><li>在文档最末尾插入 script 标签，书写体验代码。</li><li>$(‘div’).hide() 可以隐藏盒子。</li></ul><h3 id="1-2-3-jQuery的入口函数"><a href="#1-2-3-jQuery的入口函数" class="headerlink" title="1.2.3. jQuery的入口函数"></a>1.2.3. jQuery的入口函数</h3><p>​    jQuery中常见的两种入口函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种: 简单易用。</span><br>$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;   <br>    ...  <span class="hljs-comment">// 此处是页面 DOM 加载完成的入口</span><br>&#125;) ; <br><br><span class="hljs-comment">// 第二种: 繁琐，但是也可以实现</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>   ...  <span class="hljs-comment">//  此处是页面DOM加载完成的入口</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>​    总结：</p><ol><li>等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</li><li>相当于原生 js 中的 DOMContentLoaded。</li><li>不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。</li><li>更推荐使用第一种方式。</li></ol><h3 id="1-2-4-jQuery中的顶级对象"><a href="#1-2-4-jQuery中的顶级对象" class="headerlink" title="1.2.4. jQuery中的顶级对象$"></a>1.2.4. jQuery中的顶级对象$</h3><ol><li> $是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。</li><li> $是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。</li></ol><h3 id="1-2-5-jQuery-对象和-DOM-对象"><a href="#1-2-5-jQuery-对象和-DOM-对象" class="headerlink" title="1.2.5.  jQuery 对象和 DOM 对象"></a>1.2.5.  jQuery 对象和 DOM 对象</h3><p>​    使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 : </p><ol><li>用原生 JS 获取来的对象就是 DOM 对象</li><li>jQuery 方法获取的元素就是 jQuery 对象。</li><li>jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。</li></ol><blockquote><p>注意：</p><p>只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。</p></blockquote><p><img src="/img/webimg/jQuery%E5%AF%B9%E8%B1%A1%E5%92%8CDOM%E5%AF%B9%E8%B1%A1.png" alt="jQuery对象和DOM对象"></p><h3 id="1-2-6-jQuery-对象和-DOM-对象转换"><a href="#1-2-6-jQuery-对象和-DOM-对象转换" class="headerlink" title="1.2.6.  jQuery 对象和 DOM 对象转换"></a>1.2.6.  jQuery 对象和 DOM 对象转换</h3><p>​    DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.DOM对象转换成jQuery对象，方法只有一种</span><br><span class="hljs-keyword">var</span> box = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box&#x27;</span>);  <span class="hljs-comment">// 获取DOM对象</span><br><span class="hljs-keyword">var</span> jQueryObject = $(box);  <span class="hljs-comment">// 把DOM对象转换为 jQuery 对象</span><br><br><span class="hljs-comment">// 2.jQuery 对象转换为 DOM 对象有两种方法：</span><br><span class="hljs-comment">//   2.1 jQuery对象[索引值]</span><br><span class="hljs-keyword">var</span> domObject1 = $(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">//   2.2 jQuery对象.get(索引值)</span><br><span class="hljs-keyword">var</span> domObject2 = $(<span class="hljs-string">&#x27;div&#x27;</span>).get(<span class="hljs-number">0</span>)<br> <br></code></pre></td></tr></table></figure><p>总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。</p><h2 id="1-3-jQuery-选择器"><a href="#1-3-jQuery-选择器" class="headerlink" title="1.3. jQuery 选择器"></a>1.3. jQuery 选择器</h2><p>​    原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。</p><h3 id="1-3-1-基础选择器"><a href="#1-3-1-基础选择器" class="headerlink" title="1.3.1. 基础选择器"></a>1.3.1. 基础选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;选择器&quot;</span>)   <span class="hljs-comment">//  里面选择器直接写 CSS 选择器即可，但是要加引号 </span><br></code></pre></td></tr></table></figure><p>​    <img src="/img/webimg/%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="基础选择器"></p><h3 id="1-3-2-层级选择器"><a href="#1-3-2-层级选择器" class="headerlink" title="1.3.2. 层级选择器"></a>1.3.2. 层级选择器</h3><p>​    层级选择器最常用的两个分别为：后代选择器和子代选择器。</p><p>​    <img src="/img/webimg/%E5%B1%82%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="层级选择器"></p><p><strong>基础选择器和层级选择器案例代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>我是nav div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是ul 的<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是ul 的<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是ul 的<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.nav&quot;</span>));</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;ul li&quot;</span>));</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-3-筛选选择器"><a href="#1-3-3-筛选选择器" class="headerlink" title="1.3.3. 筛选选择器"></a>1.3.3. 筛选选择器</h3><p>​    筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</p><p><img src="/img/webimg/%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="筛选选择器"></p><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ul li:first&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ul li:eq(2)&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ol li:odd&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;skyblue&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ol li:even&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;pink&quot;</span>);</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>另:  jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。</p><p><img src="/img/webimg/relation.png" alt="筛选方法"></p><p>偏重于记忆，演示代码略。</p><h3 id="1-3-4-知识铺垫"><a href="#1-3-4-知识铺垫" class="headerlink" title="1.3.4 知识铺垫"></a>1.3.4 知识铺垫</h3><ul><li>jQuery 设置样式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).css(<span class="hljs-string">&#x27;属性&#x27;</span>, <span class="hljs-string">&#x27;值&#x27;</span>)    <br></code></pre></td></tr></table></figure><ul><li>jQuery 里面的排他思想</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。</span><br>$(<span class="hljs-built_in">this</span>).css(“color”,”red”);<br>$(<span class="hljs-built_in">this</span>).siblings(). css(“color”,””);<br></code></pre></td></tr></table></figure><ul><li>隐式迭代</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。</span><br><span class="hljs-comment">// 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).hide();  <span class="hljs-comment">// 页面中所有的div全部隐藏，不用循环操作</span><br></code></pre></td></tr></table></figure><ul><li>链式编程</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 链式编程是为了节省代码量，看起来更优雅。</span><br>$(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>).sibling().css(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <br></code></pre></td></tr></table></figure><h3 id="1-3-5-案例：淘宝服饰精品案例"><a href="#1-3-5-案例：淘宝服饰精品案例" class="headerlink" title="1.3.5 案例：淘宝服饰精品案例"></a>1.3.5 案例：淘宝服饰精品案例</h3><blockquote><p>思路分析:<br>1.核心原理：鼠标经过左侧盒子某个小li，就让内容区盒子相对应图片显示，其余的图片隐藏。<br>2.需要得到当前小li 的索引号，就可以显示对应索引号的图片<br>3.jQuery 得到当前元素索引号 $(this).index()<br>4.中间对应的图片，可以通过  eq(index) 方法去选择<br>5.显示元素 show()   隐藏元素 hide()</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-4-jQuery-样式操作"><a href="#1-4-jQuery-样式操作" class="headerlink" title="1.4.  jQuery 样式操作"></a>1.4.  jQuery 样式操作</h2><p>​    jQuery中常用的样式操作有两种：css() 和 设置类样式方法</p><h3 id="1-4-1-方法1-操作-css-方法"><a href="#1-4-1-方法1-操作-css-方法" class="headerlink" title="1.4.1. 方法1: 操作 css 方法"></a>1.4.1. 方法1: 操作 css 方法</h3><p>​    jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。</p><p>​    常用以下三种形式 : </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.参数只写属性名，则是返回属性值</span><br><span class="hljs-keyword">var</span> strColor = $(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&#x27;color&#x27;</span>);<br><br><span class="hljs-comment">// 2.  参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号</span><br>$(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&#x27;&#x27;</span>color<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>red<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 3.  参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号</span><br>$(<span class="hljs-built_in">this</span>).css(&#123; <span class="hljs-string">&quot;color&quot;</span>:<span class="hljs-string">&quot;white&quot;</span>,<span class="hljs-string">&quot;font-size&quot;</span>:<span class="hljs-string">&quot;20px&quot;</span>&#125;);<br><br></code></pre></td></tr></table></figure><p>​    注意：css() 多用于样式少时操作，多了则不太方便。</p><h3 id="1-4-2-方法2-设置类样式方法"><a href="#1-4-2-方法2-设置类样式方法" class="headerlink" title="1.4.2. 方法2: 设置类样式方法"></a>1.4.2. 方法2: 设置类样式方法</h3><p>​    作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。</p><p>​    常用的三种设置类样式方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.添加类</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).addClass(<span class="hljs-string">&quot;current&quot;</span>);<br><br><span class="hljs-comment">// 2.删除类</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).removeClass(<span class="hljs-string">&quot;current&quot;</span>);<br><br><span class="hljs-comment">// 3.切换类</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).toggleClass(<span class="hljs-string">&quot;current&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>​    注意：</p><ol><li>设置类样式方法比较适合样式多时操作，可以弥补css()的不足。</li><li>原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。</li></ol><h3 id="1-4-3-案例：tab-栏切换"><a href="#1-4-3-案例：tab-栏切换" class="headerlink" title="1.4.3. 案例：tab 栏切换"></a>1.4.3. 案例：tab 栏切换</h3><blockquote><p>思路分析:<br>1.点击上部的li，当前li 添加current类，其余兄弟移除类。<br>2.点击的同时，得到当前li 的索引号<br>3.让下部里面相应索引号的item显示，其余的item隐藏</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-5-jQuery-效果"><a href="#1-5-jQuery-效果" class="headerlink" title="1.5. jQuery 效果"></a>1.5. jQuery 效果</h2><p>​    jQuery 给我们封装了很多动画效果，最为常见的如下：</p><ul><li>显示隐藏：show() / hide() / toggle() ;</li><li>划入画出：slideDown() / slideUp() / slideToggle() ; </li><li>淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; </li><li>自定义动画：animate() ;</li></ul><blockquote><p>注意：</p><p>动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</p><p>jQuery为我们提供另一个方法，可以停止动画排队：stop() ;</p></blockquote><h3 id="1-5-1-显示隐藏"><a href="#1-5-1-显示隐藏" class="headerlink" title="1.5.1. 显示隐藏"></a>1.5.1. 显示隐藏</h3><p>​    显示隐藏动画，常见有三个方法：show() / hide() / toggle() ;</p><p>​    语法规范如下:</p><p><img src="/img/webimg/show.png" alt="show"></p><p><img src="/img/webimg/hide.png" alt="hide"></p><p><img src="/img/webimg/toggle.png" alt="toggle"></p><p><strong>代码演示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>显示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">0</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).show(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                    alert(<span class="hljs-number">1</span>);</span></span><br><span class="javascript"><span class="xml">                &#125;);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">1</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).hide(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                    alert(<span class="hljs-number">1</span>);</span></span><br><span class="javascript"><span class="xml">                &#125;);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">2</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">              $(<span class="hljs-string">&quot;div&quot;</span>).toggle(<span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 一般情况下，我们都不加参数直接显示隐藏就可以了</span></span></span><br><span class="javascript"><span class="xml">        &#125;);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-5-2-滑入滑出"><a href="#1-5-2-滑入滑出" class="headerlink" title="1.5.2. 滑入滑出"></a>1.5.2. 滑入滑出</h3><p>​    滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ; </p><p>​    语法规范如下:</p><p><img src="/img/webimg/slideDown.png" alt="slideDown"></p><p><img src="/img/webimg/slideUp.png" alt="slideUp"></p><p><img src="/img/webimg/slideToggle.png" alt="slideToggle"></p><p><strong>代码演示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>下拉滑动<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上拉滑动<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>切换滑动<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">0</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 下滑动 slideDown()</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).slideDown();</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">1</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 上滑动 slideUp()</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).slideUp(<span class="hljs-number">500</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">2</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 滑动切换 slideToggle()</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).slideToggle(<span class="hljs-number">500</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">        &#125;);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><blockquote><p>小案例：下拉菜单略（详情参看源码）。</p></blockquote><h3 id="1-5-3-淡入淡出"><a href="#1-5-3-淡入淡出" class="headerlink" title="1.5.3 淡入淡出"></a>1.5.3 淡入淡出</h3><p>​    淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; </p><p>​    语法规范如下:</p><p><img src="/img/webimg/fadeIn.png" alt="fadeIn"></p><p><img src="/img/webimg/fadeOut.png" alt="fadeOut"></p><p><img src="/img/webimg/fadeToggle.png" alt="fadeToggle"></p><p><img src="/img/webimg/fadeTo.png" alt="fadeTo"></p><p><strong>代码演示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>淡入效果<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>淡出效果<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>淡入淡出切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>修改透明度<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">0</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 淡入 fadeIn()</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).fadeIn(<span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">1</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 淡出 fadeOut()</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).fadeOut(<span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">2</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 淡入淡出切换 fadeToggle()</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).fadeToggle(<span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">3</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">//  修改透明度 fadeTo() 这个速度和透明度要必须写</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).fadeTo(<span class="hljs-number">1000</span>, <span class="hljs-number">0.5</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">        &#125;);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-5-4-自定义动画"><a href="#1-5-4-自定义动画" class="headerlink" title="1.5.4 自定义动画"></a>1.5.4 自定义动画</h3><p>​    自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ;</p><p>​    语法规范如下:</p><p><img src="/img/webimg/animate.png"></p><p><strong>代码演示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>动起来<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;div&quot;</span>).animate(&#123;</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-attr">left</span>: <span class="hljs-number">500</span>,</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-attr">top</span>: <span class="hljs-number">300</span>,</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-attr">opacity</span>: <span class="hljs-number">.4</span>,</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-attr">width</span>: <span class="hljs-number">500</span></span></span><br><span class="javascript"><span class="xml">                &#125;, <span class="hljs-number">500</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-5-5-停止动画排队"><a href="#1-5-5-停止动画排队" class="headerlink" title="1.5.5 停止动画排队"></a>1.5.5 停止动画排队</h3><p>​    动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</p><p>​    停止动画排队的方法为：stop() ; </p><ul><li>stop() 方法用于停止动画或效果。</li><li>stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。</li></ul><p>​        总结: 每次使用动画之前，先调用 stop() ,在调用动画。</p><h3 id="1-5-6-事件切换"><a href="#1-5-6-事件切换" class="headerlink" title="1.5.6. 事件切换"></a>1.5.6. 事件切换</h3><p>​    jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下</p><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">hover([over,]out)     <span class="hljs-comment">// 其中over和out为两个函数</span><br></code></pre></td></tr></table></figure><ul><li>over:鼠标移到元素上要触发的函数（相当于mouseenter）</li><li>out:鼠标移出元素要触发的函数（相当于mouseleave）</li><li>如果只写一个函数，则鼠标经过和离开都会触发它</li></ul><p><strong>hover事件和停止动画排列案例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>微博<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>私信<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>评论<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>@我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>微博<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>私信<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>评论<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>@我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 鼠标经过</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;.nav&gt;li&quot;).mouseover(function() &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     // $(this) jQuery 当前元素  this不要加引号</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     // show() 显示元素  hide() 隐藏元素</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     $(this).children(&quot;ul&quot;).slideDown(200);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// // 鼠标离开</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;.nav&gt;li&quot;).mouseout(function() &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     $(this).children(&quot;ul&quot;).slideUp(200);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 1. 事件切换 hover 就是鼠标经过和离开的复合写法</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;.nav&gt;li&quot;).hover(function() &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     $(this).children(&quot;ul&quot;).slideDown(200);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;, function() &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     $(this).children(&quot;ul&quot;).slideUp(200);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. 事件切换 hover  如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;.nav&gt;li&quot;</span>).hover(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// stop 方法必须写到动画的前面</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-built_in">this</span>).children(<span class="hljs-string">&quot;ul&quot;</span>).stop().slideToggle();</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-5-7-案例：王者荣耀手风琴效果"><a href="#1-5-7-案例：王者荣耀手风琴效果" class="headerlink" title="1.5.7. 案例：王者荣耀手风琴效果"></a>1.5.7. 案例：王者荣耀手风琴效果</h3><blockquote><p>思路分析:<br>1.鼠标经过某个小li 有两步操作：<br>2.当前小li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入<br>3.其余兄弟小li宽度变为69px， 小图片淡入， 大图片淡出</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-6-今日总结"><a href="#1-6-今日总结" class="headerlink" title="1.6. 今日总结"></a>1.6. 今日总结</h2><p><img src="/img/webimg/%E6%80%BB%E7%BB%93.png" alt="总结"></p><h1 id="day02-jQuery"><a href="#day02-jQuery" class="headerlink" title="day02 - jQuery"></a>day02 - jQuery</h1><blockquote><p>学习目标：</p><p>能够操作  jQuery 属性<br>能够操作  jQuery 元素<br>能够操作  jQuery 元素尺寸、位置</p></blockquote><h2 id="1-1-jQuery-属性操作"><a href="#1-1-jQuery-属性操作" class="headerlink" title="1.1. jQuery 属性操作"></a>1.1. jQuery 属性操作</h2><p>​    jQuery 常用属性操作有三种：prop() / attr() / data() ;</p><h3 id="1-1-1-元素固有属性值-prop"><a href="#1-1-1-元素固有属性值-prop" class="headerlink" title="1.1.1 元素固有属性值 prop()"></a>1.1.1 元素固有属性值 prop()</h3><p>​    所谓元素固有属性就是元素本身自带的属性，比如 <a> 元素里面的 href ，比如 <code>&lt;input&gt;</code> 元素里面的 type。 </a></p><p><strong>语法</strong></p><p><img src="/img/webimg/prop.png" alt="prop"></p><p>​    注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</p><h3 id="1-1-2-元素自定义属性值-attr"><a href="#1-1-2-元素自定义属性值-attr" class="headerlink" title="1.1.2 元素自定义属性值 attr()"></a>1.1.2 元素自定义属性值 attr()</h3><p>​    用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 </p><p><strong>语法</strong></p><p><img src="/img/webimg/attr.png" alt="attr"></p><p>​    注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性）</p><h3 id="1-1-3-数据缓存-data"><a href="#1-1-3-数据缓存-data" class="headerlink" title="1.1.3 数据缓存 data()"></a>1.1.3 数据缓存 data()</h3><p>​    data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 </p><p><strong>语法</strong></p><p><img src="/img/webimg/data.png" alt="data"></p><p>​    注意：同时，还可以读取 HTML5 自定义属性  data-index ，得到的是数字型。</p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;都挺好&quot;</span>&gt;</span>都挺好<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">checked</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;a&quot;</span>).prop(<span class="hljs-string">&quot;href&quot;</span>));</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;a&quot;</span>).prop(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;我们都挺好&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;input&quot;</span>).change(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-built_in">console</span>.log($(<span class="hljs-built_in">this</span>).prop(<span class="hljs-string">&quot;checked&quot;</span>));</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// console.log($(&quot;div&quot;).prop(&quot;index&quot;));</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. 元素的自定义属性 我们通过 attr()</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).attr(<span class="hljs-string">&quot;index&quot;</span>));</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).attr(<span class="hljs-string">&quot;index&quot;</span>, <span class="hljs-number">4</span>);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).attr(<span class="hljs-string">&quot;data-index&quot;</span>));</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;span&quot;</span>).data(<span class="hljs-string">&quot;uname&quot;</span>, <span class="hljs-string">&quot;andy&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;span&quot;</span>).data(<span class="hljs-string">&quot;uname&quot;</span>));</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).data(<span class="hljs-string">&quot;index&quot;</span>));</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-1-4-案例：购物车案例模块-全选"><a href="#1-1-4-案例：购物车案例模块-全选" class="headerlink" title="1.1.4 案例：购物车案例模块-全选"></a>1.1.4 案例：购物车案例模块-全选</h3><blockquote><p>1.全选思路：里面3个小的复选框按钮（j-checkbox）选中状态（checked）跟着全选按钮（checkall）走。<br>2.因为checked 是复选框的固有属性，此时我们需要利用prop()方法获取和设置该属性。<br>3.把全选按钮状态赋值给3小复选框就可以了。<br>4.当我们每次点击小的复选框按钮，就来判断：<br>5.如果小复选框被选中的个数等于3 就应该把全选按钮选上，否则全选按钮不选。<br>6.:checked 选择器      :checked 查找被选中的表单元素。</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-2-jQuery-文本属性值"><a href="#1-2-jQuery-文本属性值" class="headerlink" title="1.2. jQuery 文本属性值"></a>1.2. jQuery 文本属性值</h2><p>​    jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。</p><h3 id="1-2-1-jQuery内容文本值"><a href="#1-2-1-jQuery内容文本值" class="headerlink" title="1.2.1 jQuery内容文本值"></a>1.2.1 jQuery内容文本值</h3><p>​    常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。</p><p><strong>语法</strong></p><p><img src="/img/webimg/html.png" alt="html"></p><p>​    注意：html() 可识别标签，text() 不识别标签。</p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;请输入内容&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 获取设置元素内容 html()</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).html());</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// $(&quot;div&quot;).html(&quot;123&quot;);</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. 获取设置元素文本内容 text()</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).text());</span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-string">&quot;div&quot;</span>).text(<span class="hljs-string">&quot;123&quot;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 3. 获取设置表单值 val()</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;input&quot;</span>).val());</span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-string">&quot;input&quot;</span>).val(<span class="hljs-string">&quot;123&quot;</span>);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-2-2-案例：购物车案例模块-增减商品数量"><a href="#1-2-2-案例：购物车案例模块-增减商品数量" class="headerlink" title="1.2.2. 案例：购物车案例模块-增减商品数量"></a>1.2.2. 案例：购物车案例模块-增减商品数量</h3><blockquote><p>1.核心思路：首先声明一个变量，当我们点击+号（increment），就让这个值++，然后赋值给文本框。<br>2.注意1： 只能增加本商品的数量， 就是当前+号的兄弟文本框（itxt）的值。<br>3.修改表单的值是val() 方法<br>4.注意2： 这个变量初始值应该是这个文本框的值，在这个值的基础上++。要获取表单的值<br>5.减号（decrement）思路同理，但是如果文本框的值是1，就不能再减了。</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h3 id="1-2-3-案例：购物车案例模块-修改商品小计"><a href="#1-2-3-案例：购物车案例模块-修改商品小计" class="headerlink" title="1.2.3. 案例：购物车案例模块-修改商品小计"></a>1.2.3. 案例：购物车案例模块-修改商品小计</h3><blockquote><p>1.核心思路：每次点击+号或者-号，根据文本框的值 乘以 当前商品的价格  就是 商品的小计<br>2.注意1： 只能增加本商品的小计， 就是当前商品的小计模块（p-sum）<br>3.修改普通元素的内容是text() 方法<br>4.注意2： 当前商品的价格，要把￥符号去掉再相乘 截取字符串 substr(1)<br>5.parents(‘选择器’) 可以返回指定祖先元素<br>6.最后计算的结果如果想要保留2位小数 通过 toFixed(2)  方法<br>7.用户也可以直接修改表单里面的值，同样要计算小计。 用表单change事件<br>8.用最新的表单内的值 乘以 单价即可  但是还是当前商品小计</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-3-jQuery-元素操作"><a href="#1-3-jQuery-元素操作" class="headerlink" title="1.3. jQuery 元素操作"></a>1.3. jQuery 元素操作</h2><p>​    jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。</p><h3 id="1-3-1-遍历元素"><a href="#1-3-1-遍历元素" class="headerlink" title="1.3.1. 遍历元素"></a>1.3.1. 遍历元素</h3><p>​    jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。</p><p><strong>语法1</strong></p><p><img src="/img/webimg/each1.png" alt="each1"></p><p>​    注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</p><p><strong>语法2</strong></p><p><img src="/img/webimg/each2.png" alt="each2"></p><p>​    注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 1. each() 方法遍历元素 </span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, domEle</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 回调函数第一个参数一定是索引号  可以自己指定索引号号名称</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// console.log(i);</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 回调函数第二个参数一定是 dom 元素对象，也是自己命名</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// console.log(domEle);  // 使用jQuery方法需要转换 $(domEle)</span></span></span><br><span class="javascript"><span class="xml">                $(domEle).css(<span class="hljs-string">&quot;color&quot;</span>, arr[i]);</span></span><br><span class="javascript"><span class="xml">                sum += <span class="hljs-built_in">parseInt</span>($(domEle).text());</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log(sum);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $.each($(&quot;div&quot;), function(i, ele) &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     console.log(i);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     console.log(ele);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $.each(arr, function(i, ele) &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     console.log(i);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     console.log(ele);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;)</span></span></span><br><span class="javascript"><span class="xml">            $.each(&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;andy&quot;</span>,</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">age</span>: <span class="hljs-number">18</span></span></span><br><span class="javascript"><span class="xml">            &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, ele</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 输出的是 name age 属性名</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-built_in">console</span>.log(ele); <span class="hljs-comment">// 输出的是 andy  18 属性值</span></span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-案例：购物车案例模块-计算总计和总额"><a href="#1-3-2-案例：购物车案例模块-计算总计和总额" class="headerlink" title="1.3.2. 案例：购物车案例模块-计算总计和总额"></a>1.3.2. 案例：购物车案例模块-计算总计和总额</h3><blockquote><p>1.把所有文本框中的值相加就是总额数量，总计同理。<br>2.文本框里面的值不同，如果想要相加需要用 each() 遍历，声明一个变量做计数器，累加即可。</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h3 id="1-3-3-创建、添加、删除"><a href="#1-3-3-创建、添加、删除" class="headerlink" title="1.3.3. 创建、添加、删除"></a>1.3.3. 创建、添加、删除</h3><p>​    jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下：</p><p><strong>语法总和</strong></p><p><img src="/img/webimg/create.png" alt="create"></p><p><img src="/img/webimg/append1.png" alt="append1"></p><p><img src="/img/webimg/append2.png" alt="append2"></p><p><img src="/img/webimg/remove.png" alt="remove"></p><p>​    注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。</p><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>原先的li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>我是原先的div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 1. 创建元素</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> li = $(<span class="hljs-string">&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;</span>);</span></span><br><span class="javascript"><span class="xml">      </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. 添加元素</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2.1 内部添加</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;ul&quot;).append(li);  内部添加并且放到内容的最后面 </span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ul&quot;</span>).prepend(li); <span class="hljs-comment">// 内部添加并且放到内容的最前面</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//  2.2 外部添加</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> div = $(<span class="hljs-string">&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;.test&quot;).after(div);</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;.test&quot;</span>).before(div);</span></span><br><span class="javascript"><span class="xml">      </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 3. 删除元素</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ul&quot;</span>).html(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 可以删除匹配的元素里面的子节点 孩子</span></span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-4-案例：购物车案例模块-删除商品模块"><a href="#1-3-4-案例：购物车案例模块-删除商品模块" class="headerlink" title="1.3.4 案例：购物车案例模块-删除商品模块"></a>1.3.4 案例：购物车案例模块-删除商品模块</h3><blockquote><p>1.核心思路：把商品remove() 删除元素即可<br>2.有三个地方需要删除： 1. 商品后面的删除按钮 2. 删除选中的商品 3. 清理购物车<br>3.商品后面的删除按钮： 一定是删除当前的商品，所以从 $(this) 出发<br>4.删除选中的商品： 先判断小的复选框按钮是否选中状态，如果是选中，则删除对应的商品<br>5.清理购物车： 则是把所有的商品全部删掉</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h3 id="1-3-5-案例：购物车案例模块-选中商品添加背景"><a href="#1-3-5-案例：购物车案例模块-选中商品添加背景" class="headerlink" title="1.3.5 案例：购物车案例模块-选中商品添加背景"></a>1.3.5 案例：购物车案例模块-选中商品添加背景</h3><blockquote><p>1.核心思路：选中的商品添加背景，不选中移除背景即可<br>2.全选按钮点击：如果全选是选中的，则所有的商品添加背景，否则移除背景<br>3.小的复选框点击： 如果是选中状态，则当前商品添加背景，否则移除背景<br>4.这个背景，可以通过类名修改，添加类和删除类</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-4-jQuery-尺寸、位置操作"><a href="#1-4-jQuery-尺寸、位置操作" class="headerlink" title="1.4.  jQuery 尺寸、位置操作"></a>1.4.  jQuery 尺寸、位置操作</h2><p>​    jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</p><h3 id="1-4-1-jQuery-尺寸操作"><a href="#1-4-1-jQuery-尺寸操作" class="headerlink" title="1.4.1.  jQuery 尺寸操作"></a>1.4.1.  jQuery 尺寸操作</h3><p>​     jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。</p><p><strong>语法</strong></p><p><img src="/img/webimg/size.png" alt="size"></p><p><strong>代码演示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 1. width() / height() 获取设置元素 width和height大小 </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).width());</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;div&quot;).width(300);</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小 </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).innerWidth());</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小 </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).outerWidth());</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).outerWidth(<span class="hljs-literal">true</span>));</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>​    注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。</p><h3 id="1-4-2-jQuery-位置操作"><a href="#1-4-2-jQuery-位置操作" class="headerlink" title="1.4.2. jQuery 位置操作"></a>1.4.2. jQuery 位置操作</h3><p>​    jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下: </p><p><strong>语法</strong></p><p><img src="/img/webimg/offset.png" alt="offset"></p><p><img src="/img/webimg/position.png" alt="position"></p><p><img src="/img/webimg/scroll.png" alt="scroll"></p><p><strong>代码演示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        <br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;back&quot;</span>&gt;</span>返回顶部<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 1. 获取设置距离文档的位置（偏移） offset</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.son&quot;</span>).offset());</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.son&quot;</span>).offset().top);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;.son&quot;).offset(&#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     top: 200,</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     left: 200</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;);</span></span></span><br><span class="javascript"><span class="xml">      </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. 获取距离带有定位父级位置（偏移） position   如果没有带有定位的父级，则以文档为准</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 这个方法只能获取不能设置偏移</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.son&quot;</span>).position());</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;.son&quot;).position(&#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     top: 200,</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     left: 200</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;);</span></span></span><br><span class="javascript"><span class="xml">      </span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 3. 被卷去的头部</span></span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-built_in">document</span>).scrollTop(<span class="hljs-number">100</span>);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 被卷去的头部 scrollTop()  / 被卷去的左侧 scrollLeft()</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 页面滚动事件</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> boxTop = $(<span class="hljs-string">&quot;.container&quot;</span>).offset().top;</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-built_in">window</span>).scroll(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// console.log(11);</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-built_in">console</span>.log($(<span class="hljs-built_in">document</span>).scrollTop());</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">document</span>).scrollTop() &gt;= boxTop) &#123;</span></span><br><span class="javascript"><span class="xml">                    $(<span class="hljs-string">&quot;.back&quot;</span>).fadeIn();</span></span><br><span class="javascript"><span class="xml">                &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">                    $(<span class="hljs-string">&quot;.back&quot;</span>).fadeOut();</span></span><br><span class="javascript"><span class="xml">                &#125;</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 返回顶部</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;.back&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// $(document).scrollTop(0);</span></span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-string">&quot;body, html&quot;</span>).stop().animate(&#123;</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-attr">scrollTop</span>: <span class="hljs-number">0</span></span></span><br><span class="javascript"><span class="xml">                &#125;);</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// $(document).stop().animate(&#123;</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">//     scrollTop: 0</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// &#125;); 不能是文档而是 html和body元素做动画</span></span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-4-3-案例：带有动画的返回顶部"><a href="#1-4-3-案例：带有动画的返回顶部" class="headerlink" title="1.4.3. 案例：带有动画的返回顶部"></a>1.4.3. 案例：带有动画的返回顶部</h3><blockquote><p>1.核心原理： 使用animate动画返回顶部。<br>2.animate动画函数里面有个scrollTop 属性，可以设置位置<br>3.但是是元素做动画，因此 $(“body,html”).animate({scrollTop: 0})</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h3 id="1-4-4-案例：-品优购电梯导航（上）"><a href="#1-4-4-案例：-品优购电梯导航（上）" class="headerlink" title="1.4.4. 案例： 品优购电梯导航（上）"></a>1.4.4. 案例： 品优购电梯导航（上）</h3><blockquote><p>1.当我们滚动到 今日推荐 模块，就让电梯导航显示出来<br>2.点击电梯导航页面可以滚动到相应内容区域<br>3.核心算法：因为电梯导航模块和内容区模块一一对应的<br>4.当我们点击电梯导航某个小模块，就可以拿到当前小模块的索引号<br>5.就可以把animate要移动的距离求出来：当前索引号内容区模块它的offset().top<br>6.然后执行动画即可</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h3 id="1-4-5-案例：品优购电梯导航（下）"><a href="#1-4-5-案例：品优购电梯导航（下）" class="headerlink" title="1.4.5. 案例：品优购电梯导航（下）"></a>1.4.5. 案例：品优购电梯导航（下）</h3><blockquote><p>1.当我们点击电梯导航某个小li， 当前小li 添加current类，兄弟移除类名<br>2.当我们页面滚动到内容区域某个模块， 左侧电梯导航，相对应的小li模块，也会添加current类， 兄弟移除current类。<br>3.触发的事件是页面滚动，因此这个功能要写到页面滚动事件里面。<br>4.需要用到each，遍历内容区域大模块。 each里面能拿到内容区域每一个模块元素和索引号<br>5.判断的条件：  被卷去的头部 大于等于 内容区域里面每个模块的offset().top<br>6.就利用这个索引号找到相应的电梯导航小li添加类。</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-5-今日总结"><a href="#1-5-今日总结" class="headerlink" title="1.5. 今日总结"></a>1.5. 今日总结</h2><p><img src="/img/webimg/%E6%80%BB%E7%BB%9302.png" alt="总结"></p><h1 id="day03-jQuery"><a href="#day03-jQuery" class="headerlink" title="day03 - jQuery"></a>day03 - jQuery</h1><blockquote><p>学习目标：</p><p>能够说出4种常见的注册事件<br>能够说出 on 绑定事件的优势<br>能够说出 jQuery 事件委派的优点以及方式<br>能够说出绑定事件与解绑事件<br>能够说出 jQuery 对象的拷贝方法<br>能够说出 jQuery 多库共存的2种方法<br>能够使用 jQuery 插件</p></blockquote><h2 id="1-1-jQuery-事件注册"><a href="#1-1-jQuery-事件注册" class="headerlink" title="1.1. jQuery 事件注册"></a>1.1. jQuery 事件注册</h2><p>​    jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下：</p><ul><li>优点: 操作简单，且不用担心事件覆盖等问题。</li><li>缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。</li></ul><p><strong>语法</strong></p><p><img src="/img/webimg/register.png" alt="register"></p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 1. 单个事件注册</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&quot;background&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).mouseenter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&quot;background&quot;</span>, <span class="hljs-string">&quot;skyblue&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h2 id="1-2-jQuery-事件处理"><a href="#1-2-jQuery-事件处理" class="headerlink" title="1.2. jQuery 事件处理"></a>1.2. jQuery 事件处理</h2><p>​    因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下：</p><ul><li>on(): 用于事件绑定，目前最好用的事件绑定方法</li><li>off(): 事件解绑</li><li>trigger() / triggerHandler(): 事件触发</li></ul><h3 id="1-2-1-事件处理-on-绑定事件"><a href="#1-2-1-事件处理-on-绑定事件" class="headerlink" title="1.2.1 事件处理 on() 绑定事件"></a>1.2.1 事件处理 on() 绑定事件</h3><p>​    因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on()</p><p><strong>语法</strong></p><p><img src="/img/webimg/on1.png" alt="on1"></p><p><img src="/img/webimg/on2.png" alt="on2"></p><p><img src="/img/webimg/on3.png" alt="on3"></p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我们都是好孩子<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我们都是好孩子<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我们都是好孩子<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></span><br><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (1) on可以绑定1个或者多个事件处理程序</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;div&quot;).on(&#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     mouseenter: function() &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//         $(this).css(&quot;background&quot;, &quot;skyblue&quot;);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     &#125;,</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     click: function() &#123;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//         $(this).css(&quot;background&quot;, &quot;purple&quot;);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//     &#125;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// &#125;);</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).on(<span class="hljs-string">&quot;mouseenter mouseleave&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                $(<span class="hljs-built_in">this</span>).toggleClass(<span class="hljs-string">&quot;current&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (2) on可以实现事件委托（委派）</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;ul li&quot;).click();</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ul&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                alert(<span class="hljs-number">11</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (3) on可以给未来动态创建的元素绑定事件</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ol&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                alert(<span class="hljs-number">11</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> li = $(<span class="hljs-string">&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ol&quot;</span>).append(li);</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br><br></code></pre></td></tr></table></figure><h3 id="1-2-2-案例：发布微博案例"><a href="#1-2-2-案例：发布微博案例" class="headerlink" title="1.2.2. 案例：发布微博案例"></a>1.2.2. 案例：发布微博案例</h3><blockquote><p>1.点击发布按钮， 动态创建一个小li，放入文本框的内容和删除按钮， 并且添加到ul 中。<br>2.点击的删除按钮，可以删除当前的微博留言。</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h3 id="1-2-3-事件处理-off-解绑事件"><a href="#1-2-3-事件处理-off-解绑事件" class="headerlink" title="1.2.3. 事件处理 off() 解绑事件"></a>1.2.3. 事件处理 off() 解绑事件</h3><p>​    当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ;</p><p><strong>语法</strong></p><p><img src="/img/webimg/off.png" alt="off"></p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我们都是好孩子<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我们都是好孩子<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我们都是好孩子<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个P标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// 事件绑定</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).on(&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">click</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我点击了&quot;</span>);</span></span><br><span class="javascript"><span class="xml">                &#125;,</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">mouseover</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我鼠标经过了&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">                &#125;</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ul&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                alert(<span class="hljs-number">11</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;);</span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 1. 事件解绑 off </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// $(&quot;div&quot;).off();  // 这个是解除了div身上的所有事件</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).off(<span class="hljs-string">&quot;click&quot;</span>); <span class="hljs-comment">// 这个是解除了div身上的点击事件</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;ul&quot;</span>).off(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>);</span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. one() 但是它只能触发事件一次</span></span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;p&quot;</span>).one(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                alert(<span class="hljs-number">11</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-2-4-事件处理-trigger-自动触发事件"><a href="#1-2-4-事件处理-trigger-自动触发事件" class="headerlink" title="1.2.4. 事件处理 trigger() 自动触发事件"></a>1.2.4. 事件处理 trigger() 自动触发事件</h3><p>​    有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; </p><p><strong>语法</strong></p><p><img src="/img/webimg/t1.png" alt="t1"></p><p><img src="/img/webimg/t2.png" alt="t2"></p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span></span><br><span class="xml">      </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 绑定事件</span></span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&quot;div&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        alert(<span class="hljs-number">11</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;);</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 自动触发事件</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 1. 元素.事件()</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// $(&quot;div&quot;).click();会触发元素的默认行为</span></span></span><br><span class="javascript"><span class="xml">      </span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 2. 元素.trigger(&quot;事件&quot;)</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为</span></span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&quot;input&quot;</span>).trigger(<span class="hljs-string">&quot;focus&quot;</span>);</span></span><br><span class="javascript"><span class="xml">      </span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为</span></span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&quot;input&quot;</span>).on(<span class="hljs-string">&quot;focus&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-built_in">this</span>).val(<span class="hljs-string">&quot;你好吗&quot;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;);</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 一个会获取焦点，一个不会</span></span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&quot;div&quot;</span>).triggerHandler(<span class="hljs-string">&quot;click&quot;</span>);</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);</span></span></span><br><span class="javascript"><span class="xml">    &#125;);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="1-3-jQuery-事件对象"><a href="#1-3-jQuery-事件对象" class="headerlink" title="1.3. jQuery 事件对象"></a>1.3. jQuery 事件对象</h2><p>​    jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。</p><p><strong>语法</strong></p><p><img src="/img/webimg/event.png" alt="event"></p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-built_in">document</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;点击了document&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">            $(<span class="hljs-string">&quot;div&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// console.log(event);</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;点击了div&quot;</span>);</span></span><br><span class="javascript"><span class="xml">                event.stopPropagation();</span></span><br><span class="javascript"><span class="xml">            &#125;)</span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。</p><h2 id="1-4-jQuery-拷贝对象"><a href="#1-4-jQuery-拷贝对象" class="headerlink" title="1.4.  jQuery 拷贝对象"></a>1.4.  jQuery 拷贝对象</h2><p>​    jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</p><p><strong>语法</strong></p><p><img src="/img/webimg/extend.png" alt="extend"></p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>       $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 1.合并数据</span><br>           <span class="hljs-keyword">var</span> targetObj = &#123;&#125;;<br>           <span class="hljs-keyword">var</span> obj = &#123;<br>               <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>               <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;andy&quot;</span><br>           &#125;;<br>           <span class="hljs-comment">// $.extend(target, obj);</span><br>           $.extend(targetObj, obj);<br>           <span class="hljs-built_in">console</span>.log(targetObj);<br>  <br>  <span class="hljs-comment">// 2. 会覆盖 targetObj 里面原来的数据</span><br>           <span class="hljs-keyword">var</span> targetObj = &#123;<br>               <span class="hljs-attr">id</span>: <span class="hljs-number">0</span><br>           &#125;;<br>           <span class="hljs-keyword">var</span> obj = &#123;<br>               <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>               <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;andy&quot;</span><br>           &#125;;<br>           <span class="hljs-comment">// $.extend(target, obj);</span><br>           $.extend(targetObj, obj);<br>           <span class="hljs-built_in">console</span>.log(targetObj); <br>       &#125;)<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="1-5-jQuery-多库共存"><a href="#1-5-jQuery-多库共存" class="headerlink" title="1.5.  jQuery 多库共存"></a>1.5.  jQuery 多库共存</h2><p>​    实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。</p><p><strong>语法</strong></p><p><img src="/img/webimg/noconfig.png" alt="noconfig"></p><p><strong>演示代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 让jquery 释放对$ 控制权 让用自己决定</span><br>  <span class="hljs-keyword">var</span> suibian = jQuery.noConflict();<br>  <span class="hljs-built_in">console</span>.log(suibian(<span class="hljs-string">&quot;span&quot;</span>));<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="1-6-jQuery-插件"><a href="#1-6-jQuery-插件" class="headerlink" title="1.6.  jQuery 插件"></a>1.6.  jQuery 插件</h2><p>​    jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入</p><p>jQuery文件，因此也称为 jQuery 插件。</p><p>​    jQuery 插件常用的网站：</p><ol><li><p>jQuery 插件库  <a href="http://www.jq22.com/">http://www.jq22.com/</a>     </p></li><li><p>jQuery 之家   <a href="http://www.htmleaf.com/">http://www.htmleaf.com/</a> </p><p>jQuery 插件使用步骤：</p></li><li><p>引入相关文件。（jQuery 文件 和 插件文件）    </p></li><li><p>复制相关html、css、js (调用插件)。</p></li></ol><h3 id="1-4-1-瀑布流插件（重点讲解）"><a href="#1-4-1-瀑布流插件（重点讲解）" class="headerlink" title="1.4.1.  瀑布流插件（重点讲解）"></a>1.4.1.  瀑布流插件（重点讲解）</h3><p>​    我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。</p><p><strong>下载位置</strong></p><p><img src="/img/webimg/water.png" alt="water"></p><p><img src="/img/webimg/download.png"></p><p><strong>代码演示</strong></p><p>​    插件的使用三点：   1. 引入css.           2.引入JS            3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js）</p><ul><li>1.引入css.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;css/normalize.css&quot;</span>&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/default.css&quot;</span>&gt;</span></span><br><span class="xml">  </span><br><span class="xml"><span class="hljs-comment">&lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="css"><span class="xml">  <span class="hljs-selector-id">#gallery-wrapper</span> &#123;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">position</span>: relative;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">75%</span>;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">width</span>: <span class="hljs-number">75%</span>;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span> auto;</span></span><br><span class="css"><span class="xml">  &#125;</span></span><br><span class="css"><span class="xml"></span></span><br><span class="css"><span class="xml">  <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.thumb</span> &#123;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">height</span>: auto;</span></span><br><span class="css"><span class="xml">  &#125;</span></span><br><span class="css"><span class="xml"></span></span><br><span class="css"><span class="xml">  <span class="hljs-selector-class">.white-panel</span> &#123;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">background</span>: white;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="css"><span class="xml">  &#125;</span></span><br><span class="css"><span class="xml"></span></span><br><span class="css"><span class="xml">  <span class="hljs-selector-class">.white-panel</span> <span class="hljs-selector-tag">h1</span> &#123;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;</span></span><br><span class="css"><span class="xml">  &#125;</span></span><br><span class="css"><span class="xml"></span></span><br><span class="css"><span class="xml">  <span class="hljs-selector-class">.white-panel</span> <span class="hljs-selector-tag">h1</span> <span class="hljs-selector-tag">a</span> &#123;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">color</span>: <span class="hljs-number">#A92733</span>;</span></span><br><span class="css"><span class="xml">  &#125;</span></span><br><span class="css"><span class="xml"></span></span><br><span class="css"><span class="xml">  <span class="hljs-selector-class">.white-panel</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">5px</span>;</span></span><br><span class="css"><span class="xml">    -webkit-<span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease-in-out;</span></span><br><span class="css"><span class="xml">    -moz-<span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease-in-out;</span></span><br><span class="css"><span class="xml">    -o-<span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease-in-out;</span></span><br><span class="css"><span class="xml">    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease-in-out;</span></span><br><span class="css"><span class="xml">  &#125;</span></span><br><span class="css"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>2.引入js.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 前两个必须引入 --&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/pinterest_grid.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&quot;#gallery-wrapper&quot;</span>).pinterest_grid(&#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-attr">no_columns</span>: <span class="hljs-number">5</span>,</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-attr">padding_x</span>: <span class="hljs-number">15</span>,</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-attr">padding_y</span>: <span class="hljs-number">10</span>,</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-attr">margin_bottom</span>: <span class="hljs-number">50</span>,</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-attr">single_column_breakpoint</span>: <span class="hljs-number">700</span></span></span><br><span class="javascript"><span class="xml">      &#125;);</span></span><br><span class="javascript"><span class="xml">&#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>3.引入html.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt;<br>&lt;section id=&quot;gallery-wrapper&quot;&gt;<br>       &lt;article class=&quot;white-panel&quot;&gt;<br>           &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt;<br>           &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;<br>           &lt;p&gt;里面很精彩哦&lt;/p&gt;<br>       &lt;/article&gt;<br>       &lt;article class=&quot;white-panel&quot;&gt;<br>           &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt;<br>           &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;<br>           &lt;p&gt;里面很精彩哦&lt;/p&gt;<br>       &lt;/article&gt;<br>       &lt;article class=&quot;white-panel&quot;&gt;<br>           &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt;<br>           &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;<br>           &lt;p&gt;里面很精彩哦&lt;/p&gt;<br>       &lt;/article&gt;<br>       &lt;article class=&quot;white-panel&quot;&gt;<br>           &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt;<br>           &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;<br>           &lt;p&gt;里面很精彩哦&lt;/p&gt;<br>       &lt;/article&gt;<br>   &lt;/section&gt;<br></code></pre></td></tr></table></figure><p>总结：jQuery插件就是引入别人写好的：html 、css、js  （有时也可以只引入一部分，读懂后也可以修改部分内容）</p><h3 id="1-4-2-图片懒加载插件"><a href="#1-4-2-图片懒加载插件" class="headerlink" title="1.4.2. 图片懒加载插件"></a>1.4.2. 图片懒加载插件</h3><p>​    图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略）</p><p><strong>代码演示</strong></p><p>​    懒加载只需引入html 和 js操作 即可，此插件不涉及css。</p><ul><li>1.引入js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;js/EasyLazyload.min.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">   lazyLoadInit(&#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">showTime</span>: <span class="hljs-number">1100</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">onLoadBackEnd</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;onLoadBackEnd:&quot;</span> + i);</span></span><br><span class="javascript"><span class="xml">   &#125;,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">onLoadBackStart</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;onLoadBackStart:&quot;</span> + i);</span></span><br><span class="javascript"><span class="xml">   &#125;</span></span><br><span class="javascript"><span class="xml"> &#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>2.引入html</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;img data-lazy-src=<span class="hljs-string">&quot;upload/floor-1-3.png&quot;</span> alt=<span class="hljs-string">&quot;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="1-4-3-全屏滚动插件"><a href="#1-4-3-全屏滚动插件" class="headerlink" title="1.4.3. 全屏滚动插件"></a>1.4.3. 全屏滚动插件</h3><p>​    全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为：</p><p><a href="http://www.dowebok.com/demo/2014/77/">http://www.dowebok.com/demo/2014/77/</a></p><p><strong>代码演示</strong></p><p>​    全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际</p><p>项目需要使用哪种风格引入对应的HTML和CSS。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;js/jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/fullpage.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">  $(<span class="hljs-string">&#x27;#dowebok&#x27;</span>).fullpage(&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">sectionsColor</span>: [<span class="hljs-string">&#x27;pink&#x27;</span>, <span class="hljs-string">&#x27;#4BBFC3&#x27;</span>, <span class="hljs-string">&#x27;#7BAABE&#x27;</span>, <span class="hljs-string">&#x27;#f90&#x27;</span>],</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">navigation</span>: <span class="hljs-literal">true</span></span></span><br><span class="javascript"><span class="xml">  &#125;);</span></span><br><span class="javascript"><span class="xml">&#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。</p><h3 id="1-4-4-bootstrap组件"><a href="#1-4-4-bootstrap组件" class="headerlink" title="1.4.4. bootstrap组件"></a>1.4.4. bootstrap组件</h3><p>​    Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式</p><p>布局，使得 Web 开发更加方便快捷。</p><p>​    <strong>凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件</strong>。Bootstrap组件使</p><p>用非常方便:  1.引入bootstrap相关css和js        2.去官网复制html</p><p><strong>代码演示</strong></p><ol><li>引入bootstrap相关css和js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;bootstrap/css/bootstrap.min.css&quot;</span>&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bootstrap/js/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bootstrap/js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>去官网复制html的功能模块</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>       &lt;!-- Single button --&gt;<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn-group&quot;</span>&gt;</span></span><br><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-default dropdown-toggle&quot;</span> <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">&quot;dropdown&quot;</span> <span class="hljs-attr">aria-haspopup</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">aria-expanded</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="xml">     Action <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;caret&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown-menu&quot;</span>&gt;</span></span><br><span class="xml">               <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Action<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">               <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Another action<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">               <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Something else here<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">               <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;separator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;divider&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">               <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Separated link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">           <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="1-4-5-bootstrap插件（JS）"><a href="#1-4-5-bootstrap插件（JS）" class="headerlink" title="1.4.5. bootstrap插件（JS）"></a>1.4.5. bootstrap插件（JS）</h3><p>​    bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以</p><p>省略js，用属性实现）。</p><p>​    步骤： 1.引入bootstrap相关css和js        2.去官网复制html        3.复制js代码，启动js插件。</p><p><strong>代码演示</strong></p><ol><li>引入bootstrap相关css和js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;bootstrap/css/bootstrap.min.css&quot;</span>&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bootstrap/js/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bootstrap/js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>去官网复制html的功能模块</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 模态框 --&gt;<br>&lt;!-- Large modal --&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">&quot;modal&quot;</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">&quot;.bs-example-modal-lg&quot;</span>&gt;</span>Large modal<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal fade bs-example-modal-lg&quot;</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;-1&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;dialog&quot;</span> <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">&quot;myLargeModalLabel&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-dialog modal-lg&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;document&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-content&quot;</span>&gt;</span></span><br><span class="xml">            里面就是模态框</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>复制js代码，启动js插件。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br><span class="hljs-comment">// 当我们点击了自己定义的按钮，就弹出模态框</span><br>$(<span class="hljs-string">&quot;.myBtn&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">// alert(11);</span><br>$(<span class="hljs-string">&#x27;#btn&#x27;</span>).modal()<br>&#125;)<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="1-4-6-bootstrap案例-阿里百秀"><a href="#1-4-6-bootstrap案例-阿里百秀" class="headerlink" title="1.4.6. bootstrap案例-阿里百秀"></a>1.4.6. bootstrap案例-阿里百秀</h3><blockquote><p>1.通过调用组件实现导航栏<br>2.通过调用插件实现登录<br>3.通过调用插件标签页实现 tab 栏</p></blockquote><p>​    代码实现略。(详情参考源代码)</p><h2 id="1-7-综合案例-toDoList案例分析（代码略）"><a href="#1-7-综合案例-toDoList案例分析（代码略）" class="headerlink" title="1.7. 综合案例: toDoList案例分析（代码略）"></a>1.7. 综合案例: toDoList案例分析（代码略）</h2><h3 id="1-7-1-案例：案例介绍"><a href="#1-7-1-案例：案例介绍" class="headerlink" title="1.7.1 案例：案例介绍"></a>1.7.1 案例：案例介绍</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 文本框里面输入内容，按下回车，就可以生成待办事项。</span><br><span class="hljs-comment">// 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。</span><br><span class="hljs-comment">// 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。</span><br><span class="hljs-comment">// 4. 但是本页面内容刷新页面不会丢失。</span><br></code></pre></td></tr></table></figure><h3 id="1-7-2-案例：toDoList-分析"><a href="#1-7-2-案例：toDoList-分析" class="headerlink" title="1.7.2 案例：toDoList 分析"></a>1.7.2 案例：toDoList 分析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage</span><br><span class="hljs-comment">// 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据</span><br><span class="hljs-comment">// 3. 存储的数据格式：var todolist =  [&#123; title : ‘xxx’, done: false&#125;]</span><br><span class="hljs-comment">// 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。</span><br><span class="hljs-comment">// 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。</span><br></code></pre></td></tr></table></figure><h3 id="1-7-3-案例：toDoList-按下回车把新数据添加到本地存储里面"><a href="#1-7-3-案例：toDoList-按下回车把新数据添加到本地存储里面" class="headerlink" title="1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面"></a>1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。</span><br><span class="hljs-comment">// 2.利用事件对象.keyCode判断用户按下回车键（13）。</span><br><span class="hljs-comment">// 3.声明一个数组，保存数据。</span><br><span class="hljs-comment">// 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。</span><br><span class="hljs-comment">// 5.之后把最新从表单获取过来的数据，追加到数组里面。</span><br><span class="hljs-comment">// 6.最后把数组存储给本地存储 (声明函数 savaDate())</span><br></code></pre></td></tr></table></figure><h3 id="1-7-4-案例：toDoList-本地存储数据渲染加载到页面"><a href="#1-7-4-案例：toDoList-本地存储数据渲染加载到页面" class="headerlink" title="1.7.4 案例：toDoList 本地存储数据渲染加载到页面"></a>1.7.4 案例：toDoList 本地存储数据渲染加载到页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用</span><br><span class="hljs-comment">// 2.先要读取本地存储数据。（数据不要忘记转换为对象格式）</span><br><span class="hljs-comment">// 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。</span><br><span class="hljs-comment">// 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。</span><br></code></pre></td></tr></table></figure><h3 id="1-7-5-案例：toDoList-删除操作"><a href="#1-7-5-案例：toDoList-删除操作" class="headerlink" title="1.7.5 案例：toDoList 删除操作"></a>1.7.5 案例：toDoList 删除操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。</span><br><span class="hljs-comment">// 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li</span><br><span class="hljs-comment">// 3.我们可以给链接自定义属性记录当前的索引号</span><br><span class="hljs-comment">// 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法</span><br><span class="hljs-comment">// 5.存储修改后的数据，然后存储给本地存储</span><br><span class="hljs-comment">// 6.重新渲染加载数据列表</span><br><span class="hljs-comment">// 7.因为a是动态创建的，我们使用on方法绑定事件</span><br></code></pre></td></tr></table></figure><h3 id="1-7-6-案例：toDoList-正在进行和已完成选项操作"><a href="#1-7-6-案例：toDoList-正在进行和已完成选项操作" class="headerlink" title="1.7.6 案例：toDoList  正在进行和已完成选项操作"></a>1.7.6 案例：toDoList  正在进行和已完成选项操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。</span><br><span class="hljs-comment">// 2.点击之后，获取本地存储数据。</span><br><span class="hljs-comment">// 3.修改对应数据属性 done 为当前复选框的checked状态。</span><br><span class="hljs-comment">// 4.之后保存数据到本地存储</span><br><span class="hljs-comment">// 5.重新渲染加载数据列表</span><br><span class="hljs-comment">// 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面</span><br><span class="hljs-comment">// 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面</span><br></code></pre></td></tr></table></figure><h3 id="1-7-7-案例：toDoList-统计正在进行个数和已经完成个数"><a href="#1-7-7-案例：toDoList-统计正在进行个数和已经完成个数" class="headerlink" title="1.7.7 案例：toDoList 统计正在进行个数和已经完成个数"></a>1.7.7 案例：toDoList 统计正在进行个数和已经完成个数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.在我们load 函数里面操作</span><br><span class="hljs-comment">// 2.声明2个变量 ：todoCount 待办个数  doneCount 已完成个数   </span><br><span class="hljs-comment">// 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++</span><br><span class="hljs-comment">// 4.最后修改相应的元素 text() </span><br></code></pre></td></tr></table></figure><h2 id="1-8-今日总结"><a href="#1-8-今日总结" class="headerlink" title="1.8. 今日总结"></a>1.8. 今日总结</h2><p><img src="/img/webimg/%E6%80%BB%E7%BB%9303.png" alt="总结"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习07-JavaScript</title>
    <link href="/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A007-JavaScript/"/>
    <url>/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A007-JavaScript/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript基础数据"><a href="#JavaScript基础数据" class="headerlink" title="JavaScript基础数据"></a>JavaScript基础数据</h1><h2 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1 - 编程语言"></a>1 - 编程语言</h2><h3 id="1-1-编程"><a href="#1-1-编程" class="headerlink" title="1.1 编程"></a>1.1 编程</h3><ul><li>编程：<ul><li>就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</li></ul></li><li>计算机程序：<ul><li>就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令。</li></ul></li></ul><h3 id="1-2-计算机语言"><a href="#1-2-计算机语言" class="headerlink" title="1.2 计算机语言"></a>1.2 计算机语言</h3><ul><li><p>计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介。</p></li><li><p>计算机语言的种类非常的多，总的来说可以分成机器语言，汇编语言和高级语言三大类。</p></li><li><p>实际上计算机最终所执行的都是 机器语言，它是由“0”和“1”组成的二进制数，二进制是计算机语言的基础。</p></li></ul><h3 id="1-3-编程语言"><a href="#1-3-编程语言" class="headerlink" title="1.3 编程语言"></a>1.3 编程语言</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">编程语言：<br>可以通过类似于人类语言的“语言”来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言（Programming Language）。编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守。如今通用的编程语言有两种形式：汇编语言和高级语言。<br></code></pre></td></tr></table></figure><table><thead><tr><th>语言类型</th><th align="center">说明</th></tr></thead><tbody><tr><td><strong>汇编语言</strong></td><td align="center">汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。</td></tr><tr><td><strong>高级语言</strong></td><td align="center">高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等。</td></tr></tbody></table><h3 id="1-4-翻译器"><a href="#1-4-翻译器" class="headerlink" title="1.4 翻译器"></a>1.4 翻译器</h3><pre><code>    高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。</code></pre><h3 id="1-5-编程语言和标记语言区别"><a href="#1-5-编程语言和标记语言区别" class="headerlink" title="1.5 编程语言和标记语言区别"></a>1.5 编程语言和标记语言区别</h3><table><thead><tr><th>语言</th><th>说明</th></tr></thead><tbody><tr><td>编程语言</td><td>编程语言有很强的逻辑和行为能力。在编程语言里, 你会看到很多 if else 、for 、while等具有逻辑性和行为能力的指令，这是主动的。</td></tr><tr><td>标记语言</td><td>标记语言（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 他是被动的。</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>计算机可以帮助人类解决某些问题</li><li>程序员利用编程语言编写程序发出指令控制计算机来实现这些任务</li><li>编程语言有机器语言、汇编语言、高级语言</li><li>高级语言需要一个翻译器转换为计算机识别的机器语言</li><li>编程语言是主动的有很强的逻辑性</li></ol><h2 id="2-计算机基础"><a href="#2-计算机基础" class="headerlink" title="2 - 计算机基础"></a>2 - 计算机基础</h2><h3 id="2-1-计算机组成"><a href="#2-1-计算机组成" class="headerlink" title="2.1 计算机组成"></a>2.1 计算机组成</h3><p><img src="/img/web/js01.jpg"></p><h3 id="2-2-数据存储"><a href="#2-2-数据存储" class="headerlink" title="2.2 数据存储"></a>2.2 数据存储</h3><ol><li>计算机内部使用二进制 0 和 1来表示数据。</li><li>所有数据，包括文件、图片等最终都是以二进制数据（0 和 1）的形式存放在硬盘中的。</li><li>所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安装软件，其实就是把程序文件复制到硬盘中。</li><li>硬盘、内存都是保存的二进制数据。</li></ol><h3 id="2-3-数据存储单位"><a href="#2-3-数据存储单位" class="headerlink" title="2.3 数据存储单位"></a>2.3 数据存储单位</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">大小关系：bit &lt; <span class="hljs-keyword">byte</span> &lt; kb &lt; GB &lt; TB&lt;.....<br></code></pre></td></tr></table></figure><ul><li>位(bit)：   1bit 可以保存一个 0 或者 1 （最小的存储单位）</li><li>字节(Byte)：1B = 8b</li><li>千字节(KB)：1KB = 1024B</li><li>兆字节(MB)：1MB = 1024KB</li><li>吉字节(GB):  1GB = 1024MB</li><li>太字节(TB):  1TB = 1024GB</li></ul><h3 id="2-4-程序运行"><a href="#2-4-程序运行" class="headerlink" title="2.4 程序运行"></a>2.4 程序运行</h3><pre><code>计算机运行软件的过程：1. 打开某个程序时，先从硬盘中把程序的代码加载到内存中2. CPU执行内存中的代码   注意：之所以要内存的一个重要原因，是因为 cpu运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据。（内存是电，硬盘是机械）</code></pre><h2 id="3-初始JavaScript"><a href="#3-初始JavaScript" class="headerlink" title="3 - 初始JavaScript"></a>3 - 初始JavaScript</h2><h3 id="3-1-JavaScript-是什么"><a href="#3-1-JavaScript-是什么" class="headerlink" title="3.1 JavaScript 是什么"></a>3.1 JavaScript 是什么</h3><ul><li><p>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）</p></li><li><p>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</p></li><li><p>现在也可以基于 Node.js 技术进行服务器端编程</p></li></ul><h3 id="3-2-JavaScript的作用"><a href="#3-2-JavaScript的作用" class="headerlink" title="3.2 JavaScript的作用"></a>3.2 JavaScript的作用</h3><ul><li> 表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）</li><li> 网页特效</li><li> 服务端开发(Node.js)</li><li> 桌面程序(Electron)</li><li> App(Cordova) </li><li> 控制硬件-物联网(Ruff)</li><li> 游戏开发(cocos2d-js)</li></ul><h3 id="3-4-浏览器执行-JS-简介"><a href="#3-4-浏览器执行-JS-简介" class="headerlink" title="3.4 浏览器执行 JS 简介"></a>3.4 浏览器执行 JS 简介</h3><p><strong>浏览器分成两部分：渲染引擎和 JS 引擎</strong></p><p><img src="/img/web/js02.jpg"></p><pre><code>    浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</code></pre><p><img src="/img/web/js03.jpg"></p><h3 id="3-5-JS-的组成"><a href="#3-5-JS-的组成" class="headerlink" title="3.5 JS 的组成"></a>3.5 JS 的组成</h3><p><img src="/img/web/js04.jpg"></p><ol><li><h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a><strong>ECMAScript</strong></h4><p>​        ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p><p><img src="/img/web/js05.jpg"></p><p>​        ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p><p>更多参看MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN手册</a></p></li><li><h4 id="DOM——文档对象模型"><a href="#DOM——文档对象模型" class="headerlink" title="DOM——文档对象模型"></a><strong>DOM——文档对象模型</strong></h4><p>​        <strong>文档对象模型</strong>（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p></li><li><h4 id="BOM——浏览器对象模型"><a href="#BOM——浏览器对象模型" class="headerlink" title="BOM——浏览器对象模型"></a><strong>BOM——浏览器对象模型</strong></h4><p>​        <strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p></li></ol><h3 id="3-6-JS-初体验"><a href="#3-6-JS-初体验" class="headerlink" title="3.6 JS 初体验"></a>3.6 JS 初体验</h3><pre><code>JS 有3种书写位置，分别为行内、内嵌和外部。</code></pre><ol><li><p>行内式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点我试试&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li><li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li><li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li><li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li><li>特殊情况下使用</li></ul></li><li><p>内嵌式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    alert(<span class="hljs-string">&#x27;Hello  World~!&#x27;</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>可以将多行JS代码写到 script 标签中</li><li>内嵌 JS 是学习时常用的方式</li></ul></li><li><p>外部JS文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li><li>引用外部 JS文件的 script 标签中间不可以写代码</li><li>适合于JS 代码量比较大的情况</li></ul></li></ol><h2 id="4-JavaScript注释"><a href="#4-JavaScript注释" class="headerlink" title="4 - JavaScript注释"></a>4 - JavaScript注释</h2><ul><li>flex子项目占的份数</li><li>align-self控制子项自己在侧轴的排列方式</li><li>order属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="4-1-单行注释"><a href="#4-1-单行注释" class="headerlink" title="4.1  单行注释"></a>4.1  单行注释</h3><pre><code>为了提高代码的可读性，JS与CSS一样，也提供了注释功能。JS中的注释主要有两种，分别是 单行注释 和 多行注释。</code></pre><p>单行注释的注释方式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来<br></code></pre></td></tr></table></figure><pre><code>// 用来注释单行文字（  快捷键   ctrl  +  /   ）</code></pre><h3 id="4-2-多行注释"><a href="#4-2-多行注释" class="headerlink" title="4.2 多行注释"></a>4.2 多行注释</h3><p>多行注释的注释方式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">/*<br>  获取用户年龄和姓名<br>  并通过提示框显示出来<br>*/<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* */</span>  用来注释多行文字（ 默认快捷键  alt +  shift  + a ） <br></code></pre></td></tr></table></figure><p>快捷键修改为：   ctrl + shift  +  /</p><p>vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认</p><h2 id="5-JavaScript输入输出语句"><a href="#5-JavaScript输入输出语句" class="headerlink" title="5 - JavaScript输入输出语句"></a>5 - JavaScript输入输出语句</h2><p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p><table><thead><tr><th>方法</th><th>说明</th><th>归属</th></tr></thead><tbody><tr><td>alert(msg)</td><td>浏览器弹出警示框</td><td>浏览器</td></tr><tr><td>console.log(msg)</td><td>浏览器控制台打印输出信息</td><td>浏览器</td></tr><tr><td>prompt(info)</td><td>浏览器弹出输入框，用户可以输入</td><td>浏览器</td></tr></tbody></table><ul><li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li></ul><h2 id="6-变量的概念"><a href="#6-变量的概念" class="headerlink" title="6 - 变量的概念"></a>6 - 变量的概念</h2><h3 id="6-1-什么是变量"><a href="#6-1-什么是变量" class="headerlink" title="6.1 什么是变量"></a>6.1 什么是变量</h3><p>白话：变量就是一个装东西的盒子。</p><p>通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。</p><h3 id="6-2-变量在内存中的存储"><a href="#6-2-变量在内存中的存储" class="headerlink" title="6.2 变量在内存中的存储"></a>6.2 变量在内存中的存储</h3><pre><code>    本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。  </code></pre><p><img src="/img/web/js06.jpg"></p><h2 id="7-变量的使用"><a href="#7-变量的使用" class="headerlink" title="7 - 变量的使用"></a>7 - 变量的使用</h2><ul><li>变量的声明   </li><li>变量的赋值 </li></ul><h3 id="7-1-声明变量"><a href="#7-1-声明变量" class="headerlink" title="7.1 声明变量"></a>7.1 声明变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  声明变量  </span><br><span class="hljs-keyword">var</span> age; <span class="hljs-comment">//  声明一个 名称为age 的变量     </span><br></code></pre></td></tr></table></figure><ul><li><p>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</p></li><li><p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</p></li></ul><h3 id="7-2-赋值"><a href="#7-2-赋值" class="headerlink" title="7.2 赋值"></a>7.2 赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">age = <span class="hljs-number">10</span>; <span class="hljs-comment">// 给 age  这个变量赋值为 10          </span><br></code></pre></td></tr></table></figure><ul><li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思</li><li>变量值是程序员保存到变量空间里的值</li></ul><h3 id="7-3-变量的初始化"><a href="#7-3-变量的初始化" class="headerlink" title="7.3 变量的初始化"></a>7.3 变量的初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age  = <span class="hljs-number">18</span>;  <span class="hljs-comment">// 声明变量同时赋值为 18</span><br><span class="hljs-comment">// 声明一个变量并赋值， 我们称之为变量的初始化。</span><br></code></pre></td></tr></table></figure><h3 id="7-4-变量语法扩展"><a href="#7-4-变量语法扩展" class="headerlink" title="7.4 变量语法扩展"></a>7.4 变量语法扩展</h3><ul><li><p>更新变量</p><p>​        一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br><br>age = <span class="hljs-number">81</span>;   <span class="hljs-comment">// 最后的结果就是81因为18 被覆盖掉了          </span><br></code></pre></td></tr></table></figure></li><li><p>同时声明多个变量</p><p>​        同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>,  name = <span class="hljs-string">&#x27;zs&#x27;</span>, sex = <span class="hljs-number">2</span>;       <br></code></pre></td></tr></table></figure></li><li><p>声明变量特殊情况</p><table><thead><tr><th>情况</th><th>说明</th><th>结果</th></tr></thead><tbody><tr><td>var  age ; console.log (age);</td><td>只声明 不赋值</td><td>undefined</td></tr><tr><td>console.log(age)</td><td>不声明 不赋值  直接使用</td><td>报错</td></tr><tr><td>age   = 10; console.log (age);</td><td>不声明   只赋值</td><td>10</td></tr></tbody></table></li></ul><h3 id="7-5-变量命名规范"><a href="#7-5-变量命名规范" class="headerlink" title="7.5 变量命名规范"></a>7.5 变量命名规范</h3><p>规则：</p><ul><li><p>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name</p></li><li><p>严格区分大小写。var app; 和 var App; 是两个变量</p></li><li><p>不能 以数字开头。  18age   是错误的</p></li><li><p>不能 是关键字、保留字。例如：var、for、while</p></li><li><p>变量名必须有意义。 MMD   BBD        nl   →     age  </p></li><li><p>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">myFirstName</span><br></code></pre></td></tr></table></figure></li></ul><p>推荐翻译网站： 有道    爱词霸</p><h2 id="8-数据类型"><a href="#8-数据类型" class="headerlink" title="8 - 数据类型"></a>8 - 数据类型</h2><h3 id="8-1-数据类型简介"><a href="#8-1-数据类型简介" class="headerlink" title="8.1 数据类型简介"></a>8.1 数据类型简介</h3><ul><li><p>为什么需要数据类型</p><p>​        在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。</p><pre><code>     简单来说，数据类型就是数据的类别型号。比如姓名“张三”，年龄18，这些数据的类型是不一样的。</code></pre></li><li><p>变量的数据类型</p><p>​        变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;        <span class="hljs-comment">// 这是一个数字型</span><br><span class="hljs-keyword">var</span> areYouOk = <span class="hljs-string">&#x27;是的&#x27;</span>;   <span class="hljs-comment">// 这是一个字符串     </span><br></code></pre></td></tr></table></figure><p>​        在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">6</span>;           <span class="hljs-comment">// x 为数字</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;Bill&quot;</span>;      <span class="hljs-comment">// x 为字符串    </span><br></code></pre></td></tr></table></figure></li><li><p>数据类型的分类</p><p>JS 把数据类型分为两类：</p><ul><li><p>简单数据类型 （Number,String,Boolean,Undefined,Null）</p></li><li><p>复杂数据类型 （object)    </p></li></ul></li></ul><h3 id="8-2-简单数据类型"><a href="#8-2-简单数据类型" class="headerlink" title="8.2 简单数据类型"></a>8.2 简单数据类型</h3><p>简单数据类型（基本数据类型）</p><p>JavaScript 中的简单数据类型及其说明如下：</p><p><img src="/img/web/js07.jpg"></p><ul><li><p>数字型 Number</p><p>​        JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">21</span>;       <span class="hljs-comment">// 整数</span><br><span class="hljs-keyword">var</span> Age = <span class="hljs-number">21.3747</span>;  <span class="hljs-comment">// 小数     </span><br></code></pre></td></tr></table></figure><ol><li><p>数字型进制</p><p>最常见的进制有二进制、八进制、十进制、十六进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 1.八进制数字序列范围：0~7</span><br><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">07</span>;   <span class="hljs-comment">// 对应十进制的7</span><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">019</span>;  <span class="hljs-comment">// 对应十进制的19</span><br><span class="hljs-keyword">var</span> num3 = <span class="hljs-number">08</span>;   <span class="hljs-comment">// 对应十进制的8</span><br> <span class="hljs-comment">// 2.十六进制数字序列范围：0~9以及A~F</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">0xA</span>;   <br></code></pre></td></tr></table></figure><p>现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x  </p></li><li><p>数字型范围</p><p>JavaScript中数值的最大和最小值</p><ul><li><p>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308</p></li><li><p>最小值：Number.MIN_VALUE，这个值为：5e-32</p></li></ul></li></ol></li></ul><ol start="3"><li><p>数字型三个特殊值</p><ul><li><p>Infinity ，代表无穷大，大于任何数值</p></li><li><p>-Infinity ，代表无穷小，小于任何数值</p></li><li><p>NaN ，Not a number，代表一个非数值</p></li></ul></li><li><p>isNaN</p><p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p></li></ol><p>   <img src="/img/web/js08.jpg"></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">var</span> usrAge = <span class="hljs-number">21</span>;<br><span class="hljs-keyword">var</span> isOk = <span class="hljs-built_in">isNaN</span>(userAge);<br>  <span class="hljs-built_in">console</span>.log(isNum);          <span class="hljs-comment">// false ，21 不是一个非数字</span><br><span class="hljs-keyword">var</span> usrName = <span class="hljs-string">&quot;andy&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(userName));<span class="hljs-comment">// true ，&quot;andy&quot;是一个非数字</span><br></code></pre></td></tr></table></figure><ul><li><p>字符串型 String</p><p>​        字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> strMsg = <span class="hljs-string">&quot;我爱北京天安门~&quot;</span>;  <span class="hljs-comment">// 使用双引号表示字符串</span><br><span class="hljs-keyword">var</span> strMsg2 = <span class="hljs-string">&#x27;我爱吃猪蹄~&#x27;</span>;    <span class="hljs-comment">// 使用单引号表示字符串</span><br><span class="hljs-comment">// 常见错误</span><br><span class="hljs-keyword">var</span> strMsg3 = 我爱大肘子;       <span class="hljs-comment">// 报错，没使用引号，会被认为是js代码，但js没有这些语法</span><br></code></pre></td></tr></table></figure><p>​        因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。</p><ol><li><p>字符串引号嵌套</p><p>​        JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> strMsg = <span class="hljs-string">&#x27;我是&quot;高帅富&quot;程序猿&#x27;</span>;   <span class="hljs-comment">// 可以用&#x27;&#x27;包含&quot;&quot;</span><br><span class="hljs-keyword">var</span> strMsg2 = <span class="hljs-string">&quot;我是&#x27;高帅富&#x27;程序猿&quot;</span>;  <span class="hljs-comment">// 也可以用&quot;&quot; 包含&#x27;&#x27;</span><br><span class="hljs-comment">//  常见错误</span><br><span class="hljs-keyword">var</span> badQuotes = <span class="hljs-string">&#x27;What on earth?&quot;; // 报错，不能 单双引号搭配</span><br></code></pre></td></tr></table></figure></li><li><p>字符串转义符</p><p>​        类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</p><p>​        转义符都是 \ 开头的，常用的转义符及其说明如下：</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n   是   newline   的意思</td></tr><tr><td>\ \</td><td>斜杠   \</td></tr><tr><td>&#39;</td><td>‘   单引号</td></tr><tr><td>&quot;</td><td>”双引号</td></tr><tr><td>\t</td><td>tab  缩进</td></tr><tr><td>\b</td><td>空格 ，b   是   blank  的意思</td></tr></tbody></table></li><li><p>字符串长度</p><p>​        字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> strMsg = <span class="hljs-string">&quot;我是帅气多金的程序猿！&quot;</span>;<br>alert(strMsg.length); <span class="hljs-comment">// 显示 11</span><br></code></pre></td></tr></table></figure></li><li><p>字符串拼接</p><ul><li><p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</p></li><li><p>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.1 字符串 &quot;相加&quot;</span><br>alert(<span class="hljs-string">&#x27;hello&#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-string">&#x27;world&#x27;</span>); <span class="hljs-comment">// hello world</span><br><span class="hljs-comment">//1.2 数值字符串 &quot;相加&quot;</span><br>alert(<span class="hljs-string">&#x27;100&#x27;</span> + <span class="hljs-string">&#x27;100&#x27;</span>); <span class="hljs-comment">// 100100</span><br><span class="hljs-comment">//1.3 数值字符串 + 数值</span><br>alert(<span class="hljs-string">&#x27;11&#x27;</span> + <span class="hljs-number">12</span>);     <span class="hljs-comment">// 1112 </span><br></code></pre></td></tr></table></figure><ul><li><em><strong>+ 号总结口诀：数值相加 ，字符相连</strong></em></li></ul></li></ul></li><li><p>字符串拼接加强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;pink老师&#x27;</span> + <span class="hljs-number">18</span>);        <span class="hljs-comment">// 只要有字符就会相连 </span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;pink老师age岁啦&#x27;</span>);      <span class="hljs-comment">// 这样不行哦</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;pink老师&#x27;</span> + age);         <span class="hljs-comment">// pink老师18</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;pink老师&#x27;</span> + age + <span class="hljs-string">&#x27;岁啦&#x27;</span>); <span class="hljs-comment">// pink老师18岁啦</span><br></code></pre></td></tr></table></figure><ul><li>经常会将字符串和变量来拼接，变量可以很方便地修改里面的值</li><li>变量是不能添加引号的，因为加引号的变量会变成字符串</li><li>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</li></ul></li></ol></li><li><p>布尔型Boolean</p><p>​        布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</p><p>​        布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>Undefined和 Null</p><p>​        一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> variable;<br><span class="hljs-built_in">console</span>.log(variable);           <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好&#x27;</span> + variable);  <span class="hljs-comment">// 你好undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span> + variable);     <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + variable);   <span class="hljs-comment">//  NaN</span><br></code></pre></td></tr></table></figure><p>​        一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vari = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好&#x27;</span> + vari);  <span class="hljs-comment">// 你好null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span> + vari);     <span class="hljs-comment">// 11</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + vari);   <span class="hljs-comment">//  1</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="8-3-获取变量数据类型"><a href="#8-3-获取变量数据类型" class="headerlink" title="8.3 获取变量数据类型"></a>8.3 获取变量数据类型</h3><ul><li><p>获取检测变量的数据类型</p><p>​        typeof 可用来获取检测变量的数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">18</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num) <span class="hljs-comment">// 结果 number      </span><br></code></pre></td></tr></table></figure><p>​        不同类型的返回值</p><p><img src="/img/web/js09.jpg"></p></li><li><p>字面量</p><p>​        字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。</p><ul><li>数字字面量：8, 9, 10</li><li>字符串字面量：’黑马程序员’, “大前端”</li><li>布尔字面量：true，false</li></ul></li></ul><h3 id="8-4-数据类型转换"><a href="#8-4-数据类型转换" class="headerlink" title="8.4 数据类型转换"></a>8.4 数据类型转换</h3><p>​        什么是数据类型转换？</p><p>​        使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">转换为字符串类型<br>转换为数字型<br>转换为布尔型<br></code></pre></td></tr></table></figure><ul><li><p>转换为字符串</p><p><img src="/img/web/js10.jpg"></p><ul><li>toString() 和 String()  使用方式不一样。</li><li>三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。</li></ul></li><li><p>转换为数字型（重点）</p><p><img src="/img/web/js11.jpg"></p><ul><li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li><li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li></ul></li><li><p>转换为布尔型</p><p><img src="/img/web/js12.jpg"></p><ul><li><p>代表空、否定的值会被转换为 false  ，如 ‘’、0、NaN、null、undefined  </p></li><li><p>其余值都会被转换为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;小白&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">12</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="9-解释型语言和编译型语言"><a href="#9-解释型语言和编译型语言" class="headerlink" title="9 - 解释型语言和编译型语言"></a>9 - 解释型语言和编译型语言</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><pre><code>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。</code></pre><p><img src="/img/web/js13.jpg"></p><ul><li> 翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</li><li> 编译器是在代码执行之前进行编译，生成中间代码文件</li><li> 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)</li></ul><h3 id="9-2-执行过程"><a href="#9-2-执行过程" class="headerlink" title="9.2 执行过程"></a>9.2 执行过程</h3><p><img src="/img/web/js14.jpg"></p><pre><code>类似于请客吃饭：    编译语言：首先把所有菜做好，才能上桌吃饭    解释语言：好比吃火锅，边吃边涮，同时进行</code></pre><h2 id="10-关键字和保留字"><a href="#10-关键字和保留字" class="headerlink" title="10 - 关键字和保留字"></a>10 - 关键字和保留字</h2><h3 id="10-1-标识符"><a href="#10-1-标识符" class="headerlink" title="10.1 标识符"></a>10.1 标识符</h3><pre><code>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。标识符不能是关键字或保留字。</code></pre><h3 id="10-2-关键字"><a href="#10-2-关键字" class="headerlink" title="10.2 关键字"></a>10.2 关键字</h3><pre><code>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。</code></pre><h3 id="10-3-保留字"><a href="#10-3-保留字" class="headerlink" title="10.3 保留字"></a>10.3 保留字</h3><pre><code>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。</code></pre><h1 id="JavaScript基础运算"><a href="#JavaScript基础运算" class="headerlink" title="JavaScript基础运算"></a>JavaScript基础运算</h1><h2 id="1-运算符（操作符）"><a href="#1-运算符（操作符）" class="headerlink" title="1 - 运算符（操作符）"></a>1 - 运算符（操作符）</h2><h3 id="1-1-运算符的分类"><a href="#1-1-运算符的分类" class="headerlink" title="1.1 运算符的分类"></a>1.1 运算符的分类</h3><p>​        <strong>运算符</strong>（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">JavaScript中常用的运算符有：<br>- 算数运算符<br>- 递增和递减运算符<br>- 比较运算符<br>- 逻辑运算符<br>- 赋值运算符<br></code></pre></td></tr></table></figure><h3 id="1-2-算数运算符"><a href="#1-2-算数运算符" class="headerlink" title="1.2 算数运算符"></a>1.2 算数运算符</h3><ul><li><p>算术运算符概述</p><p>概念：算术运算使用的符号，用于执行两个变量或值的算术运算。</p><p><img src="/img/web/js15.jpg"></p></li><li><p>浮点数的精度问题</p><p>​        浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> result = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<span class="hljs-comment">//结果是：0.30000000000000004</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.07</span> * <span class="hljs-number">100</span>);<span class="hljs-comment">//结果是：7.000000000000001</span><br></code></pre></td></tr></table></figure><p>​        所以：不要直接判断两个浮点数是否相等 ! </p></li><li><p>表达式和返回值</p><p>​        表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合</p><p>​        简单理解：是由数字、运算符、变量等组成的式子</p><p>​        表达式最终都会有一个结果，返回给开发者，称为返回值</p></li></ul><h3 id="1-3-递增和递减运算符"><a href="#1-3-递增和递减运算符" class="headerlink" title="1.3 递增和递减运算符"></a>1.3 递增和递减运算符</h3><ul><li><p>递增和递减运算符概述</p><p>​        如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ – ）运算符来完成。</p><pre><code>     在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。     注意：递增和递减运算符必须和变量配合使用。 </code></pre></li><li><p>递增运算符</p><ul><li><p>前置递增运算符</p><p>++num 前置递增，就是自加1，类似于 num =  num + 1</p><p>使用口诀：先自加，后返回值</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span>  num = <span class="hljs-number">10</span>;<br>alert(++num + <span class="hljs-number">10</span>);   <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><ul><li><p>后置递增运算符</p><p>num++ 后置递增，就是自加1，类似于 num =  num + 1 </p><p>使用口诀：先返回原值，后自加 </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span>  num = <span class="hljs-number">10</span>;<br>alert(<span class="hljs-number">10</span> + num++);  <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-4-比较运算符"><a href="#1-4-比较运算符" class="headerlink" title="1.4 比较运算符"></a>1.4 比较运算符</h3><ul><li><p>比较运算符概述</p><p>​        概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。</p><p><img src="/img/web/js16.jpg"></p></li><li><p>等号比较</p><p><img src="/img/web/js17.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">18</span> == <span class="hljs-string">&#x27;18&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">18</span> === <span class="hljs-string">&#x27;18&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-5-逻辑运算符"><a href="#1-5-逻辑运算符" class="headerlink" title="1.5 逻辑运算符"></a>1.5 逻辑运算符</h3><ul><li><p>逻辑运算符概述</p><p>​        逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断</p><p><img src="/img/web/js18.jpg"></p></li><li><p>逻辑与&amp;&amp;</p><p>​        两边都是 true才返回 true，否则返回 false</p><p><img src="/img/web/js19.jpg"></p></li><li><p>逻辑或 ||</p><p>​        两边都是 true才返回 true，否则返回 false</p><p><img src="/img/web/js20.jpg"></p></li><li><p>逻辑非 ！</p><p>​        逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isOk = !<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">console</span>.log(isOk);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>短路运算（逻辑中断）</p><p>​        逻辑元素父左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值;</p><ul><li><p>逻辑与</p><p>​    语法： 表达式1 &amp;&amp; 表达式2</p><pre><code>- 如果第一个表达式的值为真，则返回表达式2</code></pre><ul><li>如果第一个表达式的值为假，则返回表达式1</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span> );        <span class="hljs-comment">// 456</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">456</span> );          <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span>&amp;&amp; <span class="hljs-number">789</span> );  <span class="hljs-comment">// 789</span><br></code></pre></td></tr></table></figure><ul><li><p>逻辑或</p><p>​    语法： 表达式1 || 表达式2</p><pre><code>- 如果第一个表达式的值为真，则返回表达式1 - 如果第一个表达式的值为假，则返回表达式2</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> );         <span class="hljs-comment">//  123</span><br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> ||  <span class="hljs-number">456</span> );          <span class="hljs-comment">//  456</span><br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> || <span class="hljs-number">789</span> );  <span class="hljs-comment">//  123</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-6-赋值运算符"><a href="#1-6-赋值运算符" class="headerlink" title="1.6 赋值运算符"></a>1.6 赋值运算符</h3><p>​        概念：用来把数据赋值给变量的运算符。</p><p><img src="/img/web/js21.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;<br>age += <span class="hljs-number">5</span>;  <span class="hljs-comment">// 相当于 age = age + 5;</span><br>age -= <span class="hljs-number">5</span>;  <span class="hljs-comment">// 相当于 age = age - 5;</span><br>age *= <span class="hljs-number">10</span>; <span class="hljs-comment">// 相当于 age = age * 10;</span><br></code></pre></td></tr></table></figure><h3 id="1-7-运算符优先级"><a href="#1-7-运算符优先级" class="headerlink" title="1.7 运算符优先级"></a>1.7 运算符优先级</h3><p><img src="/img/web/js22.jpg"></p><ul><li>一元运算符里面的逻辑非优先级很高</li><li>逻辑与比逻辑或优先级高</li></ul><h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2 - 流程控制"></a>2 - 流程控制</h2><h3 id="2-1-流程控制概念"><a href="#2-1-流程控制概念" class="headerlink" title="2.1 流程控制概念"></a>2.1 流程控制概念</h3><p>​        在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。</p><p>​        简单理解：流程控制就是来控制代码按照一定结构顺序来执行</p><p>​        流程控制主要有三种结构：顺序结构、分支结构、循环结构</p><p><img src="/img/web/js23.jpg"></p><h3 id="2-2-顺序流程控制"><a href="#2-2-顺序流程控制" class="headerlink" title="2.2 顺序流程控制"></a>2.2 顺序流程控制</h3><p>​    <img src="/img/web/js24.jpg"></p><h3 id="2-3-分支流程控制"><a href="#2-3-分支流程控制" class="headerlink" title="2.3 分支流程控制"></a>2.3 分支流程控制</h3><ul><li>分支结构</li></ul><p>​        <img src="/img/web/js25.jpg"></p><p>​        JS 语言提供了两种分支结构语句：if 语句、switch 语句</p><ul><li><p>if 语句</p><ul><li>语法结构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立执行代码，否则什么也不做</span><br><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    <span class="hljs-comment">// 条件成立执行的代码语句</span><br>&#125;<br></code></pre></td></tr></table></figure><pre><code>    语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。</code></pre><ul><li><p>执行流程</p><p><img src="/img/web/js26.jpg"></p></li></ul></li><li><p>if else语句（双分支语句）</p><ul><li><p>语法结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立  执行 if 里面代码，否则执行else 里面的代码</span><br><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    <span class="hljs-comment">// [如果] 条件成立执行的代码</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// [否则] 执行的代码</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>执行流程</p><p><img src="/img/web/js27.jpg"></p></li></ul></li><li><p>if else if 语句(多分支语句)</p><ul><li><p>语法结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 适合于检查多重条件。</span><br><span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123;<br>    语句<span class="hljs-number">1</span>；<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>)  &#123;<br>    语句<span class="hljs-number">2</span>；<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">3</span>)  &#123;<br>   语句<span class="hljs-number">3</span>；<br> ....<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 上述条件都不成立执行此处代码</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>执行逻辑</p><p><img src="/img/web/js28.jpg"></p></li></ul></li></ul><h3 id="2-4-三元表达式"><a href="#2-4-三元表达式" class="headerlink" title="2.4 三元表达式"></a>2.4 三元表达式</h3><ul><li><p>语法结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">表达式<span class="hljs-number">1</span> ? 表达式<span class="hljs-number">2</span> : 表达式<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行思路</p><ul><li>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</li><li>简单理解： 就类似于  if  else （双分支） 的简写</li></ul></li></ul><h3 id="2-5-switch分支流程控制"><a href="#2-5-switch分支流程控制" class="headerlink" title="2.5 switch分支流程控制"></a>2.5 switch分支流程控制</h3><ul><li><p>语法结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span>( 表达式 )&#123; <br>   <span class="hljs-keyword">case</span> value1:<br>       <span class="hljs-comment">// 表达式 等于 value1 时要执行的代码</span><br>       <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">case</span> value2:<br>       <span class="hljs-comment">// 表达式 等于 value2 时要执行的代码</span><br>       <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">default</span>:<br>       <span class="hljs-comment">// 表达式 不等于任何一个 value 时要执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>关键字 switch 后面括号内可以是表达式或值， 通常是一个变量</p></li><li><p>关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号</p></li><li><p>switch 表达式的值会与结构中的 case 的值做比较 </p></li><li><p>如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束</p></li><li><p>如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码</p><p><strong>注意： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。</strong></p></li></ul></li><li><p>switch 语句和 if else if 语句的区别</p><ul><li>一般情况下，它们两个语句可以相互替换</li><li>switch…case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围)</li><li>switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。</li><li>当分支比较少时，if… else语句的执行效率比 switch语句高。</li><li>当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。 </li></ul></li></ul><h1 id="JavaScript循环"><a href="#JavaScript循环" class="headerlink" title="JavaScript循环"></a>JavaScript循环</h1><h2 id="1-循环"><a href="#1-循环" class="headerlink" title="1 - 循环"></a>1 - 循环</h2><h3 id="1-1-for循环"><a href="#1-1-for循环" class="headerlink" title="1.1 for循环"></a>1.1 for循环</h3><ul><li><p>语法结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(初始化变量; 条件表达式; 操作表达式 )&#123;<br>    <span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>初始化变量</td><td>通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。</td></tr><tr><td>条件表达式</td><td>用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。</td></tr><tr><td>操作表达式</td><td>用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。</td></tr></tbody></table><p>执行过程：</p><ol><li>初始化变量，初始化操作在整个 for 循环只会执行一次。</li></ol></li><li><p>执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。</p></li></ul><ol><li>执行操作表达式，此时第一轮结束。</li><li>第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。</li><li>继续执行操作表达式，第二轮结束。</li><li>后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。</li></ol><p>断点调试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">断点调试的流程：<br>1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点<br>2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。<br>3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。<br></code></pre></td></tr></table></figure><ul><li><p>for 循环重复相同的代码</p><p>比如输出10句“媳妇我错了”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  基本写法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;媳妇我错了~&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 用户输入次数</span><br><span class="hljs-keyword">var</span> num = prompt(<span class="hljs-string">&#x27;请输入次数:&#x27;</span>)；<br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span> ; i &lt;= num; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;媳妇我错了~&#x27;</span>);<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>for 循环重复不相同的代码</p><p>例如，求输出1到100岁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  基本写法</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这个人今年&#x27;</span> + i + <span class="hljs-string">&#x27;岁了&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，求输出1到100岁，并提示出生、死亡</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// for 里面是可以添加其他语句的 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这个人今年1岁了， 它出生了&#x27;</span>);<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这个人今年100岁了，它死了&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这个人今年&#x27;</span> + i + <span class="hljs-string">&#x27;岁了&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环因为有了计数器的存在，还可以重复的执行某些操作，比如做一些算术运算。</p></li></ul><h3 id="1-2-双重for循环"><a href="#1-2-双重for循环" class="headerlink" title="1.2 双重for循环"></a>1.2 双重for循环</h3><ul><li><p>双重 for 循环概述</p><pre><code>   循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。</code></pre></li><li><p>双重 for 循环语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (外循环的初始; 外循环的条件; 外循环的操作表达式) &#123;<br>    <span class="hljs-keyword">for</span> (内循环的初始; 内循环的条件; 内循环的操作表达式) &#123;  <br>       需执行的代码;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内层循环可以看做外层循环的循环体语句</li><li>内层循环执行的顺序也要遵循 for 循环的执行顺序 </li><li>外层循环执行一次，内层循环要执行全部次数</li></ul></li><li><p>打印五行五列星星</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> star = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">3</span>; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>      star += <span class="hljs-string">&#x27;☆&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">// 每次满 5个星星 就 加一次换行</span><br>    star += <span class="hljs-string">&#x27;\n&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(star);<br></code></pre></td></tr></table></figure><p>核心逻辑：</p><p>1.内层循环负责一行打印五个星星</p><p>2.外层循环负责打印五行</p></li><li><p>for 循环小结</p><ul><li>for 循环可以重复执行某些相同代码</li><li>for 循环可以重复执行些许不同的代码，因为我们有计数器</li><li>for 循环可以重复执行某些操作，比如算术运算符加法操作</li><li>随着需求增加，双重for循环可以做更多、更好看的效果</li><li>双重 for 循环，外层循环一次，内层 for 循环全部执行</li><li>for 循环是循环条件和数字直接相关的循环</li></ul></li></ul><h3 id="1-3-while循环"><a href="#1-3-while循环" class="headerlink" title="1.3 while循环"></a>1.3 while循环</h3><p>while语句的语法结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span> (条件表达式) &#123;<br>    <span class="hljs-comment">// 循环体代码 </span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行思路：</p><ul><li>1 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码</li><li>2 执行循环体代码</li><li>3 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束</li></ul><p>注意：</p><ul><li>使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环</li></ul><h3 id="1-4-do-while循环"><a href="#1-4-do-while循环" class="headerlink" title="1.4 do-while循环"></a>1.4 do-while循环</h3><p>do… while 语句的语法结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 循环体代码 - 条件表达式为 true 时重复执行循环体代码</span><br>&#125; <span class="hljs-keyword">while</span>(条件表达式);<br></code></pre></td></tr></table></figure><p>执行思路</p><ul><li><p>1 先执行一次循环体代码 </p></li><li><p>2 再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码    </p><p>注意：先再执行循环体，再判断，do…while循环语句至少会执行一次循环体代码</p></li></ul><h3 id="1-5-continue、break"><a href="#1-5-continue、break" class="headerlink" title="1.5 continue、break"></a>1.5 continue、break</h3><p>continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。</p><p>例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这个包子有虫子，扔掉&#x27;</span>);<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳出本次循环，跳出的是第3次循环 </span><br>     &#125;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我正在吃第&#x27;</span> + i + <span class="hljs-string">&#x27;个包子呢&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>  break 关键字用于立即跳出整个循环（循环结束）。</p><p>  例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>   <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 直接退出整个for 循环，跳到整个for下面的语句</span><br>   &#125;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我正在吃第&#x27;</span> + i + <span class="hljs-string">&#x27;个包子呢&#x27;</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="2-代码规范"><a href="#2-代码规范" class="headerlink" title="2 - 代码规范"></a>2 - 代码规范</h2><h3 id="2-1-标识符命名规范"><a href="#2-1-标识符命名规范" class="headerlink" title="2.1 标识符命名规范"></a>2.1 标识符命名规范</h3><ul><li> 变量、函数的命名必须要有意义</li><li> 变量的名称一般用名词  </li><li> 函数的名称一般用动词  </li></ul><h3 id="2-2-操作符规范"><a href="#2-2-操作符规范" class="headerlink" title="2.2 操作符规范"></a>2.2 操作符规范</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 操作符的左右两侧各保留一个空格</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>   <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 直接退出整个 for 循环，跳到整个for循环下面的语句</span><br>   &#125;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我正在吃第&#x27;</span> + i + <span class="hljs-string">&#x27;个包子呢&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-单行注释规范"><a href="#2-3-单行注释规范" class="headerlink" title="2.3 单行注释规范"></a>2.3 单行注释规范</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>   <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 单行注释前面注意有个空格</span><br>   &#125;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我正在吃第&#x27;</span> + i + <span class="hljs-string">&#x27;个包子呢&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-其他规范"><a href="#2-4-其他规范" class="headerlink" title="2.4 其他规范"></a>2.4 其他规范</h3><pre><code>关键词、操作符之间后加空格</code></pre><p><img src="/img/web/js29.jpg"></p><h1 id="JavaScript数组"><a href="#JavaScript数组" class="headerlink" title="JavaScript数组"></a>JavaScript数组</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1 - 数组"></a>1 - 数组</h2><h3 id="1-1-数组的概念"><a href="#1-1-数组的概念" class="headerlink" title="1.1 数组的概念"></a>1.1 数组的概念</h3><ul><li>数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。</li><li>数组是指<strong>一组数据的集合</strong>，其中的每个数据被称作<strong>元素</strong>，在数组中可以<strong>存放任意类型的元素</strong>。数组是一种将一组数据存储在单个变量名下的优雅方式。</li></ul><h3 id="1-2-创建数组"><a href="#1-2-创建数组" class="headerlink" title="1.2 创建数组"></a>1.2 创建数组</h3><p>JS 中创建数组有两种方式：</p><ul><li><p>利用  new 创建数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 数组名 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() ；<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();   <span class="hljs-comment">// 创建一个新的空数组</span><br></code></pre></td></tr></table></figure><p>注意 Array () ，A 要大写    </p></li><li><p>利用数组字面量创建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. 使用数组字面量方式创建空的数组</span><br><span class="hljs-keyword">var</span>  数组名 = []；<br><span class="hljs-comment">//2. 使用数组字面量方式创建带初始值的数组</span><br><span class="hljs-keyword">var</span>  数组名 = [<span class="hljs-string">&#x27;小白&#x27;</span>,<span class="hljs-string">&#x27;小黑&#x27;</span>,<span class="hljs-string">&#x27;大黄&#x27;</span>,<span class="hljs-string">&#x27;瑞奇&#x27;</span>];<br></code></pre></td></tr></table></figure><ul><li>数组的字面量是方括号 [ ] </li><li>声明数组并赋值称为数组的初始化</li><li>这种字面量方式也是我们以后最多使用的方式</li></ul></li><li><p>数组元素的类型</p><p>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arrStus = [<span class="hljs-string">&#x27;小白&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">28.9</span>];<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-获取数组中的元素"><a href="#1-3-获取数组中的元素" class="headerlink" title="1.3 获取数组中的元素"></a>1.3 获取数组中的元素</h3><p>​        索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。</p><p>​        数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义数组</span><br><span class="hljs-keyword">var</span> arrStus = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-comment">// 获取数组中的第2个元素</span><br>alert(arrStus[<span class="hljs-number">1</span>]);    <br></code></pre></td></tr></table></figure><p>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</p><h3 id="1-4-遍历数组"><a href="#1-4-遍历数组" class="headerlink" title="1.4 遍历数组"></a>1.4 遍历数组</h3><ul><li><p>数组遍历</p><p>​        把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(arrStus[i]);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>数组的长度</p><p>数组的长度：默认情况下表示数组中元素的个数</p><p>使用“数组名.length”可以访问数组元素的数量（数组长度）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arrStus = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>alert(arrStus.length);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>  <strong>注意</strong>：</p><ul><li>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</li></ul></li><li><p>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</p><ul><li>数组的length属性可以被修改：</li></ul></li><li><p>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</p><ul><li>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</li></ul></li></ul><h3 id="1-5-数组中新增元素"><a href="#1-5-数组中新增元素" class="headerlink" title="1.5 数组中新增元素"></a>1.5 数组中新增元素</h3><p>​        数组中可以通过以下方式在数组的末尾插入新元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组[ 数组.length ] = 新数据;<br></code></pre></td></tr></table></figure><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2 - 函数"></a>2 - 函数</h2><h3 id="2-1-函数的概念"><a href="#2-1-函数的概念" class="headerlink" title="2.1 函数的概念"></a>2.1 函数的概念</h3><p>​        在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。</p><p>​        函数：就是<strong>封装了一段可被重复调用执行的代码块</strong>。通过此代码块可以<strong>实现大量代码的重复使用</strong>。  </p><h3 id="2-2-函数的使用"><a href="#2-2-函数的使用" class="headerlink" title="2.2 函数的使用"></a>2.2 函数的使用</h3><h4 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">//函数体代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>function 是声明函数的关键字,必须小写</p></li><li><p>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p></li></ul><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 调用函数</span><br>函数名();  <span class="hljs-comment">// 通过调用函数名来执行函数体代码</span><br></code></pre></td></tr></table></figure><ul><li><p>调用的时候千万不要忘记添加小括号</p></li><li><p>口诀：函数不调用，自己不执行</p><p>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p></li></ul><h4 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h4><ul><li><p>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</p></li><li><p>简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）  </p><p>例子：封装计算1-100累加和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* </span><br><span class="hljs-comment">   计算1-100之间值的函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 声明函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> sumNum = <span class="hljs-number">0</span>;<span class="hljs-comment">// 准备一个变量，保存数字和</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    sumNum += i;<span class="hljs-comment">// 把每个数值 都累加 到变量中</span><br>  &#125;<br>  alert(sumNum);<br>&#125;<br><span class="hljs-comment">// 调用函数</span><br>getSum();<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-函数的参数"><a href="#2-3-函数的参数" class="headerlink" title="2.3 函数的参数"></a>2.3 函数的参数</h3><h4 id="函数参数语法"><a href="#函数参数语法" class="headerlink" title="函数参数语法"></a>函数参数语法</h4><ul><li><p>形参：函数定义时设置接收调用时传入</p></li><li><p>实参：函数调用时传入小括号内的真实数据</p><p>​    参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</p><p>函数参数的运用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 带参数的函数声明</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">形参<span class="hljs-number">1</span>, 形参<span class="hljs-number">2</span> , 形参<span class="hljs-number">3.</span>..</span>) </span>&#123; <span class="hljs-comment">// 可以定义任意多的参数，用逗号分隔</span><br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br><span class="hljs-comment">// 带参数的函数调用</span><br>函数名(实参<span class="hljs-number">1</span>, 实参<span class="hljs-number">2</span>, 实参<span class="hljs-number">3.</span>..); <br></code></pre></td></tr></table></figure><ol><li>调用的时候实参值是传递给形参的</li><li>形参简单理解为：不用声明的变量</li><li>实参和形参的多个参数之间用逗号（,）分隔</li></ol></li></ul><h4 id="函数形参和实参数量不匹配时"><a href="#函数形参和实参数量不匹配时" class="headerlink" title="函数形参和实参数量不匹配时"></a>函数形参和实参数量不匹配时</h4><p><img src="/img/web/js30.jpg"></p><pre><code>注意：在JavaScript中，形参的默认值是undefined。</code></pre><p>小结：</p><ul><li> 函数可以带参数也可以不带参数</li><li> 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined</li><li> 调用函数的时候，函数名括号里面的是实参</li><li> 多个参数中间用逗号分隔</li><li> 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配</li></ul><h3 id="2-4-函数的返回值"><a href="#2-4-函数的返回值" class="headerlink" title="2.4 函数的返回值"></a>2.4 函数的返回值</h3><h4 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h4><pre><code>返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名（）</span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span>  需要返回的值；<br>&#125;<br><span class="hljs-comment">// 调用函数</span><br>函数名();    <span class="hljs-comment">// 此时调用函数就可以得到函数体内return 后面的值</span><br></code></pre></td></tr></table></figure><ul><li> 在使用 return 语句时，函数会停止执行，并返回指定的值</li><li> 如果函数没有 return ，返回的值是 undefined</li></ul><h4 id="break-continue-return-的区别"><a href="#break-continue-return-的区别" class="headerlink" title="break ,continue ,return 的区别"></a>break ,continue ,return 的区别</h4><ul><li>break ：结束当前的循环体（如 for、while）</li><li>continue ：跳出本次循环，继续执行下次循环（如 for、while）</li><li>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</li></ul><h3 id="2-5-arguments的使用"><a href="#2-5-arguments的使用" class="headerlink" title="2.5 arguments的使用"></a>2.5 arguments的使用</h3><p>​        当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><ul><li><p>具有 length 属性</p></li><li><p>按索引方式储存数据</p></li><li><p>不具有数组的 push , pop 等方法</p><p>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</p></li></ul><h3 id="2-6-函数案例"><a href="#2-6-函数案例" class="headerlink" title="2.6 函数案例"></a>2.6 函数案例</h3><pre><code>    函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。</code></pre><h3 id="2-7-函数的两种声明方式"><a href="#2-7-函数的两种声明方式" class="headerlink" title="2.7 函数的两种声明方式"></a>2.7 函数的两种声明方式</h3><ul><li><p>自定义函数方式(命名函数)</p><p>利用函数关键字 function 自定义函数方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明定义方式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br><span class="hljs-comment">// 调用  </span><br>fn();  <br></code></pre></td></tr></table></figure><ul><li>因为有名字，所以也被称为命名函数</li><li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li></ul></li><li><p>函数表达式方式(匿名函数）</p><p>利用函数表达式方式的写法如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是函数表达式写法，匿名函数后面跟分号结束</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;；<br><span class="hljs-comment">// 调用的方式，函数调用必须写到函数体下面</span><br>fn();<br></code></pre></td></tr></table></figure><ul><li>因为函数没有名字，所以也被称为匿名函数</li><li>这个fn 里面存储的是一个函数  </li><li>函数表达式方式原理跟声明变量方式是一致的</li><li>函数调用的代码必须写到函数体后面</li></ul></li></ul><h1 id="JavaScript作用域"><a href="#JavaScript作用域" class="headerlink" title="JavaScript作用域"></a>JavaScript作用域</h1><h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1 - 作用域"></a>1 - 作用域</h2><h3 id="1-1-作用域概述"><a href="#1-1-作用域概述" class="headerlink" title="1.1 作用域概述"></a>1.1 作用域概述</h3><p>​        通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</p><p>JavaScript（es6前）中的作用域有两种：</p><ul><li>全局作用域</li><li>局部作用域（函数作用域）    </li></ul><h3 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h3><pre><code>    作用于所有代码执行的环境(整个script标签内部)或独立的js文件。</code></pre><h3 id="1-3-局部作用域"><a href="#1-3-局部作用域" class="headerlink" title="1.3 局部作用域"></a>1.3 局部作用域</h3><pre><code>    作用于函数内的代码环境，就是局部作用域。     因为跟函数有关系，所以也称为函数作用域。</code></pre><h3 id="1-4-jS没有块级作用域"><a href="#1-4-jS没有块级作用域" class="headerlink" title="1.4 jS没有块级作用域"></a>1.4 jS没有块级作用域</h3><ul><li><p>块作用域由 { } 包括。</p></li><li><p>在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：    </p><p>java有块级作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>)&#123;<br>  <span class="hljs-keyword">int</span> num = <span class="hljs-number">123</span>;<br>  system.out.print(num);  <span class="hljs-comment">// 123</span><br>&#125;<br>system.out.print(num);    <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>​        以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；而与之类似的JavaScript代码，则不会报错。</p><p>js中没有块级作用域（在ES6之前）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>); <span class="hljs-comment">//123</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>);   <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2 - 变量的作用域"></a>2 - 变量的作用域</h2><pre><code>在JavaScript中，根据作用域的不同，变量可以分为两种：</code></pre><ul><li>全局变量</li><li>局部变量</li></ul><p>2.1 全局变量</p><pre><code>在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</code></pre><ul><li>全局变量在代码的任何位置都可以使用</li><li>在全局作用域下 var 声明的变量 是全局变量</li><li>特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）</li></ul><p>2.2 局部变量</p><pre><code>在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</code></pre><ul><li>局部变量只能在该函数内部使用</li><li>在函数内部 var 声明的变量是局部变量</li><li>函数的形参实际上就是局部变量</li></ul><p>2.3 全局变量和局部变量的区别</p><ul><li>全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</li><li>局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</li></ul><h2 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3 - 作用域链"></a>3 - 作用域链</h2><p>​        只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">案例分析<span class="hljs-number">1</span>：<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log( num );<br>    &#125;<br>    f2();<br>&#125;<br><span class="hljs-keyword">var</span> num = <span class="hljs-number">456</span>;<br>f1();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">作用域链：采取就近原则的方式来查找变量最终的值<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;22&#x27;</span>;<br>    fn2();<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>        fn3();<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> a = <span class="hljs-number">4</span>;<br>            <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//a的值 ?</span><br>            <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//b的值 ?</span><br>        &#125;<br>    &#125;<br>&#125;<br>fn1();<br></code></pre></td></tr></table></figure><p><img src="/img/web/js31.jpg"></p><h2 id="4-预解析"><a href="#4-预解析" class="headerlink" title="4 - 预解析"></a>4 - 预解析</h2><p>4.1 预解析的相关概念</p><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。</p><p>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：</p><p>​    预解析和代码执行。</p><ul><li><p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。</p></li><li><p>代码执行： 从上到下执行JS语句。</p><p>注意：<strong>预解析会把变量和函数的声明在代码执行之前执行完成。</strong></p></li></ul><p>4.2 变量预解析</p><p>​    变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(num);  <span class="hljs-comment">// 结果是多少？</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;      <span class="hljs-comment">// ？</span><br></code></pre></td></tr></table></figure><p>结果：undefined<br>注意：<strong>变量提升只提升声明，不提升赋值</strong></p><p>4.3 函数预解析</p><p>​     函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn();<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;打印&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：控制台打印字符串 — ”打印“ </p><p>注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！    </p><p>4.4 函数表达式声明函数问题</p><p>函数表达式创建函数，会执行变量提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn();<br><span class="hljs-keyword">var</span>  fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;想不到吧&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：报错提示 ”fn is not a function”</p><p>解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用</p><h2 id="5-对象"><a href="#5-对象" class="headerlink" title="5 - 对象"></a>5 - 对象</h2><h3 id="5-1-对象的相关概念"><a href="#5-1-对象的相关概念" class="headerlink" title="5.1 对象的相关概念"></a>5.1 对象的相关概念</h3><ul><li><p>什么是对象？</p><p>​        在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p><pre><code>     对象是由属性和方法组成的。</code></pre><ul><li><p>属性：事物的特征，在对象中用属性来表示（常用名词）</p></li><li><p>方法：事物的行为，在对象中用方法来表示（常用动词）</p></li></ul></li><li><p>为什么需要对象？</p><p>​        保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。</p><pre><code>     如果要保存一个人的完整信息呢？     例如，将“张三疯”的个人的信息保存在数组中的方式为：</code></pre><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> arr = [‘张三疯’, ‘男<span class="hljs-string">&#x27;, 128,154];</span><br></code></pre></td></tr></table></figure><p>​        上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。</p><p>​        为了让更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。</p><p>使用对象记录上组数据为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;张三疯&quot;</span>,<br>    <span class="hljs-string">&quot;sex&quot;</span>:<span class="hljs-string">&quot;男&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">128</span>,<br>    <span class="hljs-string">&quot;height&quot;</span>:<span class="hljs-number">154</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JS中的对象表达结构更清晰，更强大。</p></li></ul><h3 id="5-2-创建对象的三种方式"><a href="#5-2-创建对象的三种方式" class="headerlink" title="5.2 创建对象的三种方式"></a>5.2 创建对象的三种方式</h3><h4 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">花括号 </span><span class="hljs-template-variable">&#123; &#125;</span><span class="xml"> 里面包含了表达这个具体事物（对象）的属性和方法；</span><span class="hljs-template-variable">&#123; &#125;</span><span class="xml"> 里面采取键值对的形式表示 </span><br></code></pre></td></tr></table></figure><ul><li><p>键：相当于属性名</p></li><li><p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> star = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;pink&#x27;</span>,<br>    <span class="hljs-attr">age</span> : <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">sex</span> : <span class="hljs-string">&#x27;男&#x27;</span>,<br>    <span class="hljs-attr">sayHi</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        alert(<span class="hljs-string">&#x27;大家好啊~&#x27;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码中 star即是创建的对象。</p></li><li><p>对象的使用</p><ul><li><p>对象的属性</p><ul><li>对象中存储<strong>具体数据</strong>的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项</li></ul></li><li><p>对象的方法</p><ul><li>对象中存储<strong>函数</strong>的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项</li></ul></li><li><p>访问对象的属性</p><ul><li><p>对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”  </p></li><li><p>对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号      </p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(star.name)     <span class="hljs-comment">// 调用名字属性</span><br><span class="hljs-built_in">console</span>.log(star[<span class="hljs-string">&#x27;name&#x27;</span>])  <span class="hljs-comment">// 调用名字属性</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>调用对象的方法</p><ul><li><p>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号 </p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">star.sayHi(); <span class="hljs-comment">// 调用 sayHi 方法,注意一定要带后面的括号</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>变量、属性、函数、方法总结</p><p>​        属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器</p><ul><li><p>变量：单独声明赋值，单独存在</p></li><li><p>属性：对象里面的变量称为属性，不需要声明</p><p>​    方法是对象的一部分，函数是单独封装操作的容器</p></li><li><p>函数：单独存在的，通过“函数名()”的方式就可以调用</p></li><li><p>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用</p></li></ul></li></ul></li></ul><h4 id="利用-new-Object-创建对象"><a href="#利用-new-Object-创建对象" class="headerlink" title="利用 new Object 创建对象"></a>利用 new Object 创建对象</h4><ul><li><p>创建空对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> andy = <span class="hljs-keyword">new</span> Obect();<br></code></pre></td></tr></table></figure><p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p></li><li><p>给空对象添加属性和方法</p><ul><li><p>通过对象操作属性和方法的方式，来为对象增加属性和方法</p><p>示例代码如下：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">andy.name = <span class="hljs-string">&#x27;pink&#x27;</span>;<br>andy.age = <span class="hljs-number">18</span>;<br>andy.sex = <span class="hljs-string">&#x27;男&#x27;</span>;<br>andy.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;大家好啊~&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>Object() ：第一个字母大写   </li><li>new Object() ：需要 new 关键字</li><li>使用的格式：对象.属性 =  值;     </li></ul></li></ul><h4 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h4><ul><li><p>构造函数</p><ul><li><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>构造函数的封装格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> 构造函数名(<span class="hljs-params">形参<span class="hljs-number">1</span>,形参<span class="hljs-number">2</span>,形参<span class="hljs-number">3</span></span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.属性名<span class="hljs-number">1</span> = 参数<span class="hljs-number">1</span>;<br>     <span class="hljs-built_in">this</span>.属性名<span class="hljs-number">2</span> = 参数<span class="hljs-number">2</span>;<br>     <span class="hljs-built_in">this</span>.属性名<span class="hljs-number">3</span> = 参数<span class="hljs-number">3</span>;<br>     <span class="hljs-built_in">this</span>.方法名 = 函数体;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造函数的调用格式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> obj = new 构造函数名(实参<span class="hljs-number">1</span>，实参<span class="hljs-number">2</span>，实参<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>以上代码中，obj即接收到构造函数创建出来的对象。</p></li><li><p>注意事项</p><ol><li>  构造函数约定<strong>首字母大写</strong>。</li><li>  函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li><li>  构造函数中<strong>不需要 return 返回结果</strong>。</li><li>  当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li></ol></li><li><p>其他</p><p>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p></li></ul></li><li><p>new关键字的作用</p><ol><li>在构造函数代码开始执行之前，创建一个空对象；</li><li>修改this的指向，把this指向创建出来的空对象；</li><li>执行函数的代码</li><li>在函数完成之后，返回this—即创建出来的对象</li></ol><h3 id="5-3-遍历对象"><a href="#5-3-遍历对象" class="headerlink" title="5.3 遍历对象"></a>5.3 遍历对象</h3><p>​        for…in 语句用于对数组或者对象的属性进行循环操作。</p><p>​        其语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (变量 <span class="hljs-keyword">in</span> 对象名字) &#123;<br>    <span class="hljs-comment">// 在此执行代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​        语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-built_in">console</span>.log(k);      <span class="hljs-comment">// 这里的 k 是属性名</span><br>    <span class="hljs-built_in">console</span>.log(obj[k]); <span class="hljs-comment">// 这里的 obj[k] 是属性值</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="JavaScript内置对象"><a href="#JavaScript内置对象" class="headerlink" title="JavaScript内置对象"></a>JavaScript内置对象</h1><h2 id="1-内置对象"><a href="#1-内置对象" class="headerlink" title="1 - 内置对象"></a>1 - 内置对象</h2><h3 id="1-1-内置对象"><a href="#1-1-内置对象" class="headerlink" title="1.1 内置对象"></a>1.1 内置对象</h3><p>​         JavaScript 中的对象分为3种：<strong>自定义对象 、内置对象、 浏览器对象</strong><br>​        前面两种对象是JS 基础 内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是<strong>最基本而必要的功能</strong>（属性和方法），内置对象最大的优点就是帮助我们快速开发</p><p>​         JavaScript 提供了多个内置对象：Math、 Date 、Array、String等    </p><h3 id="1-2-查文档"><a href="#1-2-查文档" class="headerlink" title="1.2 查文档"></a>1.2 查文档</h3><p>​        查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。<br>​        Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。<br>​        MDN:<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><h3 id="1-3-Math对象"><a href="#1-3-Math对象" class="headerlink" title="1.3 Math对象"></a>1.3 Math对象</h3><p>​        Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><table><thead><tr><th>属性、方法名</th><th>功能</th></tr></thead><tbody><tr><td>Math.PI</td><td>圆周率</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.round()</td><td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr><tr><td>Math.max()/Math.min()</td><td>求最大和最小值</td></tr><tr><td>Math.random()</td><td>获取范围在[0,1)内的随机值</td></tr></tbody></table><p>​    注意：上面的方法使用时必须带括号</p><p>​    <strong>获取指定范围内的随机整数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandom</span>(<span class="hljs-params">min, max</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-日期对象"><a href="#1-4-日期对象" class="headerlink" title="1.4 日期对象"></a>1.4 日期对象</h3><p>​         Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p><ul><li><p>使用Date实例化日期对象</p><ul><li>获取当前时间必须实例化：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br></code></pre></td></tr></table></figure><ul><li>获取指定时间的日期对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> future = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2019/5/1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p></li><li><p>使用Date实例的方法和属性    </p><p><img src="/img/web/js32.jpg"></p></li><li><p>通过Date实例获取总毫米数</p><ul><li><p>总毫秒数的含义</p><p>​    基于1970年1月1日（世界标准时间）起的毫秒数</p></li><li><p>获取总毫秒数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实例化Date对象</span><br><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-comment">// 1. 用于获取对象的原始值</span><br><span class="hljs-built_in">console</span>.log(date.valueOf())<br><span class="hljs-built_in">console</span>.log(date.getTime())<br><span class="hljs-comment">// 2. 简单写可以这么做</span><br><span class="hljs-keyword">var</span> now = + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-comment">// 3. HTML5中提供的方法，有兼容性问题</span><br><span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now();<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-数组对象"><a href="#1-5-数组对象" class="headerlink" title="1.5 数组对象"></a>1.5 数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li><p>字面量方式</p><ul><li><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-literal">true</span>];<br></code></pre></td></tr></table></figure></li></ul></li><li><p>new Array()</p><ul><li><p>示例代码如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>();<br></code></pre></td></tr></table></figure><p>​    注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p><p>​    参数传递规则如下：</p><ul><li><p>如果只传入一个参数，则参数规定了数组的长度</p></li><li><p>如果传入了多个参数，则参数称为数组的元素</p></li></ul></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li><p>instanceof 运算符</p><ul><li><p>instanceof 可以判断一个对象是否是某个构造函数的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>Array.isArray()</p><ul><li><p>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arr));   <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(obj));   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><ul><li><p>数组中有进行增加、删除元素的方法，部分方法如下表</p><p><img src="/img/web/js33.jpg"></p><p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p></li></ul><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><ul><li><p>数组中有对数组本身排序的方法，部分方法如下表</p><p><img src="/img/web/js34.jpg"></p><p>注意：sort方法需要传入参数来设置升序、降序排序</p><ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul></li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><ul><li><p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p><p><img src="/img/web/js35.jpg"></p></li></ul><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><ul><li><p>数组中有把数组转化为字符串的方法，部分方法如下表</p><p><img src="/img/web/js36.jpg"></p><p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p>数组中还有其他操作方法，同学们可以在课下自行查阅学习</p><p><img src="/img/web/js37.jpg"></p></li></ul><h3 id="1-6-字符串对象"><a href="#1-6-字符串对象" class="headerlink" title="1.6 字符串对象"></a>1.6 字符串对象</h3><h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><p>​        为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p><p>​        基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 下面代码有什么问题？</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;andy&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.length);<br></code></pre></td></tr></table></figure><p>​        按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为</p><p>​        js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span><br><span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;andy&#x27;</span>);<br><span class="hljs-comment">// 2. 赋值给我们声明的字符变量</span><br>str = temp;<br><span class="hljs-comment">// 3. 销毁临时变量</span><br>temp = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h4 id="字符串的不可变"><a href="#字符串的不可变" class="headerlink" title="字符串的不可变"></a>字符串的不可变</h4><p>​        指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p><p>​        当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>​        由于字符串的不可变，在<strong>大量拼接字符串</strong>的时候会有效率问题</p><h4 id="根据字符返回位置"><a href="#根据字符返回位置" class="headerlink" title="根据字符返回位置"></a>根据字符返回位置</h4><p>​        字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p><p><img src="/img/web/js38.jpg"></p><p>​        案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数</p><ol><li>先查找第一个o出现的位置</li><li>然后 只要indexOf 返回的结果不是 -1 就继续往后查找</li><li>因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找     </li></ol><h4 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a>根据位置返回字符</h4><p>​        字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p><p><img src="/img/web/js39.jpg"></p><p>​        在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码</p><p>​        案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数</p><ol><li><p>核心算法：利用 charAt(） 遍历这个字符串</p></li><li><p>把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</p></li><li><p>遍历对象，得到最大值和该字符     </p><p>​    注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数</p></li></ol><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p>​        字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</p><p><img src="/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A007-JavaScript/img/web/js40.jpg)"></p><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><p>​        replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：  </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">字符串.<span class="hljs-built_in">replace</span>(被替换的字符串， 要替换为的字符串)；<br></code></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><p>​        split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p><p>​        其使用格式如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">字符串.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;分割字符&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-简单数据类型和复杂数据类型"><a href="#2-简单数据类型和复杂数据类型" class="headerlink" title="2 - 简单数据类型和复杂数据类型"></a>2 - 简单数据类型和复杂数据类型</h2><h3 id="2-1-简单数据类型"><a href="#2-1-简单数据类型" class="headerlink" title="2.1 简单数据类型"></a>2.1 简单数据类型</h3><p>​        <strong>简单类型</strong>（<strong>基本数据类型</strong>、<strong>值类型</strong>）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</p><h3 id="2-2-复杂数据类型"><a href="#2-2-复杂数据类型" class="headerlink" title="2.2 复杂数据类型"></a>2.2 复杂数据类型</h3><p>​        <strong>复杂数据类型（引用类型）</strong>：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</p><h3 id="2-3-堆栈"><a href="#2-3-堆栈" class="headerlink" title="2.3 堆栈"></a>2.3 堆栈</h3><ul><li>堆栈空间分配区别：</li></ul><p>　　1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</p><p>简单数据类型存放到栈里面</p><p>　　2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p><p><img src="/img/web/js41.jpg"></p><ul><li><p>简单数据类型的存储方式</p><p>​        值类型变量的数据直接存放在变量（栈空间）中</p></li></ul><p><img src="/img/web/js42.jpg"></p><ul><li><p>复杂数据类型的存储方式</p><p>​        引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</p></li></ul><h3 id="2-4-简单类型传参"><a href="#2-4-简单类型传参" class="headerlink" title="2.4 简单类型传参"></a>2.4 简单类型传参</h3><p>​        函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    a++;<br>    <span class="hljs-built_in">console</span>.log(a); <br>&#125;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br>fn(x);<br><span class="hljs-built_in">console</span>.log(x)；<br></code></pre></td></tr></table></figure><h3 id="2-5-复杂数据类型传参"><a href="#2-5-复杂数据类型传参" class="headerlink" title="2.5 复杂数据类型传参"></a>2.5 复杂数据类型传参</h3><p>​        函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-comment">// x = p</span><br>    <span class="hljs-built_in">console</span>.log(x.name); <span class="hljs-comment">// 2. 这个输出什么 ?    </span><br>    x.name = <span class="hljs-string">&quot;张学友&quot;</span>;<br>    <span class="hljs-built_in">console</span>.log(x.name); <span class="hljs-comment">// 3. 这个输出什么 ?    </span><br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;刘德华&quot;</span>);<br><span class="hljs-built_in">console</span>.log(p.name);    <span class="hljs-comment">// 1. 这个输出什么 ?   </span><br>f1(p);<br><span class="hljs-built_in">console</span>.log(p.name);    <span class="hljs-comment">// 4. 这个输出什么 ?  </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习08-Web APIs</title>
    <link href="/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A008-Web%20APIs/"/>
    <url>/2017/12/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A008-Web%20APIs/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="day01-Web-APIs"><a href="#day01-Web-APIs" class="headerlink" title="day01 - Web APIs"></a>day01 - Web APIs</h1><blockquote><p>学习目标：</p><p>能够通过ID来获取元素<br>能够通过标签名来获取元素<br>能够通过class来获取元素<br>能够通过选择器来获取元素<br>能够获取body和html元素<br>能够给元素注册事件<br>能够修改元素的内容<br>能够区分innerText和innerHTML的区别<br>能够修改像div这类普通元素的属性<br>能够修改表单元素的属性<br>能够修改元素的样式属性</p></blockquote><h2 id="1-1-Web-API介绍"><a href="#1-1-Web-API介绍" class="headerlink" title="1.1. Web API介绍"></a>1.1. Web API介绍</h2><h3 id="1-1-1-API的概念"><a href="#1-1-1-API的概念" class="headerlink" title="1.1.1 API的概念"></a>1.1.1 API的概念</h3><p>API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</p><blockquote><p>举例解释什么是API。</p><p>例如，</p><p>​    C语言中有一个函数 fopen()可以打开硬盘上的文件，这个函数对于我们来说，就是一个C语言提供的打开文件的工具。</p><p>​    javascript中有一个函数alert()可以在页面弹一个提示框，这个函数就是js提供的一个弹框工具。</p><p>这些工具（函数）由编程语言提供，内部的实现已经封装好了，我们只要学会灵活的使用这些工具即可。</p></blockquote><h3 id="1-1-2-Web-API的概念"><a href="#1-1-2-Web-API的概念" class="headerlink" title="1.1.2 Web  API的概念"></a>1.1.2 Web  API的概念</h3><p>​    Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</p><p>​    现阶段我们主要针对于浏览器讲解常用的 API , 主要针对浏览器做交互效果。比如我们想要浏览器弹出一个警示框， 直接使用 alert(‘弹出’)</p><p>​    MDN 详细 API : <a href="https://developer.mozilla.org/zh-CN/docs/Web/API">https://developer.mozilla.org/zh-CN/docs/Web/API</a></p><p>​    因为 Web API 很多，所以我们将这个阶段称为 Web APIs。</p><p>​    此处的 Web API 特指浏览器提供的一系列API(很多函数或对象方法)，即操作网页的一系列工具。例如：操作html标签、操作页面地址的方法。</p><h3 id="1-1-3-API-和-Web-API-总结"><a href="#1-1-3-API-和-Web-API-总结" class="headerlink" title="1.1.3 API 和 Web  API 总结"></a>1.1.3 API 和 Web  API 总结</h3><ol><li><p>API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现</p></li><li><p>Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。</p></li><li><p>Web API 一般都有输入和输出（函数的传参和返回值），Web API 很多都是方法（函数）</p></li><li><p>学习 Web API 可以结合前面学习内置对象方法的思路学习</p></li></ol><h2 id="1-2-DOM-介绍"><a href="#1-2-DOM-介绍" class="headerlink" title="1.2. DOM 介绍"></a>1.2. DOM 介绍</h2><h3 id="1-2-1-什么是DOM"><a href="#1-2-1-什么是DOM" class="headerlink" title="1.2.1 什么是DOM"></a>1.2.1 什么是DOM</h3><p>​    文档对象模型（Document Object Model，简称DOM），是 <a href="https://baike.baidu.com/item/W3C">W3C</a> 组织推荐的处理<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展标记语言</a>（html或者xhtml）的标准<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3">编程接口</a>。</p><p>​    W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p><blockquote><p>DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。</p></blockquote><h3 id="1-2-2-DOM树"><a href="#1-2-2-DOM树" class="headerlink" title="1.2.2. DOM树"></a>1.2.2. DOM树</h3><p><img src="/img/web/webapi.jpg"></p><p>DOM树 又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。DOM将这些内容都当作对象</p><ul><li>文档：一个页面就是一个文档，DOM中使用document表示</li><li>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示</li><li>标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示</li></ul><h2 id="1-3-获取元素"><a href="#1-3-获取元素" class="headerlink" title="1.3. 获取元素"></a>1.3. 获取元素</h2><p>为什么要获取页面元素？</p><p>例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。</p><h3 id="1-3-1-根据ID获取"><a href="#1-3-1-根据ID获取" class="headerlink" title="1.3.1. 根据ID获取"></a>1.3.1. 根据ID获取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">语法：<span class="hljs-built_in">document</span>.getElementById(id)<br>作用：根据ID获取元素对象<br>参数：id值，区分大小写的字符串<br>返回值：元素对象 或 <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span>2019-9-9<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;time&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(timer);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> timer);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.dir(timer);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-根据标签名获取元素"><a href="#1-3-2-根据标签名获取元素" class="headerlink" title="1.3.2. 根据标签名获取元素"></a>1.3.2. 根据标签名获取元素</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">语法：<span class="hljs-selector-tag">document</span><span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;标签名&#x27;</span>) 或者 <span class="hljs-selector-tag">element</span><span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;标签名&#x27;</span>) <br>作用：根据标签名获取元素对象<br>参数：标签名<br>返回值：元素对象集合（伪数组，数组元素是元素对象）<br></code></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是等你好久11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是等你好久22<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是等你好久33<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是等你好久44<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是等你好久55<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>生僻字<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>生僻字<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>生僻字<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>生僻字<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>生僻字<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> lis = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(lis);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(lis[<span class="hljs-number">0</span>]);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log(lis[i]);</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 3. element.getElementsByTagName()  可以得到这个元素里面的某些标签</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> nav = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;nav&#x27;</span>); <span class="hljs-comment">// 这个获得nav 元素</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> navLis = nav.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(navLis);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><blockquote><p>1,因为得到的是一个对象的集合,所以我们想要操作黎明的元素就需要遍历</p><p>2,得到元素对象是动态的</p></blockquote><p>注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</p><h3 id="1-3-3-H5新增获取元素方式"><a href="#1-3-3-H5新增获取元素方式" class="headerlink" title="1.3.3. H5新增获取元素方式"></a>1.3.3. H5新增获取元素方式</h3><p><img src="/img/web/webapi01.jpg"></p><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>盒子1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>盒子2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>产品<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. getElementsByClassName 根据类名获得某些元素集合</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> boxs = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;box&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(boxs);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> firstBox = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.box&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(firstBox);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#nav&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(nav);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(li);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 3. querySelectorAll()返回指定选择器的所有元素对象集合</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> allBox = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.box&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(allBox);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> lis = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(lis);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-4-获取特殊元素（body，html）"><a href="#1-3-4-获取特殊元素（body，html）" class="headerlink" title="1.3.4 获取特殊元素（body，html）"></a>1.3.4 获取特殊元素（body，html）</h3><p><img src="/img/web/webapi02.jpg"></p><h2 id="1-4-事件基础"><a href="#1-4-事件基础" class="headerlink" title="1.4. 事件基础"></a>1.4. 事件基础</h2><h3 id="1-4-1-事件概述"><a href="#1-4-1-事件概述" class="headerlink" title="1.4.1. 事件概述"></a>1.4.1. 事件概述</h3><p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p><p>简单理解： <strong>触发— 响应机制</strong>。</p><p>​    网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p><h3 id="1-4-2-事件三要素"><a href="#1-4-2-事件三要素" class="headerlink" title="1.4.2. 事件三要素"></a>1.4.2. 事件三要素</h3><ul><li>事件源（谁）：触发事件的元素</li><li>事件类型（什么事件）： 例如 click 点击事件</li><li>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</li></ul><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>唐伯虎<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 点击一个按钮，弹出对话框</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//(1) 事件源 事件被触发的对象   谁  按钮</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//(3) 事件处理程序  通过一个函数赋值的方式 完成</span></span></span><br><span class="javascript"><span class="xml">        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            alert(<span class="hljs-string">&#x27;点秋香&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-4-3-执行事件的步骤"><a href="#1-4-3-执行事件的步骤" class="headerlink" title="1.4.3. 执行事件的步骤"></a>1.4.3. 执行事件的步骤</h3><ul><li>获取事件源</li><li>注册事件(绑定事件)</li><li>添加事件处理程序(采取函数赋值形式)</li></ul><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 执行事件步骤</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 点击div 控制台输出 我被选中了</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 获取事件源</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2.绑定事件 注册事件</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// div.onclick </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 3.添加事件处理程序 </span></span></span><br><span class="javascript"><span class="xml">        div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我被选中了&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-4-4-常见的鼠标事件"><a href="#1-4-4-常见的鼠标事件" class="headerlink" title="1.4.4. 常见的鼠标事件"></a>1.4.4. 常见的鼠标事件</h3><p><img src="/img/web/webapi03.jpg"></p><p>1.4.5. 分析事件三要素</p><ul><li><p>下拉菜单三要素</p></li><li><p>关闭广告三要素</p></li></ul><h2 id="1-5-操作元素"><a href="#1-5-操作元素" class="headerlink" title="1.5. 操作元素"></a>1.5. 操作元素</h2><p>​    JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p><h3 id="1-5-1-改变元素内容（获取或设置）"><a href="#1-5-1-改变元素内容（获取或设置）" class="headerlink" title="1.5.1. 改变元素内容（获取或设置）"></a>1.5.1. 改变元素内容（获取或设置）</h3><p><img src="/img/web/webapi04.jpg"></p><p><strong>innerText改变元素内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>显示当前系统时间<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>某个时间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 当我们点击了按钮，  div里面的文字会发生变化</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 获取元素 </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2.注册事件</span></span></span><br><span class="javascript"><span class="xml">        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// div.innerText = &#x27;2019-6-6&#x27;;</span></span></span><br><span class="javascript"><span class="xml">            div.innerHTML = getDate();</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 我们写一个 2019年 5月 1日 星期三</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> year = date.getFullYear();</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> month = date.getMonth() + <span class="hljs-number">1</span>;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> dates = date.getDate();</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;星期日&#x27;</span>, <span class="hljs-string">&#x27;星期一&#x27;</span>, <span class="hljs-string">&#x27;星期二&#x27;</span>, <span class="hljs-string">&#x27;星期三&#x27;</span>, <span class="hljs-string">&#x27;星期四&#x27;</span>, <span class="hljs-string">&#x27;星期五&#x27;</span>, <span class="hljs-string">&#x27;星期六&#x27;</span>];</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> day = date.getDay();</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;今天是：&#x27;</span> + year + <span class="hljs-string">&#x27;年&#x27;</span> + month + <span class="hljs-string">&#x27;月&#x27;</span> + dates + <span class="hljs-string">&#x27;日 &#x27;</span> + arr[day];</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>innerText和innerHTML的区别</strong></p><ul><li>获取内容时的区别：</li></ul><p>​    innerText会去除空格和换行，而innerHTML会保留空格和换行    </p><ul><li>设置内容时的区别：</li></ul><p>​    innerText不会识别html，而innerHTML会识别</p><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        我是文字</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// innerText 和 innerHTML的区别 </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. innerText 不识别html标签 非标准  去除空格和换行</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. innerHTML 识别html标签 W3C标准 保留空格和换行的</span></span></span><br><span class="javascript"><span class="xml">        div.innerHTML = <span class="hljs-string">&#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 这两个属性是可读写的  可以获取元素里面的内容</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> p = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;p&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(p.innerText);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(p.innerHTML);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-5-2-常用元素的属性操作"><a href="#1-5-2-常用元素的属性操作" class="headerlink" title="1.5.2. 常用元素的属性操作"></a>1.5.2. 常用元素的属性操作</h3><ul><li>innerText,innerHTML</li><li>src,href</li><li>id,alt,title</li></ul><p><strong>获取属性的值</strong></p><blockquote><p>元素对象.属性名</p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p>元素对象.属性名 = 值</p></blockquote><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ldh&quot;</span>&gt;</span>刘德华<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zxy&quot;</span>&gt;</span>张学友<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span> &lt;br&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/ldh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;刘德华&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 修改元素属性  src</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 获取元素</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> ldh = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ldh&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> zxy = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;zxy&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. 注册事件  处理程序</span></span></span><br><span class="javascript"><span class="xml">        zxy.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            img.src = <span class="hljs-string">&#x27;images/zxy.jpg&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">            img.title = <span class="hljs-string">&#x27;张学友思密达&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">        ldh.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            img.src = <span class="hljs-string">&#x27;images/ldh.jpg&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">            img.title = <span class="hljs-string">&#x27;刘德华&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-5-3-案例：分时问候"><a href="#1-5-3-案例：分时问候" class="headerlink" title="1.5.3. 案例：分时问候"></a>1.5.3. 案例：分时问候</h3><p><img src="/img/web/webapi05.jpg"></p><h3 id="1-5-4-表单元素的属性操作"><a href="#1-5-4-表单元素的属性操作" class="headerlink" title="1.5.4. 表单元素的属性操作"></a>1.5.4. 表单元素的属性操作</h3><p><img src="/img/web/webapi06.jpg"></p><p><strong>获取属性的值</strong></p><blockquote><p>元素对象.属性名</p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p>元素对象.属性名 = 值</p><p>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</p></blockquote><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;输入内容&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 获取元素</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. 注册事件 处理程序</span></span></span><br><span class="javascript"><span class="xml">        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 表单里面的值 文字内容是通过 value 来修改的</span></span></span><br><span class="javascript"><span class="xml">            input.value = <span class="hljs-string">&#x27;被点击了&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// btn.disabled = true;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.disabled = <span class="hljs-literal">true</span>;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// this 指向的是事件函数的调用者 btn</span></span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-5-6-样式属性操作"><a href="#1-5-6-样式属性操作" class="headerlink" title="1.5.6. 样式属性操作"></a>1.5.6. 样式属性操作</h3><p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p><p><strong>常用方式</strong></p><ul><li>element.style   行内样式操作</li><li>element.className  类名样式操作</li></ul><h4 id="方式1：通过操作style属性"><a href="#方式1：通过操作style属性" class="headerlink" title="方式1：通过操作style属性"></a>方式1：通过操作style属性</h4><blockquote><p>元素对象的style属性也是一个对象！</p><p>元素对象.style.样式属性 = 值;</p></blockquote><p>​        注意:</p><pre><code>        * JS里面的样式采用驼峰命名法        * JS修改style样式操作,产生的是行内样式,CSS权重比较高</code></pre><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 获取元素</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. 注册事件 处理程序</span></span></span><br><span class="javascript"><span class="xml">        div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// div.style里面的属性 采取驼峰命名法 </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.style.backgroundColor = <span class="hljs-string">&#x27;purple&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.style.width = <span class="hljs-string">&#x27;250px&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="方式2：通过操作className属性"><a href="#方式2：通过操作className属性" class="headerlink" title="方式2：通过操作className属性"></a>方式2：通过操作className属性</h4><blockquote><p>元素对象.className = 值;</p><p>因为class是关键字，所有使用className。</p></blockquote><p><img src="/img/web/webapi07.jpg"></p><p><strong>案例代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> test = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        test.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// this.style.backgroundColor = &#x27;purple&#x27;;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// this.style.color = &#x27;#fff&#x27;;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// this.style.fontSize = &#x27;25px&#x27;;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// this.style.marginTop = &#x27;100px&#x27;;</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// this.className = &#x27;change&#x27;;</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.className = <span class="hljs-string">&#x27;first change&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h2 id="1-6-今日总结"><a href="#1-6-今日总结" class="headerlink" title="1.6. 今日总结"></a>1.6. 今日总结</h2><p><img src="/img/web/webapi08.jpg"></p><h1 id="day02-Web-APIs"><a href="#day02-Web-APIs" class="headerlink" title="day02 - Web APIs"></a>day02 - Web APIs</h1><blockquote><p>学习目标：</p><p>能够说出排他操作的一般实现步骤</p><p>能够使用html5中的dataset方式操作自定义属性</p><p>能够根据提示完成百度换肤的案例</p><p>能够根据提示完成全选案例</p><p>能够根据提示完成tab栏切换案例</p><p>能够区分元素节点、文本节点、属性节点</p><p>能够获取指定元素的父元素</p><p>能够获取指定元素的所有子元素</p><p>能够说出childNodes和children的区别</p><p>能够使用createElement创建页面元素</p></blockquote><h2 id="1-1-排他操作"><a href="#1-1-排他操作" class="headerlink" title="1.1. 排他操作"></a>1.1. 排他操作</h2><h3 id="1-1-1-排他思想"><a href="#1-1-1-排他思想" class="headerlink" title="1.1.1 排他思想"></a>1.1.1 排他思想</h3><p><img src="/img/web/webapi09.jpg"></p><p>如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：</p><ol><li><p>所有元素全部清除样式（干掉其他人）</p></li><li><p>给当前元素设置样式 （留下我自己）</p></li><li><p>注意顺序不能颠倒，首先干掉其他人，再设置自己</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;按钮<span class="hljs-number">1</span>&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 获取所有按钮元素</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// btns得到的是伪数组  里面的每一个元素 btns[i]</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="javascript"><span class="xml">        btns[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (1) 我们先把所有的按钮背景颜色去掉  干掉所有人</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="javascript"><span class="xml">                btns[i].style.backgroundColor = <span class="hljs-string">&#x27;&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">            &#125;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (2) 然后才让当前的元素背景颜色为pink 留下我自己</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.style.backgroundColor = <span class="hljs-string">&#x27;pink&#x27;</span>;</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="1-2-案例：百度换肤"><a href="#1-2-案例：百度换肤" class="headerlink" title="1.2 案例：百度换肤"></a>1.2 案例：百度换肤</h2><p><img src="/img/web/webapi10.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;ul class=&quot;baidu&quot;&gt;<br>        &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot;&gt;&lt;/li&gt;<br>        &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot;&gt;&lt;/li&gt;<br>        &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot;&gt;&lt;/li&gt;<br>        &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot;&gt;&lt;/li&gt;<br>    &lt;/ul&gt;<br>    &lt;script&gt;<br>        // 1. 获取元素 <br>        var imgs = document.querySelector(&#x27;.baidu&#x27;).querySelectorAll(&#x27;img&#x27;);<br>        // console.log(imgs);<br>        // 2. 循环注册事件 <br>        for (var i = 0; i &lt; imgs.length; i++) &#123;<br>            imgs[i].onclick = function() &#123;<br>                // this.src 就是我们点击图片的路径   images/2.jpg<br>                // console.log(this.src);<br>                // 把这个路径 this.src 给body 就可以了<br>                document.body.style.backgroundImage = &#x27;url(&#x27; + this.src + &#x27;)&#x27;;<br>            &#125;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h2 id="1-3-案例：表格隔行变色"><a href="#1-3-案例：表格隔行变色" class="headerlink" title="1.3 案例：表格隔行变色"></a>1.3 案例：表格隔行变色</h2><p><img src="/img/web/webapi11.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1.获取元素 获取的是 tbody 里面所有的行</span><br>    <span class="hljs-keyword">var</span> trs = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;tbody&#x27;</span>).querySelectorAll(<span class="hljs-string">&#x27;tr&#x27;</span>);<br>    <span class="hljs-comment">// 2. 利用循环绑定注册事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; trs.length; i++) &#123;<br>        <span class="hljs-comment">// 3. 鼠标经过事件 onmouseover</span><br>        trs[i].onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-comment">// console.log(11);</span><br>                <span class="hljs-built_in">this</span>.className = <span class="hljs-string">&#x27;bg&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">// 4. 鼠标离开事件 onmouseout</span><br>        trs[i].onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">this</span>.className = <span class="hljs-string">&#x27;&#x27;</span>;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="1-4-案例：全选"><a href="#1-4-案例：全选" class="headerlink" title="1.4 案例：全选"></a>1.4 案例：全选</h2><p><img src="/img/web/webapi12.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可</span><br>    <span class="hljs-comment">// 获取元素</span><br>    <br>    <span class="hljs-keyword">var</span> j_cbAll = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;j_cbAll&#x27;</span>); <br>    <span class="hljs-keyword">var</span> j_tbs = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;j_tb&#x27;</span>).getElementsByTagName(<span class="hljs-string">&#x27;input&#x27;</span>); <br>    <span class="hljs-comment">// 全选按钮注册事件</span><br>    j_cbAll.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// this.checked 当前复选框的选中状态</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.checked);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; j_tbs.length; i++) &#123;<br>                j_tbs[i].checked = <span class="hljs-built_in">this</span>.checked;<br>            &#125;<br>     &#125;<br>     <span class="hljs-comment">// 给所有的子复选框注册单击事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; j_tbs.length; i++) &#123;<br>        j_tbs[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// flag 控制全选按钮是否选中</span><br>            <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; j_tbs.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!j_tbs[i].checked) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>; <br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 设置全选按钮的状态</span><br>            j_cbAll.checked = flag;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="1-5-自定义属性操作"><a href="#1-5-自定义属性操作" class="headerlink" title="1.5. 自定义属性操作"></a>1.5. 自定义属性操作</h2><h3 id="1-5-1-获取属性值"><a href="#1-5-1-获取属性值" class="headerlink" title="1.5.1 获取属性值"></a>1.5.1 获取属性值</h3><p><img src="/img/web/webapi13.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">   &lt;div id=<span class="hljs-string">&quot;demo&quot;</span> index=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;&lt;/div&gt;<br>   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">       <span class="hljs-comment">// 1. 获取元素的属性值</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-comment">// (1) element.属性</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-built_in">console</span>.log(div.id);</span></span><br><span class="javascript"><span class="xml">       <span class="hljs-comment">//(2) element.getAttribute(&#x27;属性&#x27;)  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;id&#x27;</span>));</span></span><br><span class="javascript"><span class="xml">       <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;index&#x27;</span>));</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-5-2-设置属性值"><a href="#1-5-2-设置属性值" class="headerlink" title="1.5.2. 设置属性值"></a>1.5.2. 设置属性值</h3><p><img src="/img/web/webapi14.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 2. 设置元素属性值</span><br><span class="hljs-comment">// (1) element.属性= &#x27;值&#x27;</span><br>div.id = <span class="hljs-string">&#x27;test&#x27;</span>;<br>div.className = <span class="hljs-string">&#x27;navs&#x27;</span>;<br><span class="hljs-comment">// (2) element.setAttribute(&#x27;属性&#x27;, &#x27;值&#x27;);  主要针对于自定义属性</span><br>div.setAttribute(<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-number">2</span>);<br>div.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;footer&#x27;</span>); <span class="hljs-comment">// class 特殊  这里面写的就是</span><br></code></pre></td></tr></table></figure><h3 id="1-5-3-移出属性"><a href="#1-5-3-移出属性" class="headerlink" title="1.5.3. 移出属性"></a>1.5.3. 移出属性</h3><p><img src="/img/webimg/1550915513137.png" alt="1550915513137"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// class 不是className</span><br>      <span class="hljs-comment">// 3 移除属性 removeAttribute(属性)    </span><br>      div.removeAttribute(<span class="hljs-string">&#x27;index&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-5-4-案例：tab栏"><a href="#1-5-4-案例：tab栏" class="headerlink" title="1.5.4. 案例：tab栏"></a>1.5.4. 案例：tab栏</h3><p><img src="/img/web/webapi16.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 获取元素</span><br>    <span class="hljs-keyword">var</span> tab_list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.tab_list&#x27;</span>);<br>    <span class="hljs-keyword">var</span> lis = tab_list.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    <span class="hljs-keyword">var</span> items = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.item&#x27;</span>);<br>    <span class="hljs-comment">// for循环，给选项卡绑定点击事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br>        <span class="hljs-comment">// 开始给5个小li 设置索引号 </span><br>        lis[i].setAttribute(<span class="hljs-string">&#x27;index&#x27;</span>, i);<br>        lis[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）</span><br>            <span class="hljs-comment">// 干掉所有人 其余的li清除 class 这个类</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br>                lis[i].className = <span class="hljs-string">&#x27;&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">// 留下我自己 </span><br>            <span class="hljs-built_in">this</span>.className = <span class="hljs-string">&#x27;current&#x27;</span>;<br>            <span class="hljs-comment">// 2. 下面的显示内容模块</span><br>            <span class="hljs-keyword">var</span> index = <span class="hljs-built_in">this</span>.getAttribute(<span class="hljs-string">&#x27;index&#x27;</span>);<br>            <span class="hljs-built_in">console</span>.log(index);<br>            <span class="hljs-comment">// 干掉所有人 让其余的item 这些div 隐藏</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;<br>                items[i].style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">// 留下我自己 让对应的item 显示出来</span><br>            items[index].style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-5-5-H5自定义属性"><a href="#1-5-5-H5自定义属性" class="headerlink" title="1.5.5. H5自定义属性"></a>1.5.5. H5自定义属性</h3><p>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</p><p>自定义属性获取是通过getAttribute(‘属性’) 获取。</p><p>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</p><p>H5给我们新增了自定义属性：</p><p><img src="/img/web/webapi17.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div getTime=<span class="hljs-string">&quot;20&quot;</span> data-index=<span class="hljs-string">&quot;2&quot;</span> data-list-name=<span class="hljs-string">&quot;andy&quot;</span>&gt;&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// console.log(div.getTime);</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;getTime&#x27;</span>));</span></span><br><span class="javascript"><span class="xml">    div.setAttribute(<span class="hljs-string">&#x27;data-time&#x27;</span>, <span class="hljs-number">20</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;data-index&#x27;</span>));</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;data-list-name&#x27;</span>));</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// h5新增的获取自定义属性的方法 它只能获取data-开头的</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// dataset 是一个集合里面存放了所有以data开头的自定义属性</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.dataset);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.dataset.index);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.dataset[<span class="hljs-string">&#x27;index&#x27;</span>]);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.dataset.listName);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.dataset[<span class="hljs-string">&#x27;listName&#x27;</span>]);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="1-6-节点操作"><a href="#1-6-节点操作" class="headerlink" title="1.6. 节点操作"></a>1.6. 节点操作</h2><h3 id="1-6-1-节点概述"><a href="#1-6-1-节点概述" class="headerlink" title="1.6.1. 节点概述"></a>1.6.1. 节点概述</h3><p>​    网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p><p>​    HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p><p><img src="/img/web/webapi18.jpg"></p><p>​    一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><p><img src="/img/web/webapi19.jpg"></p><h3 id="1-6-2-节点层级"><a href="#1-6-2-节点层级" class="headerlink" title="1.6.2. 节点层级"></a>1.6.2. 节点层级</h3><p>​    利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p><p>​    <img src="/img/web/webapi20.jpg"></p><h3 id="1-6-3-父级节点"><a href="#1-6-3-父级节点" class="headerlink" title="1.6.3. 父级节点"></a>1.6.3. 父级节点</h3><p><img src="/img/web/webapi21.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;erweima&quot;</span>&gt;</span>×<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 父节点 parentNode</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> erweima = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.erweima&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// var box = document.querySelector(&#x27;.box&#x27;);</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(erweima.parentNode);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-6-4-子节点"><a href="#1-6-4-子节点" class="headerlink" title="1.6.4. 子节点"></a>1.6.4. 子节点</h3><p><strong>所有子节点</strong></p><p><img src="/img/webimg/1550971263925.png" alt="1550971263925"></p><p><strong>子元素节点</strong></p><p><img src="/img/webimg/1550971325828.png" alt="1550971325828"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// DOM 提供的方法（API）获取</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> lis = ul.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ul.childNodes);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ul.childNodes[<span class="hljs-number">0</span>].nodeType);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ul.childNodes[<span class="hljs-number">1</span>].nodeType);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. children 获取所有的子元素节点 也是我们实际开发常用的</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ul.children);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>第1个子节点</strong></p><p><img src="/img/webimg/1550971774758.png" alt="1550971774758"></p><p><strong>最后1个子节点</strong></p><p><img src="/img/webimg/1550971825493.png" alt="1550971825493"></p><p><strong>第1个子元素节点</strong></p><p><img src="/img/webimg/1550972014509.png" alt="1550972014509"></p><p><strong>最后1个子元素节点</strong></p><p><img src="/img/webimg/1550972106485.png" alt="1550972106485"></p><p>​    实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？</p><p><img src="/img/webimg/1550972648014.png" alt="1550972648014"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ol&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是li5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ol&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ol = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ol&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. firstChild 第一个子节点 不管是文本节点还是元素节点</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ol.firstChild);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ol.lastChild);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. firstElementChild 返回第一个子元素节点 ie9才支持</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ol.firstElementChild);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ol.lastElementChild);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ol.children[<span class="hljs-number">0</span>]);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(ol.children[ol.children.length - <span class="hljs-number">1</span>]);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-6-5-案例：新浪下拉菜单"><a href="#1-6-5-案例：新浪下拉菜单" class="headerlink" title="1.6.5. 案例：新浪下拉菜单"></a>1.6.5. 案例：新浪下拉菜单</h3><p><img src="/img/webimg/1550974934894.png" alt="1550974934894"></p><p><img src="/img/webimg/1550975025608.png" alt="1550975025608"></p><p><img src="/img/webimg/1550975049176.png" alt="1550975049176"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1. 获取元素</span><br>    <span class="hljs-keyword">var</span> nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.nav&#x27;</span>);<br>    <span class="hljs-keyword">var</span> lis = nav.children; <span class="hljs-comment">// 得到4个小li</span><br>    <span class="hljs-comment">// 2.循环注册事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br>        lis[i].onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">this</span>.children[<span class="hljs-number">1</span>].style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>        &#125;<br>        lis[i].onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">this</span>.children[<span class="hljs-number">1</span>].style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-6-6-兄弟节点"><a href="#1-6-6-兄弟节点" class="headerlink" title="1.6.6. 兄弟节点"></a>1.6.6. 兄弟节点</h3><p><strong>下一个兄弟节点</strong></p><p><img src="/img/webimg/1550973538696.png" alt="1550973538696"></p><p><strong>上一个兄弟节点</strong></p><p><img src="/img/webimg/1550973558511.png" alt="1550973558511"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;我是div&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.nextSibling);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.previousSibling);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. nextElementSibling 得到下一个兄弟元素节点</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.nextElementSibling);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(div.previousElementSibling);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>下一个兄弟元素节点（有兼容性问题）</strong></p><p><img src="/img/webimg/1550973610223.png" alt="1550973610223"></p><p><strong>上一个兄弟元素节点（有兼容性问题）</strong></p><p><img src="/img/webimg/1550973630150.png" alt="1550973630150"></p><p><img src="/img/webimg/1550973722805.png" alt="1550973722805"></p><p><img src="/img/webimg/1550973799759.png" alt="1550973799759"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextElementSibling</span>(<span class="hljs-params">element</span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> el = element;<br>   <span class="hljs-keyword">while</span> (el = el.nextSibling) &#123;<br>     <span class="hljs-keyword">if</span> (el.nodeType === <span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-keyword">return</span> el;<br>     &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;  <br></code></pre></td></tr></table></figure><h3 id="1-6-7-创建节点"><a href="#1-6-7-创建节点" class="headerlink" title="1.6.7. 创建节点"></a>1.6.7. 创建节点</h3><p><img src="/img/webimg/1550975514321.png" alt="1550975514321"></p><h3 id="1-6-8-添加节点"><a href="#1-6-8-添加节点" class="headerlink" title="1.6.8. 添加节点"></a>1.6.8. 添加节点</h3><p><img src="/img/webimg/1550975640170.png" alt="1550975640170"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 创建节点元素节点</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    ul.appendChild(li);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 3. 添加节点 node.insertBefore(child, 指定元素);</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> lili = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    ul.insertBefore(lili, ul.children[<span class="hljs-number">0</span>]);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素</span></span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-6-9-案例：简单版发布留言"><a href="#1-6-9-案例：简单版发布留言" class="headerlink" title="1.6.9. 案例：简单版发布留言"></a>1.6.9. 案例：简单版发布留言</h3><p><img src="/img/webimg/1550975849302.png" alt="1550975849302"></p><p><img src="/img/webimg/1550975887017.png" alt="1550975887017"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>发布<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 获取元素</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;textarea&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 2. 注册事件</span></span></span><br><span class="javascript"><span class="xml">        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">if</span> (text.value == <span class="hljs-string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="javascript"><span class="xml">                alert(<span class="hljs-string">&#x27;您没有输入内容&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">            &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// console.log(text.value);</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// (1) 创建元素</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// 先有li 才能赋值</span></span></span><br><span class="javascript"><span class="xml">                li.innerHTML = text.value;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// (2) 添加元素</span></span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// ul.appendChild(li);</span></span></span><br><span class="javascript"><span class="xml">                ul.insertBefore(li, ul.children[<span class="hljs-number">0</span>]);</span></span><br><span class="javascript"><span class="xml">            &#125;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h1 id="day03-Web-APIs"><a href="#day03-Web-APIs" class="headerlink" title="day03 - Web APIs"></a>day03 - Web APIs</h1><blockquote><p>学习目标：</p><p>能够使用removeChild()方法删除节点</p><p>能够完成动态生成表格案例</p><p>能够使用传统方式和监听方式给元素注册事件</p><p>能够说出事件流执行的三个阶段</p><p>能够在事件处理函数中获取事件对象</p><p>能够使用事件对象取消默认行为</p><p>能够使用事件对象阻止事件冒泡</p><p>能够使用事件对象获取鼠标的位置</p><p>能够完成跟随鼠标的天使案例</p></blockquote><h2 id="1-1-节点操作"><a href="#1-1-节点操作" class="headerlink" title="1.1. 节点操作"></a>1.1. 节点操作</h2><h3 id="1-1-1-删除节点"><a href="#1-1-1-删除节点" class="headerlink" title="1.1.1 删除节点"></a>1.1.1 删除节点</h3><p><img src="/img/webimg/1551163384254.png" alt="1551163384254"></p><p>node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;删除&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>熊大<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>熊二<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>光头强<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1.获取元素</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. 删除元素  node.removeChild(child)</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// ul.removeChild(ul.children[0]);</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 3. 点击按钮依次删除里面的孩子</span></span></span><br><span class="javascript"><span class="xml">    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (ul.children.length == <span class="hljs-number">0</span>) &#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.disabled = <span class="hljs-literal">true</span>;</span></span><br><span class="javascript"><span class="xml">        &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">            ul.removeChild(ul.children[<span class="hljs-number">0</span>]);</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-1-2-案例：删除留言"><a href="#1-1-2-案例：删除留言" class="headerlink" title="1.1.2 案例：删除留言"></a>1.1.2 案例：删除留言</h3><p><img src="/img/webimg/1551163586475.png" alt="1551163586475"></p><p><img src="/img/webimg/1551163635501.png" alt="1551163635501"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;textarea name=<span class="hljs-string">&quot;&quot;</span> id=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/textarea&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>发布<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 获取元素</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;textarea&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. 注册事件</span></span></span><br><span class="javascript"><span class="xml">    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (text.value == <span class="hljs-string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="javascript"><span class="xml">            alert(<span class="hljs-string">&#x27;您没有输入内容&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">        &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// console.log(text.value);</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (1) 创建元素</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 先有li 才能赋值</span></span></span><br><span class="javascript"><span class="xml">            li.innerHTML = text.value + <span class="hljs-string">&quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;</span>;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (2) 添加元素</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// ul.appendChild(li);</span></span></span><br><span class="javascript"><span class="xml">            ul.insertBefore(li, ul.children[<span class="hljs-number">0</span>]);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// (3) 删除元素 删除的是当前链接的li  它的父亲</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> <span class="hljs-keyword">as</span> = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;a&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">as</span>.length; i++) &#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-keyword">as</span>[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">                    <span class="hljs-comment">// 删除的是 li 当前a所在的li  this.parentNode;</span></span></span><br><span class="javascript"><span class="xml">                    ul.removeChild(<span class="hljs-built_in">this</span>.parentNode);</span></span><br><span class="javascript"><span class="xml">                &#125;</span></span><br><span class="javascript"><span class="xml">            &#125;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-1-3-复制（克隆）节点"><a href="#1-1-3-复制（克隆）节点" class="headerlink" title="1.1.3 复制（克隆）节点"></a>1.1.3 复制（克隆）节点</h3><p><img src="/img/webimg/1551163763825.png" alt="1551163763825"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> lili = ul.children[<span class="hljs-number">0</span>].cloneNode(<span class="hljs-literal">true</span>);</span></span><br><span class="javascript"><span class="xml">    ul.appendChild(lili);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-1-4-案例：动态生成表格"><a href="#1-1-4-案例：动态生成表格" class="headerlink" title="1.1.4 案例：动态生成表格"></a>1.1.4 案例：动态生成表格</h3><p><img src="/img/webimg/1551163900675.png" alt="1551163900675"></p><p><img src="/img/webimg/1551163924396.png" alt="1551163924396"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;script&gt;<br>      <span class="hljs-comment">// 1.先去准备好学生的数据</span><br>      <span class="hljs-keyword">var</span> datas = [&#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;魏璎珞&#x27;</span>,<br>          <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;JavaScript&#x27;</span>,<br>          <span class="hljs-attr">score</span>: <span class="hljs-number">100</span><br>      &#125;, &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;弘历&#x27;</span>,<br>          <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;JavaScript&#x27;</span>,<br>          <span class="hljs-attr">score</span>: <span class="hljs-number">98</span><br>      &#125;, &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;傅恒&#x27;</span>,<br>          <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;JavaScript&#x27;</span>,<br>          <span class="hljs-attr">score</span>: <span class="hljs-number">99</span><br>      &#125;, &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;明玉&#x27;</span>,<br>          <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;JavaScript&#x27;</span>,<br>          <span class="hljs-attr">score</span>: <span class="hljs-number">88</span><br>      &#125;, &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;大猪蹄子&#x27;</span>,<br>          <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;JavaScript&#x27;</span>,<br>          <span class="hljs-attr">score</span>: <span class="hljs-number">0</span><br>      &#125;];<br>      <span class="hljs-comment">// 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行</span><br>      <span class="hljs-keyword">var</span> tbody = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;tbody&#x27;</span>);<br><span class="hljs-comment">// 遍历数组</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; datas.length; i++) &#123; <br>          <span class="hljs-comment">// 1. 创建 tr行</span><br>          <span class="hljs-keyword">var</span> tr = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;tr&#x27;</span>);<br>          tbody.appendChild(tr);<br>          <span class="hljs-comment">// 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数  </span><br>          <span class="hljs-comment">// 使用for in遍历学生对象</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> datas[i]) &#123; <br>              <span class="hljs-comment">// 创建单元格 </span><br>              <span class="hljs-keyword">var</span> td = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;td&#x27;</span>);<br>              <span class="hljs-comment">// 把对象里面的属性值 datas[i][k] 给 td  </span><br>              td.innerHTML = datas[i][k];<br>              tr.appendChild(td);<br>          &#125;<br>          <span class="hljs-comment">// 3. 创建有删除2个字的单元格 </span><br>          <span class="hljs-keyword">var</span> td = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;td&#x27;</span>);<br>          td.innerHTML = <span class="hljs-string">&#x27;&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;&#x27;</span>;<br>          tr.appendChild(td);<br><br>      &#125;<br>      <span class="hljs-comment">// 4. 删除操作 开始 </span><br>      <span class="hljs-keyword">var</span> <span class="hljs-keyword">as</span> = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;a&#x27;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">as</span>.length; i++) &#123;<br>          <span class="hljs-keyword">as</span>[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-comment">// 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)  </span><br>              tbody.removeChild(<span class="hljs-built_in">this</span>.parentNode.parentNode)<br>          &#125;<br>      &#125;<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-1-5-创建元素的三种方式"><a href="#1-1-5-创建元素的三种方式" class="headerlink" title="1.1.5 创建元素的三种方式"></a>1.1.5 创建元素的三种方式</h3><p><img src="/img/webimg/1551164214925.png" alt="1551164214925"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 三种创建元素方式区别 </span><br>    <span class="hljs-comment">// 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘</span><br>     <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);<br>     btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>         <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;&lt;div&gt;123&lt;/div&gt;&#x27;</span>);<br>     &#125;<br><br>    <span class="hljs-comment">// 2. innerHTML 创建元素</span><br>    <span class="hljs-keyword">var</span> inner = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.inner&#x27;</span>);<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>         inner.innerHTML += <span class="hljs-string">&#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;</span><br>     &#125;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>        arr.push(<span class="hljs-string">&#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;</span>);<br>    &#125;<br>    inner.innerHTML = arr.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-comment">// 3. document.createElement() 创建元素</span><br>    <span class="hljs-keyword">var</span> create = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.create&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        create.appendChild(a);<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-1-6-innerTHML和createElement效率对比"><a href="#1-1-6-innerTHML和createElement效率对比" class="headerlink" title="1.1.6 innerTHML和createElement效率对比"></a>1.1.6 innerTHML和createElement效率对比</h3><p><strong>innerHTML字符串拼接方式（效率低）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> d1 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-built_in">document</span>.body.innerHTML += <span class="hljs-string">&#x27;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">var</span> d2 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-built_in">console</span>.log(d2 - d1);<br>    &#125;<br>    fn();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>createElement方式（效率一般）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> d1 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>            div.style.width = <span class="hljs-string">&#x27;100px&#x27;</span>;<br>            div.style.height = <span class="hljs-string">&#x27;2px&#x27;</span>;<br>            div.style.border = <span class="hljs-string">&#x27;1px solid red&#x27;</span>;<br>            <span class="hljs-built_in">document</span>.body.appendChild(div);<br>        &#125;<br>        <span class="hljs-keyword">var</span> d2 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-built_in">console</span>.log(d2 - d1);<br>    &#125;<br>    fn();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>innerHTML数组方式（效率高）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> d1 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-keyword">var</span> array = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            array.push(<span class="hljs-string">&#x27;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#x27;</span>);<br>        &#125;<br>        <span class="hljs-built_in">document</span>.body.innerHTML = array.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-keyword">var</span> d2 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-built_in">console</span>.log(d2 - d1);<br>    &#125;<br>    fn();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="1-2-DOM的核心总结"><a href="#1-2-DOM的核心总结" class="headerlink" title="1.2. DOM的核心总结"></a>1.2. DOM的核心总结</h2><p><img src="/img/webimg/1551164669434.png" alt="1551164669434"></p><p><img src="/img/webimg/1551164715018.png" alt="1551164715018"></p><p>关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</p><h3 id="1-2-1-创建"><a href="#1-2-1-创建" class="headerlink" title="1.2.1. 创建"></a>1.2.1. 创建</h3><p><img src="/img/webimg/1551164797164.png" alt="1551164797164"></p><h3 id="1-2-2-增加"><a href="#1-2-2-增加" class="headerlink" title="1.2.2. 增加"></a>1.2.2. 增加</h3><p><img src="/img/webimg/1551164829832.png" alt="1551164829832"></p><h3 id="1-2-3-删"><a href="#1-2-3-删" class="headerlink" title="1.2.3. 删"></a>1.2.3. 删</h3><p><img src="/img/webimg/1551164872533.png" alt="1551164872533"></p><h3 id="1-2-4-改"><a href="#1-2-4-改" class="headerlink" title="1.2.4. 改"></a>1.2.4. 改</h3><p><img src="/img/webimg/1551164907830.png" alt="1551164907830"></p><h3 id="1-2-5-查"><a href="#1-2-5-查" class="headerlink" title="1.2.5. 查"></a>1.2.5. 查</h3><p><img src="/img/webimg/1551164936214.png" alt="1551164936214"></p><h3 id="1-2-6-属性操作"><a href="#1-2-6-属性操作" class="headerlink" title="1.2.6. 属性操作"></a>1.2.6. 属性操作</h3><p><img src="/img/webimg/1551164985383.png" alt="1551164985383"></p><h3 id="1-2-7-事件操作（重点）"><a href="#1-2-7-事件操作（重点）" class="headerlink" title="1.2.7. 事件操作（重点）"></a>1.2.7. 事件操作（重点）</h3><h2 id="1-3-事件高级"><a href="#1-3-事件高级" class="headerlink" title="1.3. 事件高级"></a>1.3. 事件高级</h2><h3 id="1-3-1-注册事件（2种方式）"><a href="#1-3-1-注册事件（2种方式）" class="headerlink" title="1.3.1. 注册事件（2种方式）"></a>1.3.1. 注册事件（2种方式）</h3><p><img src="/img/webimg/1551165252019.png" alt="1551165252019"></p><h3 id="1-3-2-事件监听"><a href="#1-3-2-事件监听" class="headerlink" title="1.3.2 事件监听"></a>1.3.2 事件监听</h3><h4 id="addEventListener-事件监听（IE9以后支持）"><a href="#addEventListener-事件监听（IE9以后支持）" class="headerlink" title="addEventListener()事件监听（IE9以后支持）"></a>addEventListener()事件监听（IE9以后支持）</h4><p><img src="/img/webimg/1551165364122.png" alt="1551165364122"></p><p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p><p><img src="/img/webimg/1551165604792.png" alt="1551165604792"></p><h4 id="attacheEvent-事件监听（IE678支持）"><a href="#attacheEvent-事件监听（IE678支持）" class="headerlink" title="attacheEvent()事件监听（IE678支持）"></a>attacheEvent()事件监听（IE678支持）</h4><p><img src="/img/webimg/1551165781836.png" alt="1551165781836"></p><p>​    eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p><p><img src="/img/webimg/1551165843912.png" alt="1551165843912"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;传统注册事件&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>方法监听注册事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>ie9 attachEvent<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 传统方式注册事件</span></span></span><br><span class="javascript"><span class="xml">    btns[<span class="hljs-number">0</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        alert(<span class="hljs-string">&#x27;hi&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">    btns[<span class="hljs-number">0</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            alert(<span class="hljs-string">&#x27;hao a u&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-comment">// 2. 事件侦听注册事件 addEventListener </span></span></span><br><span class="javascript"><span class="xml">   <span class="hljs-comment">// (1) 里面的事件类型是字符串 必定加引号 而且不带on</span></span></span><br><span class="javascript"><span class="xml">   <span class="hljs-comment">// (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）</span></span></span><br><span class="javascript"><span class="xml">    btns[<span class="hljs-number">1</span>].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        alert(<span class="hljs-number">22</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;)</span></span><br><span class="javascript"><span class="xml">    btns[<span class="hljs-number">1</span>].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            alert(<span class="hljs-number">33</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;)</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 3. attachEvent ie9以前的版本支持</span></span></span><br><span class="javascript"><span class="xml">    btns[<span class="hljs-number">2</span>].attachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        alert(<span class="hljs-number">11</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;)</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="事件监听兼容性解决方案"><a href="#事件监听兼容性解决方案" class="headerlink" title="事件监听兼容性解决方案"></a>事件监听兼容性解决方案</h4><p>封装一个函数，函数中判断浏览器的类型：</p><p><img src="/img/webimg/1551166023885.png" alt="1551166023885"></p><h3 id="1-3-3-删除事件（解绑事件）"><a href="#1-3-3-删除事件（解绑事件）" class="headerlink" title="1.3.3. 删除事件（解绑事件）"></a>1.3.3. 删除事件（解绑事件）</h3><p><img src="/img/webimg/1551166185410.png" alt="1551166185410"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<span class="hljs-number">1</span>&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    divs[<span class="hljs-number">0</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        alert(<span class="hljs-number">11</span>);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 1. 传统方式删除事件</span></span></span><br><span class="javascript"><span class="xml">        divs[<span class="hljs-number">0</span>].onclick = <span class="hljs-literal">null</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. removeEventListener 删除事件</span></span></span><br><span class="javascript"><span class="xml">    divs[<span class="hljs-number">1</span>].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, fn) <span class="hljs-comment">// 里面的fn 不需要调用加小括号</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        alert(<span class="hljs-number">22</span>);</span></span><br><span class="javascript"><span class="xml">        divs[<span class="hljs-number">1</span>].removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, fn);</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 3. detachEvent</span></span></span><br><span class="javascript"><span class="xml">    divs[<span class="hljs-number">2</span>].attachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, fn1);</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        alert(<span class="hljs-number">33</span>);</span></span><br><span class="javascript"><span class="xml">        divs[<span class="hljs-number">2</span>].detachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, fn1);</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>**删除事件兼容性解决方案 **</p><p><img src="/img/webimg/1551166332453.png" alt="1551166332453"></p><h3 id="1-3-4-DOM事件流"><a href="#1-3-4-DOM事件流" class="headerlink" title="1.3.4. DOM事件流"></a>1.3.4. DOM事件流</h3><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。<br>当你单击一个<span class="hljs-selector-tag">div</span>时，同时你也单击了<span class="hljs-selector-tag">div</span>的父元素，甚至整个页面。<br><br>那么是先执行父元素的单击事件，还是先执行<span class="hljs-selector-tag">div</span>的单击事件 ？？？<br></code></pre></td></tr></table></figure></blockquote><p><img src="/img/webimg/1551166423144.png" alt="1551166423144"></p><blockquote><p>比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</p></blockquote><p><img src="/img/webimg/1551166555833.png" alt="1551166555833"></p><p><img src="/img/webimg/1551166581552.png" alt="1551166581552"></p><blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">当时的<span class="hljs-number">2</span>大浏览器霸主谁也不服谁！<br>IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。<br>Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。<br><br>江湖纷争，武林盟主也脑壳疼！！！<br><br>最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —<span class="hljs-comment">--— 先捕获再冒泡。</span><br>现代浏览器都遵循了此标准，所以当事件发生时，会经历<span class="hljs-number">3</span>个阶段。<br></code></pre></td></tr></table></figure></blockquote><p>DOM 事件流会经历3个阶段： </p><ol><li><p>捕获阶段</p></li><li><p>当前目标阶段</p></li><li><p>冒泡阶段 </p></li></ol><p>​    我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。 </p><p><img src="/img/webimg/1551169007768.png" alt="1551169007768"></p><p><img src="/img/webimg/1551169042295.png" alt="1551169042295"></p><p><strong>事件冒泡</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span>son盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &lt;/div&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// onclick 和 attachEvent（ie） 在冒泡阶段触发</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 </span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// son -&gt; father -&gt;body -&gt; html -&gt; document</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.son&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给son注册单击事件</span></span></span><br><span class="javascript"><span class="xml">      son.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          alert(<span class="hljs-string">&#x27;son&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;, <span class="hljs-literal">false</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给father注册单击事件</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.father&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      father.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          alert(<span class="hljs-string">&#x27;father&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;, <span class="hljs-literal">false</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给document注册单击事件，省略第3个参数</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          alert(<span class="hljs-string">&#x27;document&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;)</span></span><br><span class="javascript"><span class="xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>事件捕获</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span>son盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &lt;/div&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// document -&gt; html -&gt; body -&gt; father -&gt; son</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.son&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给son注册单击事件，第3个参数为true</span></span></span><br><span class="javascript"><span class="xml">       son.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">           alert(<span class="hljs-string">&#x27;son&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">       &#125;, <span class="hljs-literal">true</span>);</span></span><br><span class="javascript"><span class="xml">       <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.father&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给father注册单击事件，第3个参数为true</span></span></span><br><span class="javascript"><span class="xml">       father.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">           alert(<span class="hljs-string">&#x27;father&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">       &#125;, <span class="hljs-literal">true</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给document注册单击事件，第3个参数为true</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          alert(<span class="hljs-string">&#x27;document&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;, <span class="hljs-literal">true</span>)</span></span><br><span class="javascript"><span class="xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-3-5-事件对象"><a href="#1-3-5-事件对象" class="headerlink" title="1.3.5. 事件对象"></a>1.3.5. 事件对象</h3><h4 id="什么是事件对象"><a href="#什么是事件对象" class="headerlink" title="什么是事件对象"></a>什么是事件对象</h4><p>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</p><p>比如：  </p><ol><li><p>谁绑定了这个事件。</p></li><li><p>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</p></li><li><p>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</p></li></ol><h4 id="事件对象的使用"><a href="#事件对象的使用" class="headerlink" title="事件对象的使用"></a>事件对象的使用</h4><p>事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</p><p>所以，在事件处理函数中声明1个形参用来接收事件对象。</p><p><img src="/img/webimg/1551169537789.png" alt="1551169537789"></p><h4 id="事件对象的兼容性处理"><a href="#事件对象的兼容性处理" class="headerlink" title="事件对象的兼容性处理"></a>事件对象的兼容性处理</h4><p>事件对象本身的获取存在兼容问题：</p><ol><li><p>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</p></li><li><p>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</p></li></ol><p><img src="/img/webimg/1551169680823.png" alt="1551169680823"></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">只要“||”前面为<span class="hljs-literal">false</span>, 不管“||”后面是<span class="hljs-literal">true</span> 还是 <span class="hljs-literal">false</span>，都返回 “||” 后面的值。<br>只要“||”前面为<span class="hljs-literal">true</span>, 不管“||”后面是<span class="hljs-literal">true</span> 还是 <span class="hljs-literal">false</span>，都返回 “||” 前面的值。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">// 事件对象</span></span></span><br><span class="javascript"><span class="xml">            e = e || <span class="hljs-built_in">window</span>.event;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log(e);</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="事件对象的属性和方法"><a href="#事件对象的属性和方法" class="headerlink" title="事件对象的属性和方法"></a>事件对象的属性和方法</h4><p><img src="/img/webimg/1551169931778.png" alt="1551169931778"></p><h4 id="e-target-和-this-的区别"><a href="#e-target-和-this-的区别" class="headerlink" title="e.target 和 this 的区别"></a>e.target 和 this 的区别</h4><ul><li><p> this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</p></li><li><p> e.target 是事件触发的元素。</p></li></ul><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">常情况下terget 和 <span class="hljs-keyword">this</span>是一致的，<br>但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），<br>这时候<span class="hljs-keyword">this</span>指向的是父元素，因为它是绑定事件的元素对象，<br>而target指向的是子元素，因为他是触发事件的那个具体元素对象。<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// e.target 和 this指向的都是div</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(e.target);</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    &#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>事件冒泡下的e.target和this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>abc<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>abc<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>abc<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    ul.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 我们给ul 绑定了事件  那么this 就指向ul  </span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// ul</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-built_in">console</span>.log(e.target); <span class="hljs-comment">// li</span></span></span><br><span class="javascript"><span class="xml">    &#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-3-6-阻止默认行为"><a href="#1-3-6-阻止默认行为" class="headerlink" title="1.3.6 阻止默认行为"></a>1.3.6 阻止默认行为</h3><blockquote><p>html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;a href=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>&gt;百度&lt;/a&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. 阻止默认行为 让链接不跳转 </span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;a&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    a.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">         e.preventDefault(); <span class="hljs-comment">//  dom 标准写法</span></span></span><br><span class="javascript"><span class="xml">    &#125;);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 3. 传统的注册方式</span></span></span><br><span class="javascript"><span class="xml">    a.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 普通浏览器 e.preventDefault();  方法</span></span></span><br><span class="javascript"><span class="xml">        e.preventDefault();</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 低版本浏览器 ie678  returnValue  属性</span></span></span><br><span class="javascript"><span class="xml">        e.returnValue = <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 我们可以利用return false 也能阻止默认行为 没有兼容性问题</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-3-7-阻止事件冒泡"><a href="#1-3-7-阻止事件冒泡" class="headerlink" title="1.3.7 阻止事件冒泡"></a>1.3.7 阻止事件冒泡</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p><p><img src="/img/webimg/1551171467194.png" alt="1551171467194"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span>son儿子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &lt;/div&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.son&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给son注册单击事件</span></span></span><br><span class="javascript"><span class="xml">      son.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          alert(<span class="hljs-string">&#x27;son&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">          e.stopPropagation(); <span class="hljs-comment">// stop 停止  Propagation 传播</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 非标准 cancel 取消 bubble 泡泡</span></span></span><br><span class="javascript"><span class="xml">      &#125;, <span class="hljs-literal">false</span>);</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.father&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给father注册单击事件</span></span></span><br><span class="javascript"><span class="xml">      father.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          alert(<span class="hljs-string">&#x27;father&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;, <span class="hljs-literal">false</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给document注册单击事件</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          alert(<span class="hljs-string">&#x27;document&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;)</span></span><br><span class="javascript"><span class="xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>阻止事件冒泡的兼容性处理</strong></p><p><img src="/img/webimg/1551171657513.png" alt="1551171657513"></p><h3 id="1-3-8-事件委托"><a href="#1-3-8-事件委托" class="headerlink" title="1.3.8 事件委托"></a>1.3.8 事件委托</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p><h4 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">把事情委托给别人，代为处理。<br></code></pre></td></tr></table></figure><p>事件委托也称为事件代理，在 jQuery 里面称为事件委派。</p><blockquote><p>说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</p></blockquote><p><strong>生活中的代理：</strong></p><p><img src="/img/webimg/1551172082624.png" alt="1551172082624"></p><p><strong>js事件中的代理：</strong></p><p><img src="/img/webimg/1551172159273.png" alt="1551172159273"></p><h4 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h4><p>​    给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</p><h4 id="事件委托的作用"><a href="#事件委托的作用" class="headerlink" title="事件委托的作用"></a>事件委托的作用</h4><ul><li><p>我们只操作了一次 DOM ，提高了程序的性能。</p></li><li><p>动态新创建的子元素，也拥有事件。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，点我应有弹框在手！<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，点我应有弹框在手！<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，点我应有弹框在手！<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，点我应有弹框在手！<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，点我应有弹框在手！<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    ul.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// e.target 这个可以得到我们点击的对象</span></span></span><br><span class="javascript"><span class="xml">        e.target.style.backgroundColor = <span class="hljs-string">&#x27;pink&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;)</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="1-4-常用鼠标事件"><a href="#1-4-常用鼠标事件" class="headerlink" title="1.4. 常用鼠标事件"></a>1.4. 常用鼠标事件</h2><p><img src="/img/webimg/1551172699854.png" alt="1551172699854"></p><h3 id="1-4-1-案例：禁止选中文字和禁止右键菜单"><a href="#1-4-1-案例：禁止选中文字和禁止右键菜单" class="headerlink" title="1.4.1 案例：禁止选中文字和禁止右键菜单"></a>1.4.1 案例：禁止选中文字和禁止右键菜单</h3><p><img src="/img/webimg/1551172755484.png" alt="1551172755484"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    我是一段不愿意分享的文字<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 1. contextmenu 我们可以禁用右键菜单</span><br>        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>                e.preventDefault();<br>        &#125;)<br>        <span class="hljs-comment">// 2. 禁止选中文字 selectstart</span><br>        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;selectstart&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>            e.preventDefault();<br>        &#125;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="1-4-2-鼠标事件对象"><a href="#1-4-2-鼠标事件对象" class="headerlink" title="1.4.2 鼠标事件对象"></a>1.4.2 鼠标事件对象</h3><p><img src="/img/webimg/1551173103741.png" alt="1551173103741"></p><h3 id="1-4-3-获取鼠标在页面的坐标"><a href="#1-4-3-获取鼠标在页面的坐标" class="headerlink" title="1.4.3 获取鼠标在页面的坐标"></a>1.4.3 获取鼠标在页面的坐标</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 鼠标事件对象 MouseEvent</span><br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>        <span class="hljs-comment">// 1. client 鼠标在可视区的x和y坐标</span><br>        <span class="hljs-built_in">console</span>.log(e.clientX);<br>        <span class="hljs-built_in">console</span>.log(e.clientY);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------&#x27;</span>);<br><br>        <span class="hljs-comment">// 2. page 鼠标在页面文档的x和y坐标</span><br>        <span class="hljs-built_in">console</span>.log(e.pageX);<br>        <span class="hljs-built_in">console</span>.log(e.pageY);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------&#x27;</span>);<br><br>        <span class="hljs-comment">// 3. screen 鼠标在电脑屏幕的x和y坐标</span><br>        <span class="hljs-built_in">console</span>.log(e.screenX);<br>        <span class="hljs-built_in">console</span>.log(e.screenY);<br><br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-4-4-案例：跟随鼠标的天使"><a href="#1-4-4-案例：跟随鼠标的天使" class="headerlink" title="1.4.4 案例：跟随鼠标的天使"></a>1.4.4 案例：跟随鼠标的天使</h3><p><img src="/img/webimg/1551173172613.png" alt="1551173172613"></p><p><img src="/img/webimg/1551173186812.png" alt="1551173186812"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;img src=<span class="hljs-string">&quot;images/angel.gif&quot;</span> alt=<span class="hljs-string">&quot;&quot;</span>&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> pic = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. mousemove只要我们鼠标移动1px 就会触发这个事件</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 把这个x和y坐标做为图片的top和left 值就可以移动图片</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> x = e.pageX;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> y = e.pageY;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x坐标是&#x27;</span> + x, <span class="hljs-string">&#x27;y坐标是&#x27;</span> + y);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//3 . 千万不要忘记给left 和top 添加px 单位</span></span></span><br><span class="javascript"><span class="xml">    pic.style.left = x - <span class="hljs-number">50</span> + <span class="hljs-string">&#x27;px&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">    pic.style.top = y - <span class="hljs-number">40</span> + <span class="hljs-string">&#x27;px&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">&#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="day04-Web-APIs"><a href="#day04-Web-APIs" class="headerlink" title="day04 - Web APIs"></a>day04 - Web APIs</h1><blockquote><p>学习目标：</p><p>能够说出常用的3-5个键盘事件</p><p>能够知道如何获取当前键盘按下的是哪个键</p><p>能够知道浏览器的顶级对象window</p><p>能够使用window.onload事件</p><p>能够使用window.onresize事件</p><p>能够说出两种定时器的区别</p><p>能够使用location对象的href属性完成页面之间的跳转</p><p>能够使用location对象获取url中的参数部分</p><p>能够使用history提供的方法实现页面刷新</p></blockquote><h2 id="1-1-常用的键盘事件"><a href="#1-1-常用的键盘事件" class="headerlink" title="1.1. 常用的键盘事件"></a>1.1. 常用的键盘事件</h2><h3 id="1-1-1-键盘事件"><a href="#1-1-1-键盘事件" class="headerlink" title="1.1.1 键盘事件"></a>1.1.1 键盘事件</h3><p><img src="/img/webimg/1551318122855.png" alt="1551318122855"></p><p><img src="/img/webimg/1551318160371.png" alt="1551318160371"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 常用的键盘事件</span><br>    <span class="hljs-comment">//1. keyup 按键弹起的时候触发 </span><br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我弹起了&#x27;</span>);<br>    &#125;)<br><br>    <span class="hljs-comment">//3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊</span><br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我按下了press&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-comment">//2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊</span><br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我按下了down&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-comment">// 4. 三个事件的执行顺序  keydown -- keypress -- keyup</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-1-2-键盘事件对象"><a href="#1-1-2-键盘事件对象" class="headerlink" title="1.1.2 键盘事件对象"></a>1.1.2 键盘事件对象</h3><p><img src="/img/webimg/1551318355505.png" alt="1551318355505"></p><p><img src="/img/webimg/1551318404238.png" alt="1551318404238"></p><p><strong>使用keyCode属性判断用户按下哪个键</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值</span><br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;up:&#x27;</span> + e.keyCode);<br>        <span class="hljs-comment">// 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键</span><br>        <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">65</span>) &#123;<br>            alert(<span class="hljs-string">&#x27;您按下的a键&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            alert(<span class="hljs-string">&#x27;您没有按下a键&#x27;</span>)<br>        &#125;<br>    &#125;)<br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>        <span class="hljs-comment">// console.log(e);</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;press:&#x27;</span> + e.keyCode);<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-1-3-案例：模拟京东按键输入内容"><a href="#1-1-3-案例：模拟京东按键输入内容" class="headerlink" title="1.1.3 案例：模拟京东按键输入内容"></a>1.1.3 案例：模拟京东按键输入内容</h3><p>当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</p><p><img src="/img/webimg/1551318669520.png" alt="1551318669520"></p><blockquote><p>注意：触发获得焦点事件，可以使用 元素对象.focus()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;input type=<span class="hljs-string">&quot;text&quot;</span>&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 获取输入框</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> search = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给document注册keyup事件</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 判断keyCode的值</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">83</span>) &#123;</span></span><br><span class="javascript"><span class="xml">              <span class="hljs-comment">// 触发输入框的获得焦点事件</span></span></span><br><span class="javascript"><span class="xml">              search.focus();</span></span><br><span class="javascript"><span class="xml">          &#125;</span></span><br><span class="javascript"><span class="xml">      &#125;)</span></span><br><span class="javascript"><span class="xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-1-4-案例：模拟京东快递单号查询"><a href="#1-1-4-案例：模拟京东快递单号查询" class="headerlink" title="1.1.4 案例：模拟京东快递单号查询"></a>1.1.4 案例：模拟京东快递单号查询</h3><p>要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</p><p><img src="/img/webimg/1551318882189.png" alt="1551318882189"></p><p><img src="/img/webimg/1551318909264.png" alt="1551318909264"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;search&quot;</span>&gt;<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;con&quot;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入您的快递单号&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jd&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 获取要操作的元素</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> con = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.con&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> jd_input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.jd&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给输入框注册keyup事件</span></span></span><br><span class="javascript"><span class="xml">      jd_input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 判断输入框内容是否为空</span></span></span><br><span class="javascript"><span class="xml">              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.value == <span class="hljs-string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="javascript"><span class="xml">                  <span class="hljs-comment">// 为空，隐藏放大提示盒子</span></span></span><br><span class="javascript"><span class="xml">                  con.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">              &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">                  <span class="hljs-comment">// 不为空，显示放大提示盒子，设置盒子的内容</span></span></span><br><span class="javascript"><span class="xml">                  con.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">                  con.innerText = <span class="hljs-built_in">this</span>.value;</span></span><br><span class="javascript"><span class="xml">              &#125;</span></span><br><span class="javascript"><span class="xml">          &#125;)</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 给输入框注册失去焦点事件，隐藏放大提示盒子</span></span></span><br><span class="javascript"><span class="xml">      jd_input.addEventListener(<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">              con.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">          &#125;)</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 给输入框注册获得焦点事件</span></span></span><br><span class="javascript"><span class="xml">      jd_input.addEventListener(<span class="hljs-string">&#x27;focus&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 判断输入框内容是否为空</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.value !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="javascript"><span class="xml">              <span class="hljs-comment">// 不为空则显示提示盒子</span></span></span><br><span class="javascript"><span class="xml">              con.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">          &#125;</span></span><br><span class="javascript"><span class="xml">      &#125;)</span></span><br><span class="javascript"><span class="xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="1-2-BOM"><a href="#1-2-BOM" class="headerlink" title="1.2. BOM"></a>1.2. BOM</h2><h3 id="1-2-1-什么是BOM"><a href="#1-2-1-什么是BOM" class="headerlink" title="1.2.1. 什么是BOM"></a>1.2.1. 什么是BOM</h3><p>​    BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p><p>​    BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p><p>​    BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p><p><img src="/img/webimg/1551319264407.png" alt="1551319264407"></p><h3 id="1-2-2-BOM的构成"><a href="#1-2-2-BOM的构成" class="headerlink" title="1.2.2. BOM的构成"></a>1.2.2. BOM的构成</h3><p>BOM 比 DOM 更大，它包含 DOM。</p><p><img src="/img/webimg/1551319344183.png" alt="1551319344183"></p><h3 id="1-2-3-顶级对象window"><a href="#1-2-3-顶级对象window" class="headerlink" title="1.2.3. 顶级对象window"></a>1.2.3. 顶级对象window</h3><p><img src="/img/webimg/1551319372909.png" alt="1551319372909"></p><h3 id="1-2-4-window对象的常见事件"><a href="#1-2-4-window对象的常见事件" class="headerlink" title="1.2.4. window对象的常见事件"></a>1.2.4. window对象的常见事件</h3><h4 id="页面（窗口）加载事件（2种）"><a href="#页面（窗口）加载事件（2种）" class="headerlink" title="页面（窗口）加载事件（2种）"></a>页面（窗口）加载事件（2种）</h4><p><strong>第1种</strong></p><p><img src="/img/webimg/1551319525109.png" alt="1551319525109"></p><p>window.onload 是窗口 (页面）加载事件，<strong>当文档内容完全加载完成</strong>会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p><p><img src="/img/webimg/1551319600263.png" alt="1551319600263"></p><p><strong>第2种</strong></p><p><img src="/img/webimg/1551319620299.png" alt="1551319620299"></p><p>​    DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</p><p>​    IE9以上才支持！！！</p><p>​    如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);<br>        btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            alert(<span class="hljs-string">&#x27;点击我&#x27;</span>);<br>        &#125;)<br>    &#125;)<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alert(<span class="hljs-number">22</span>);<br>    &#125;)<br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alert(<span class="hljs-number">33</span>);<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h4><p><img src="/img/webimg/1551319803117.png" alt="1551319803117"></p><p>​    window.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。</p><p>注意：</p><ol><li><p>只要窗口大小发生像素变化，就会触发这个事件。</p></li><li><p>我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 注册页面加载事件</span><br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    <span class="hljs-comment">// 注册调整窗口大小事件</span><br>        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// window.innerWidth 获取窗口大小</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;变化了&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.innerWidth &lt;= <span class="hljs-number">800</span>) &#123;<br>                div.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                div.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>            &#125;<br>        &#125;)<br>    &#125;)<br>&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-2-5-定时器（两种）"><a href="#1-2-5-定时器（两种）" class="headerlink" title="1.2.5. 定时器（两种）"></a>1.2.5. 定时器（两种）</h3><p>window 对象给我们提供了 2 个非常好用的方法-定时器。</p><ul><li><p>setTimeout() </p></li><li><p>setInterval()  </p></li></ul><h4 id="setTimeout-炸弹定时器"><a href="#setTimeout-炸弹定时器" class="headerlink" title="setTimeout() 炸弹定时器"></a>setTimeout() 炸弹定时器</h4><h5 id="开启定时器"><a href="#开启定时器" class="headerlink" title="开启定时器"></a>开启定时器</h5><p><img src="/img/webimg/1551320279307.png" alt="1551320279307"></p><p><img src="/img/webimg/1551320408854.png" alt="1551320408854"></p><p><img src="/img/webimg/1551320298981.png" alt="1551320298981"></p><blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">普通函数是按照代码顺序直接调用。<br><br>简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。<br>例如：定时器中的调用函数，事件处理函数，也是回调函数。<br><br>以前我们讲的   element.onclick = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;   或者  element.add<span class="hljs-constructor">EventListener(“<span class="hljs-params">click</span>”, <span class="hljs-params">fn</span>)</span>;   里面的 函数也是回调函数。<br><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;script&gt;<br>      <span class="hljs-comment">// 回调函数是一个匿名函数</span><br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;时间到了&#x27;</span>);<br><br>       &#125;, <span class="hljs-number">2000</span>);<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;爆炸了&#x27;</span>);<br>      &#125;<br><span class="hljs-comment">// 回调函数是一个有名函数</span><br>      <span class="hljs-keyword">var</span> timer1 = <span class="hljs-built_in">setTimeout</span>(callback, <span class="hljs-number">3000</span>);<br>      <span class="hljs-keyword">var</span> timer2 = <span class="hljs-built_in">setTimeout</span>(callback, <span class="hljs-number">5000</span>);<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="案例：5秒后关闭广告"><a href="#案例：5秒后关闭广告" class="headerlink" title="案例：5秒后关闭广告"></a>案例：5秒后关闭广告</h5><p><img src="/img/webimg/1551320924828.png" alt="1551320924828"></p><p><img src="/img/webimg/1551320959756.png" alt="1551320959756"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/ad.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ad&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 获取要操作的元素</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> ad = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.ad&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 开启定时器</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            ad.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">        &#125;, <span class="hljs-number">5000</span>);</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="停止定时器"><a href="#停止定时器" class="headerlink" title="停止定时器"></a>停止定时器</h5><p><img src="/img/webimg/1551321051001.png" alt="1551321051001"></p><p><img src="/img/webimg/1551321064154.png" alt="1551321064154"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">  &lt;button&gt;点击停止定时器&lt;/button&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 开启定时器</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;爆炸了&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;, <span class="hljs-number">5000</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 给按钮注册单击事件</span></span></span><br><span class="javascript"><span class="xml">      btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 停止定时器</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="javascript"><span class="xml">      &#125;)</span></span><br><span class="javascript"><span class="xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="setInterval-闹钟定时器"><a href="#setInterval-闹钟定时器" class="headerlink" title="setInterval() 闹钟定时器"></a>setInterval() 闹钟定时器</h4><h5 id="开启定时器-1"><a href="#开启定时器-1" class="headerlink" title="开启定时器"></a>开启定时器</h5><p><img src="/img/webimg/1551321162158.png" alt="1551321162158"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1. setInterval </span><br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;继续输出&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="案例：倒计时"><a href="#案例：倒计时" class="headerlink" title="案例：倒计时"></a>案例：倒计时</h5><p><img src="/img/webimg/1551321298787.png" alt="1551321298787"></p><p><img src="/img/webimg/1551321322188.png" alt="1551321322188"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hour&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;minute&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 获取元素（时分秒盒子） </span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> hour = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.hour&#x27;</span>); <span class="hljs-comment">// 小时的黑色盒子</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> minute = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.minute&#x27;</span>); <span class="hljs-comment">// 分钟的黑色盒子</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> second = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.second&#x27;</span>); <span class="hljs-comment">// 秒数的黑色盒子</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> inputTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2019-5-1 18:00:00&#x27;</span>); <span class="hljs-comment">// 返回的是用户输入时间总的毫秒数</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    countDown(); <span class="hljs-comment">// 我们先调用一次这个函数，防止第一次刷新页面有空白 </span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. 开启定时器</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">setInterval</span>(countDown, <span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDown</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> nowTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// 返回的是当前时间总的毫秒数</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> times = (inputTime - nowTime) / <span class="hljs-number">1000</span>; <span class="hljs-comment">// times是剩余时间总的秒数 </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> h = <span class="hljs-built_in">parseInt</span>(times / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> % <span class="hljs-number">24</span>); <span class="hljs-comment">//时</span></span></span><br><span class="javascript"><span class="xml">        h = h &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + h : h;</span></span><br><span class="javascript"><span class="xml">        hour.innerHTML = h; <span class="hljs-comment">// 把剩余的小时给 小时黑色盒子</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">parseInt</span>(times / <span class="hljs-number">60</span> % <span class="hljs-number">60</span>); <span class="hljs-comment">// 分</span></span></span><br><span class="javascript"><span class="xml">        m = m &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + m : m;</span></span><br><span class="javascript"><span class="xml">        minute.innerHTML = m;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">parseInt</span>(times % <span class="hljs-number">60</span>); <span class="hljs-comment">// 当前的秒</span></span></span><br><span class="javascript"><span class="xml">        s = s &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + s : s;</span></span><br><span class="javascript"><span class="xml">        second.innerHTML = s;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="停止定时器-1"><a href="#停止定时器-1" class="headerlink" title="停止定时器"></a>停止定时器</h5><p><img src="/img/webimg/1551321444559.png" alt="1551321444559"></p><h4 id="案例：发送短信倒计时"><a href="#案例：发送短信倒计时" class="headerlink" title="案例：发送短信倒计时"></a>案例：发送短信倒计时</h4><p>​    点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。</p><p><img src="/img/webimg/1551321540676.png" alt="1551321540676"></p><p><img src="/img/webimg/1551321564247.png" alt="1551321564247"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">  手机号码： &lt;input type=<span class="hljs-string">&quot;number&quot;</span>&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 全局变量，定义剩下的秒数</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> time = <span class="hljs-number">3</span>; </span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">// 注册单击事件</span></span></span><br><span class="javascript"><span class="xml">      btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 禁用按钮</span></span></span><br><span class="javascript"><span class="xml">          btn.disabled = <span class="hljs-literal">true</span>;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 开启定时器</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">              <span class="hljs-comment">// 判断剩余秒数</span></span></span><br><span class="javascript"><span class="xml">              <span class="hljs-keyword">if</span> (time == <span class="hljs-number">0</span>) &#123;</span></span><br><span class="javascript"><span class="xml">                  <span class="hljs-comment">// 清除定时器和复原按钮</span></span></span><br><span class="javascript"><span class="xml">                  <span class="hljs-built_in">clearInterval</span>(timer);</span></span><br><span class="javascript"><span class="xml">                  btn.disabled = <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">                  btn.innerHTML = <span class="hljs-string">&#x27;发送&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">              &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">                  btn.innerHTML = <span class="hljs-string">&#x27;还剩下&#x27;</span> + time + <span class="hljs-string">&#x27;秒&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">                  time--;</span></span><br><span class="javascript"><span class="xml">              &#125;</span></span><br><span class="javascript"><span class="xml">          &#125;, <span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml">      &#125;);</span></span><br><span class="javascript"><span class="xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-2-6-this指向问题"><a href="#1-2-6-this指向问题" class="headerlink" title="1.2.6. this指向问题"></a>1.2.6. this指向问题</h3><p>​    this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。</p><p>现阶段，我们先了解一下几个this指向</p><ol><li><p>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</p></li><li><p>方法调用中谁调用this指向谁</p></li><li><p>构造函数中this指向构造函数的实例</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;点击&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// this 指向问题 一般情况下this的最终指向的是那个调用它的对象</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">window</span>.fn();</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;, <span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 2. 方法调用中谁调用this指向谁</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> o = &#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// this指向的是 o 这个对象</span></span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">    o.sayHi();</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 事件处理函数中的this指向的是btn这个按钮对象</span></span></span><br><span class="javascript"><span class="xml">        &#125;)</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// 3. 构造函数中this指向构造函数的实例</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fun</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// this 指向的是fun 实例对象</span></span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">new</span> Fun();</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-2-7-location对象"><a href="#1-2-7-location对象" class="headerlink" title="1.2.7. location对象"></a>1.2.7. location对象</h3><h4 id="什么是-location-对象"><a href="#什么是-location-对象" class="headerlink" title="什么是 location 对象"></a>什么是 location 对象</h4><p><img src="/img/webimg/1551322091638.png" alt="1551322091638"></p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p><img src="/img/webimg/1551322373704.png" alt="1551322373704"></p><p><img src="/img/webimg/1551322387201.png" alt="1551322387201"></p><h4 id="location-对象的属性"><a href="#location-对象的属性" class="headerlink" title="location 对象的属性"></a>location 对象的属性</h4><p><img src="/img/webimg/1551322416716.png" alt="1551322416716"></p><p><img src="/img/webimg/1551322438200.png" alt="1551322438200"></p><h4 id="案例：5分钟自动跳转页面"><a href="#案例：5分钟自动跳转页面" class="headerlink" title="案例：5分钟自动跳转页面"></a>案例：5分钟自动跳转页面</h4><p><img src="/img/webimg/1551322496871.png" alt="1551322496871"></p><p><img src="/img/webimg/1551322517605.png" alt="1551322517605"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;点击&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// console.log(location.href);</span></span></span><br><span class="javascript"><span class="xml">        location.href = <span class="hljs-string">&#x27;http://www.itcast.cn&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;)</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> timer = <span class="hljs-number">5</span>;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (timer == <span class="hljs-number">0</span>) &#123;</span></span><br><span class="javascript"><span class="xml">            location.href = <span class="hljs-string">&#x27;http://www.itcast.cn&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">        &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="javascript"><span class="xml">            div.innerHTML = <span class="hljs-string">&#x27;您将在&#x27;</span> + timer + <span class="hljs-string">&#x27;秒钟之后跳转到首页&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">            timer--;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;, <span class="hljs-number">1000</span>);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="案例：获取URL参数"><a href="#案例：获取URL参数" class="headerlink" title="案例：获取URL参数"></a>案例：获取URL参数</h4><p><img src="/img/webimg/1551322622640.png" alt="1551322622640"></p><p><img src="/img/webimg/1551322639241.png" alt="1551322639241"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">   &lt;div&gt;&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-built_in">console</span>.log(location.search); <span class="hljs-comment">// ?uname=andy</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-comment">// 1.先去掉？  substr(&#x27;起始的位置&#x27;，截取几个字符);</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-keyword">var</span> params = location.search.substr(<span class="hljs-number">1</span>); <span class="hljs-comment">// uname=andy</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-built_in">console</span>.log(params);</span></span><br><span class="javascript"><span class="xml">       <span class="hljs-comment">// 2. 利用=把字符串分割为数组 split(&#x27;=&#x27;);</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-keyword">var</span> arr = params.split(<span class="hljs-string">&#x27;=&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">       <span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [&quot;uname&quot;, &quot;ANDY&quot;]</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">       <span class="hljs-comment">// 3.把数据写入div中</span></span></span><br><span class="javascript"><span class="xml">       div.innerHTML = arr[<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;欢迎您&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="location对象的常见方法"><a href="#location对象的常见方法" class="headerlink" title="location对象的常见方法"></a>location对象的常见方法</h4><p><img src="/img/webimg/1551322750241.png" alt="1551322750241"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;点击&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">    btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 记录浏览历史，所以可以实现后退功能</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// location.assign(&#x27;http://www.itcast.cn&#x27;);</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// 不记录浏览历史，所以不可以实现后退功能</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">// location.replace(&#x27;http://www.itcast.cn&#x27;);</span></span></span><br><span class="javascript"><span class="xml">        location.reload(<span class="hljs-literal">true</span>);</span></span><br><span class="javascript"><span class="xml">    &#125;)</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-2-8-navigator对象"><a href="#1-2-8-navigator对象" class="headerlink" title="1.2.8. navigator对象"></a>1.2.8. navigator对象</h3><p>​    navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</p><p>下面前端代码可以判断用户那个终端打开页面，实现跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>((navigator.userAgent.match(<span class="hljs-regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;<br>    <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;&quot;</span>;     <span class="hljs-comment">//手机</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;&quot;</span>;     <span class="hljs-comment">//电脑</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-9-history对象"><a href="#1-2-9-history对象" class="headerlink" title="1.2.9 history对象"></a>1.2.9 history对象</h3><p>​    window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p><p><img src="/img/webimg/1551322885216.png" alt="1551322885216"></p><p>history对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。</p><p><img src="/img/webimg/1551322959148.png" alt="1551322959148"></p><h2 id="1-3-JS执行机制"><a href="#1-3-JS执行机制" class="headerlink" title="1.3. JS执行机制"></a>1.3. JS执行机制</h2><p>以下代码执行的结果是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>以下代码执行的结果是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="1-3-1-JS-是单线程"><a href="#1-3-1-JS-是单线程" class="headerlink" title="1.3.1 JS 是单线程"></a>1.3.1 JS 是单线程</h3><p><img src="/img/webimg/1551415019322.png" alt="1551415019322"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。<br></code></pre></td></tr></table></figure><h3 id="1-3-2-同步任务和异步任务"><a href="#1-3-2-同步任务和异步任务" class="headerlink" title="1.3.2 同步任务和异步任务"></a>1.3.2 同步任务和异步任务</h3><p>​    单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！</p><p>​    为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了<strong>同步任务</strong>和<strong>异步任务</strong>。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>​    前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>​    你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。</p><p><img src="/img/webimg/1551434295074.png" alt="1551434295074"></p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<br><br>同步任务指的是：<br>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br>异步任务指的是：<br>不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。<br></code></pre></td></tr></table></figure></blockquote><p><img src="/img/webimg/1551434972778.png" alt="1551434972778"></p><h3 id="1-3-3-JS执行机制（事件循环）"><a href="#1-3-3-JS执行机制（事件循环）" class="headerlink" title="1.3.3 JS执行机制（事件循环）"></a>1.3.3 JS执行机制（事件循环）</h3><p><img src="/img/webimg/1551435335464.png" alt="1551435335464"></p><p><img src="/img/webimg/1551435398306.png" alt="1551435398306"></p><p><img src="/img/webimg/1551435449634.png" alt="1551435449634"></p><h3 id="1-3-4-代码思考题"><a href="#1-3-4-代码思考题" class="headerlink" title="1.3.4 代码思考题"></a>1.3.4 代码思考题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">document</span>.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;click&#x27;</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;, <span class="hljs-number">3000</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h1 id="day05-Web-APIs"><a href="#day05-Web-APIs" class="headerlink" title="day05 - Web APIs"></a><strong>day05 - Web APIs</strong></h1><blockquote><p><strong>学习目标:</strong></p><p>能够说出常见 offset 系列属性的作用</p><p>能够说出常见 client 系列属性的作用</p><p>能够说出常见 scroll 系列属性的作用</p><p>能够封装简单动画函数</p></blockquote><h2 id="1-1-元素偏移量-offset-系列"><a href="#1-1-元素偏移量-offset-系列" class="headerlink" title="**1.1. **元素偏移量 offset 系列"></a>**1.1. **元素偏移量 offset 系列</h2><h3 id="1-1-1-offset-概述"><a href="#1-1-1-offset-概述" class="headerlink" title="1.1.1 offset 概述"></a>1.1.1 offset 概述</h3><p>offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p><ol><li><p>获得元素距离带有定位父元素的位置</p></li><li><p>获得元素自身的大小（宽度高度）</p></li><li><p>注意：返回的数值都不带单位</p></li></ol><p><img src="/img/webimg/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p><img src="/img/webimg/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><h3 id="1-1-2-offset-与-style-区别"><a href="#1-1-2-offset-与-style-区别" class="headerlink" title="1.1.2 offset 与 style 区别"></a>1.1.2 offset 与 style 区别</h3><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><ul><li><p>offset 可以得到任意样式表中的样式值</p></li><li><p>offset 系列获得的数值是没有单位的</p></li><li><p>offsetWidth 包含padding+border+width</p></li><li><p>offsetWidth 等属性是只读属性，只能获取不能赋值</p></li><li><blockquote><p>所以，我们想要获取元素大小位置，用offset更合适</p></blockquote></li></ul><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><ul><li><p>style 只能得到行内样式表中的样式值</p></li><li><p>style.width 获得的是带有单位的字符串</p></li><li><p>style.width 获得不包含padding和border 的值</p></li><li><p>style.width 是可读写属性，可以获取也可以赋值</p></li><li><blockquote><p>所以，我们想要给元素更改值，则需要用style改变</p></blockquote></li></ul><blockquote><p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p></blockquote><h3 id="1-1-3-案例：获取鼠标在盒子内的坐标"><a href="#1-1-3-案例：获取鼠标在盒子内的坐标" class="headerlink" title="1.1.3  案例：获取鼠标在盒子内的坐标"></a>1.1.3  案例：获取鼠标在盒子内的坐标</h3><ol><li>我们在盒子内点击，想要得到鼠标距离盒子左右的距离。</li><li>首先得到鼠标在页面中的坐标（e.pageX, e.pageY）</li><li>其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop)</li><li>用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标</li><li>如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> box = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.box&#x27;</span>);<br>box.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br><span class="hljs-keyword">var</span> x = e.pageX - <span class="hljs-built_in">this</span>.offsetLeft;<br><span class="hljs-keyword">var</span> y = e.pageY - <span class="hljs-built_in">this</span>.offsetTop;<br><span class="hljs-built_in">this</span>.innerHTML = <span class="hljs-string">&#x27;x坐标是&#x27;</span> + x + <span class="hljs-string">&#x27; y坐标是&#x27;</span> + y;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="1-1-4-案例：模态框拖拽"><a href="#1-1-4-案例：模态框拖拽" class="headerlink" title="1.1.4  案例：模态框拖拽"></a>1.1.4  案例：模态框拖拽</h3><p>弹出框，我们也称为模态框。</p><p>​    1.点击弹出层，会弹出模态框， 并且显示灰色半透明的遮挡层。</p><p>​    2.点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。</p><p>​    3.鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。</p><p>​    4.鼠标松开，可以停止拖动模态框移动</p><h3 id="1-1-5-案例分析"><a href="#1-1-5-案例分析" class="headerlink" title="1.1.5. 案例分析:"></a>1.1.5. 案例分析:</h3><ol><li>点击弹出层， 模态框和遮挡层就会显示出来 display:block;</li><li>点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;</li><li>在页面中拖拽的原理：鼠标按下并且移动， 之后松开鼠标</li><li>触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup</li><li>拖拽过程:  鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了</li><li>鼠标按下触发的事件源是最上面一行，就是  id 为 title </li><li>鼠标的坐标减去 鼠标在盒子内的坐标， 才是模态框真正的位置。</li><li>鼠标按下，我们要得到鼠标在盒子的坐标。</li><li>鼠标移动，就让模态框的坐标  设置为  ：鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。</li><li>鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 获取元素</span><br>       <span class="hljs-keyword">var</span> login = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.login&#x27;</span>);<br>       <span class="hljs-keyword">var</span> mask = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.login-bg&#x27;</span>);<br>       <span class="hljs-keyword">var</span> link = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#link&#x27;</span>);<br>       <span class="hljs-keyword">var</span> closeBtn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#closeBtn&#x27;</span>);<br>       <span class="hljs-keyword">var</span> title = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#title&#x27;</span>);<br>       <span class="hljs-comment">// 2. 点击弹出层这个链接 link  让mask 和login 显示出来</span><br>       link.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               mask.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>               login.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>           &#125;)<br>           <span class="hljs-comment">// 3. 点击 closeBtn 就隐藏 mask 和 login </span><br>       closeBtn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               mask.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>               login.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>           &#125;)<br>           <span class="hljs-comment">// 4. 开始拖拽</span><br>           <span class="hljs-comment">// (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标</span><br>       title.addEventListener(<span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>           <span class="hljs-keyword">var</span> x = e.pageX - login.offsetLeft;<br>           <span class="hljs-keyword">var</span> y = e.pageY - login.offsetTop;<br>           <span class="hljs-comment">// (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值</span><br>           <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, move)<br><br>           <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">e</span>) </span>&#123;<br>               login.style.left = e.pageX - x + <span class="hljs-string">&#x27;px&#x27;</span>;<br>               login.style.top = e.pageY - y + <span class="hljs-string">&#x27;px&#x27;</span>;<br>           &#125;<br>           <span class="hljs-comment">// (3) 鼠标弹起，就让鼠标移动事件移除</span><br>           <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, move);<br>           &#125;)<br>       &#125;)<br><br></code></pre></td></tr></table></figure><h3 id="1-1-6-案例：仿京东放大镜"><a href="#1-1-6-案例：仿京东放大镜" class="headerlink" title="1.1.6  案例：仿京东放大镜"></a>1.1.6  案例：仿京东放大镜</h3><ol><li>整个案例可以分为三个功能模块</li><li>鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能</li><li>黄色的遮挡层跟随鼠标功能。 </li><li>移动黄色遮挡层，大图片跟随移动功能。</li></ol><h3 id="1-1-7-案例分析"><a href="#1-1-7-案例分析" class="headerlink" title="1.1.7. 案例分析:"></a>1.1.7. 案例分析:</h3><ol><li>黄色的遮挡层跟随鼠标功能。</li><li>把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。</li><li>首先是获得鼠标在盒子的坐标。 </li><li>之后把数值给遮挡层做为left 和top值。</li><li>此时用到鼠标移动事件，但是还是在小图片盒子内移动。</li><li>发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。</li><li>遮挡层不能超出小图片盒子范围。</li><li>如果小于零，就把坐标设置为0</li><li>如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离</li><li>遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</li></ol><p><img src="/img/web/webapi22.jpg"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> preview_img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.preview_img&#x27;</span>);<br>    <span class="hljs-keyword">var</span> mask = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.mask&#x27;</span>);<br>    <span class="hljs-keyword">var</span> big = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.big&#x27;</span>);<br>    <span class="hljs-comment">// 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子</span><br>    preview_img.addEventListener(<span class="hljs-string">&#x27;mouseover&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        mask.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>        big.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>    &#125;)<br>    preview_img.addEventListener(<span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            mask.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>            big.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>        &#125;)<br>        <span class="hljs-comment">// 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走</span><br>    preview_img.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>        <span class="hljs-comment">// (1). 先计算出鼠标在盒子内的坐标</span><br>        <span class="hljs-keyword">var</span> x = e.pageX - <span class="hljs-built_in">this</span>.offsetLeft;<br>        <span class="hljs-keyword">var</span> y = e.pageY - <span class="hljs-built_in">this</span>.offsetTop;<br>        <span class="hljs-comment">// console.log(x, y);</span><br>        <span class="hljs-comment">// (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了</span><br>        <span class="hljs-comment">// (3) 我们mask 移动的距离</span><br>        <span class="hljs-keyword">var</span> maskX = x - mask.offsetWidth / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">var</span> maskY = y - mask.offsetHeight / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// (4) 如果x 坐标小于了0 就让他停在0 的位置</span><br>        <span class="hljs-comment">// 遮挡层的最大移动距离</span><br>        <span class="hljs-keyword">var</span> maskMax = preview_img.offsetWidth - mask.offsetWidth;<br>        <span class="hljs-keyword">if</span> (maskX &lt;= <span class="hljs-number">0</span>) &#123;<br>            maskX = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maskX &gt;= maskMax) &#123;<br>            maskX = maskMax;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maskY &lt;= <span class="hljs-number">0</span>) &#123;<br>            maskY = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maskY &gt;= maskMax) &#123;<br>            maskY = maskMax;<br>        &#125;<br>        mask.style.left = maskX + <span class="hljs-string">&#x27;px&#x27;</span>;<br>        mask.style.top = maskY + <span class="hljs-string">&#x27;px&#x27;</span>;<br>        <span class="hljs-comment">// 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离</span><br>        <span class="hljs-comment">// 大图</span><br>        <span class="hljs-keyword">var</span> bigIMg = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.bigImg&#x27;</span>);<br>        <span class="hljs-comment">// 大图片最大移动距离</span><br>        <span class="hljs-keyword">var</span> bigMax = bigIMg.offsetWidth - big.offsetWidth;<br>        <span class="hljs-comment">// 大图片的移动距离 X Y</span><br>        <span class="hljs-keyword">var</span> bigX = maskX * bigMax / maskMax;<br>        <span class="hljs-keyword">var</span> bigY = maskY * bigMax / maskMax;<br>        bigIMg.style.left = -bigX + <span class="hljs-string">&#x27;px&#x27;</span>;<br>        bigIMg.style.top = -bigY + <span class="hljs-string">&#x27;px&#x27;</span>;<br><br>    &#125;)<br><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="1-2-元素可视区-client-系列"><a href="#1-2-元素可视区-client-系列" class="headerlink" title="1.2. 元素可视区 client 系列"></a>1.2. 元素可视区 client 系列</h2><h3 id="1-2-1-client概述"><a href="#1-2-1-client概述" class="headerlink" title="1.2.1 client概述"></a>1.2.1 client概述</h3><p>client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client<br>系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><p><img src="/img/webimg/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><p><img src="/img/webimg/%E5%9B%BE%E7%89%874.png" alt="图片4"></p><h3 id="1-2-2-淘宝-flexible-js-源码分析"><a href="#1-2-2-淘宝-flexible-js-源码分析" class="headerlink" title="1.2.2. 淘宝 flexible.js 源码分析"></a>1.2.2. 淘宝 flexible.js 源码分析</h3><p>立即执行函数 (function(){})()  或者 (function(){}())</p><p>主要作用： 创建一个独立的作用域。 避免了命名冲突问题</p><p>下面三种情况都会刷新页面都会触发 load 事件。</p><p>1.a标签的超链接</p><p>2.F5或者刷新按钮（强制刷新）</p><p>3.前进后退按钮</p><p>但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。</p><p>所以此时后退按钮不能刷新页面。</p><p>此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件</p><p><code>注意这个事件给window添加。</code></p><h2 id="1-3-元素滚动-scroll-系列"><a href="#1-3-元素滚动-scroll-系列" class="headerlink" title="1.3.元素滚动 scroll 系列"></a>1.3.元素滚动 scroll 系列</h2><h3 id="1-3-1-scroll-概述"><a href="#1-3-1-scroll-概述" class="headerlink" title="1.3.1. scroll 概述"></a>1.3.1. scroll 概述</h3><p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p><p><img src="/img/webimg/%E5%9B%BE%E7%89%875.png" alt="图片5"></p><p><img src="/img/webimg/%E5%9B%BE%E7%89%876.png" alt="图片6"></p><h3 id="1-3-2-页面被卷去的头部"><a href="#1-3-2-页面被卷去的头部" class="headerlink" title="1.3.2. 页面被卷去的头部"></a>1.3.2. 页面被卷去的头部</h3><p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。</p><h3 id="1-3-3-案例：仿淘宝固定右侧侧边栏"><a href="#1-3-3-案例：仿淘宝固定右侧侧边栏" class="headerlink" title="1.3.3.案例：仿淘宝固定右侧侧边栏"></a>1.3.3.案例：仿淘宝固定右侧侧边栏</h3><ol><li>原先侧边栏是绝对定位</li><li>当页面滚动到一定位置，侧边栏改为固定定位</li><li>页面继续滚动，会让 返回顶部显示出来</li></ol><h3 id="1-3-4-案例分析"><a href="#1-3-4-案例分析" class="headerlink" title="1.3.4.案例分析:"></a>1.3.4.案例分析:</h3><ol><li>需要用到页面滚动事件 scroll  因为是页面滚动，所以事件源是document</li><li>滚动到某个位置，就是判断页面被卷去的上部值。</li><li>页面被卷去的头部：可以通过window.pageYOffset 获得  如果是被卷去的左侧window.pageXOffset</li><li>注意，元素被卷去的头部是element.scrollTop  , 如果是页面被卷去的头部 则是 window.pageYOffset</li><li>其实这个值 可以通过盒子的 offsetTop可以得到，如果大于等于这个值，就可以让盒子固定定位了</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 获取元素</span><br>      <span class="hljs-keyword">var</span> sliderbar = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.slider-bar&#x27;</span>);<br>      <span class="hljs-keyword">var</span> banner = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.banner&#x27;</span>);<br>      <span class="hljs-comment">// banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面</span><br>      <span class="hljs-keyword">var</span> bannerTop = banner.offsetTop<br>          <span class="hljs-comment">// 当我们侧边栏固定定位之后应该变化的数值</span><br>      <span class="hljs-keyword">var</span> sliderbarTop = sliderbar.offsetTop - bannerTop;<br>      <span class="hljs-comment">// 获取main 主体元素</span><br>      <span class="hljs-keyword">var</span> main = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.main&#x27;</span>);<br>      <span class="hljs-keyword">var</span> goBack = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.goBack&#x27;</span>);<br>      <span class="hljs-keyword">var</span> mainTop = main.offsetTop;<br>      <span class="hljs-comment">// 2. 页面滚动事件 scroll</span><br>      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-comment">// console.log(11);</span><br>          <span class="hljs-comment">// window.pageYOffset 页面被卷去的头部</span><br>          <span class="hljs-comment">// console.log(window.pageYOffset);</span><br>          <span class="hljs-comment">// 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.pageYOffset &gt;= bannerTop) &#123;<br>              sliderbar.style.position = <span class="hljs-string">&#x27;fixed&#x27;</span>;<br>              sliderbar.style.top = sliderbarTop + <span class="hljs-string">&#x27;px&#x27;</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              sliderbar.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span>;<br>              sliderbar.style.top = <span class="hljs-string">&#x27;300px&#x27;</span>;<br>          &#125;<br>          <span class="hljs-comment">// 4. 当我们页面滚动到main盒子，就显示 goback模块</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.pageYOffset &gt;= mainTop) &#123;<br>              goBack.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              goBack.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>          &#125;<br><br>      &#125;)<br></code></pre></td></tr></table></figure><h3 id="1-3-5-页面被卷去的头部兼容性解决方案"><a href="#1-3-5-页面被卷去的头部兼容性解决方案" class="headerlink" title="1.3.5.页面被卷去的头部兼容性解决方案"></a>1.3.5.页面被卷去的头部兼容性解决方案</h3><p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</p><ol><li>声明了 DTD，使用 document.documentElement.scrollTop</li><li>未声明 DTD，使用  document.body.scrollTop</li><li>新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScroll</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">left</span>: <span class="hljs-built_in">window</span>.pageXOffset || <span class="hljs-built_in">document</span>.documentElement.scrollLeft || <span class="hljs-built_in">document</span>.body.scrollLeft||<span class="hljs-number">0</span>,<br>      <span class="hljs-attr">top</span>: <span class="hljs-built_in">window</span>.pageYOffset || <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-number">0</span><br>    &#125;;<br> &#125; <br>使用的时候  getScroll().left<br><br></code></pre></td></tr></table></figure><h2 id="1-4-三大系列总结"><a href="#1-4-三大系列总结" class="headerlink" title="1.4. 三大系列总结"></a>1.4. 三大系列总结</h2><p><img src="/img/webimg/%E5%9B%BE%E7%89%877.png" alt="图片7"></p><p>他们主要用法：</p><p>1.offset系列 经常用于获得元素位置    offsetLeft  offsetTop</p><p>2.client经常用于获取元素大小  clientWidth clientHeight</p><p>3.scroll 经常用于获取滚动距离 scrollTop  scrollLeft  </p><p>4.注意页面滚动的距离通过 window.pageXOffset  获得</p><h2 id="1-5-mouseenter-和mouseover的区别"><a href="#1-5-mouseenter-和mouseover的区别" class="headerlink" title="1.5. mouseenter 和mouseover的区别"></a>1.5. mouseenter 和mouseover的区别</h2><ul><li>当鼠标移动到元素上时就会触发mouseenter 事件</li><li>类似 mouseover，它们两者之间的差别是</li><li>mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</li><li>之所以这样，就是因为mouseenter不会冒泡</li><li>跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</li></ul><h2 id="1-6-动画函数封装"><a href="#1-6-动画函数封装" class="headerlink" title="1.6. 动画函数封装"></a>1.6. 动画函数封装</h2><h3 id="1-6-1-动画实现原理"><a href="#1-6-1-动画实现原理" class="headerlink" title="1.6.1. 动画实现原理"></a>1.6.1. 动画实现原理</h3><blockquote><p>核心原理：通过定时器 setInterval() 不断移动盒子位置。</p></blockquote><p>实现步骤：</p><ol><li>获得盒子当前位置</li><li>让盒子在当前位置加上1个移动距离</li><li>利用定时器不断重复这个操作</li><li>加一个结束定时器的条件</li><li>注意此元素需要添加定位，才能使用element.style.left</li></ol><h3 id="1-6-2-动画函数给不同元素记录不同定时器"><a href="#1-6-2-动画函数给不同元素记录不同定时器" class="headerlink" title="1.6.2. 动画函数给不同元素记录不同定时器"></a>1.6.2. 动画函数给不同元素记录不同定时器</h3><p>如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。</p><blockquote><p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">obj, target</span>) </span>&#123;<br>           <span class="hljs-comment">// 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器</span><br>           <span class="hljs-comment">// 解决方案就是 让我们元素只有一个定时器执行</span><br>           <span class="hljs-comment">// 先清除以前的定时器，只保留当前的一个定时器执行</span><br>           <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>           obj.timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               <span class="hljs-keyword">if</span> (obj.offsetLeft &gt;= target) &#123;<br>                   <span class="hljs-comment">// 停止动画 本质是停止定时器</span><br>                   <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>               &#125;<br>               obj.style.left = obj.offsetLeft + <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;px&#x27;</span>;<br><br>           &#125;, <span class="hljs-number">30</span>);<br>       &#125;<br><br></code></pre></td></tr></table></figure><h1 id="day06-Web-APIs"><a href="#day06-Web-APIs" class="headerlink" title="day06 - Web APIs"></a><strong>day06 - Web APIs</strong></h1><blockquote><p><strong>学习目标:</strong></p><p>能够封装简单动画函数</p><p>能够理解缓动动画的封装</p><p>能够使用动画函数</p><p>能够写出网页轮播图案例</p><p>能够写出移动端触屏事件</p></blockquote><h2 id="1-1-动画函数封装"><a href="#1-1-动画函数封装" class="headerlink" title="**1.1. **动画函数封装"></a>**1.1. **动画函数封装</h2><h3 id="1-1-1-缓动效果原理"><a href="#1-1-1-缓动效果原理" class="headerlink" title="1.1.1 缓动效果原理"></a>1.1.1 缓动效果原理</h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p><p>思路：</p><ol><li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li><li>核心算法： (目标值 - 现在的位置)   /  10    做为每次移动的距离步长</li><li>停止的条件是： 让当前盒子位置等于目标位置就停止定时器  </li><li>注意步长值需要取整  </li></ol><h3 id="1-1-2-动画函数多个目标值之间移动"><a href="#1-1-2-动画函数多个目标值之间移动" class="headerlink" title="1.1.2 动画函数多个目标值之间移动"></a>1.1.2 动画函数多个目标值之间移动</h3><p>可以让动画函数从 800 移动到 500。</p><p>当我们点击按钮时候，判断步长是正值还是负值</p><p>​    1.如果是正值，则步长往大了取整</p><p>​    2.如果是负值，则步长 向小了取整</p><h3 id="1-1-3-动函数添加回调函数"><a href="#1-1-3-动函数添加回调函数" class="headerlink" title="1.1.3  动函数添加回调函数"></a>1.1.3  动函数添加回调函数</h3><p>回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。</p><p>回调函数写的位置：定时器结束的位置。</p><h3 id="1-1-4-动画完整版代码"><a href="#1-1-4-动画完整版代码" class="headerlink" title="1.1.4  动画完整版代码:"></a>1.1.4  动画完整版代码:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">obj, target, callback</span>) </span>&#123;<br>    <span class="hljs-comment">// console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()</span><br><br>    <span class="hljs-comment">// 先清除以前的定时器，只保留当前的一个定时器执行</span><br>    <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>    obj.timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 步长值写到定时器的里面</span><br>        <span class="hljs-comment">// 把我们步长值改为整数 不要出现小数的问题</span><br>        <span class="hljs-comment">// var step = Math.ceil((target - obj.offsetLeft) / 10);</span><br>        <span class="hljs-keyword">var</span> step = (target - obj.offsetLeft) / <span class="hljs-number">10</span>;<br>        step = step &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.ceil(step) : <span class="hljs-built_in">Math</span>.floor(step);<br>        <span class="hljs-keyword">if</span> (obj.offsetLeft == target) &#123;<br>            <span class="hljs-comment">// 停止动画 本质是停止定时器</span><br>            <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>            <span class="hljs-comment">// 回调函数写到定时器结束里面</span><br>            <span class="hljs-comment">// if (callback) &#123;</span><br>            <span class="hljs-comment">//     // 调用函数</span><br>            <span class="hljs-comment">//     callback();</span><br>            <span class="hljs-comment">// &#125;</span><br>            callback &amp;&amp; callback();<br>        &#125;<br>        <span class="hljs-comment">// 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10</span><br>        obj.style.left = obj.offsetLeft + step + <span class="hljs-string">&#x27;px&#x27;</span>;<br><br>    &#125;, <span class="hljs-number">15</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-常见网页特效案例"><a href="#1-2-常见网页特效案例" class="headerlink" title="1.2. 常见网页特效案例"></a>1.2. 常见网页特效案例</h2><h3 id="1-2-1-案例：网页轮播图"><a href="#1-2-1-案例：网页轮播图" class="headerlink" title="1.2.1 案例：网页轮播图"></a>1.2.1 案例：网页轮播图</h3><p>轮播图也称为焦点图，是网页中比较常见的网页特效。</p><p>功能需求：</p><p>​    1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。</p><p>​    2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。</p><p>​    3.图片播放的同时，下面小圆圈模块跟随一起变化。</p><p>​    4.点击小圆圈，可以播放相应图片。</p><p>​    5.鼠标不经过轮播图，轮播图也会自动播放图片。</p><p>​    6.鼠标经过，轮播图模块， 自动播放停止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 1. 获取元素</span><br>    <span class="hljs-keyword">var</span> arrow_l = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.arrow-l&#x27;</span>);<br>    <span class="hljs-keyword">var</span> arrow_r = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.arrow-r&#x27;</span>);<br>    <span class="hljs-keyword">var</span> focus = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.focus&#x27;</span>);<br>    <span class="hljs-keyword">var</span> focusWidth = focus.offsetWidth;<br>    <span class="hljs-comment">// 2. 鼠标经过focus 就显示隐藏左右按钮</span><br>    focus.addEventListener(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        arrow_l.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>        arrow_r.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>        <span class="hljs-built_in">clearInterval</span>(timer);<br>        timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除定时器变量</span><br>    &#125;);<br>    focus.addEventListener(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        arrow_l.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>        arrow_r.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>        timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">//手动调用点击事件</span><br>            arrow_r.click();<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;);<br>    <span class="hljs-comment">// 3. 动态生成小圆圈  有几张图片，我就生成几个小圆圈</span><br>    <span class="hljs-keyword">var</span> ul = focus.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);<br>    <span class="hljs-keyword">var</span> ol = focus.querySelector(<span class="hljs-string">&#x27;.circle&#x27;</span>);<br>    <span class="hljs-comment">// console.log(ul.children.length);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ul.children.length; i++) &#123;<br>        <span class="hljs-comment">// 创建一个小li </span><br>        <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);<br>        <span class="hljs-comment">// 记录当前小圆圈的索引号 通过自定义属性来做 </span><br>        li.setAttribute(<span class="hljs-string">&#x27;index&#x27;</span>, i);<br>        <span class="hljs-comment">// 把小li插入到ol 里面</span><br>        ol.appendChild(li);<br>        <span class="hljs-comment">// 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件</span><br>        li.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 干掉所有人 把所有的小li 清除 current 类名</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ol.children.length; i++) &#123;<br>                ol.children[i].className = <span class="hljs-string">&#x27;&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">// 留下我自己  当前的小li 设置current 类名</span><br>            <span class="hljs-built_in">this</span>.className = <span class="hljs-string">&#x27;current&#x27;</span>;<br>            <span class="hljs-comment">// 5. 点击小圆圈，移动图片 当然移动的是 ul </span><br>            <span class="hljs-comment">// ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值</span><br>            <span class="hljs-comment">// 当我们点击了某个小li 就拿到当前小li 的索引号</span><br>            <span class="hljs-keyword">var</span> index = <span class="hljs-built_in">this</span>.getAttribute(<span class="hljs-string">&#x27;index&#x27;</span>);<br>            <span class="hljs-comment">// 当我们点击了某个小li 就要把这个li 的索引号给 num  </span><br>            num = index;<br>            <span class="hljs-comment">// 当我们点击了某个小li 就要把这个li 的索引号给 circle  </span><br>            circle = index;<br>            <span class="hljs-comment">// num = circle = index;</span><br>            <span class="hljs-built_in">console</span>.log(focusWidth);<br>            <span class="hljs-built_in">console</span>.log(index);<br><br>            animate(ul, -index * focusWidth);<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 把ol里面的第一个小li设置类名为 current</span><br>    ol.children[<span class="hljs-number">0</span>].className = <span class="hljs-string">&#x27;current&#x27;</span>;<br>    <span class="hljs-comment">// 6. 克隆第一张图片(li)放到ul 最后面</span><br>    <span class="hljs-keyword">var</span> first = ul.children[<span class="hljs-number">0</span>].cloneNode(<span class="hljs-literal">true</span>);<br>    ul.appendChild(first);<br>    <span class="hljs-comment">// 7. 点击右侧按钮， 图片滚动一张</span><br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// circle 控制小圆圈的播放</span><br>    <span class="hljs-keyword">var</span> circle = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// flag 节流阀</span><br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;<br>    arrow_r.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 关闭节流阀</span><br>            <span class="hljs-comment">// 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0</span><br>            <span class="hljs-keyword">if</span> (num == ul.children.length - <span class="hljs-number">1</span>) &#123;<br>                ul.style.left = <span class="hljs-number">0</span>;<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>            num++;<br>            animate(ul, -num * focusWidth, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 打开节流阀</span><br>            &#125;);<br>            <span class="hljs-comment">// 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放</span><br>            circle++;<br>            <span class="hljs-comment">// 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原</span><br>            <span class="hljs-keyword">if</span> (circle == ol.children.length) &#123;<br>                circle = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// 调用函数</span><br>            circleChange();<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 9. 左侧按钮做法</span><br>    arrow_l.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>                num = ul.children.length - <span class="hljs-number">1</span>;<br>                ul.style.left = -num * focusWidth + <span class="hljs-string">&#x27;px&#x27;</span>;<br><br>            &#125;<br>            num--;<br>            animate(ul, -num * focusWidth, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;);<br>            <span class="hljs-comment">// 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放</span><br>            circle--;<br>            <span class="hljs-comment">// 如果circle &lt; 0  说明第一张图片，则小圆圈要改为第4个小圆圈（3）</span><br>            <span class="hljs-comment">// if (circle &lt; 0) &#123;</span><br>            <span class="hljs-comment">//     circle = ol.children.length - 1;</span><br>            <span class="hljs-comment">// &#125;</span><br>            circle = circle &lt; <span class="hljs-number">0</span> ? ol.children.length - <span class="hljs-number">1</span> : circle;<br>            <span class="hljs-comment">// 调用函数</span><br>            circleChange();<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">circleChange</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 先清除其余小圆圈的current类名</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ol.children.length; i++) &#123;<br>            ol.children[i].className = <span class="hljs-string">&#x27;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 留下当前的小圆圈的current类名</span><br>        ol.children[circle].className = <span class="hljs-string">&#x27;current&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 10. 自动播放轮播图</span><br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">//手动调用点击事件</span><br>        arrow_r.click();<br>    &#125;, <span class="hljs-number">2000</span>);<br><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="1-2-2-节流阀"><a href="#1-2-2-节流阀" class="headerlink" title="1.2.2. 节流阀"></a>1.2.2. 节流阀</h3><p>防止轮播图按钮连续点击造成播放过快。</p><p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p><p> 开始设置一个变量var flag= true;</p><p>If(flag){flag = false; do something}       关闭水龙头</p><p>利用回调函数动画执行完毕， flag = true     打开水龙头</p><h3 id="1-2-3-案例：返回顶部"><a href="#1-2-3-案例：返回顶部" class="headerlink" title="1.2.3. 案例：返回顶部"></a>1.2.3. 案例：返回顶部</h3><ol><li>带有动画的返回顶部</li><li>此时可以继续使用我们封装的动画函数</li><li>只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了</li><li>页面滚动了多少，可以通过 window.pageYOffset 得到</li><li>最后是页面滚动，使用 window.scroll(x,y) </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 获取元素</span><br>      <span class="hljs-keyword">var</span> sliderbar = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.slider-bar&#x27;</span>);<br>      <span class="hljs-keyword">var</span> banner = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.banner&#x27;</span>);<br>      <span class="hljs-comment">// banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面</span><br>      <span class="hljs-keyword">var</span> bannerTop = banner.offsetTop<br>          <span class="hljs-comment">// 当我们侧边栏固定定位之后应该变化的数值</span><br>      <span class="hljs-keyword">var</span> sliderbarTop = sliderbar.offsetTop - bannerTop;<br>      <span class="hljs-comment">// 获取main 主体元素</span><br>      <span class="hljs-keyword">var</span> main = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.main&#x27;</span>);<br>      <span class="hljs-keyword">var</span> goBack = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.goBack&#x27;</span>);<br>      <span class="hljs-keyword">var</span> mainTop = main.offsetTop;<br>      <span class="hljs-comment">// 2. 页面滚动事件 scroll</span><br>      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-comment">// console.log(11);</span><br>              <span class="hljs-comment">// window.pageYOffset 页面被卷去的头部</span><br>              <span class="hljs-comment">// console.log(window.pageYOffset);</span><br>              <span class="hljs-comment">// 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位</span><br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.pageYOffset &gt;= bannerTop) &#123;<br>                  sliderbar.style.position = <span class="hljs-string">&#x27;fixed&#x27;</span>;<br>                  sliderbar.style.top = sliderbarTop + <span class="hljs-string">&#x27;px&#x27;</span>;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  sliderbar.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span>;<br>                  sliderbar.style.top = <span class="hljs-string">&#x27;300px&#x27;</span>;<br>              &#125;<br>              <span class="hljs-comment">// 4. 当我们页面滚动到main盒子，就显示 goback模块</span><br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.pageYOffset &gt;= mainTop) &#123;<br>                  goBack.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  goBack.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>              &#125;<br><br>          &#125;)<br>          <span class="hljs-comment">// 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方</span><br>      goBack.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-comment">// 里面的x和y 不跟单位的 直接写数字即可</span><br>          <span class="hljs-comment">// window.scroll(0, 0);</span><br>          <span class="hljs-comment">// 因为是窗口滚动 所以对象是window</span><br>          animate(<span class="hljs-built_in">window</span>, <span class="hljs-number">0</span>);<br>      &#125;);<br><br></code></pre></td></tr></table></figure><h3 id="1-2-4-案例：筋头云案例"><a href="#1-2-4-案例：筋头云案例" class="headerlink" title="1.2.4. 案例：筋头云案例"></a>1.2.4. 案例：筋头云案例</h3><ol><li>利用动画函数做动画效果</li><li>原先筋斗云的起始位置是0</li><li>鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可</li><li>鼠标离开某个小li，就把目标值设为 0</li><li>如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-comment">// 1. 获取元素</span><br>           <span class="hljs-keyword">var</span> cloud = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.cloud&#x27;</span>);<br>           <span class="hljs-keyword">var</span> c_nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.c-nav&#x27;</span>);<br>           <span class="hljs-keyword">var</span> lis = c_nav.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);<br>           <span class="hljs-comment">// 2. 给所有的小li绑定事件 </span><br>           <span class="hljs-comment">// 这个current 做为筋斗云的起始位置</span><br>           <span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br>               <span class="hljs-comment">// (1) 鼠标经过把当前小li 的位置做为目标值</span><br>               lis[i].addEventListener(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                   animate(cloud, <span class="hljs-built_in">this</span>.offsetLeft);<br>               &#125;);<br>               <span class="hljs-comment">// (2) 鼠标离开就回到起始的位置 </span><br>               lis[i].addEventListener(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                   animate(cloud, current);<br>               &#125;);<br>               <span class="hljs-comment">// (3) 当我们鼠标点击，就把当前位置做为目标值</span><br>               lis[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                   current = <span class="hljs-built_in">this</span>.offsetLeft;<br>               &#125;);<br>           &#125;<br>       &#125;)<br><br></code></pre></td></tr></table></figure><h2 id="1-3-触屏事件"><a href="#1-3-触屏事件" class="headerlink" title="1.3. 触屏事件"></a>1.3. 触屏事件</h2><h3 id="1-3-1-触屏事件概述"><a href="#1-3-1-触屏事件概述" class="headerlink" title="1.3.1. 触屏事件概述"></a>1.3.1. 触屏事件概述</h3><p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。</p><p>touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。</p><p>常见的触屏事件如下：</p><p><img src="/img/webimg/webapi0001.png"></p><h3 id="1-3-2-触摸事件对象（TouchEvent）"><a href="#1-3-2-触摸事件对象（TouchEvent）" class="headerlink" title="1.3.2. 触摸事件对象（TouchEvent）"></a>1.3.2. 触摸事件对象（TouchEvent）</h3><p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p><p>touchstart、touchmove、touchend 三个事件都会各自有事件对象。</p><p>触摸事件对象重点我们看三个常见对象列表：</p><p><img src="/img/webimg/webapi0002.png" alt="图片2"></p><blockquote><p><code>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</code></p></blockquote><h3 id="1-3-3-案例：移动端拖动元素"><a href="#1-3-3-案例：移动端拖动元素" class="headerlink" title="1.3.3.案例：移动端拖动元素"></a>1.3.3.案例：移动端拖动元素</h3><ol><li><p>touchstart、touchmove、touchend可以实现拖动元素</p></li><li><p>但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY </p></li><li><p>移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</p></li><li><p>手指移动的距离：  手指滑动中的位置 减去  手指刚开始触摸的位置</p><p>拖动元素三步曲：</p><p>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置</p><p>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子</p><p>（3） 离开手指 touchend:</p><p><code>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</code></p></li></ol><h1 id="day07-Web-APIs"><a href="#day07-Web-APIs" class="headerlink" title="day07 - Web APIs"></a><strong>day07 - Web APIs</strong></h1><blockquote><p><strong>学习目标:</strong></p><p>能够写出移动端触屏事件<br>能够写出常见的移动端特效<br>能够使用移动端开发插件开发移动端特效<br>能够使用移动端开发框架开发移动端特效<br>能够写出 sessionStorage 数据的存储以及获取<br>能够写出 localStorage 数据的存储以及获取<br>能够说出它们两者的区别</p></blockquote><h2 id="1-1-触屏事件"><a href="#1-1-触屏事件" class="headerlink" title="1.1. 触屏事件"></a><strong>1.1. 触屏事件</strong></h2><h3 id="1-1-1-触屏事件概述"><a href="#1-1-1-触屏事件概述" class="headerlink" title="1.1.1 触屏事件概述"></a>1.1.1 触屏事件概述</h3><p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。</p><p>常见的触屏事件如下：</p><p><img src="/img/webimg/%E5%9B%BE%E7%89%871-1623199168400.png" alt="图片1"></p><h3 id="1-1-2-触摸事件对象（TouchEvent）"><a href="#1-1-2-触摸事件对象（TouchEvent）" class="headerlink" title="1.1.2 触摸事件对象（TouchEvent）"></a>1.1.2 触摸事件对象（TouchEvent）</h3><p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p><p>touchstart、touchmove、touchend 三个事件都会各自有事件对象。</p><p>触摸事件对象重点我们看三个常见对象列表：</p><p><img src="/img/webimg/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><blockquote><p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p></blockquote><h3 id="1-1-3-移动端拖动元素"><a href="#1-1-3-移动端拖动元素" class="headerlink" title="1.1.3  移动端拖动元素"></a>1.1.3  移动端拖动元素</h3><ol><li> touchstart、touchmove、touchend 可以实现拖动元素</li><li> 但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY </li><li> 移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</li><li> 手指移动的距离：  手指滑动中的位置 减去  手指刚开始触摸的位置</li></ol><p>拖动元素三步曲：</p><p>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置</p><p>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子</p><p>（3） 离开手指 touchend:</p><blockquote><p><strong>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</strong></p></blockquote><h2 id="1-2-移动端常见特效"><a href="#1-2-移动端常见特效" class="headerlink" title="1.2. 移动端常见特效"></a>1.2. 移动端常见特效</h2><h3 id="1-2-1-案例-移动轮播图"><a href="#1-2-1-案例-移动轮播图" class="headerlink" title="1.2.1 案例: 移动轮播图"></a>1.2.1 案例: 移动轮播图</h3><p><code>移动端轮播图功能和基本PC端一致。</code></p><ol><li>可以自动播放图片</li><li>手指可以拖动播放轮播图</li></ol><h3 id="1-2-2-案例分析"><a href="#1-2-2-案例分析" class="headerlink" title="1.2.2. 案例分析:"></a>1.2.2. 案例分析:</h3><ol><li>自动播放功能</li><li>开启定时器</li><li>移动端移动，可以使用translate 移动</li><li>想要图片优雅的移动，请添加过渡效果<img src="/img/webimg/1551795152(1).jpg" alt="1551795152"></li></ol><ol><li><p>自动播放功能-无缝滚动</p></li><li><p>注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断</p></li><li><p>此时需要添加检测过渡完成事件  transitionend </p></li><li><p>判断条件：如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0</p></li><li><p>此时图片，去掉过渡效果，然后移动</p></li><li><p>如果索引号小于0， 说明是倒着走， 索引号等于2 </p></li><li><p>此时图片，去掉过渡效果，然后移动</p><p><img src="/img/webimg/1551795483(1).jpg" alt="1551795483"></p></li></ol><h2 id="1-2-3-classList-属性"><a href="#1-2-3-classList-属性" class="headerlink" title="1.2.3 classList 属性"></a>1.2.3 classList 属性</h2><p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p><p>该属性用于在元素中添加，移除及切换 CSS 类。有以下方法</p><p><strong>添加类：</strong></p><p>element.classList.add（’类名’）；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">focus.classList.add(<span class="hljs-string">&#x27;current&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>移除类：</strong></p><p>element.classList.remove（’类名’）;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">focus.classList.remove(<span class="hljs-string">&#x27;current&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>切换类：</strong></p><p>element.classList.toggle（’类名’）;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">focus.classList.toggle(<span class="hljs-string">&#x27;current&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>注意:以上方法里面，所有类名都不带点</code></p><h3 id="1-2-4-案例分析"><a href="#1-2-4-案例分析" class="headerlink" title="1.2.4. 案例分析"></a>1.2.4. 案例分析</h3><ol><li><p>小圆点跟随变化效果</p></li><li><p>把ol里面li带有current类名的选出来去掉类名 remove</p></li><li><p>让当前索引号的小li 加上 current   add</p></li><li><p>但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面</p><p><img src="/img/webimg/1551796072(1).jpg" alt="1551796072"></p></li></ol><ol><li>手指滑动轮播图</li><li>本质就是ul跟随手指移动，简单说就是移动端拖动元素</li><li>触摸元素touchstart：  获取手指初始坐标</li><li>移动手指touchmove：  计算手指的滑动距离，并且移动盒子</li><li>离开手指touchend:   根据滑动的距离分不同的情况</li><li>如果移动距离小于某个像素  就回弹原来位置</li><li>如果移动距离大于某个像素就上一张下一张滑动。</li><li>滑动也分为左滑动和右滑动判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑 </li><li>如果是左滑就播放下一张 （index++）</li><li>如果是右滑就播放上一张  (index–)</li></ol><p><img src="/img/webimg/1551796363(1).jpg"></p><p><img src="/img/webimg/1551796502(1).jpg"></p><h3 id="1-3-1-案例：返回顶部"><a href="#1-3-1-案例：返回顶部" class="headerlink" title="1.3.1. 案例：返回顶部"></a>1.3.1. 案例：返回顶部</h3><p>当页面滚动某个地方，就显示，否则隐藏</p><p>点击可以返回顶部</p><h3 id="1-3-2-案例分析"><a href="#1-3-2-案例分析" class="headerlink" title="1.3.2.案例分析"></a>1.3.2.案例分析</h3><ol><li>滚动某个地方显示</li><li>事件：scroll页面滚动事件  </li><li>如果被卷去的头部（window.pageYOffset ）大于某个数值</li><li>点击，window.scroll(0,0) 返回顶部</li></ol><p><img src="/img/webimg/1551797003(1).jpg"></p><h2 id="1-4-click-延时解决方案"><a href="#1-4-click-延时解决方案" class="headerlink" title="1.4. click 延时解决方案"></a>1.4. click 延时解决方案</h2><p>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。</p><p>解决方案：</p><p>​    1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​    2.利用touch事件自己封装这个事件解决300ms 延迟。 </p><p>​    原理就是：</p><ol><li> 当我们手指触摸屏幕，记录当前触摸时间</li><li> 当我们手指离开屏幕， 用离开的时间减去触摸的时间</li><li> 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击</li></ol><p>代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//封装tap，解决click 300ms 延时</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tap</span> (<span class="hljs-params">obj, callback</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> isMove = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">var</span> startTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录触摸时候的时间变量</span><br>        obj.addEventListener(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>            startTime = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// 记录触摸时间</span><br>        &#125;);<br>        obj.addEventListener(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>            isMove = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 看看是否有滑动，有滑动算拖拽，不算点击</span><br>        &#125;);<br>        obj.addEventListener(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (!isMove &amp;&amp; (<span class="hljs-built_in">Date</span>.now() - startTime) &lt; <span class="hljs-number">150</span>) &#123;  <span class="hljs-comment">// 如果手指触摸和离开时间小于150ms 算点击</span><br>                callback &amp;&amp; callback(); <span class="hljs-comment">// 执行回调函数</span><br>            &#125;<br>            isMove = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//  取反 重置</span><br>            startTime = <span class="hljs-number">0</span>;<br>        &#125;);<br>&#125;<br><span class="hljs-comment">//调用  </span><br>  tap(div, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-comment">// 执行代码  &#125;);</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li><p>使用插件。fastclick 插件解决300ms 延迟。 </p><p><img src="/img/webimg/1551797533(1).jpg"></p></li></ol><h2 id="1-5-移动端常用开发插件"><a href="#1-5-移动端常用开发插件" class="headerlink" title="1.5. 移动端常用开发插件"></a>1.5. 移动端常用开发插件</h2><h3 id="1-5-1-什么是插件"><a href="#1-5-1-什么是插件" class="headerlink" title="1.5.1. 什么是插件"></a>1.5.1. 什么是插件</h3><p>移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？</p><p>JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。</p><p>特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p><p>我们以前写的animate.js 也算一个最简单的插件</p><p>fastclick 插件解决 300ms 延迟。 使用延时</p><p>GitHub官网地址： <a href="https://github.com/ftlabs/fastclick">https://</a><a href="https://github.com/ftlabs/fastclick">github.com/ftlabs/fastclick</a></p><h3 id="1-5-2-插件的使用"><a href="#1-5-2-插件的使用" class="headerlink" title="1.5.2. 插件的使用"></a>1.5.2. 插件的使用</h3><ol><li><p>引入 js 插件文件。</p></li><li><p>按照规定语法使用。</p></li><li><p>fastclick 插件解决 300ms 延迟。 使用延时</p></li><li><p>GitHub官网地址： <a href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;addEventListener&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>) &#123;<br>            <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                       FastClick.attach(<span class="hljs-built_in">document</span>.body);<br>            &#125;, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-3-Swiper-插件的使用"><a href="#1-5-3-Swiper-插件的使用" class="headerlink" title="1.5.3. Swiper 插件的使用"></a>1.5.3. Swiper 插件的使用</h3><p>中文官网地址： <a href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a> </p><ol><li> 引入插件相关文件。</li><li> 按照规定语法使用</li></ol><h3 id="1-5-4-其他移动端常见插件"><a href="#1-5-4-其他移动端常见插件" class="headerlink" title="1.5.4. 其他移动端常见插件"></a>1.5.4. 其他移动端常见插件</h3><p>lsuperslide： <a href="http://www.superslide2.com/">http://www.superslide2.com/</a></p><p>l iscroll： <a href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></p><h3 id="1-5-5-插件的使用总结"><a href="#1-5-5-插件的使用总结" class="headerlink" title="1.5.5. 插件的使用总结"></a>1.5.5. 插件的使用总结</h3><p>1.确认插件实现的功能</p><p>2.去官网查看使用说明</p><p>3.下载插件</p><p>4.打开demo实例文件，查看需要引入的相关文件，并且引入</p><p>5.复制demo实例文件中的结构html，样式css以及js代码</p><h3 id="1-5-6-移动端视频插件-zy-media-js"><a href="#1-5-6-移动端视频插件-zy-media-js" class="headerlink" title="1.5.6. 移动端视频插件 zy.media.js"></a>1.5.6. 移动端视频插件 zy.media.js</h3><p>H5 给我们提供了 video 标签，但是浏览器的支持情况不同。</p><p>不同的视频格式文件，我们可以通过source解决。</p><p>但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。</p><p>这个时候我们可以使用插件方式来制作。</p><p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p><h2 id="1-6-移动端常用开发框架"><a href="#1-6-移动端常用开发框架" class="headerlink" title="1.6. 移动端常用开发框架"></a>1.6. 移动端常用开发框架</h2><h3 id="1-6-1-移动端视频插件-zy-media-js"><a href="#1-6-1-移动端视频插件-zy-media-js" class="headerlink" title="1.6.1. 移动端视频插件 zy.media.js"></a>1.6.1. 移动端视频插件 zy.media.js</h3><p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。</p><p>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p><p>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端</p><p>前端常用的移动端插件有 swiper、superslide、iscroll等。</p><p>框架： 大而全，一整套解决方案</p><p>插件： 小而专一，某个功能的解决方案</p><h3 id="1-6-2-Bootstrap"><a href="#1-6-2-Bootstrap" class="headerlink" title="1.6.2. Bootstrap"></a>1.6.2. Bootstrap</h3><p>Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。</p><p>它能开发PC端，也能开发移动端 </p><p>Bootstrap JS插件使用步骤：</p><p>1.引入相关js 文件</p><p>2.复制HTML 结构</p><p>3.修改对应样式</p><p>4.修改相应JS 参数</p><h2 id="1-7-本地存储"><a href="#1-7-本地存储" class="headerlink" title="1.7. 本地存储"></a>1.7. 本地存储</h2><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。</p><h3 id="1-7-1-本地存储特性"><a href="#1-7-1-本地存储特性" class="headerlink" title="1.7.1.本地存储特性"></a>1.7.1.本地存储特性</h3><p>1、数据存储在用户浏览器中</p><p>2、设置、读取方便、甚至页面刷新不丢失数据</p><p>3、容量较大，sessionStorage约5M、localStorage约20M</p><p>4、只能存储字符串，可以将对象JSON.stringify() 编码后存储</p><h3 id="1-7-2-window-sessionStorage"><a href="#1-7-2-window-sessionStorage" class="headerlink" title="1.7.2.window.sessionStorage"></a>1.7.2.window.sessionStorage</h3><p>1、生命周期为关闭浏览器窗口</p><p>2、在同一个窗口(页面)下数据可以共享</p><p>3、以键值对的形式存储使用</p><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sessionStorage.setItem(key, value)<br></code></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sessionStorage.getItem(key)<br></code></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sessionStorage.removeItem(key)<br></code></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sessionStorage.clear()<br></code></pre></td></tr></table></figure><h3 id="1-7-3-window-localStorage"><a href="#1-7-3-window-localStorage" class="headerlink" title="1.7.3.window.localStorage"></a>1.7.3.window.localStorage</h3><p>1、声明周期永久生效，除非手动删除 否则关闭页面也会存在</p><p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p><p>3.  以键值对的形式存储使用</p><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">localStorage</span>.setItem(key, value)<br></code></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">localStorage</span>.getItem(key)<br></code></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">localStorage</span>.removeItem(key)<br></code></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">localStorage</span>.clear()<br></code></pre></td></tr></table></figure><h3 id="1-7-4-案例：记住用户名"><a href="#1-7-4-案例：记住用户名" class="headerlink" title="1.7.4.案例：记住用户名"></a>1.7.4.案例：记住用户名</h3><p>如果勾选记住用户名， 下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名</p><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ol><li><p>把数据存起来，用到本地存储</p></li><li><p>关闭页面，也可以显示用户名，所以用到localStorage</p></li><li><p>打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框</p></li><li><p>当复选框发生改变的时候change事件</p></li><li><p>如果勾选，就存储，否则就移除</p><p><img src="/img/webimg/1551800263(1).jpg"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习05-Flex伸缩布局</title>
    <link href="/2017/12/25/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A005-Flex%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80/"/>
    <url>/2017/12/25/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A005-Flex%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="移动web开发流式布局"><a href="#移动web开发流式布局" class="headerlink" title="移动web开发流式布局"></a>移动web开发流式布局</h1><h3 id="1-0-移动端基础"><a href="#1-0-移动端基础" class="headerlink" title="1.0 移动端基础"></a>1.0 移动端基础</h3><h4 id="1-1浏览器现状"><a href="#1-1浏览器现状" class="headerlink" title="1.1浏览器现状"></a>1.1浏览器现状</h4><p> PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器。</p><p>移动端常见浏览器：UC浏览器，QQ浏览器，欧朋浏览器，百度手机浏览器，360安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，以及其他杂牌浏览器。</p><p>国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。</p><p><strong>总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。</strong></p><h4 id="1-2-手机屏幕的现状"><a href="#1-2-手机屏幕的现状" class="headerlink" title="1.2 手机屏幕的现状"></a>1.2 手机屏幕的现状</h4><ul><li>移动端设备屏幕尺寸非常多，碎片化严重。</li><li>Android设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920等，还有传说中的2K，4k屏。</li><li>近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208等。</li><li>作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。</li></ul><h4 id="1-4移动端调试方法"><a href="#1-4移动端调试方法" class="headerlink" title="1.4移动端调试方法"></a>1.4移动端调试方法</h4><ul><li>Chrome DevTools（谷歌浏览器）的模拟手机调试</li><li>搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器</li><li>使用外网服务器，直接IP或域名访问</li></ul><h3 id="2-0-视口"><a href="#2-0-视口" class="headerlink" title="2.0 视口"></a>2.0 视口</h3><p>视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口</p><h4 id="2-1-布局视口-layout-viewport"><a href="#2-1-布局视口-layout-viewport" class="headerlink" title="2.1 布局视口 layout viewport"></a>2.1 布局视口 layout viewport</h4><p>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。</p><p>iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</p><p><img src="/img/web/flex01.jpg"></p><p>####2.2视觉视口 visual viewport</p><p>字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。</p><p>我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。</p><p><img src="/img/web/flex02.jpg"></p><p>2.3理想视口 ideal viewport</p><p>为了使网站在移动端有最理想的浏览和阅读宽度而设定</p><p>理想视口，对设备来讲，是最理想的视口尺寸</p><p>需要手动添写meta视口标签通知浏览器操作</p><p>meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽</p><p><strong>总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口</strong></p><h4 id="2-4meta标签"><a href="#2-4meta标签" class="headerlink" title="2.4meta标签"></a>2.4meta标签</h4><p><img src="/img/web/flex03.jpg"></p><p>最标准的viewport设置</p><ul><li>视口宽度和设备保持一致</li><li>视口的默认缩放比例1.0</li><li>不允许用户自行缩放</li><li>最大允许的缩放比例1.0</li><li>最小允许的缩放比例1.0</li></ul><h3 id="3-0二倍图"><a href="#3-0二倍图" class="headerlink" title="3.0二倍图"></a>3.0二倍图</h3><p>####3.1物理像素&amp;物理像素比</p><p>物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6 是  750* 1334</p><p>我们开发时候的1px 不是一定等于1个物理像素的</p><p>一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比</p><p>如果把1张100*100的图片放到手机里面会按照物理像素比给我们缩放</p><p>lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p><p>对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊</p><p>在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题</p><p>通常使用二倍图， 因为iPhone 6 的影响背景图片 注意缩放问题</p><h4 id="3-2背景缩放background-size"><a href="#3-2背景缩放background-size" class="headerlink" title="3.2背景缩放background-size"></a>3.2背景缩放background-size</h4><p>background-size 属性规定背景图像的尺寸</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">background-size: 背景图片宽度 背景图片高度;<br></code></pre></td></tr></table></figure><p>单位： 长度|百分比|cover|contain;</p><p>cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</p><p>contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</p><h3 id="4-0-移动开发选择和技术解决方案"><a href="#4-0-移动开发选择和技术解决方案" class="headerlink" title="4.0 移动开发选择和技术解决方案"></a>4.0 移动开发选择和技术解决方案</h3><p>####4.1移动端主流方案</p><p>1.单独制作移动端页面（主流）</p><p>通常情况下，网址域名前面加 m(mobile)<br>可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。  </p><p>也就是说，PC端和移动端为两套网站，pc端是pc断的样式，移动端在写一套，专门针对移动端适配的一套网站</p><p>京东pc端,京东移动端就是两套页面</p><p>2.响应式页面兼容移动端（其次）</p><p>苹果页面</p><p>响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配</p><h4 id="4-2-移动端技术解决方案"><a href="#4-2-移动端技术解决方案" class="headerlink" title="4.2 移动端技术解决方案"></a>4.2 移动端技术解决方案</h4><p>1.移动端浏览器兼容问题</p><p>移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。</p><p>我们可以放心使用 H5 标签和 CSS3 样式。</p><p>同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可</p><p>2.移动端公共样式</p><p>移动端 CSS 初始化推荐使用 normalize.css/</p><p>Normalize.css：保护了有价值的默认值</p><p>Normalize.css：修复了浏览器的bug</p><p>Normalize.css：是模块化的</p><p>Normalize.css：拥有详细的文档</p><p>官网地址： <a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p><h4 id="4-3-移动端大量使用-CSS3盒子模型box-sizin"><a href="#4-3-移动端大量使用-CSS3盒子模型box-sizin" class="headerlink" title="4.3 移动端大量使用 CSS3盒子模型box-sizin"></a>4.3 移动端大量使用 CSS3盒子模型box-sizin</h4><p>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding </p><p>CSS3盒子模型：     盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding </p><p>也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/*CSS3盒子模型*/</span><br><span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>;<br><span class="hljs-comment">/*传统盒子模型*/</span><br><span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>;<br><br></code></pre></td></tr></table></figure><p>移动端可以全部CSS3 盒子模型</p><p>PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</p><h4 id="4-4移动端特殊样式"><a href="#4-4移动端特殊样式" class="headerlink" title="4.4移动端特殊样式"></a>4.4移动端特殊样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*CSS3盒子模型*/</span><br><span class="hljs-attribute">box-sizing</span>: border-box;<br>-webkit-<span class="hljs-attribute">box-sizing</span>: border-box;<br><span class="hljs-comment">/*点击高亮我们需要清除清除  设置为transparent 完成透明*/</span><br>-webkit-tap-highlight-<span class="hljs-attribute">color</span>: transparent;<br><span class="hljs-comment">/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/</span><br>-webkit-appearance: none;<br><span class="hljs-comment">/*禁用长按页面时的弹出菜单*/</span><br><span class="hljs-selector-tag">img</span>,<span class="hljs-selector-tag">a</span> &#123; -webkit-touch-callout: none; &#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-0移动端常见布局"><a href="#5-0移动端常见布局" class="headerlink" title="5.0移动端常见布局"></a>5.0移动端常见布局</h3><p>移动端单独制作</p><ul><li>流式布局（百分比布局）</li><li>flex 弹性布局（强烈推荐）</li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul><p>响应式</p><ul><li>媒体查询</li><li>bootstarp</li></ul><p>流式布局：</p><p>流式布局，就是百分比布局，也称非固定像素布局。</p><p>通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。</p><p>流式布局方式是移动web开发使用的比较常见的布局方式。</p><h1 id="移动web开发——flex布局"><a href="#移动web开发——flex布局" class="headerlink" title="移动web开发——flex布局"></a>移动web开发——flex布局</h1><h2 id="1-0传统布局和flex布局对比"><a href="#1-0传统布局和flex布局对比" class="headerlink" title="1.0传统布局和flex布局对比"></a>1.0传统布局和flex布局对比</h2><h3 id="1-1传统布局"><a href="#1-1传统布局" class="headerlink" title="1.1传统布局"></a>1.1传统布局</h3><ul><li>兼容性好</li><li>布局繁琐</li><li>局限性，不能再移动端很好的布局</li></ul><h3 id="1-2-flex布局"><a href="#1-2-flex布局" class="headerlink" title="1.2 flex布局"></a>1.2 flex布局</h3><ul><li>操作方便，布局极其简单，移动端使用比较广泛</li><li>pc端浏览器支持情况比较差</li><li>IE11或更低版本不支持flex或仅支持部分</li></ul><h3 id="1-3-建议"><a href="#1-3-建议" class="headerlink" title="1.3 建议"></a>1.3 建议</h3><ul><li> 如果是pc端页面布局，还是采用传统方式</li><li> 如果是移动端或者是不考虑兼容的pc则采用flex</li></ul><h2 id="2-0-flex布局原理"><a href="#2-0-flex布局原理" class="headerlink" title="2.0 flex布局原理"></a>2.0 flex布局原理</h2><ul><li>flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</li><li>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</li><li>flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局 </li><li>采用 Flex 布局的元素，称为 Flex 容器（flex</li></ul><p>container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex<br>item），简称”项目”。</p><p><strong>总结</strong>：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</p><h2 id="3-0-父项常见属性"><a href="#3-0-父项常见属性" class="headerlink" title="3.0 父项常见属性"></a>3.0 父项常见属性</h2><ul><li>flex-direction：设置主轴的方向</li><li>justify-content：设置主轴上的子元素排列方式</li><li>flex-wrap：设置子元素是否换行  </li><li>align-content：设置侧轴上的子元素的排列方式（多行）</li><li>align-items：设置侧轴上的子元素排列方式（单行）</li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h3 id="3-1-flex-direction设置主轴的方向"><a href="#3-1-flex-direction设置主轴的方向" class="headerlink" title="3.1 flex-direction设置主轴的方向"></a>3.1 flex-direction设置主轴的方向</h3><ul><li>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴</li><li>默认主轴方向就是 x 轴方向，水平向右</li><li>默认侧轴方向就是 y 轴方向，水平向下</li></ul><p><img src="/img/web/flex04.jpg"></p><ul><li><p>注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</p><p><img src="/img/web/flex05.jpg"></p></li></ul><h3 id="3-2-justify-content-设置主轴上的子元素排列方式"><a href="#3-2-justify-content-设置主轴上的子元素排列方式" class="headerlink" title="3.2 justify-content 设置主轴上的子元素排列方式"></a>3.2 justify-content 设置主轴上的子元素排列方式</h3><p><img src="/img/web/flex06.jpg"></p><h3 id="3-3-flex-wrap设置是否换行"><a href="#3-3-flex-wrap设置是否换行" class="headerlink" title="3.3 flex-wrap设置是否换行"></a>3.3 flex-wrap设置是否换行</h3><ul><li>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。</li><li>nowrap 不换行</li><li>wrap 换行</li></ul><h3 id="3-4-align-items-设置侧轴上的子元素排列方式（单行-）"><a href="#3-4-align-items-设置侧轴上的子元素排列方式（单行-）" class="headerlink" title="3.4 align-items 设置侧轴上的子元素排列方式（单行 ）"></a>3.4 align-items 设置侧轴上的子元素排列方式（单行 ）</h3><ul><li>该属性是控制子项在侧轴（默认是y轴）上的排列方式  在子项为单项（单行）的时候使用</li><li>flex-start 从头部开始</li><li>flex-end 从尾部开始</li><li>center 居中显示</li><li>stretch 拉伸</li></ul><h3 id="3-5-align-content-设置侧轴上的子元素的排列方式（多行）"><a href="#3-5-align-content-设置侧轴上的子元素的排列方式（多行）" class="headerlink" title="3.5 align-content  设置侧轴上的子元素的排列方式（多行）"></a>3.5 align-content  设置侧轴上的子元素的排列方式（多行）</h3><p>设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。</p><p><img src="/img/web/flex07.jpg"></p><h3 id="3-6-align-content-和align-items区别"><a href="#3-6-align-content-和align-items区别" class="headerlink" title="3.6 align-content 和align-items区别"></a>3.6 align-content 和align-items区别</h3><ul><li>align-items  适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸</li><li>align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 </li><li>总结就是单行找align-items  多行找 align-content</li></ul><h3 id="3-7-flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性"><a href="#3-7-flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性" class="headerlink" title="3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性"></a>3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-flow</span>:row wrap;<br></code></pre></td></tr></table></figure><h2 id="4-0-flex布局子项常见属性"><a href="#4-0-flex布局子项常见属性" class="headerlink" title="4.0 flex布局子项常见属性"></a>4.0 flex布局子项常见属性</h2><ul><li>flex子项目占的份数</li><li>align-self控制子项自己在侧轴的排列方式</li><li>order属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="4-1-flex-属性"><a href="#4-1-flex-属性" class="headerlink" title="4.1  flex 属性"></a>4.1  flex 属性</h3><p>flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">.<span class="hljs-class">item </span>&#123;<br><span class="hljs-symbol">    flex:</span> <span class="hljs-params">&lt;number&gt;</span>; <span class="hljs-comment">/* 默认值 0 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-2-align-self控制子项自己在侧轴上的排列方式"><a href="#4-2-align-self控制子项自己在侧轴上的排列方式" class="headerlink" title="4.2 align-self控制子项自己在侧轴上的排列方式"></a>4.2 align-self控制子项自己在侧轴上的排列方式</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。</p><p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-comment">/* 设置自己在侧轴上的排列方式 */</span><br>      <span class="hljs-attribute">align-self</span>: flex-end;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-3-order-属性定义项目的排列顺序"><a href="#4-3-order-属性定义项目的排列顺序" class="headerlink" title="4.3 order 属性定义项目的排列顺序"></a>4.3 order 属性定义项目的排列顺序</h3><p>数值越小，排列越靠前，默认为0。</p><p>注意：和 z-index 不一样。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">.<span class="hljs-class">item </span>&#123;<br><span class="hljs-symbol">    order:</span> <span class="hljs-params">&lt;number&gt;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-0-携程网首页案例制作"><a href="#5-0-携程网首页案例制作" class="headerlink" title="5.0 携程网首页案例制作"></a>5.0 携程网首页案例制作</h2><p>携程网链接：<a href="http://m.ctrip.com/">http://m.ctrip.com</a></p><p>1.技术选型</p><p>方案：我们采取单独制作移动页面方案</p><p>技术：布局采取flex布局</p><p>2.搭建相关文件夹</p><p><img src="/img/web/flex08.jpg"></p><p>3.设置视口标签以及引入初始化样式</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;<br><br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;css/normalize.css&quot;</span>&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;css/index.css&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>4.常用初始化样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">540px</span>;<br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">320px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">font</span>: normal <span class="hljs-number">14px</span>/<span class="hljs-number">1.5</span> Tahoma,<span class="hljs-string">&quot;Lucida Grande&quot;</span>,Verdana,<span class="hljs-string">&quot;Microsoft Yahei&quot;</span>,STXihei,hei;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f2f2f2</span>;<br>  <span class="hljs-attribute">overflow-x</span>: hidden;<br>  -webkit-tap-highlight-<span class="hljs-attribute">color</span>: transparent;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>5.模块名字划分</p><p><img src="/img/web/flex09.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习04-HTML5&amp;CSS3</title>
    <link href="/2017/12/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A004-HTML5&amp;CSS3/"/>
    <url>/2017/12/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A004-HTML5&amp;CSS3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="vscode推荐安装的插件"><a href="#vscode推荐安装的插件" class="headerlink" title="vscode推荐安装的插件"></a>vscode推荐安装的插件</h4><table><thead><tr><th>插件</th><th align="left">作用</th></tr></thead><tbody><tr><td>Chinese   (Simplified) Language Pack for VS Code</td><td align="left">中文（简体）语言包</td></tr><tr><td>Open   in Browser</td><td align="left">右击选择浏览器打开html文件</td></tr><tr><td>JS-CSS-HTML   Formatter</td><td align="left">每次保存，都会自动格式化js  css 和html 代码</td></tr><tr><td>Auto   Rename Tag</td><td align="left">自动重命名配对的HTML / XML标签</td></tr><tr><td>CSS   Peek</td><td align="left">追踪至样式</td></tr></tbody></table><p>注意：插件安装需要联网。</p><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h6 id="一、什么是-HTML5"><a href="#一、什么是-HTML5" class="headerlink" title="一、什么是 HTML5"></a>一、什么是 <code>HTML5</code></h6><ol><li><p><code>HTML5</code> 的概念与定义 </p><ul><li>定义：<code>HTML5</code> 定义了 <code>HTML</code> 标准的最新版本，是对 <code>HTML</code> 的第五次重大修改，号称下一代的 <code>HTML</code> </li><li>两个概念：<ul><li>是一个新版本的 <code>HTML</code> 语言，定义了新的标签、特性和属性</li><li>拥有一个强大的技术集，这些技术集是指： <code>HTML5</code> 、<code>CSS3</code> 、<code>javascript</code>, 这也是广义上的 <code>HTML5</code></li></ul></li></ul></li><li><p><code>HTML5</code> 拓展了哪些内容</p><ul><li>语义化标签</li><li>本地存储</li><li>兼容特性</li><li><code>2D</code>、<code>3D</code> </li><li>动画、过渡</li><li><code>CSS3</code> 特性</li><li>性能与集成</li></ul></li><li><p><code>HTML5 </code> 的现状</p><p>  绝对多数新的属性，都已经被浏览器所支持，最新版本的浏览器已经开始陆续支持最新的特性，</p><p>  总的来说：<code>HTML5</code> 已经是大势所趋</p></li></ol><h6 id="二、HTML5-新增标签"><a href="#二、HTML5-新增标签" class="headerlink" title="二、HTML5  新增标签"></a>二、<code>HTML5 </code> 新增标签</h6><ol><li><p>什么是语义化</p></li><li><p>新增了那些语义化标签</p><ul><li><code>header</code>   —  头部标签</li><li><code>nav</code>        —  导航标签</li><li><code>article</code> —   内容标签</li><li><code>section</code> —   块级标签</li><li><code>aside</code>     —   侧边栏标签</li><li><code>footer</code>   —   尾部标签</li></ul><p><img src="/img/web/h5c301.jpg"></p></li><li><p>使用语义化标签的注意</p><ul><li>语义化标签主要针对搜索引擎</li><li>新标签可以使用一次或者多次</li><li>在 <code>IE9</code> 浏览器中，需要把语义化标签都转换为块级元素</li><li>语义化标签，在移动端支持比较友好，</li><li>另外，<code>HTML5</code> 新增的了很多的语义化标签，随着课程深入，还会学习到其他的</li></ul></li></ol><h6 id="三、多媒体音频标签"><a href="#三、多媒体音频标签" class="headerlink" title="三、多媒体音频标签"></a>三、多媒体音频标签</h6><ol><li><p>多媒体标签有两个，分别是</p><ul><li>音频  – <code>audio</code></li><li>视频  – <code>video</code></li></ul></li><li><p><code>audio</code> 标签说明</p><ul><li>可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</li><li>但是：播放格式是有限的</li></ul></li><li><p>audio 支持的音频格式</p><ul><li>audio 目前支持三种格式</li></ul><p><img src="/img/web/h5c302.jpg"></p></li><li><p>audio 的参数</p><p><img src="/img/web/h5c316.jpg"></p></li></ol><p>5、audio 代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">body</span>&gt;<br>  &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt;<br>  &lt;!-- &lt;<span class="hljs-selector-tag">audio</span> <span class="hljs-attribute">src</span>=&quot;./media/snow<span class="hljs-selector-class">.mp3</span>&quot; controls autoplay&gt;&lt;/<span class="hljs-selector-tag">audio</span>&gt; --&gt;<br><br>  &lt;!-- <br>    因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件<br>   --&gt;<br>  &lt;<span class="hljs-selector-tag">audio</span> controls&gt;<br>    &lt;source <span class="hljs-attribute">src</span>=&quot;./media/snow<span class="hljs-selector-class">.mp3</span>&quot; type=&quot;<span class="hljs-selector-tag">audio</span>/mpeg&quot; /&gt;<br>  &lt;/<span class="hljs-selector-tag">audio</span>&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br></code></pre></td></tr></table></figure><h6 id="四、多媒体视频标签"><a href="#四、多媒体视频标签" class="headerlink" title="四、多媒体视频标签"></a>四、多媒体视频标签</h6><ol><li><p>video 视频标签</p><ul><li>目前支持三种格式</li></ul><p><img src="/img/web/h5c302.jpg"></p></li><li><p>语法格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./media/video.mp4&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>video 参数</p><p><img src="/img/web/h5c303.jpg"></p></li><li><p>video 代码演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">muted</span> <span class="hljs-attr">loop</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&quot;./media/pig.jpg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./media/video.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./media/video.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>多媒体标签总结</p><ul><li>音频标签与视频标签使用基本一致</li><li>多媒体标签在不同浏览器下情况不同，存在兼容性问题</li><li>谷歌浏览器把音频和视频标签的自动播放都禁止了</li><li>谷歌浏览器中视频添加 muted 标签可以自己播放</li><li>注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</li></ul></li></ol><h6 id="五、新增-input-标签"><a href="#五、新增-input-标签" class="headerlink" title="五、新增 input 标签"></a>五、新增 input 标签</h6><p><img src="/img/web/h5c305.jpg"></p><h6 id="六、新增表单属性"><a href="#六、新增表单属性" class="headerlink" title="六、新增表单属性"></a>六、新增表单属性</h6><p><img src="/img/web/h5c306.jpg"></p><h6 id="七、CSS3-属性选择器-上"><a href="#七、CSS3-属性选择器-上" class="headerlink" title="七、CSS3  属性选择器(上)"></a>七、<code>CSS3 </code> 属性选择器(上)</h6><ol><li><p>什么是 <code>CSS3</code></p><ul><li>在 <code>CSS2</code> 的基础上拓展、新增的样式</li></ul></li><li><p><code>CSS3</code> 发展现状</p><ul><li>移动端支持优于 <code>PC</code> 端</li><li><code>CSS3</code> 目前还草案，在不断改进中</li><li><code>CSS3</code> 相对 <code>H5</code>，应用非常广泛</li></ul></li><li><p>属性选择器列表</p><p><img src="/img/web/h5c306.jpg"></p></li></ol><ol start="4"><li><p>属性选择器代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">cursor</span>: pointer;<br>&#125;<br><span class="hljs-selector-tag">button</span><span class="hljs-selector-attr">[disabled]</span> &#123;<br>  <span class="hljs-attribute">cursor</span>: default<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="八、CSS3-属性选择器-下"><a href="#八、CSS3-属性选择器-下" class="headerlink" title="八、CSS3  属性选择器(下)"></a>八、<code>CSS3 </code> 属性选择器(下)</h6><ol><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=search]</span> &#123;<br>  <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br><br><span class="hljs-selector-tag">span</span><span class="hljs-selector-attr">[class^=black]</span> &#123;<br>  <span class="hljs-attribute">color</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-tag">span</span><span class="hljs-selector-attr">[class$=black]</span> &#123;<br>  <span class="hljs-attribute">color</span>: lightsalmon;<br>&#125;<br><br><span class="hljs-selector-tag">span</span><span class="hljs-selector-attr">[class*=black]</span> &#123;<br>  <span class="hljs-attribute">color</span>: lightseagreen;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="九、结构伪类选择器"><a href="#九、结构伪类选择器" class="headerlink" title="九、结构伪类选择器"></a>九、结构伪类选择器</h6><ol><li><p>属性列表</p><ol><li> <img src="/img/web/h5c307.jpg"></li></ol></li></ol><ol start="2"><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">background-color</span>: lightseagreen;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: lightcoral;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">background-color</span>: aqua;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="十、nth-child-参数详解"><a href="#十、nth-child-参数详解" class="headerlink" title="十、nth-child 参数详解"></a>十、<code>nth-child</code> 参数详解</h6><ol><li><p>nth-child 详解</p><ul><li><p>注意：本质上就是选中第几个子元素</p></li><li><p>n 可以是数字、关键字、公式</p></li><li><p>n 如果是数字，就是选中第几个</p></li><li><p>常见的关键字有 <code>even</code> 偶数、<code>odd</code> 奇数</p></li><li><p>常见的公式如下(如果 n 是公式，则从 0 开始计算)</p></li><li><p>但是第 0 个元素或者超出了元素的个数会被忽略</p><p><img src="/img/web/h5c308.jpg"></p></li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-comment">/* 偶数 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(even) &#123;<br>    <span class="hljs-attribute">background-color</span>: aquamarine;<br>  &#125;<br><br>  <span class="hljs-comment">/* 奇数 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(odd) &#123;<br>    <span class="hljs-attribute">background-color</span>: blueviolet;<br>  &#125;<br><br>  <span class="hljs-comment">/*n 是公式，从 0 开始计算 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(n) &#123;<br>    <span class="hljs-attribute">background-color</span>: lightcoral;<br>  &#125;<br><br>  <span class="hljs-comment">/* 偶数 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>n) &#123;<br>    <span class="hljs-attribute">background-color</span>: lightskyblue;<br>  &#125;<br><br>  <span class="hljs-comment">/* 奇数 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>n + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: lightsalmon;<br>  &#125;<br><br>  <span class="hljs-comment">/* 选择第 0 5 10 15, 应该怎么选 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">5</span>n) &#123;<br>    <span class="hljs-attribute">background-color</span>: orangered;<br>  &#125;<br><br>  <span class="hljs-comment">/* n + 5 就是从第5个开始往后选择 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(n + <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: peru;<br>  &#125;<br><br>  <span class="hljs-comment">/* -n + 5 前五个 */</span><br>  <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(-n + <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: tan;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li></ol><h6 id="十一、nth-child-和-nt-of-type-的区别"><a href="#十一、nth-child-和-nt-of-type-的区别" class="headerlink" title="十一、nth-child 和  nt-of-type 的区别"></a>十一、<code>nth-child</code> 和  <code>nt-of-type</code> 的区别</h6><ol><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: lightblue;<br>  &#125;<br><br>  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: lightpink;<br>  &#125;<br><br>  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: lightseagreen;<br>  &#125;<br><br>  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>区别</p><ul><li><code>nth-child</code>  选择父元素里面的第几个子元素，不管是第几个类型</li><li><code>nt-of-type</code>  选择指定类型的元素</li></ul></li></ol><h6 id="十二、伪元素选择器"><a href="#十二、伪元素选择器" class="headerlink" title="十二、伪元素选择器"></a>十二、伪元素选择器</h6><ol><li><p>伪类选择器</p><p><img src="/img/web/h5c308.jpg"></p></li><li><p>伪类选择器注意事项</p><ul><li><code>before</code> 和 <code>after</code> 必须有 <code>content</code> 属性</li><li><code>before</code> 在内容前面，after 在内容后面</li><li><code>before</code> 和 <code>after</code> 创建的是一个元素，但是属于行内元素</li><li>创建出来的元素在 <code>Dom</code> 中查找不到，所以称为伪元素</li><li>伪元素和标签选择器一样，权重为 1</li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-tag">div</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid lightcoral;<br>    &#125;<br><br>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::after</span>,<br>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>      <span class="hljs-attribute">text-align</span>: center;<br>      <span class="hljs-attribute">display</span>: inline-block;<br>    &#125;<br>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>      <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;德&#x27;</span>;<br>      <span class="hljs-attribute">background-color</span>: lightskyblue;<br>    &#125;<br><br>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>      <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;道&#x27;</span>;<br>      <span class="hljs-attribute">background-color</span>: mediumaquamarine;<br>    &#125;<br>  &lt;/style&gt;<br></code></pre></td></tr></table></figure></li></ol><h6 id="十三、伪元素的案例"><a href="#十三、伪元素的案例" class="headerlink" title="十三、伪元素的案例"></a>十三、伪元素的案例</h6><ol><li><p>添加字体图标</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">220px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">22px</span>;<br>   <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid lightseagreen;<br>   <span class="hljs-attribute">margin</span>: <span class="hljs-number">60px</span>;<br>   <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;\ea50&#x27;</span>;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;icomoon&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">1px</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="十四、2D-转换之-translate"><a href="#十四、2D-转换之-translate" class="headerlink" title="十四、2D 转换之 translate"></a>十四、<code>2D</code> 转换之 <code>translate</code></h6><ol><li><p><code>2D</code> 转换</p><ul><li><p><code>2D</code> 转换是改变标签在二维平面上的位置和形状</p></li><li><p>移动： <code>translate</code></p></li><li><p>旋转： <code>rotate</code></p></li><li><p>缩放： <code>scale</code></p></li></ul></li><li><p><code>translate</code> 语法</p><ul><li>x 就是 x 轴上水平移动</li><li>y 就是 y 轴上水平移动</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(x, y)<br>transform: <span class="hljs-built_in">translateX</span>(n)<br>transfrom: <span class="hljs-built_in">translateY</span>(n)<br></code></pre></td></tr></table></figure></li><li><p>重点知识点</p><ul><li><code>2D</code> 的移动主要是指 水平、垂直方向上的移动</li><li><code>translate</code> 最大的优点就是不影响其他元素的位置</li><li><code>translate</code> 中的100%单位，是相对于本身的宽度和高度来进行计算的</li><li>行内标签没有效果</li></ul></li><li><p>代码演示</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: lightseagreen;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-comment">/* 平移 */</span><br>  <span class="hljs-comment">/* 水平垂直移动 100px */</span><br>  <span class="hljs-comment">/* transform: translate(100px, 100px); */</span><br><br>  <span class="hljs-comment">/* 水平移动 100px */</span><br>  <span class="hljs-comment">/* transform: translate(100px, 0) */</span><br><br>  <span class="hljs-comment">/* 垂直移动 100px */</span><br>  <span class="hljs-comment">/* transform: translate(0, 100px) */</span><br><br>  <span class="hljs-comment">/* 水平移动 100px */</span><br>  <span class="hljs-comment">/* transform: translateX(100px); */</span><br><br>  <span class="hljs-comment">/* 垂直移动 100px */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">100px</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="十五、让一个盒子水平垂直居中"><a href="#十五、让一个盒子水平垂直居中" class="headerlink" title="十五、让一个盒子水平垂直居中"></a>十五、让一个盒子水平垂直居中</h6><ul><li>看代码</li></ul><h6 id="十六、2D-转换-rotate"><a href="#十六、2D-转换-rotate" class="headerlink" title="十六、2D 转换 rotate"></a>十六、<code>2D 转换 rotate</code></h6><ol><li><p>rotate 旋转</p><ul><li><code>2D</code> 旋转指的是让元素在二维平面内顺时针或者逆时针旋转</li></ul></li><li><p><code>rotate</code> 语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 单位是：deg */</span><br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(度数) <br></code></pre></td></tr></table></figure></li><li><p>重点知识点</p><ul><li><code>rotate</code> 里面跟度数，单位是 <code>deg</code></li><li>角度为正时，顺时针，角度为负时，逆时针</li><li>默认旋转的中心点是元素的中心点</li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><h6 id="一、rotate"><a href="#一、rotate" class="headerlink" title="一、rotate"></a>一、rotate</h6><blockquote><p>2d旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转</p></blockquote><p>使用步骤：</p><ol><li>给元素添加转换属性 <code>transform</code></li><li>属性值为 <code>rotate(角度)</code>  如 <code>transform:rotate(30deg)</code>  顺时针方向旋转<strong>30度</strong></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="二、三角"><a href="#二、三角" class="headerlink" title="二、三角"></a>二、三角</h6><ul><li>代码演示</li></ul><h6 id="二、设置元素旋转中心点-transform-origin"><a href="#二、设置元素旋转中心点-transform-origin" class="headerlink" title="二、设置元素旋转中心点(transform-origin)"></a>二、设置元素旋转中心点(transform-origin)</h6><ol><li><p><code>transform-origin</code> 基础语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform-origin</span>: x y;<br></code></pre></td></tr></table></figure></li><li><p>重要知识点</p><ul><li>注意后面的参数 x 和 y 用空格隔开</li><li>x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 <code>center</code>  <code>center</code></li><li>还可以给 x y 设置像素或者方位名词(<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>center</code>)</li></ul></li></ol><h6 id="三、旋转中心案例"><a href="#三、旋转中心案例" class="headerlink" title="三、旋转中心案例"></a>三、旋转中心案例</h6><ul><li>代码演示</li></ul><h6 id="四、2D-转换之-scale"><a href="#四、2D-转换之-scale" class="headerlink" title="四、2D 转换之 scale"></a>四、<code>2D</code> 转换之 <code>scale</code></h6><ol><li><p><code>scale</code> 的作用</p><ul><li>用来控制元素的放大与缩小</li></ul></li><li><p>语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(x, y)<br></code></pre></td></tr></table></figure></li><li><p>知识要点</p><ul><li>注意，x 与 y 之间使用逗号进行分隔</li><li><code>transform: scale(1, 1)</code>: 宽高都放大一倍，相当于没有放大</li><li><code>transform: scale(2, 2)</code>: 宽和高都放大了二倍</li><li><code>transform: scale(2)</code>: 如果只写了一个参数，第二个参数就和第一个参数一致</li><li><code>transform:scale(0.5, 0.5)</code>: 缩小</li><li><code>scale</code> 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br> <span class="hljs-comment">/* 注意，数字是倍数的含义，所以不需要加单位 */</span><br> <span class="hljs-comment">/* transform: scale(2, 2) */</span><br><br> <span class="hljs-comment">/* 实现等比缩放，同时修改宽与高 */</span><br> <span class="hljs-comment">/* transform: scale(2) */</span><br><br> <span class="hljs-comment">/* 小于 1 就等于缩放*/</span><br> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="五、图片放大案例"><a href="#五、图片放大案例" class="headerlink" title="五、图片放大案例"></a>五、图片放大案例</h6><ul><li>代码演示</li></ul><h6 id="六、分页按钮案例"><a href="#六、分页按钮案例" class="headerlink" title="六、分页按钮案例"></a>六、分页按钮案例</h6><ul><li>代码演示</li></ul><h6 id="七、-2D-转换综合写法以及顺序问题"><a href="#七、-2D-转换综合写法以及顺序问题" class="headerlink" title="七、 2D 转换综合写法以及顺序问题"></a>七、 <code>2D</code> 转换综合写法以及顺序问题</h6><ol><li><p>知识要点</p><ul><li>同时使用多个转换，其格式为 <code>transform: translate() rotate() scale()</code></li><li>顺序会影响到转换的效果(先旋转会改变坐标轴方向)</li><li>但我们同时有位置或者其他属性的时候，要将位移放到最前面</li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">0</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.2</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="八、-动画-animation"><a href="#八、-动画-animation" class="headerlink" title="八、 动画(animation)"></a>八、 动画(animation)</h6><ol><li><p>什么是动画</p><ul><li>动画是 <code>CSS3</code> 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果</li></ul></li><li><p>动画的基本使用</p><ul><li>先定义动画</li><li>在调用定义好的动画</li></ul></li><li><p>语法格式(定义动画)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> 动画名称 &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    &#125;<br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>语法格式(使用动画)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-comment">/* 调用动画 */</span><br>    <span class="hljs-attribute">animation-name</span>: 动画名称;<br> <span class="hljs-comment">/* 持续时间 */</span><br> <span class="hljs-attribute">animation-duration</span>: 持续时间；<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>动画序列</p><ul><li>0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列</li><li>在 @keyframs 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果</li><li>动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</li><li>用百分比来规定变化发生的时间，或用 <code>from</code> 和 <code>to</code>，等同于 0% 和 100%</li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-tag">div</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>      <span class="hljs-attribute">background-color</span>: aquamarine;<br>      <span class="hljs-attribute">animation-name</span>: move;<br>      <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">0.5s</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">@keyframes</span> move&#123;<br>      <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0px</span>)<br>      &#125;<br>      <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">500px</span>, <span class="hljs-number">0</span>)<br>      &#125;<br>    &#125;<br>  &lt;/style&gt;<br></code></pre></td></tr></table></figure></li></ol><h6 id="九、动画序列"><a href="#九、动画序列" class="headerlink" title="九、动画序列"></a>九、动画序列</h6><ul><li>代码演示</li></ul><h6 id="十、动画常见属性"><a href="#十、动画常见属性" class="headerlink" title="十、动画常见属性"></a>十、动画常见属性</h6><ol><li><p>常见的属性</p><p><img src="/img/web/h5c310.jpg"></p></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: aquamarine;<br>  <span class="hljs-comment">/* 动画名称 */</span><br>  <span class="hljs-attribute">animation-name</span>: move;<br>  <span class="hljs-comment">/* 动画花费时长 */</span><br>  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">2s</span>;<br>  <span class="hljs-comment">/* 动画速度曲线 */</span><br>  <span class="hljs-attribute">animation-timing-function</span>: ease-in-out;<br>  <span class="hljs-comment">/* 动画等待多长时间执行 */</span><br>  <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">2s</span>;<br>  <span class="hljs-comment">/* 规定动画播放次数 infinite: 无限循环 */</span><br>  <span class="hljs-attribute">animation-iteration-count</span>: infinite;<br>  <span class="hljs-comment">/* 是否逆行播放 */</span><br>  <span class="hljs-attribute">animation-direction</span>: alternate;<br>  <span class="hljs-comment">/* 动画结束之后的状态 */</span><br>  <span class="hljs-attribute">animation-fill-mode</span>: forwards;<br>&#125;<br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-comment">/* 规定动画是否暂停或者播放 */</span><br>  <span class="hljs-attribute">animation-play-state</span>: paused;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="十一、-动画简写方式"><a href="#十一、-动画简写方式" class="headerlink" title="十一、 动画简写方式"></a>十一、 动画简写方式</h6><ol><li><p>动画简写方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */</span><br><span class="hljs-attribute">animation</span>: name duration timing-function delay iteration-count direction fill-mode<br></code></pre></td></tr></table></figure></li><li><p>知识要点</p><ul><li>简写属性里面不包含 <code>animation-paly-state</code></li><li>暂停动画 <code>animation-paly-state: paused</code>; 经常和鼠标经过等其他配合使用</li><li>要想动画走回来，而不是直接调回来：<code>animation-direction: alternate</code></li><li>盒子动画结束后，停在结束位置：<code>animation-fill-mode: forwards</code> </li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation</span>: move <span class="hljs-number">2s</span> linear <span class="hljs-number">1s</span> infinite alternate forwards;<br></code></pre></td></tr></table></figure></li></ol><h6 id="十二、速度曲线细节"><a href="#十二、速度曲线细节" class="headerlink" title="十二、速度曲线细节"></a>十二、速度曲线细节</h6><ol><li>速度曲线细节<ul><li><code>animation-timing-function</code>: 规定动画的速度曲线，默认是<code>ease</code></li></ul></li></ol><p><img src="/img/web/h5c311.jpg"></p><ol start="2"><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background-color</span>: aquamarine;<br>  <span class="hljs-attribute">animation</span>: move <span class="hljs-number">4s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">24</span>) forwards;<br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> move &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  &#125;<br><br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">480px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="十三、奔跑的熊大"><a href="#十三、奔跑的熊大" class="headerlink" title="十三、奔跑的熊大"></a>十三、奔跑的熊大</h6><ol><li> 代码演示</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;</span><br><span class="css">        &#125;      </span><br><span class="css">        <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">media/bear.png</span>) no-repeat;</span><br><span class="css">            <span class="hljs-comment">/* 我们元素可以添加多个动画， 用逗号分隔 */</span></span><br><span class="css">            <span class="hljs-attribute">animation</span>: bear .<span class="hljs-number">4s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">8</span>) infinite, move <span class="hljs-number">3s</span> forwards;</span><br><span class="css">        &#125;</span><br><span class="css">        </span><br><span class="css">        <span class="hljs-keyword">@keyframes</span> bear &#123;</span><br><span class="css">            <span class="hljs-number">0%</span> &#123;</span><br><span class="css">                <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css">            &#125;</span><br><span class="css">            <span class="hljs-number">100%</span> &#123;</span><br><span class="css">                <span class="hljs-attribute">background-position</span>: -<span class="hljs-number">1600px</span> <span class="hljs-number">0</span>;</span><br><span class="css">            &#125;</span><br><span class="css">        &#125;</span><br><span class="css">        </span><br><span class="css">        <span class="hljs-keyword">@keyframes</span> move &#123;</span><br><span class="css">            <span class="hljs-number">0%</span> &#123;</span><br><span class="css">                <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="css">            &#125;</span><br><span class="css">            <span class="hljs-number">100%</span> &#123;</span><br><span class="css">                <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">                <span class="hljs-comment">/* margin-left: -100px; */</span></span><br><span class="css">                <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);</span><br><span class="css">            &#125;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Translate3d"><a href="#Translate3d" class="headerlink" title="Translate3d"></a>Translate3d</h3><h6 id="一、-认识-3D-转换"><a href="#一、-认识-3D-转换" class="headerlink" title="一、 认识 3D 转换"></a>一、 认识 <code>3D</code> 转换</h6><ol><li><p><code>3D</code> 的特点</p><ul><li>近大远小</li><li>物体和面遮挡不可见</li></ul></li><li><p>三维坐标系</p><ul><li><p>x 轴：水平向右  – <strong>注意：x 轴右边是正值，左边是负值</strong></p></li><li><p>y 轴：垂直向下  – <strong>注意：y 轴下面是正值，上面是负值</strong></p></li><li><p>z 轴：垂直屏幕  –  <strong>注意：往外边的是正值，往里面的是负值</strong></p><p><img src="/img/web/h5c312.jpg"></p></li></ul></li></ol><p>​          </p><h6 id="二、3D-转换"><a href="#二、3D-转换" class="headerlink" title="二、3D 转换"></a>二、<code>3D</code> 转换</h6><ol><li><p><code>3D</code> 转换知识要点</p><ul><li><code>3D</code> 位移：<code>translate3d(x, y, z)</code></li><li><code>3D</code> 旋转：<code>rotate3d(x, y, z)</code></li><li>透视：<code>perspctive</code></li><li><code>3D</code>呈现 <code>transfrom-style</code></li></ul></li><li><p><code>3D</code> 移动 <code>translate3d</code></p><ul><li><code>3D</code> 移动就是在 <code>2D</code> 移动的基础上多加了一个可以移动的方向，就是 z 轴方向</li><li><code>transform: translateX(100px)</code>：仅仅是在 x 轴上移动</li><li><code>transform: translateY(100px)</code>：仅仅是在 y 轴上移动</li><li><code>transform: translateZ(100px)</code>：仅仅是在 z 轴上移动</li><li><code>transform: translate3d(x, y, z)</code>：其中x、y、z 分别指要移动的轴的方向的距离</li><li><strong>注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充</strong></li></ul></li><li><p>语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(x, y, z)<br></code></pre></td></tr></table></figure></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>)<br>/* 注意：x, y, z 对应的值不能省略，不需要填写用 <span class="hljs-number">0</span> 进行填充 */<br>transform: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li></ol><h6 id="三、透视-perspective"><a href="#三、透视-perspective" class="headerlink" title="三、透视 perspective"></a>三、透视 <code>perspective</code></h6><ol><li><p>知识点讲解</p><ul><li>如果想要网页产生 <code>3D</code> 效果需要透视(理解成 <code>3D</code> 物体投影的 <code>2D</code> 平面上)</li><li>实际上模仿人类的视觉位置，可视为安排一直眼睛去看</li><li>透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</li><li>距离视觉点越近的在电脑平面成像越大，越远成像越小</li><li>透视的单位是像素</li></ul></li><li><p>知识要点</p><ul><li><p><strong>透视需要写在被视察元素的父盒子上面</strong></p></li><li><p>注意下方图片</p><ul><li><p>d：就是视距，视距就是指人的眼睛到屏幕的距离</p></li><li><p>z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大</p><p><img src="/img/web/h5c313.jpg"></p></li></ul></li></ul><p>​            </p></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h6 id="四、-translateZ"><a href="#四、-translateZ" class="headerlink" title="四、 translateZ"></a>四、 <code>translateZ</code></h6><ol><li><code>translateZ</code> 与 <code>perspecitve</code> 的区别<ul><li><code>perspecitve</code> 给父级进行设置，<code>translateZ</code> 给 子元素进行设置不同的大小</li></ul></li></ol><h6 id="五、3D-旋转rotateX"><a href="#五、3D-旋转rotateX" class="headerlink" title="五、3D 旋转rotateX"></a>五、<code>3D</code> 旋转<code>rotateX</code></h6><blockquote><p>3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转</p></blockquote><ol><li><p>语法</p><ul><li><code>transform: rotateX(45deg)</code> – 沿着 x 轴正方向旋转 45 度</li><li><code>transform: rotateY(45deg)</code> – 沿着 y 轴正方向旋转 45 度</li><li><code>transform: rotateZ(45deg)</code> – 沿着 z 轴正方向旋转 45 度</li><li><code>transform: rotate3d(x, y, z, 45deg)</code> – 沿着自定义轴旋转 45 deg 为角度</li></ul></li><li><p>代码案例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(-<span class="hljs-number">45deg</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>左手准则</p><ul><li><p>左手的手拇指指向 x 轴的正方向</p></li><li><p>其余手指的弯曲方向就是该元素沿着 x 轴旋转的方向</p><p><img src="/img/web/h5c314.jpg"></p></li></ul></li></ol><p>​              </p><h6 id="六、3D-旋转-rotateY"><a href="#六、3D-旋转-rotateY" class="headerlink" title="六、3D 旋转 rotateY"></a>六、<code>3D</code> 旋转 <code>rotateY</code></h6><ol><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">500px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>左手准则</p><ul><li><p>左手的拇指指向 y 轴的正方向</p></li><li><p>其余的手指弯曲方向就是该元素沿着 y 轴旋转的方向(正值)</p><p><img src="/img/web/h5c315.jpg"></p></li></ul></li></ol><h6 id="七、-3D-旋转-rotateZ"><a href="#七、-3D-旋转-rotateZ" class="headerlink" title="七、 3D 旋转 rotateZ"></a>七、 <code>3D</code> 旋转 <code>rotateZ</code></h6><ol><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">500px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateZ</span>(<span class="hljs-number">180deg</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>rotate3d</code></p><ul><li><code>transform: rotate3d(x, y, z, deg)</code> – 沿着自定义轴旋转 deg 为角度</li><li>x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度<ul><li><code>transform: rotate3d(1, 1, 0, 180deg)</code> – 沿着对角线旋转 45deg</li><li><code>transform: rotate3d(1, 0, 0, 180deg)</code> – 沿着 x 轴旋转 45deg</li></ul></li></ul></li><li><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">500px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span>;<br>&#125;<br><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate3d</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180deg</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="八、3D-呈现-transform-style"><a href="#八、3D-呈现-transform-style" class="headerlink" title="八、3D 呈现 transform-style"></a>八、<code>3D</code> 呈现 <code>transform-style</code></h6><ol><li><p><code>transform-style</code></p><ul><li><p>☆☆☆☆☆</p></li><li><p>控制子元素是否开启三维立体环境</p></li><li><p><code>transform-style: flat</code>  代表子元素不开启 <code>3D</code> 立体空间，默认的</p></li><li><p><code>transform-style: preserve-3d</code> 子元素开启立体空间</p></li><li><p>代码写给父级，但是影响的是子盒子</p></li></ul></li><li><p> 代码演示</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习01-HTML</title>
    <link href="/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A001-HTML/"/>
    <url>/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A001-HTML/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认识WEB"><a href="#认识WEB" class="headerlink" title="认识WEB"></a>认识WEB</h1><h2 id="1-认识网页"><a href="#1-认识网页" class="headerlink" title="1. 认识网页"></a>1. 认识网页</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。<br></code></pre></td></tr></table></figure><p><strong>思考：</strong> </p><p>网页是如何形成</p><p><img src="/img/web/html01.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网页有图片、链接、文字等元素组成，我们后面的任务就是要把这部分网页元素用代码写出来。。。</p><h2 id="2-浏览器（显示代码）"><a href="#2-浏览器（显示代码）" class="headerlink" title="2. 浏览器（显示代码）"></a>2. 浏览器（显示代码）</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">浏览器是网页显示、运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。<br></code></pre></td></tr></table></figure><p><img src="/img/web/html02.jpg"></p><h3 id="2-1-查看浏览器占有的市场份额"><a href="#2-1-查看浏览器占有的市场份额" class="headerlink" title="2.1 查看浏览器占有的市场份额"></a>2.1 查看浏览器占有的市场份额</h3><p>查看网站： <a href="http://tongji.baidu.com/data/browser" target="_blank">http://tongji.baidu.com/data/browser</a></p><p><img src="/img/web/html03.jpg"></p><p> 2008年，大名鼎鼎的互联网巨头Google公司发布了它的首款浏览器Chrome浏览器。   </p><h3 id="2-2-常见浏览器内核（了解）"><a href="#2-2-常见浏览器内核（了解）" class="headerlink" title="2.2 常见浏览器内核（了解）"></a>2.2 常见浏览器内核（了解）</h3><p>首先解释一下浏览器内核是什么东西。英文叫做：Rendering Engine，中文翻译很多，排版引擎、解释引擎、渲染引擎，现在流行称为浏览器内核.</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">负责读取网页内容，整理讯息，计算网页的显示方式并显示页面.<br></code></pre></td></tr></table></figure><p>因为浏览器太多啦， 但是现在主要流行的就是下面几个：</p><table><thead><tr><th align="left">浏览器</th><th align="center">内核</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">IE</td><td align="center">Trident</td><td align="left">IE、猎豹安全、360极速浏览器、百度浏览器</td></tr><tr><td align="left">firefox</td><td align="center">Gecko</td><td align="left">可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</td></tr><tr><td align="left">Safari</td><td align="center">webkit</td><td align="left">现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。</td></tr><tr><td align="left">chrome</td><td align="center">Chromium/Blink</td><td align="left">在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发</td></tr><tr><td align="left">Opera</td><td align="center">blink</td><td align="left">现在跟随chrome用blink内核。</td></tr></tbody></table><p><strong>拓展阅读：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">移动端的浏览器内核主要说的是系统内置浏览器的内核。<br><br><span class="hljs-keyword">Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。</span><br><span class="hljs-keyword"></span><br>iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的<br></code></pre></td></tr></table></figure><h2 id="3-Web标准（重点）"><a href="#3-Web标准（重点）" class="headerlink" title="3. Web标准（重点）"></a>3. Web标准（重点）</h2><p>目标</p><ul><li>记忆<ul><li>能说出网页 中 web 标准三层组成</li></ul></li><li>理解<ul><li>能结合人来表述web标准三层</li></ul></li></ul><p>Web标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。</p><p>W3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。</p><p><strong>w3c就类似于现实世界中的联合国。</strong></p><h3 id="3-1-为什么要遵循WEB标准呢？"><a href="#3-1-为什么要遵循WEB标准呢？" class="headerlink" title="3.1 为什么要遵循WEB标准呢？"></a>3.1 为什么要遵循WEB标准呢？</h3><p> 通过以上浏览器不同内核不同，我们知道他们显示页面或者排版就有些许差异。</p><p><img src="/img/web/html04.jpg"></p><h3 id="3-2-Web-标准的好处"><a href="#3-2-Web-标准的好处" class="headerlink" title="3.2 Web 标准的好处"></a>3.2 Web 标准的好处</h3><p>遵循web标准可以让不同我们写的页面更标准更统一外，还有许多优点</p><p><em>1</em>、让Web的发展前景更广阔<br><em>2</em>、内容能被更广泛的设备访问<br><em>3</em>、更容易被搜寻引擎搜索<br><em>4</em>、降低网站流量费用<br><em>5</em>、使网站更易于维护<br><em>6</em>、提高页面浏览速度</p><h3 id="3-3-Web-标准构成"><a href="#3-3-Web-标准构成" class="headerlink" title="3.3 Web 标准构成"></a>3.3 Web 标准构成</h3><p><strong>构成：</strong> 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p><table><thead><tr><th align="left">标准</th><th align="left">说明</th><th align="left"></th></tr></thead><tbody><tr><td align="left">结构</td><td align="left">结构用于对<strong>网页元素</strong>进行整理和分类，咱们主要学的是HTML。</td><td align="left"></td></tr><tr><td align="left">表现</td><td align="left">表现用于设置网页元素的版式、颜色、大小等<strong>外观样式</strong>，主要指的是CSS</td><td align="left"></td></tr><tr><td align="left">行为</td><td align="left">行为是指网页模型的定义及<strong>交互</strong>的编写，咱们主要学的是 Javascript</td><td align="left"></td></tr></tbody></table><p> 理想状态我们的源码： .HTML      .css      .js </p><hr><h3 id="web标准小结"><a href="#web标准小结" class="headerlink" title="web标准小结"></a>web标准小结</h3><ul><li>web标准有三层结构，分别是结构（html）、表现（css）和行为（javascript）  </li><li>结构类似人的身体， 表现类似人的着装， 行为类似人的行为动作</li><li>理想状态下，他们三层都是独立的， 放到不同的文件里面</li></ul><h2 id="4-拓展"><a href="#4-拓展" class="headerlink" title="4. 拓展@"></a>4. 拓展@</h2><ul><li><p><strong>介绍一下你对浏览器内核的理解？常见的浏览器内核有哪些？</strong></p><p>浏览器内核包括两部分，渲染引擎和js引擎。渲染引擎负责读取网页内容，整理讯息，计算网页的显示方式并显示页面，js引擎是解析执行js获取网页的动态效果。 后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。<br>IE：Trident<br>firefox：Gecko<br>chrom、safari：webkit<br>Opera：Presto<br>Microsoft Edge：EdgeHTML</p><p>深度阅读：<a href="http://blog.csdn.net/summer_15/article/details/71249203">五大主流浏览器内核的源起以及国内各大浏览器内核总结</a> </p></li></ul><blockquote><p>第01阶段.前端基础.认识HTML</p></blockquote><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>理解<ul><li>HTML的概念</li><li>HTML标签的分类</li><li>HTML标签的关系</li><li>HTML标签的语义化</li></ul></li><li>应用<ul><li>HTML骨架格式</li><li>sublime基本使用</li></ul></li></ul><h1 id="1-HTML-初识"><a href="#1-HTML-初识" class="headerlink" title="1. HTML 初识"></a>1. HTML 初识</h1><ul><li>HTML 指的是超文本标记语言 (<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage)是用来描述网页的一种语言。</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li><li>标记语言是一套标记标签 (markup tag)</li></ul><p>html作用:</p><blockquote><p>网页是由网页元素组成的 ， 这些元素是利用html标签描述出来，然后通过浏览器解析，就可以显示给用户了。</p></blockquote><p><strong>所谓超文本，有2层含义：</strong> </p><ol><li>因为它可以加入图片、声音、动画、多媒体等内容（**超越文本限制 **）</li><li>不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（**超级链接文本 **）。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;timg.jpg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>html 总结:</strong></p><ul><li><p>html 是超文本标记(标签)语言</p></li><li><p>我们学习html 主要学习html标签</p></li><li><p>我们用html标签描述网页元素。 比如 图片标签 、文字标签、链接标签等等</p></li><li><p>标签有自己的语法规范，所有的html标签都是用 &lt;&gt; 表示的</p></li></ul><h2 id="1-1-HTML骨架标签"><a href="#1-1-HTML骨架标签" class="headerlink" title="1.1 HTML骨架标签"></a>1.1 HTML骨架标签</h2><p>日常生活的书信，我们要遵循共同的约定。 </p><p>同理：HTML 有自己的语言语法骨架格式：（要遵循，要专业） 要求务必非常流畅的默写下来。。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>     <br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="html骨架标签总结"><a href="#html骨架标签总结" class="headerlink" title="html骨架标签总结"></a>html骨架标签总结</h4><table><thead><tr><th>标签名</th><th align="center">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><html></html></td><td align="center">HTML标签</td><td align="left">页面中最大的标签，我们成为  根标签</td></tr><tr><td><head></head></td><td align="center">文档的头部</td><td align="left">注意在head标签中我们必须要设置的标签是title</td></tr><tr><td><titile></titile></td><td align="center">文档的标题</td><td align="left">让页面拥有一个属于自己的网页标题</td></tr><tr><td><body></body></td><td align="center">文档的主体</td><td align="left">元素包含文档的所有内容，页面内容 基本都是放到body里面的</td></tr></tbody></table><p>**课堂练习1： **   </p><p>书写我们的第一个HTML 页面。</p><ol><li><p>新建一个 01-html骨架标签  的 TXT 文件。</p></li><li><p>里面写入刚才的HTML 骨架。  </p></li><li><p>把后缀名改为 .HTML。</p></li><li><p>右击–谷歌浏览器打开。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>     <br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>           你我之间 黑马洗练 月薪过万   一飞冲天   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p> <img src="/img/web/html05.jpg"></p><h4 id="团队约定大小写"><a href="#团队约定大小写" class="headerlink" title="团队约定大小写"></a>团队约定大小写</h4><p>HTML标签名、类名、标签属性和大部分属性值统一用小写</p><p><em>推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>     <br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">HEAD</span>&gt;</span>     <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TITLE</span>&gt;</span>我的第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">TITLE</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">HEAD</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-2-HTML元素标签分类"><a href="#1-2-HTML元素标签分类" class="headerlink" title="1.2 HTML元素标签分类"></a>1.2 HTML元素标签分类</h2><p><strong>标签：</strong></p><p>在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;html&gt;、&lt;head&gt;、&lt;body&gt;都是HTML骨架结构标签。</p><p><strong>分类：</strong></p><ol><li>常规元素（双标签）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签名&gt; 内容 &lt;/标签名&gt;   比如 <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  我是文字  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。</li><li>和开始标签相比，结束标签只是在前面加了一个关闭符“/”。</li><li>我们以后接触的基本都是双标签</li></ul><ol start="2"><li>空元素（单标签）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签名 /&gt;  比如  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>空元素 用单标签来表示， 简单点说，就是里面不需要包含内容， 只有一个开始标签不需要关闭。</li></ul><h2 id="1-3-HTML标签关系"><a href="#1-3-HTML标签关系" class="headerlink" title="1.3 HTML标签关系"></a>1.3 HTML标签关系</h2><p>主要针对于<strong>双标签</strong> 的相互关系分为两种：  请大家务必熟悉记住这种标签关系，因为后面我们标签嵌套特别多，很容易弄混他们的关系。</p><ol><li>嵌套关系</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.并列关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>倡议：</strong> </p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位（一个tab是4个空格）。如果是并列关系，最好上下对齐。<br></code></pre></td></tr></table></figure></blockquote><h2 id="1-4-课堂一练"><a href="#1-4-课堂一练" class="headerlink" title="1.4 课堂一练"></a>1.4 课堂一练</h2><p>**请问下列哪组标签关系是错误的？ **</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">- [ ] <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><br>- [ ] <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>- [x] <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br><br>- [ ] <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-代码开发工具（书写代码）"><a href="#2-代码开发工具（书写代码）" class="headerlink" title="2. 代码开发工具（书写代码）"></a>2. 代码开发工具（书写代码）</h1><ul><li><p>为了提高我们的开发效率</p></li><li><p>减少代码的出错我们不提倡用记事本开发，我们有更好的犀利哥。</p></li></ul><p>常见开发工具  </p><ul><li><p>Dreamweaver</p></li><li><p>SublimeText</p></li><li><p>WebStorm</p></li><li><p>HBuilder</p></li><li><p>VScode</p></li></ul><p>sublime有非常多的优点， 最开心的就是非常轻量级，打开速度超快，后面更高的功能，后面再接触。</p><p><strong>sublime生成html骨架小技巧</strong></p><ul><li> 双击打开软件</li><li> 新建文件（ctrl+n）</li><li> 保存（ctrl+s）,保存为：文件名.html （ 注意 后缀名必须是 .html ) </li><li> 放大缩小代码  按住 ctrl  在 滚动鼠标滚轮  或者   ctrl+ 加号 键     和 ctrl +   减号键     </li><li>生成页面骨架结构<ul><li>html: 5    按下tab键    或者  </li><li>!    按下tab键</li></ul></li><li>在浏览器中预览页面<ul><li>右键在  浏览器中打开</li></ul></li></ul><h1 id="3-文档类型-lt-DOCTYPE-gt"><a href="#3-文档类型-lt-DOCTYPE-gt" class="headerlink" title="3. 文档类型&lt;!DOCTYPE&gt;"></a>3. 文档类型&lt;!DOCTYPE&gt;</h1><p><strong>用法：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>作用：</strong></p><!DOCTYPE><p> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。<br><strong>团队约定：</strong></html></p><blockquote><p>HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明</p></blockquote><h1 id="4-页面语言lang"><a href="#4-页面语言lang" class="headerlink" title="4. 页面语言lang"></a>4. 页面语言lang</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  指定html 语言种类<br></code></pre></td></tr></table></figure><p>最常见的2个：</p><ol><li><code>en</code>定义语言为英语</li><li><code>zh-CN</code>定义语言为中文</li></ol><blockquote> <html lang="zh-CN">  指定该html标签 内容 所用的语言为中文</html></blockquote><p><strong>团队约定：</strong></p><blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">考虑浏览器和操作系统的兼容性，目前仍然使用 zh-<span class="hljs-meta">CN</span> 属性值<br></code></pre></td></tr></table></figure></blockquote><p><strong>@拓展阅读：</strong></p><p>简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序对页面语言内容来做一些对应的处理或者事情。<br>比如可以</p><ul><li>根据根据lang属性来设定不同语言的css样式，或者字体</li><li>告诉搜索引擎做精确的识别</li><li>让语法检查程序做语言识别</li><li>帮助翻译工具做识别</li><li>帮助网页阅读程序做识别<br>等等</li></ul><h1 id="5-字符集"><a href="#5-字符集" class="headerlink" title="5. 字符集"></a>5. 字符集</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">字符集(<span class="hljs-type">Character</span> <span class="hljs-keyword">set</span>)是多个字符的集合。<br><br>计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。<br></code></pre></td></tr></table></figure><p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p><ul><li>gb2312 简单中文  包括6763个汉字  GUO BIAO</li><li>BIG5   繁体中文 港澳台等用</li><li>GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</li><li>UTF-8则基本包含全世界所有国家需要用到的字符</li><li><strong>这句代码非常关键， 是必须要写的代码，否则可能引起乱码的情况。</strong></li></ul><blockquote><p>这句话是让 html 文件是以 UTF-8 编码保存的， 浏览器根据编码去解码对应的html内容。</p></blockquote><p><strong>团队约定：</strong></p><blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">一般情况下统一使用 <span class="hljs-string">&quot;UTF-8&quot;</span> 编码, 请尽量统一写成标准的 <span class="hljs-string">&quot;UTF-8&quot;</span>，不要写成 <span class="hljs-string">&quot;utf-8&quot;</span> 或 <span class="hljs-string">&quot;utf8&quot;</span> 或 <span class="hljs-string">&quot;UTF8&quot;</span>。<br></code></pre></td></tr></table></figure></blockquote><h1 id="6-HTML标签的语义化"><a href="#6-HTML标签的语义化" class="headerlink" title="6. HTML标签的语义化"></a>6. HTML标签的语义化</h1><p>白话： 所谓标签语义化，就是指标签的含义。</p><blockquote><p>根据标签的语义，在合适的地方给一个最为合理的标签，让结构更清晰。</p></blockquote><ol><li>方便代码的阅读和维护</li><li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 </li><li>使用语义化标签会具有更好地搜索引擎优化 </li></ol><p><img src="/img/web/html06.jpg"></p><p>语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。(  裸奔起来一样好看 )</p><p>遵循的原则：先确定语义的HTML ，再选合适的CSS。所以，<strong>我们接下来学习html标签，要根据语义去记忆。</strong> HTML网页中任何元素的实现都要依靠HTML标签。</p><h1 id="1-HTML常用标签"><a href="#1-HTML常用标签" class="headerlink" title="1. HTML常用标签"></a>1. HTML常用标签</h1><p> 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。</p><h2 id="1-1-排版标签"><a href="#1-1-排版标签" class="headerlink" title="1.1 排版标签"></a>1.1 排版标签</h2><p>排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。</p><h3 id="1）标题标签h-熟记"><a href="#1）标题标签h-熟记" class="headerlink" title="1）标题标签h (熟记)"></a>1）标题标签h (熟记)</h3><p> 单词缩写：  head   头部. 标题       title  文档标题</p><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</p><p><strong>标题标签语义：</strong>  作为标题使用，并且依据重要性递减</p><p>其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示效果如下：</p><p>  <img src="/img/web/html07.jpg"></p><p><strong>小结 :</strong></p><ul><li>加了标题的文字会变的加粗，字号也会依次变大</li><li>一行是只能放一个标题的</li></ul><h3 id="2）段落标签p-熟记"><a href="#2）段落标签p-熟记" class="headerlink" title="2）段落标签p ( 熟记)"></a>2）段落标签p ( 熟记)</h3><p>单词缩写：  paragraph  段落  [ˈpærəgræf]    无须记这个单词</p><p><strong>作用语义：</strong></p><p>可以把 HTML 文档分割为若干段落</p><p> 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>  文本内容  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p><h3 id="3）水平线标签hr-认识"><a href="#3）水平线标签hr-认识" class="headerlink" title="3）水平线标签hr(认识)"></a>3）水平线标签hr(认识)</h3><p>单词缩写：  horizontal  横线    [ˌhɔrəˈzɑntl]    同上</p><p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，<hr>就是创建横跨网页水平线的标签。其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>是单标签<br></code></pre></td></tr></table></figure><p> 在网页中显示默认样式的水平线。</p><p>课堂练习:新闻页面 </p><p><img src="/img/web/html08.jpg"> </p><h3 id="4）换行标签br-熟记"><a href="#4）换行标签br-熟记" class="headerlink" title="4）换行标签br (熟记)"></a>4）换行标签br (熟记)</h3><p>单词缩写：  break   打断 ,换行</p><p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这时如果还像在word中直接敲回车键换行就不起作用了。</p><p>此处有练习题</p><h3 id="5）div-和-span标签-重点"><a href="#5）div-和-span标签-重点" class="headerlink" title="5）div 和  span标签(重点)"></a>5）div 和  span标签(重点)</h3><p>div   span    是没有语义的     是我们网页布局主要的2个盒子   想必你听过  css+div</p><p>div 就是  division  的缩写   分割， 分区的意思  其实有很多div 来组合网页。</p><p>span   跨度，跨距；范围    </p><p>语法格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 这是头部 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今日价格<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>他们两个都是盒子，用来装我们网页元素的， 只不过他们有区别，现在我们主要记住使用方法和特点就好了</p><ul><li>div标签  用来布局的，但是现在一行只能放一个div</li><li>span标签  用来布局的，一行上可以放好多个span</li></ul><p>后面后面讲显示模式的时候，会告诉大家</p><h3 id="排版标签总结"><a href="#排版标签总结" class="headerlink" title="排版标签总结"></a>排版标签总结</h3><table><thead><tr><th>标签名</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><hx></hx></td><td align="left">标题标签</td><td align="left">作为标题使用，并且依据重要性递减</td></tr><tr><td><p></p></td><td align="left">段落标签</td><td align="left">可以把 HTML 文档分割为若干段落</td></tr><tr><td><hr></td><td align="left">水平线标签</td><td align="left">没啥可说的，就是一条线</td></tr><tr><td><br></td><td align="left">换行标签</td><td align="left"></td></tr><tr><td><div></div></td><td align="left">div标签</td><td align="left">用来布局的，但是现在一行只能放一个div</td></tr><tr><td><span></span></td><td align="left">span标签</td><td align="left">用来布局的，一行上可以放好多个span</td></tr></tbody></table><h2 id="1-2-文本格式化标签-熟记"><a href="#1-2-文本格式化标签-熟记" class="headerlink" title="1.2 文本格式化标签(熟记)"></a>1.2 文本格式化标签(熟记)</h2><p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p><p><img src="/img/web/html09.jpg"></p><p><strong>区别：</strong></p><p> b  只是加粗          strong  除了可以加粗还有 强调的意思，  语义更强烈。</p><p>剩下的同理…    </p><blockquote><p>请同学们重点记住 前两组   加粗 和 倾斜   后面两组没记住回来查</p></blockquote><h2 id="1-3-标签属性"><a href="#1-3-标签属性" class="headerlink" title="1.3 标签属性"></a>1.3 标签属性</h2><p>所谓属性就是<strong>外在特性</strong>  比如 手机的颜色 手机的尺寸 ，总结就是手机的。。</p><ul><li>手机的颜色是黑色   </li><li>手机的尺寸是 8寸 </li><li>水平线的长度是 200  </li><li>图片的宽度 是  300    </li></ul><p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt;<br>&lt;手机 颜色=&quot;红色&quot; 大小=&quot;5寸&quot;&gt;  &lt;/手机&gt;<br></code></pre></td></tr></table></figure><h2 id="1-4-图像标签img-重点"><a href="#1-4-图像标签img-重点" class="headerlink" title="1.4 图像标签img (重点)"></a>1.4 图像标签img (重点)</h2><p>单词缩写：   image  图像</p><p>要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签<img>以及和他相关的属性。（它是一个单身狗）</p><p>语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像URL&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。</p><p><img src="/img/web/html10.jpg"></p><p>border 后面我们会用css来做，这里童鞋们就记住这个border 单词就好了</p><p>**注意: **</p><ol><li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>采取  键值对 的格式   key=”value”  的格式  </li></ol><p>比如:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">正常的<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;cz.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    带有边框的<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;cz.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>有提示文本的<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;cz.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;这是个小蒲公英&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>有替换文本的<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;cz.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片不存在&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-5-链接标签-重点"><a href="#1-5-链接标签-重点" class="headerlink" title="1.5 链接标签(重点)"></a>1.5 链接标签(重点)</h2><p>单词缩写：  anchor 的缩写  [ˈæŋkə(r)] 。基本解释 锚, 铁锚 的</p><p>在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。</p><p>语法格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;跳转目标&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本或图像<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>href</td><td align="left">用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td></tr><tr><td>target</td><td align="left">用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，__blank为在新窗口中打开方式。</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>外部链接 需要添加 http:// <a href="http://www.baidu.com/">www.baidu.com</a></li><li>内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 </li><li>如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。</li><li>不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。</li></ol><h2 id="1-6-注释标签"><a href="#1-6-注释标签" class="headerlink" title="1.6 注释标签"></a>1.6 注释标签</h2><p>在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。</p><p>简单解释：</p><p>注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</p><p>语法格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 注释语句 --&gt;</span>     快捷键是：    ctrl + /       或者 ctrl +shift + / <br></code></pre></td></tr></table></figure><blockquote><p>注释是给人看的，目的是为了更好的解释这部分代码是干啥的， 程序是不执行这个代码的</p></blockquote><h3 id="团队约定"><a href="#团队约定" class="headerlink" title="团队约定"></a>团队约定</h3><p>一般用于简单的描述，如某些状态描述、属性描述等</p><p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行</p><p><em>推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Comment Text --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- Comment Text --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- Comment Text --&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-路径-重点、难点"><a href="#2-路径-重点、难点" class="headerlink" title="2. 路径(重点、难点)"></a>2. 路径(重点、难点)</h1><p><img src="/img/web/html11.jpg"></p><p>实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。</p><p>**目录文件夹： **</p><p>就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html文件， 图片 等等。</p><p>**根目录 **  </p><p>打开目录文件夹的第一层  就是 根目录 </p><p>页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。</p><table><thead><tr><th>路径分类</th><th align="center">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td>同一级路径</td><td align="center"></td><td align="left">只需输入图像文件的名称即可，如&lt;img src=”baidu.gif” /&gt;。<img src="/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A001-HTML/04路径同目录.jpg"></td></tr><tr><td>下一级路径</td><td align="center">“/”</td><td align="left">图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images）                         如&lt;img src=”images/baidu.gif” /&gt;。  <img src="/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A001-HTML/05路径不同.jpg"></td></tr><tr><td>上一级路径</td><td align="center">“../”</td><td align="left">在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，                    如&lt;img src=”../baidu.gif” /&gt;。 <img src="/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A001-HTML/06路径不同.jpg"></td></tr></tbody></table><blockquote><p>相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级  简单说，就是 图片 位于 HTML 页面的位置</p></blockquote><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。</p><p>“D:\web\img\logo.gif”，或完整的网络地址，例如“<a href="http://www.itcast.cn/images/logo.gif%E2%80%9D%E3%80%82">http://www.itcast.cn/images/logo.gif”。</a></p><p><strong>注意：</strong></p><p>绝对路径用的较少，我们理解下就可以了。  但是要注意，它的写法 特别是符号  \  并不是 相对路径的   /    </p><h1 id="5-拓展阅读"><a href="#5-拓展阅读" class="headerlink" title="5. @拓展阅读"></a>5. @拓展阅读</h1><h4 id="5-1-锚点定位-（难点）"><a href="#5-1-锚点定位-（难点）" class="headerlink" title="5.1 锚点定位 （难点）"></a>5.1 锚点定位 （难点）</h4><p>通过创建锚点链接，用户能够快速定位到目标内容。</p><p>创建锚点链接分为两步：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">1. 使用相应的id名标注跳转目标的位置。 (找目标)<br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>第2集<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span> <br><br>2. 使用<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#id名&quot;</span>&gt;</span>链接文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>创建链接文本（被点击的） （拉关系）  我也有一个姓毕的姥爷..<br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#two&quot;</span>&gt;</span>   <br></code></pre></td></tr></table></figure><h4 id="5-2-base-标签"><a href="#5-2-base-标签" class="headerlink" title="5.2 base 标签"></a>5.2 base 标签</h4><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>**总结： **</p><ol><li>base 可以设置整体链接的打开状态   </li><li>base 写到  <head>  </head>  之间</li><li>把所有的连接 都默认添加 target=”_blank”</li></ol><h4 id="5-3-预格式化文本pre标签"><a href="#5-3-预格式化文本pre标签" class="headerlink" title="5.3 预格式化文本pre标签"></a>5.3 预格式化文本pre标签</h4><p><code> &lt;pre&gt; 标签可定义预格式化的文本。</code></p><p>被包围在<code> &lt;pre&gt;</code> 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;pre&gt;</span><br><br>  此例演示如何使用 <span class="hljs-keyword">pre</span> 标签<br><br>  对空行和 空格<br><br>  进行控制<br><br>&lt;/<span class="hljs-keyword">pre</span>&gt;<br></code></pre></td></tr></table></figure><blockquote><p>所谓的预格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。 </p></blockquote><p>有了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。</p><h4 id="5-4-特殊字符-（理解）"><a href="#5-4-特殊字符-（理解）" class="headerlink" title="5.4 特殊字符 （理解）"></a>5.4 特殊字符 （理解）</h4><p> 一些特殊的符号，我们再html 里面很难或者 不方便直接 使用， 我们此时可以使用下面的替代代码。</p><p><img src="/img/web/html12.jpg"></p><p><strong>虽然有很多，但是我们平时用的比较较少， 大家重点记住   空格    大于号 小于号   就可以了，剩下的回来查阅。</strong></p><p><strong>总结：</strong></p><ol><li>是以<strong>运算符</strong><code>&amp;</code>开头,以<strong>分号运算符</strong><code>;</code>结尾。</li><li>他们不是标签，而是符号。</li><li>HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</li></ol><p><strong>团队约定</strong></p><p>   <em>推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>more <span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>   <em>不推荐：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>more &gt;&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="5-5-html5发展之路"><a href="#5-5-html5发展之路" class="headerlink" title="5.5 html5发展之路"></a>5.5 html5发展之路</h4><p> <img src="/img/web/html13.jpg"></p><h4 id="5-6-什么是XHTML"><a href="#5-6-什么是XHTML" class="headerlink" title="5.6 什么是XHTML"></a>5.6 什么是XHTML</h4><p>XHTML 是更严格更纯净的 HTML 代码。</p><ul><li>XHTML 指<strong>可扩展超文本标签语言</strong>（EXtensible HyperText Markup Language）。</li><li>XHTML 的目标是取代 HTML。</li><li>XHTML 与 HTML 4.01 几乎是相同的。</li><li>XHTML 是更严格更纯净的 HTML 版本。</li><li>XHTML 是作为一种 XML 应用被重新定义的 HTML。</li><li>XHTML 是一个 W3C 标准。</li></ul><h4 id="5-7-HTML和-XHTML之间有什么区别"><a href="#5-7-HTML和-XHTML之间有什么区别" class="headerlink" title="5.7 HTML和 XHTML之间有什么区别?"></a>5.7 HTML和 XHTML之间有什么区别?</h4><ul><li>XHTML 指的是可扩展超文本标记语言</li><li>XHTML 与 HTML 4.01 几乎是相同的</li><li>XHTML 是更严格更纯净的 HTML 版本</li><li>XHTML 是以 XML 应用的方式定义的 HTML</li><li>XHTML 是 2001 年 1 月发布的 W3C 推荐标准</li><li>XHTML 得到所有主流浏览器的支持</li><li>XHTML 元素是以 XML 格式编写的 HTML 元素。XHTML是严格版本的HTML，例如它要求标签必须小写，标签必须被正确关闭，标签顺序必须正确排列，对于属性都必须使用双引号等。</li></ul><h1 id="6-深入阅读"><a href="#6-深入阅读" class="headerlink" title="6. @深入阅读"></a>6. @深入阅读</h1><p><a href="http://www.chinaz.com/manage/2015/0720/424831.shtml">HTML5的崛起之路</a></p><h1 id="表格-table"><a href="#表格-table" class="headerlink" title="表格 table"></a>表格 table</h1><p>目标：</p><p> <img src="/img/web/html13.jpg"></p><ul><li>理解：<ul><li>能说出表格用来做什么的</li><li>表格的基本结构组成</li></ul></li><li>应用：<ul><li>能够熟练写出n行n列的表格</li><li>能简单的合并单元格</li></ul></li></ul><p><strong>表格作用：</strong></p><p>存在即是合理的。  表格的现在还是较为常用的一种标签，但不是用来布局，<strong>常见显示、展示表格式数据。</strong></p><p>因为它可以让数据显示的非常的规整，可读性非常好。</p><p><strong>特别是后台展示数据的时候表格运用是否熟练就显得很重要</strong>，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。</p><p> <img src="/img/web/html15.jpg"></p><p>ps:  这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说  PPAP i hava a pen  </p><h2 id="1-创建表格"><a href="#1-创建表格" class="headerlink" title="1. 创建表格"></a>1. 创建表格</h2><p>在HTML网页中，要想创建表格，就需要使用表格相关的标签。</p><p><strong>创建表格的基本语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格内的文字<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要深刻体会表格、行、单元格他们的构成。</p><p>在上面的语法中包含基本的三对HTML标签，分别为 table、tr、td，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释</p><ol><li><p>table用于定义一个表格标签。</p></li><li><p>tr标签 用于定义表格中的行，必须嵌套在 table标签中。</p></li><li><p>td 用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中。</p></li><li><p>字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。</p><p> <img src="/img/web/html16.jpg"></p></li></ol><p>**总结： **</p><ul><li>表格的主要目的是用来显示特殊数据的</li><li>一个完整的表格有表格标签（table），行标签（tr），单元格标签（td）组成，没有列的标签</li></ul><ul><li><code>&lt;tr&gt;&lt;/tr&gt;</code>中只能嵌套<code>&lt;td&gt;&lt;/td&gt;</code> 类的单元格</li><li><code>&lt;td&gt;&lt;/td&gt;</code>标签，他就像一个容器，可以容纳所有的元素</li></ul><h2 id="2-表格属性"><a href="#2-表格属性" class="headerlink" title="2. 表格属性"></a>2. 表格属性</h2><p>表格有部分属性我们不常用，这里重点记住 cellspacing 、 cellpadding。</p><p> <img src="/img/web/html17.jpg"></p><p>我们经常有个说法，是三参为0，  平时开发的我们这三个参数    border  cellpadding  cellspacing  为  0</p><p> <img src="/img/web/html18.jpg"></p><p><strong>案例1：</strong></p><p> <img src="/img/web/html19.jpg"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>刘德华<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>55<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>郭富城<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>52<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张学友<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>58<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>黎明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>刘晓庆<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>63<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-表头单元格标签th"><a href="#3-表头单元格标签th" class="headerlink" title="3. 表头单元格标签th"></a>3. 表头单元格标签th</h2><ul><li><p>作用：</p><ul><li>一般表头单元格位于表格的第一行或第一列，并且文本加粗居中</li></ul></li><li><p>语法：</p><ul><li>只需用表头标签<code> &lt;th&gt;&lt;/th&gt; </code>替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 </li></ul><p><img src="/img/web/html20.jpg"></p></li></ul><p><strong>案例2：</strong></p><p>​    效果图</p><p> <img src="/img/web/html21.jpg"></p><p>​    代码：</p><hr><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>电话<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小王<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>110<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>120<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>th 也是一个单元格   只不过和普通的 td单元格不一样，它会让自己里面的文字居中且加粗</p></blockquote><h2 id="4-表格标题caption"><a href="#4-表格标题caption" class="headerlink" title="4. 表格标题caption"></a>4. 表格标题caption</h2><p><strong>定义和用法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>我是表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>**注意： **</p><ol><li>caption 元素定义<strong>表格标题</strong>，通常这个标题会被居中且显示于表格之上。</li><li>caption 标签必须紧随 table 标签之后。</li><li>这个标签只存在 表格里面才有意义。你是风儿我是沙</li></ol><p><strong>案例3：</strong></p><p>根据要求完成以下案例：</p><p> <img src="/img/web/html22.jpg"></p><h2 id="5-合并单元格-难点"><a href="#5-合并单元格-难点" class="headerlink" title="5. 合并单元格(难点)"></a>5. 合并单元格(难点)</h2><p>合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。</p><h3 id="5-1-合并单元格2种方式"><a href="#5-1-合并单元格2种方式" class="headerlink" title="5.1 合并单元格2种方式"></a>5.1 合并单元格2种方式</h3><ul><li>跨行合并：rowspan=”合并单元格的个数”      </li><li>跨列合并：colspan=”合并单元格的个数”</li></ul><p> <img src="/img/web/html23.jpg"></p><h3 id="5-2-合并单元格顺序"><a href="#5-2-合并单元格顺序" class="headerlink" title="5.2 合并单元格顺序"></a>5.2 合并单元格顺序</h3><blockquote><p>**合并的顺序我们按照   先上 后下     先左  后右 的顺序 **</p></blockquote><p>跟我们以前学习汉字的书写顺序完全一致。</p><h3 id="5-3-合并单元格三步曲"><a href="#5-3-合并单元格三步曲" class="headerlink" title="5.3 合并单元格三步曲"></a>5.3 合并单元格三步曲</h3><ol><li>先确定是跨行还是跨列合并</li><li>根据 先上 后下   先左  后右的原则找到目标单元格    然后写上 合并方式 还有 要合并的单元格数量  比如 ： <td colspan="3">   </td></li><li>删除多余的单元格 单元格      </li></ol><h2 id="6-总结表格"><a href="#6-总结表格" class="headerlink" title="6. 总结表格"></a>6. 总结表格</h2><table><thead><tr><th>标签名</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><table></table></td><td align="left">表格标签</td><td align="left">就是一个四方的盒子</td></tr><tr><td></td></tr><tr></tr><td align="left">表格行标签</td><td align="left">行标签要再table标签内部才有意义</td><tr><td></td><td></td><td align="left">单元格标签</td><td align="left">单元格标签是个容器级元素，可以放任何东西</td></tr><tr><td><th></th></td><td align="left">表头单元格标签</td><td align="left">它还是一个单元格，但是里面的文字会居中且加粗</td></tr><tr><td><caption></caption></td><td align="left">表格标题标签</td><td align="left">表格的标题，跟着表格一起走，和表格居中对齐</td></tr><tr><td>clospan 和 rowspan</td><td align="left">合并属性</td><td align="left">用来合并单元格的</td></tr></tbody></table><ol><li>表格提供了HTML 中定义表格式数据的方法。</li><li>表格中由行中的单元格组成。</li><li>表格中没有列元素，列的个数取决于行的单元格个数。</li><li>表格不要纠结于外观，那是CSS 的作用。</li><li>表格的学习要求：  能手写表格结构，并且能简单合并单元格。</li></ol><h2 id="7-拓展阅读"><a href="#7-拓展阅读" class="headerlink" title="7. 拓展阅读@"></a>7. 拓展阅读@</h2><h3 id="表格划分结构（了解）"><a href="#表格划分结构（了解）" class="headerlink" title="表格划分结构（了解）"></a>表格划分结构（了解）</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:<span class="hljs-selector-tag">thead</span>,<span class="hljs-selector-tag">tbody</span>,<span class="hljs-selector-tag">tfoot</span>来标注， 这样更好的分清表格结构<br></code></pre></td></tr></table></figure><p> <img src="/img/web/html24.jpg"></p><p><strong>注意：</strong></p><ol><li><thead></thead>：用于定义表格的头部。用来放标题之类的东西。<thead> 内部必须拥有 <tr> 标签！</tr></thead></li><li><tbody></tbody>：用于定义表格的主体。放数据本体 。</li><li><tfoot></tfoot>放表格的脚注之类。</li><li>以上标签都是放到table标签中。</li></ol><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul><li><p>概念：</p><p>容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表</p></li><li><p>特点：</p><p>列表最大的特点就是  整齐 、整洁、 有序，跟表格类似，但是他可组合自由度会更高。</p></li></ul><h2 id="1-1-无序列表-ul-（重点）"><a href="#1-1-无序列表-ul-（重点）" class="headerlink" title="1.1 无序列表 ul （重点）"></a>1.1 无序列表 ul （重点）</h2><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。</p><p> <img src="/img/web/html25.jpg"></p><p><strong>脚下留心：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>中只能嵌套<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>，直接在<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>标签中输入其他标签或者文字的做法是不被允许的。<br>2. <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>与<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>之间相当于一个容器，可以容纳所有元素。<br>3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！<br></code></pre></td></tr></table></figure><h2 id="1-2-有序列表-ol-（了解）"><a href="#1-2-有序列表-ol-（了解）" class="headerlink" title="1.2  有序列表 ol （了解）"></a>1.2  有序列表 ol （了解）</h2><p><img src="/img/web/html26.jpg"></p><p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  所有特性基本与ul 一致。  但是实际中比 无序列表 用的少很多。</p><h2 id="1-3-自定义列表（理解）"><a href="#1-3-自定义列表（理解）" class="headerlink" title="1.3 自定义列表（理解）"></a>1.3 自定义列表（理解）</h2><p>定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词2<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词2解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词2解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>用的还可以：</p><p><img src="/img/web/html27.jpg"></p><h2 id="1-4-列表总结"><a href="#1-4-列表总结" class="headerlink" title="1.4 列表总结"></a>1.4 列表总结</h2><table><thead><tr><th>标签名</th><th align="center">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><ul></ul></td><td align="center"><strong>无序标签</strong></td><td align="left">里面只能包含li    没有顺序，我们以后布局中最常用的列表</td></tr><tr><td><ol></ol></td><td align="center">有序标签</td><td align="left">里面只能包含li    有顺序， 使用情况较少</td></tr><tr><td><dl></dl></td><td align="center">自定义列表</td><td align="left">里面有2个兄弟， dt 和 dd</td></tr></tbody></table><p>我们现在还没有学布局，现在只要保证2个点：</p><ol><li>学会什么时候用无序列表， 学会什么时候用自定义列表</li><li>无序列表和自定义列表代码怎么写？</li><li>具体的我们刚才看的布局，等我们学了css 在来全面布局。</li></ol><h1 id="2-表单标签-掌握"><a href="#2-表单标签-掌握" class="headerlink" title="2. 表单标签(掌握)"></a>2. 表单标签(掌握)</h1><p>目标：</p><ul><li>能写出最常用的注册类表单</li><li>能说出input表单常见属性</li></ul><p>现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图</p><p><img src="/img/web/html28.jpg"></p><h3 id><a href="#" class="headerlink" title></a></h3><p>**作用： **</p><p>表单目的是为了收集用户信息。</p><p>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</p><blockquote><p>在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</p></blockquote><p><img src="/img/web/html29.jpg"></p><p>  **表单控件： **</p><p>​       包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p><p>  <strong>提示信息：</strong></p><p>​        一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p><p>  <strong>表单域：</strong>  </p><p>​      他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p><h2 id="2-1-input-控件-重点"><a href="#2-1-input-控件-重点" class="headerlink" title="2.1 input 控件(重点)"></a>2.1 input 控件(重点)</h2><ul><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;属性值&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;你好&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>input 输入的意思 </li><li>&lt;input /&gt;标签为单标签</li><li>type属性设置不同的属性值用来指定不同的控件类型</li><li>除了type属性还有别的属性</li></ul></li><li><p>常用属性：</p></li></ul><p><img src="/img/web/html30.jpg"></p><h4 id="1-type-属性"><a href="#1-type-属性" class="headerlink" title="1. type 属性"></a>1. type 属性</h4><ul><li>这个属性通过改变值，可以决定了你属于那种input表单。</li><li>比如 type = ‘text’  就表示 文本框 可以做 用户名， 昵称等。</li><li>比如 type = ‘password’  就是表示密码框   用户输入的内容 是不可见的。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">用户名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span> <br>密  码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-value属性-值"><a href="#2-value属性-值" class="headerlink" title="2. value属性   值"></a>2. value属性   值</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">用户名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span> <br></code></pre></td></tr></table></figure><ul><li>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。</li></ul><h4 id="3-name属性"><a href="#3-name属性" class="headerlink" title="3. name属性"></a>3. name属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">用户名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">“username”</span> /&gt;</span>  <br></code></pre></td></tr></table></figure><p>name表单的名字， 这样，后台可以通过这个name属性找到这个表单。  页面中的表单很多，name主要作用就是用于区别不同的表单。</p><ul><li>name属性后面的值，是我们自己定义的。</li></ul><ul><li>radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以多个选其中的一个啦</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>  /&gt;</span>男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> /&gt;</span>女<br></code></pre></td></tr></table></figure><ul><li>name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。</li></ul><h4 id="4-checked属性"><a href="#4-checked属性" class="headerlink" title="4. checked属性"></a>4. checked属性</h4><ul><li>表示默认选中状态。  较常见于 单选按钮和复选按钮。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">性    别:<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span> /&gt;</span>男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span> /&gt;</span>女 <br></code></pre></td></tr></table></figure><p>上面这个，表示就默认选中了 男 这个单选按钮</p><h4 id="5-input-属性小结"><a href="#5-input-属性小结" class="headerlink" title="5. input 属性小结"></a>5. input 属性小结</h4><table><thead><tr><th>属性</th><th align="left">说明</th><th>作用</th></tr></thead><tbody><tr><td>type</td><td align="left">表单类型</td><td>用来指定不同的控件类型</td></tr><tr><td>value</td><td align="left">表单值</td><td>表单里面默认显示的文本</td></tr><tr><td>name</td><td align="left">表单名字</td><td>页面中的表单很多，name主要作用就是用于区别不同的表单。</td></tr><tr><td>checked</td><td align="left">默认选中</td><td>表示那个单选或者复选按钮一开始就被选中了</td></tr></tbody></table><h2 id="2-2-label标签-理解"><a href="#2-2-label标签-理解" class="headerlink" title="2.2 label标签(理解)"></a>2.2 label标签(理解)</h2><p><strong>目标：</strong></p><p>label标签主要目的是为了提高用户体验。 为用户提高最优秀的服务。</p><p><strong>概念：</strong></p><p>label 标签为 input 元素定义标注（标签）。</p><p><strong>作用：</strong> </p><p> 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</p><p><strong>如何绑定元素呢？</strong></p><ol><li>第一种用法就是用label直接包括input表单。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span> 用户名： <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><p>   适合单个表单选择</p><ol start="2"><li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>pink老师 一句话说出他们:</strong></p><blockquote><p> 当我们鼠标点击 label标签里面的文字时， 光标会定位到指定的表单里面</p></blockquote><h2 id="2-3-textarea控件-文本域"><a href="#2-3-textarea控件-文本域" class="headerlink" title="2.3 textarea控件(文本域)"></a>2.3 textarea控件(文本域)</h2><p><img src="/img/web/html31.jpg"></p><ul><li>语法：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> &gt;</span><br>  文本内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>作用：</p><p>通过textarea控件可以轻松地创建多行文本输入框.</p><p>cols=”每行中的字符数” rows=”显示的行数”  我们实际开发不用</p></li></ul><h4 id="文本框和文本域区别"><a href="#文本框和文本域区别" class="headerlink" title="文本框和文本域区别"></a>文本框和文本域区别</h4><table><thead><tr><th align="left">表单</th><th align="center">名称</th><th align="center">区别</th><th align="right">默认值显示</th><th align="right">用于场景</th></tr></thead><tbody><tr><td align="left">input type=”text”</td><td align="center">文本框</td><td align="center">只能显示一行文本</td><td align="right">单标签，通过value显示默认值</td><td align="right">用户名、昵称、密码等</td></tr><tr><td align="left">textarea</td><td align="center">文本域</td><td align="center">可以显示多行文本</td><td align="right">双标签，默认值写到标签中间</td><td align="right">留言板</td></tr></tbody></table><h2 id="2-4-select下拉列表"><a href="#2-4-select下拉列表" class="headerlink" title="2.4 select下拉列表"></a>2.4 select下拉列表</h2><p><strong>目的：</strong></p><p>如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表.</p><p><img src="/img/web/html32.jpg"></p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li>&lt;select&gt;  中至少包含一对 option </li><li>在option 中定义selected =” selected “时，当前项即为默认选中项。</li><li>但是我们实际开发会用的比较少</li></ol><h1 id="3-form表单域"><a href="#3-form表单域" class="headerlink" title="3. form表单域"></a>3. form表单域</h1><ul><li><p>收集的用户信息怎么传递给服务器？</p><p>通过form表单域</p></li><li><p>目的：</p><p>在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。</p></li></ul><p>**语法: **</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;url地址&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;提交方式&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;表单名称&quot;</span>&gt;</span><br>  各种表单控件<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th align="left">属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td align="left">url地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址。</td></tr><tr><td>method</td><td align="left">get/post</td><td>用于设置表单数据的提交方式，其取值为get或post。</td></tr><tr><td>name</td><td align="left">名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单。</td></tr></tbody></table><p><strong>注意:</strong>  </p><p>每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。</p><h2 id="2-6-团队约定"><a href="#2-6-团队约定" class="headerlink" title="2.6 团队约定"></a>2.6 团队约定</h2><h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><ul><li>元素属性值使用双引号语法</li><li>元素属性值可以写上的都写上</li></ul><p><em>推荐：</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><em>不推荐：</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">text</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">checked</span> /&gt;</span><br></code></pre></td></tr></table></figure><h1 id="4-查文档"><a href="#4-查文档" class="headerlink" title="4. 查文档"></a>4. 查文档</h1><p>经常查阅文档是一个非常好的学习习惯。</p><p>W3C :  <a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a></p><p>MDN: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习02-CSS01</title>
    <link href="/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A002-CSS01/"/>
    <url>/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A002-CSS01/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>理解<ul><li>css的目的作用</li><li>css的三种引入方式</li></ul></li><li>应用<ul><li>css三种引用方式的书写</li><li>通过样式规则给标签添加简单的样式<br><img src="/img/web/css01.jpg"></li></ul></li></ul><h1 id="1-HTML的局限性"><a href="#1-HTML的局限性" class="headerlink" title="1.HTML的局限性"></a>1.HTML的局限性</h1><p>说起HTML，这其实是个非常单纯的家伙， 他只关注内容的语义， </p><p>比如</p><h1>表明这是一个大标题，用<p> 表明这是一个段落，用<img> 表明这儿有一个图片， 用<a> 表示此处有链接。</a></p><ul><li>HTML满足不了设计者的需求</li><li>操作html属性不方便</li><li>HTML里面添加样式带来的是无尽的臃肿和繁琐</li></ul><h1 id="2-CSS-网页的美容师"><a href="#2-CSS-网页的美容师" class="headerlink" title="2.CSS 网页的美容师"></a>2.CSS 网页的美容师</h1><ul><li>让我们的网页更加丰富多彩，布局更加灵活自如。   </li><li>CSS的最大贡献就是：  让 HTML 从样式中脱离，  实现了 HTML 专注去做 结构呈现，样式交给css </li></ul><blockquote><p><strong>我们理想中的结果： 结构(html)与样式(css)相分离</strong> </p></blockquote><h1 id="3-CSS初识"><a href="#3-CSS初识" class="headerlink" title="3.CSS初识"></a>3.CSS初识</h1><ul><li><p>概念：</p><p>​    CSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表（级联样式表）</p></li><li><p>作用：</p><ul><li>主要用于<strong>设置</strong> HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及<strong>版面的布局和外观显示样式。</strong></li><li>CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。</li></ul></li></ul><h1 id="4-引入CSS样式表（书写位置）"><a href="#4-引入CSS样式表（书写位置）" class="headerlink" title="4. 引入CSS样式表（书写位置）"></a>4. 引入CSS样式表（书写位置）</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">要书写css样式，那css样式书写的位置在哪呢？<br></code></pre></td></tr></table></figure><h2 id="4-1-行内式（内联样式）"><a href="#4-1-行内式（内联样式）" class="headerlink" title="4.1 行内式（内联样式）"></a>4.1 行内式（内联样式）</h2><ul><li><p>概念：</p><p>​    称行内样式、行间样式.</p><p>​    是通过标签的style属性来设置元素的样式</p></li></ul><ul><li>其基本语法格式如下：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;<br></code></pre></td></tr></table></figure><p>实际上任何HTML标签都拥有style属性，用来设置行内式。</p><ul><li>案例：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> style=&quot;<span class="hljs-attribute">color</span>: red; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>注意：<ul><li>style其实就是标签的属性</li><li>样式属性和值中间是<code>:</code></li><li>多组属性值之间用<code>;</code>隔开。</li><li>只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余</li></ul></li><li>缺点：<ul><li>没有实现样式和结构相分离</li></ul></li></ul><h2 id="4-2-内部样式表（内嵌样式表）"><a href="#4-2-内部样式表（内嵌样式表）" class="headerlink" title="4.2 内部样式表（内嵌样式表）"></a>4.2 内部样式表（内嵌样式表）</h2><ul><li><p>概念：</p><p>​    称内嵌式</p><p>​    是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义</p></li><li><p>其基本语法格式如下：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/CSS&quot;</span>&gt;</span><span class="css"></span><br><span class="css">    选择器（选择的标签） &#123; </span><br><span class="css">      属性<span class="hljs-number">1</span>: 属性值<span class="hljs-number">1</span>;</span><br><span class="css">      属性<span class="hljs-number">2</span>: 属性值<span class="hljs-number">2</span>; </span><br><span class="css">      属性<span class="hljs-number">3</span>: 属性值<span class="hljs-number">3</span>;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br> <span class="hljs-selector-tag">div</span> &#123;<br> <span class="hljs-attribute">color</span>: red;<br> <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br> &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li>style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。</li><li>type=”text/css”  在html5中可以省略。</li><li>只能控制当前的页面</li></ul></li><li><p>缺点：</p><p>没有彻底分离</p></li></ul><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>   <span class="hljs-comment">/*选择器&#123;属性:值；&#125;*/</span><br>   <span class="hljs-selector-tag">p</span> &#123;<br>     <span class="hljs-attribute">color</span>:<span class="hljs-number">#06C</span>; <br>     <span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;  <br>   &#125;  <span class="hljs-comment">/*文字的颜色是 蓝色*/</span><br>   <span class="hljs-selector-tag">h4</span> &#123;<br>    <span class="hljs-attribute">color</span>:<span class="hljs-number">#900</span>;<br>   &#125;<br>   <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">color</span>:<span class="hljs-number">#090</span>; <br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>; <br>   &#125;<br>   <span class="hljs-selector-tag">body</span> &#123; <br>    <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">bg2.jpg</span>);<br>   &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">思考：<br> <span class="hljs-number">1</span>. 如何实现结构与样式完全分离？<br> <span class="hljs-number">2</span>. 如何实现css样式共享？<br></code></pre></td></tr></table></figure><h2 id="4-3-外部样式表（外链式）"><a href="#4-3-外部样式表（外链式）" class="headerlink" title="4.3 外部样式表（外链式）"></a>4.3 外部样式表（外链式）</h2><ul><li><p>概念：</p><p>​    称链入式</p><p>​    是将所有的样式放在一个或多个以**.CSS**为扩展名的外部样式表文件中，</p><p>​    通过link标签将外部样式表文件链接到HTML文档中</p></li><li><p>其基本语法格式如下：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css文件路径&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>注意：  <ul><li>link 是个单标签</li><li>link标签需要放在head头部标签中，并且指定link标签的三个属性</li></ul></li></ul><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>rel</td><td align="left">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</td></tr><tr><td>type</td><td align="left">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略</td></tr><tr><td>href</td><td align="left">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</td></tr></tbody></table><p><img src="/img/web/css02.jpg"></p><h2 id="4-4-三种样式表总结（位置）"><a href="#4-4-三种样式表总结（位置）" class="headerlink" title="4.4 三种样式表总结（位置）"></a>4.4 三种样式表总结（位置）</h2><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>没有实现样式和结构相分离</td><td>较少</td><td>控制一个标签（少）</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面（中）</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多，强烈推荐</td><td>控制整个站点（多）</td></tr></tbody></table><h3 id="团队约定-代码风格"><a href="#团队约定-代码风格" class="headerlink" title="团队约定-代码风格"></a>团队约定-代码风格</h3><p>样式书写一般有两种：</p><ul><li>一种是紧凑格式 (Compact)</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> &#123; <span class="hljs-attribute">color</span>: deeppink;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>一种是展开格式（推荐）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> &#123;<br><span class="hljs-attribute">color</span>: deeppink;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="团队约定-代码大小写"><a href="#团队约定-代码大小写" class="headerlink" title="团队约定-代码大小写"></a>团队约定-代码大小写</h3><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 推荐 */</span><br><span class="hljs-selector-tag">h3</span>&#123;<br><span class="hljs-attribute">color</span>: pink;<br>&#125;<br><br><span class="hljs-comment">/* 不推荐 */</span><br><span class="hljs-selector-tag">H3</span>&#123;<br><span class="hljs-attribute">COLOR</span>: PINK;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-总结CSS样式规则"><a href="#5-总结CSS样式规则" class="headerlink" title="5. 总结CSS样式规则"></a>5. 总结CSS样式规则</h1><p>使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，</p><p>具体格式如下：                                          </p><p><img src="/img/web/css03.jpg"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><ol><li>选择器用于指定CSS样式作用的HTML标签，花括号内是对该对象设置的具体样式。</li><li>属性和属性值以“键值对”的形式出现。</li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</li><li>属性和属性值之间用英文“:”连接。</li><li>多个“键值对”之间用英文“;”进行区分。</li></ol><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="@拓展阅读"></a>@拓展阅读</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTAzMjcxNg==&mid=2651424749&idx=1&sn=f58bca144f50bff00ba7d1675cc8b8e7&scene=4">CSS的发展史</a></p><h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><ul><li>理解<ul><li>选择器的作用</li><li>id选择器和类选择器的区别</li></ul></li><li>应用<ul><li>能够使用基础选择器给页面元素添加样式</li></ul></li></ul><h2 id="1-CSS选择器作用（重点）"><a href="#1-CSS选择器作用（重点）" class="headerlink" title="1. CSS选择器作用（重点）"></a>1. CSS选择器作用（重点）</h2><h3 id="选择器的作用"><a href="#选择器的作用" class="headerlink" title="选择器的作用"></a>选择器的作用</h3><p>​    找到特定的HTML页面元素</p><p>css 就是 分两件事， 选对人，  做对事。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> &#123; <br><span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就是2件事， 把  h3选出来， 然后 把它变成了 红色。 以后我们都这么干。</p><p>选择器分为基础选择器和 复合选择器，我们这里先讲解一下 基础选择器。</p><h2 id="2-CSS基础选择器"><a href="#2-CSS基础选择器" class="headerlink" title="2. CSS基础选择器"></a>2. CSS基础选择器</h2><h3 id="2-1-标签选择器"><a href="#2-1-标签选择器" class="headerlink" title="2.1 标签选择器"></a>2.1 标签选择器</h3><ul><li><p>概念：</p><p>标签选择器（元素选择器）是指用<strong>HTML标签名</strong>称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p></li><li><p>语法：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">标签名&#123;属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; 属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; 属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>; &#125; <br></code></pre></td></tr></table></figure><ul><li><p>作用：</p><p>标签选择器 可以把某一类标签<strong>全部</strong>选择出来  比如所有的div标签  和 所有的 span标签</p></li><li><p>优点：</p><p>是能快速为页面中同类型的标签统一样式</p></li><li><p>缺点：</p><p>不能设计差异化样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">思考： 如果想要差异化选择不同的标签，怎么办呢？ 就是说 我想单独选一个或者某几个标签呢？<br></code></pre></td></tr></table></figure><h3 id="2-2-类选择器"><a href="#2-2-类选择器" class="headerlink" title="2.2 类选择器"></a>2.2 类选择器</h3><p>类选择器使用“.”（英文点号）进行标识，后面紧跟类名.</p><ul><li><p>语法：</p><ul><li>类名选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">.类名  &#123;   <br>    属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; <br>    属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; <br>    属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>;     <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>标签</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;类名&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li>可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 </li></ul></li><li><p>注意</p><ul><li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的)</li><li>长名称或词组可以使用中横线来为选择器命名。</li><li>不要纯数字、中文等命名， 尽量使用英文字母来表示。</li></ul></li></ul><p>命名规范：  见附件（Web前端开发规范手册.doc）</p><p>命名是我们通俗约定的，但是没有规定必须用这些常用的命名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    </span><br><span class="css">        <span class="hljs-selector-class">.blue</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">color</span>: blue;</span><br><span class="css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.red</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">color</span>: red;</span><br><span class="css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.orange</span> &#123;</span><br><span class="css"><span class="hljs-attribute">color</span>: orange;</span><br><span class="css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">        &#125;</span><br><span class="css"><span class="hljs-selector-class">.green</span> &#123;</span><br><span class="css"><span class="hljs-attribute">color</span>: green;</span><br><span class="css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">&#125;</span><br><span class="css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span>G<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>o<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;orange&quot;</span>&gt;</span>o<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span>g<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span>l<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-类选择器特殊用法-多类名"><a href="#2-3-类选择器特殊用法-多类名" class="headerlink" title="2.3 类选择器特殊用法- 多类名"></a>2.3 类选择器特殊用法- 多类名</h3><p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p><p><img src="/img/web/css04.jpg"></p><p>注意：</p><ul><li>各个类名中间用空格隔开。</li><li>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pink fontWeight font20&quot;</span>&gt;</span>亚瑟<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;font20&quot;</span>&gt;</span>刘备<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;font14 pink&quot;</span>&gt;</span>安其拉<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;font14&quot;</span>&gt;</span>貂蝉<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-id选择器"><a href="#2-4-id选择器" class="headerlink" title="2.4 id选择器"></a>2.4 id选择器</h3><p>id选择器使用<code>#</code>进行标识，后面紧跟id名</p><ul><li><p>其基本语法格式如下：</p><ul><li><p>id选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#id</span>名 &#123;属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; 属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; 属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>; &#125;<br></code></pre></td></tr></table></figure></li><li><p>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id名&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>元素的id值是唯一的，只能对应于文档中某一个具体的元素。</p></li><li><p>用法基本和类选择器相同。</p></li></ul><h4 id="id选择器和类选择器区别"><a href="#id选择器和类选择器区别" class="headerlink" title="id选择器和类选择器区别"></a>id选择器和类选择器区别</h4><ul><li>W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。<ul><li>类选择器（class） 好比人的名字，  是可以多次重复使用的， 比如  张伟  王伟  李伟  李娜</li><li>id选择器     好比人的身份证号码，  全中国是唯一的， 不得重复。 只能使用一次。</li></ul></li></ul><p><em><strong>id选择器和类选择器最大的不同在于 使用次数上。</strong></em></p><blockquote><p>类选择器我们在修改样式中，用的最多。<br>id选择器一般用于页面唯一性的元素身上，经常和我们后面学习的javascript 搭配使用。</p></blockquote><h3 id="2-6-通配符选择器"><a href="#2-6-通配符选择器" class="headerlink" title="2.6 通配符选择器"></a>2.6 通配符选择器</h3><ul><li><p>概念</p><p>通配符选择器用<code>*</code>号表示，  *   就是 选择所有的标签      他是所有选择器中作用范围最广的，能匹配页面中所有的元素。</p></li><li><p>其基本语法格式如下：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123; 属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; 属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; 属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>; &#125;<br></code></pre></td></tr></table></figure><p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;                    <span class="hljs-comment">/* 定义外边距*/</span><br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;                   <span class="hljs-comment">/* 定义内边距*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>注意：</p><p>会匹配页面所有的元素，降低页面响应速度，不建议随便使用</p></li></ul><h3 id="2-7-基础选择器总结"><a href="#2-7-基础选择器总结" class="headerlink" title="2.7 基础选择器总结"></a>2.7 基础选择器总结</h3><table><thead><tr><th>选择器</th><th>作用</th><th>缺点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签，比如p</td><td>不能差异化选择</td><td>较多</td><td>p { color：red;}</td></tr><tr><td>类选择器</td><td>可以选出1个或者多个标签</td><td>可以根据需求选择</td><td>非常多</td><td>.nav { color: red; }</td></tr><tr><td>id选择器</td><td>一次只能选择器1个标签</td><td>只能使用一次</td><td>不推荐使用</td><td>#nav {color: red;}</td></tr><tr><td>通配符选择器</td><td>选择所有的标签</td><td>选择的太多，有部分不需要</td><td>不推荐使用</td><td>* {color: red;}</td></tr></tbody></table><p>基础选择器我们一共学了4个，  每个都有自己的价值， 可能再某个地方都能用到。但是如果说，一定要找个最常用的，那么，肯定是类选择器。</p><h3 id="2-8-团队约定"><a href="#2-8-团队约定" class="headerlink" title="2.8 团队约定"></a>2.8 团队约定</h3><p>选择器</p><ul><li>尽量少用通用选择器 <code>*</code></li><li>尽量少用 ID 选择器</li><li>不使用无具体语义定义的标签选择器 div span </li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/* 推荐 */</span><br><span class="hljs-selector-class">.jdc</span> &#123;&#125;<br><span class="hljs-selector-tag">li</span> &#123;&#125;<br><span class="hljs-selector-tag">p</span>&#123;&#125;<br><br><span class="hljs-comment">/* 不推荐 */</span><br>*&#123;&#125;<br><span class="hljs-selector-id">#jdc</span> &#123;&#125;<br><span class="hljs-selector-tag">div</span>&#123;&#125;   因为<span class="hljs-selector-tag">div</span> 没有语义，我们尽量少用<br></code></pre></td></tr></table></figure><h1 id="CSS字体样式属性调试工具"><a href="#CSS字体样式属性调试工具" class="headerlink" title="CSS字体样式属性调试工具"></a>CSS字体样式属性调试工具</h1><ul><li>使用css字体样式完成对字体的设置</li><li>使用css外观属性给页面元素添加样式</li><li>使用常用的emment语法</li><li>能够使用开发人员工具代码调试</li></ul><h1 id="1-font字体"><a href="#1-font字体" class="headerlink" title="1.font字体"></a>1.font字体</h1><h2 id="1-1-font-size-大小"><a href="#1-1-font-size-大小" class="headerlink" title="1.1 font-size:大小"></a>1.1 font-size:大小</h2><ul><li><p>作用：</p><p>font-size属性用于设置字号</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;  <br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">20px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>单位：</p><ul><li>可以使用相对长度单位，也可以使用绝对长度单位。</li><li>相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。</li></ul></li></ul><p><img src="/img/web/css05.jpg"></p><p><strong>注意：</strong></p><ul><li>我们文字大小以后，基本就用px了，其他单位很少使用</li><li>谷歌浏览器默认的文字大小为16px</li><li>但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小</li></ul><h2 id="1-2-font-family-字体"><a href="#1-2-font-family-字体" class="headerlink" title="1.2 font-family:字体"></a>1.2 font-family:字体</h2><ul><li><p>作用：</p><p>font-family属性用于设置哪一种字体。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123; <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;微软雅黑&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</li><li>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">font-family</span>: Arial,<span class="hljs-string">&quot;Microsoft Yahei&quot;</span>, <span class="hljs-string">&quot;微软雅黑&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><blockquote><p><img src="/2017/12/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A002-CSS01/Users/clyde/Desktop/%25E5%25B0%259A%25E7%25A1%2585%25E8%25B0%25B7jvm/%25E9%25BB%2591%25E9%25A9%25AC%25E5%2589%258D%25E7%25AB%25AF%25E5%2585%25A8%25E5%25A5%2597%2520%25202019%25E5%25B9%25B4%25E6%259C%2580%25E6%2596%25B0/%25E3%2580%259027%25E3%2580%2591%25E6%25BA%2590%25E7%25A0%2581+%25E8%25AF%25BE%25E4%25BB%25B6+%25E8%25BD%25AF%25E4%25BB%25B6/%25E3%2580%259027%25E3%2580%2591%25E6%25BA%2590%25E7%25A0%2581+%25E8%25AF%25BE%25E4%25BB%25B6+%25E8%25BD%25AF%25E4%25BB%25B6/01-03%2520%25E5%2589%258D%25E7%25AB%25AF%25E5%25BC%2580%25E5%258F%2591%25E5%259F%25BA%25E7%25A1%2580/02-CSS%25E8%25B5%2584%25E6%2596%2599/02-CSS%25E8%25B5%2584%25E6%2596%2599/CSS-Day01/%25E7%25AC%2594%25E8%25AE%25B0/media/good.png">常用技巧：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 各种字体之间必须使用英文状态下的逗号隔开。<br><span class="hljs-bullet">2.</span> 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。<br><span class="hljs-bullet">3.</span> 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。<br><span class="hljs-bullet">4.</span> 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。<br></code></pre></td></tr></table></figure><h3 id="CSS-Unicode字体"><a href="#CSS-Unicode字体" class="headerlink" title="CSS Unicode字体"></a>CSS Unicode字体</h3><p><img src="/img/web/css06.jpg"></p><ul><li><p>为什么使用 Unicode字体</p><ul><li>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</li><li>xp 系统不支持 类似微软雅黑的中文。</li></ul></li><li><p>解决：</p><ul><li><p>方案一： 你可以使用英文来替代。 比如<code> font-family:&quot;Microsoft Yahei&quot;</code>。</p></li><li><p>方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">font-family: &quot;<span class="hljs-symbol">\5</span>FAE<span class="hljs-symbol">\8</span>F6F<span class="hljs-symbol">\9</span>6C5<span class="hljs-symbol">\9</span>ED1&quot;;   表示设置字体为“微软雅黑”。<br></code></pre></td></tr></table></figure></li></ul></li></ul><table><thead><tr><th>字体名称</th><th>英文名称</th><th>Unicode 编码</th></tr></thead><tbody><tr><td>宋体</td><td>SimSun</td><td>\5B8B\4F53</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>\65B0\5B8B\4F53</td></tr><tr><td>黑体</td><td>SimHei</td><td>\9ED1\4F53</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>\5FAE\8F6F\96C5\9ED1</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td><td>\6977\4F53_GB2312</td></tr><tr><td>隶书</td><td>LiSu</td><td>\96B6\4E66</td></tr><tr><td>幼园</td><td>YouYuan</td><td>\5E7C\5706</td></tr><tr><td>华文细黑</td><td>STXihei</td><td>\534E\6587\7EC6\9ED1</td></tr><tr><td>细明体</td><td>MingLiU</td><td>\7EC6\660E\4F53</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>\65B0\7EC6\660E\4F53</td></tr></tbody></table><p>为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</p><h2 id="1-3-font-weight-字体粗细"><a href="#1-3-font-weight-字体粗细" class="headerlink" title="1.3 font-weight:字体粗细"></a>1.3 font-weight:字体粗细</h2><ul><li>在html中如何将字体加粗我们可以用标签来实现<ul><li>使用 b  和 strong 标签是文本加粗。</li></ul></li><li>可以使用CSS 来实现，但是CSS 是没有语义的。</li></ul><table><thead><tr><th>属性值</th><th align="left">描述</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值（不加粗的）</td></tr><tr><td>bold</td><td align="left">定义粗体（加粗的）</td></tr><tr><td>100~900</td><td align="left">400 等同于 normal，而 700 等同于 bold  我们重点记住这句话</td></tr></tbody></table><p>提倡：</p><p>  我们平时更喜欢用数字来表示加粗和不加粗。</p><h2 id="1-4-font-style-字体风格"><a href="#1-4-font-style-字体风格" class="headerlink" title="1.4 font-style:字体风格"></a>1.4 font-style:字体风格</h2><ul><li>在html中如何将字体倾斜我们可以用标签来实现<ul><li>字体倾斜除了用 i  和 em 标签，</li></ul></li><li>可以使用CSS 来实现，但是CSS 是没有语义的</li></ul><p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值，浏览器会显示标准的字体样式  font-style: normal;</td></tr><tr><td>italic</td><td align="left">浏览器会显示斜体的字体样式。</td></tr></tbody></table><p>小技巧： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">平时我们很少给文字加斜体，反而喜欢给斜体标签（<span class="hljs-selector-tag">em</span>，<span class="hljs-selector-tag">i</span>）改为普通模式。<br></code></pre></td></tr></table></figure><h2 id="1-5-font-综合设置字体样式-重点"><a href="#1-5-font-综合设置字体样式-重点" class="headerlink" title="1.5 font:综合设置字体样式 (重点)"></a>1.5 font:综合设置字体样式 (重点)</h2><p>font属性用于对字体样式进行综合设置</p><ul><li>基本语法格式如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">font</span>: font-style  font-weight  font-size/line-height  font-family;&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：<ul><li>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li><li>其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</li></ul></li></ul><h2 id="1-6-font总结"><a href="#1-6-font总结" class="headerlink" title="1.6 font总结"></a>1.6 font总结</h2><table><thead><tr><th align="left">属性</th><th align="left">表示</th><th align="left">注意点</th></tr></thead><tbody><tr><td align="left">font-size</td><td align="left">字号</td><td align="left">我们通常用的单位是px 像素，一定要跟上单位</td></tr><tr><td align="left">font-family</td><td align="left">字体</td><td align="left">实际工作中按照团队约定来写字体</td></tr><tr><td align="left">font-weight</td><td align="left">字体粗细</td><td align="left">记住加粗是 700 或者 bold  不加粗 是 normal 或者  400  记住数字不要跟单位</td></tr><tr><td align="left">font-style</td><td align="left">字体样式</td><td align="left">记住倾斜是 italic     不倾斜 是 normal  工作中我们最常用 normal</td></tr><tr><td align="left">font</td><td align="left">字体连写</td><td align="left">1. 字体连写是有顺序的  不能随意换位置 2. 其中字号 和 字体 必须同时出现</td></tr></tbody></table><h1 id="2-CSS外观属性"><a href="#2-CSS外观属性" class="headerlink" title="2. CSS外观属性"></a>2. CSS外观属性</h1><h2 id="2-1-color-文本颜色"><a href="#2-1-color-文本颜色" class="headerlink" title="2.1 color:文本颜色"></a>2.1 color:文本颜色</h2><ul><li><p>作用：</p><p>color属性用于定义文本的颜色，</p></li><li><p>其取值方式有如下3种：</p></li></ul><table><thead><tr><th align="left">表示表示</th><th align="left">属性值</th></tr></thead><tbody><tr><td align="left">预定义的颜色值</td><td align="left">red，green，blue</td></tr><tr><td align="left">十六进制</td><td align="left">#FF0000，#FF6600，#29D794</td></tr><tr><td align="left">RGB代码</td><td align="left">rgb(255,0,0)或rgb(100%,0%,0%)</td></tr></tbody></table><ul><li><p>注意</p><p>我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如  #f00 代表红色</p></li></ul><h2 id="2-2-text-align-文本水平对齐方式"><a href="#2-2-text-align-文本水平对齐方式" class="headerlink" title="2.2 text-align:文本水平对齐方式"></a>2.2 text-align:文本水平对齐方式</h2><ul><li><p>作用：</p><p>text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性</p></li><li><p>其可用属性值如下：</p></li></ul><table><thead><tr><th>属性</th><th align="center">解释</th></tr></thead><tbody><tr><td>left</td><td align="center">左对齐（默认值）</td></tr><tr><td>right</td><td align="center">右对齐</td></tr><tr><td>center</td><td align="center">居中对齐</td></tr></tbody></table><ul><li><p>注意：</p><p>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</p></li></ul><h2 id="2-3-line-height-行间距"><a href="#2-3-line-height-行间距" class="headerlink" title="2.3 line-height:行间距"></a>2.3 line-height:行间距</h2><ul><li><p>作用：</p><p>line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p></li><li><p>单位：</p><ul><li>line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px</li></ul></li><li><p>技巧：</p></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">一般情况下，行距比字号大<span class="hljs-number">7.8</span>像素左右就可以了。<br>line-height: <span class="hljs-number">24</span>px;<br></code></pre></td></tr></table></figure><h2 id="2-4-text-indent-首行缩进"><a href="#2-4-text-indent-首行缩进" class="headerlink" title="2.4 text-indent:首行缩进"></a>2.4 text-indent:首行缩进</h2><ul><li><p>作用：</p><p>text-indent属性用于设置首行文本的缩进，</p></li><li><p>属性值</p><ul><li>其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</li><li>建议使用em作为设置单位。</li></ul></li></ul><p><strong>1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-comment">/*行间距*/</span><br>      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;<br>      <span class="hljs-comment">/*首行缩进2个字  em  1个em 就是1个字的大小*/</span><br>      <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;  <br> &#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-text-decoration-文本的装饰"><a href="#2-5-text-decoration-文本的装饰" class="headerlink" title="2.5 text-decoration 文本的装饰"></a>2.5 text-decoration 文本的装饰</h2><p>text-decoration   通常我们用于给链接修改装饰效果</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。 取消下划线（最常用）</td></tr><tr><td>underline</td><td>定义文本下的一条线。下划线 也是我们链接自带的（常用）</td></tr><tr><td>overline</td><td>定义文本上的一条线。（不用）</td></tr><tr><td>line-through</td><td>定义穿过文本下的一条线。（不常用）</td></tr></tbody></table><h2 id="2-6-CSS外观属性总结"><a href="#2-6-CSS外观属性总结" class="headerlink" title="2.6 CSS外观属性总结"></a>2.6 CSS外观属性总结</h2><table><thead><tr><th align="left">属性</th><th align="left">表示</th><th align="left">注意点</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">颜色</td><td align="left">我们通常用  十六进制   比如 而且是简写形式 #fff</td></tr><tr><td align="left">line-height</td><td align="left">行高</td><td align="left">控制行与行之间的距离</td></tr><tr><td align="left">text-align</td><td align="left">水平对齐</td><td align="left">可以设定文字水平的对齐方式</td></tr><tr><td align="left">text-indent</td><td align="left">首行缩进</td><td align="left">通常我们用于段落首行缩进2个字的距离   text-indent: 2em;</td></tr><tr><td align="left">text-decoration</td><td align="left">文本修饰</td><td align="left">记住 添加 下划线  underline  取消下划线  none</td></tr></tbody></table><h1 id="3-开发者工具（chrome）"><a href="#3-开发者工具（chrome）" class="headerlink" title="3.开发者工具（chrome）"></a>3.开发者工具（chrome）</h1><p><strong>此工具是我们的必备工具，以后代码出了问题</strong></p><p><strong>我们首先第一反应就是：</strong></p><ul><li>“按F12”或者是 “shift+ctrl+i”   打开 开发者工具。</li><li>菜单：   右击网页空白出—检查</li></ul><p><img src="/img/web/css07.jpg"></p><ul><li>通过开发人员工具小指针工具，查找页面元素</li><li>左侧是html页面结构，右侧是css样式</li></ul><p>小技巧：</p><ol><li>ctrl+滚轮 可以 放大开发者工具代码大小。</li><li>左边是HTML元素结构   右边是CSS样式。</li><li>右边CSS样式可以改动数值和颜色查看更改后效果。</li><li>ctrl + 0  复原浏览器大小</li></ol><h1 id="4-sublime快捷操作emmet语法"><a href="#4-sublime快捷操作emmet语法" class="headerlink" title="4. sublime快捷操作emmet语法"></a>4. sublime快捷操作emmet语法</h1><p>Emmet的前身是Zen coding,它使用缩写,来提高html/css的编写速度。</p><ol><li><p>生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 <div></div></p></li><li><p>如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div</p></li><li><p>如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了</p></li><li><p>如果有兄弟关系的标签，用  +  就可以了 比如 div+p  </p></li><li><p>如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了</p></li><li><p>如果生成的div 类名是有顺序的， 可以用 自增符号  $     </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.demo$*<span class="hljs-number">3</span>        <br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;demo1&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;demo2&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;demo3&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li></ol><h1 id="5-拓展阅读"><a href="#5-拓展阅读" class="headerlink" title="5. 拓展阅读@"></a>5. 拓展阅读@</h1><p><a href="https://www.w3cplus.com/tools/emmet-cheat-sheet.html">emment语法</a></p><blockquote><p>第01阶段.前端基础</p></blockquote><h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><ul><li>复合选择器<ul><li>后代选择器</li><li>并集选择器</li></ul></li><li>标签显示模式</li><li>CSS背景<ul><li>背景位置</li></ul></li><li>CSS三大特性<ul><li>优先级</li></ul></li></ul><p><img src="/img/web/css08.jpg"></p><h1 id="1-CSS复合选择器"><a href="#1-CSS复合选择器" class="headerlink" title="1. CSS复合选择器"></a>1. CSS复合选择器</h1><p> 目标</p><ul><li><p>理解</p><ul><li>理解css复合选择器分别的应用场景</li></ul></li><li><p>应用</p><ul><li>使用后代选择器给元素添加样式</li><li>使用并集选择器给元素添加样式</li><li>使用伪类选择器</li></ul></li></ul><p><strong>为什么要学习css复合选择器</strong></p><p>  CSS选择器分为 基础选择器 和 复合选择器 ，但是基础选择器不能满足我们实际开发中，快速高效的选择标签。</p><ul><li>目的是为了可以选择更准确更精细的目标元素标签。</li><li>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的</li></ul><h2 id="1-1-后代选择器（重点）"><a href="#1-1-后代选择器（重点）" class="headerlink" title="1.1 后代选择器（重点）"></a>1.1 后代选择器（重点）</h2><ul><li><p>概念：</p><p>后代选择器又称为包含选择器</p></li><li><p>作用：</p><p>用来选择元素或元素组的<strong>子孙后代</strong></p></li><li><p>其写法就是把外层标签写在前面，内层标签写在后面，中间用<strong>空格</strong>分隔，先写父亲爷爷，在写儿子孙子。 </p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">父级 子级&#123;属性:属性值;属性:属性值;&#125;<br></code></pre></td></tr></table></figure><ul><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class</span> <span class="hljs-selector-tag">h3</span>&#123;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>;&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/web/css09.jpg"></p><ul><li>当标签发生嵌套时，内层标签就成为外层标签的后代。</li><li>子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。</li></ul><h2 id="1-2-子元素选择器"><a href="#1-2-子元素选择器" class="headerlink" title="1.2 子元素选择器"></a>1.2 子元素选择器</h2><ul><li><p>作用：</p><p>子元素选择器只能选择作为某元素**子元素(亲儿子)**的元素。</p></li><li><p>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 <code>&gt;</code> 进行连接</p></li><li><p>语法：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class</span>&gt;<span class="hljs-selector-tag">h3</span>&#123;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/web/css10.jpg"></p><blockquote><p>这里的子 指的是 亲儿子  不包含孙子 重孙子之类。</p></blockquote><p>白话：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">比如：  <span class="hljs-selector-class">.demo</span> &gt; <span class="hljs-selector-tag">h3</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;   说明  <span class="hljs-selector-tag">h3</span> 一定是demo 亲儿子。  demo 元素包含着<span class="hljs-selector-tag">h3</span>。<br></code></pre></td></tr></table></figure><h2 id="1-3-交集选择器"><a href="#1-3-交集选择器" class="headerlink" title="1.3 交集选择器"></a>1.3 交集选择器</h2><ul><li><p>条件</p><p>交集选择器由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。</p></li></ul><p><img src="/img/web/css11.jpg"></p><ul><li>语法：</li></ul><p><img src="/img/web/css12.jpg"></p><ul><li>其中第一个为标签选择器，第二个为class选择器，两个选择器之间<strong>不能有空格</strong>，如h3.special。</li></ul><p><strong>记忆技巧：</strong></p><p>交集选择器 是 并且的意思。  即…又…的意思</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">比如：   <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.one</span>   选择的是： 类名为 <span class="hljs-selector-class">.one</span>  的 段落标签。  <br></code></pre></td></tr></table></figure><p>用的相对来说比较少，不太建议使用。</p><h2 id="1-4-并集选择器（重点）"><a href="#1-4-并集选择器（重点）" class="headerlink" title="1.4 并集选择器（重点）"></a>1.4 并集选择器（重点）</h2><ul><li>应用：<ul><li>如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。</li></ul></li><li>并集选择器（CSS选择器分组）是各个选择器通过<code>,</code>连接而成的，通常用于集体声明。</li><li>语法：</li></ul><p><img src="/img/web/css13.jpg"></p><ul><li><p>任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。</p></li><li><p>记忆技巧：</p><p>并集选择器通常用于集体声明  ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为 和的意思。</p></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">比如  <span class="hljs-selector-class">.one</span>, <span class="hljs-selector-tag">p</span> , <span class="hljs-selector-id">#test</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#F00</span>;&#125;  <br>表示   <span class="hljs-selector-class">.one</span> 和 <span class="hljs-selector-tag">p</span>  和 <span class="hljs-selector-id">#test</span> 这三个选择器都会执行颜色为红色。 <br>通常用于集体声明。  <br></code></pre></td></tr></table></figure><h2 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 主导航栏 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>公司首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>公司简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>公司产品<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>联系我们<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 侧导航栏 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sitenav&quot;</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site-l&quot;</span>&gt;</span>左侧侧导航栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site-r&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在不修改以上结构代码的前提下，完成以下任务：</p><ol><li>链接 登录 的颜色为红色</li><li>主导航栏里面的所有的链接改为橙色    </li><li>主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑。</li></ol><h2 id="1-5-链接伪类选择器（重点）"><a href="#1-5-链接伪类选择器（重点）" class="headerlink" title="1.5  链接伪类选择器（重点）"></a>1.5  链接伪类选择器（重点）</h2><p> 伪类选择器：</p><p> 为了和我们刚才学的类选择器相区别<br>类选择器是一个点 比如 .demo {}<br>而我们的伪类 用 2个点 就是 冒号  比如  :link{}    伪娘 </p><p>作用：</p><p>用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。</p><p>因为伪类选择器很多，比如链接伪类，结构伪类等等。我们这里先给大家讲解链接伪类选择器。</p><ul><li>a:link      /* 未访问的链接 */</li><li>a:visited   /* 已访问的链接 */</li><li>a:hover     /* 鼠标移动到链接上 */</li><li>a:active    /* 选定的链接 */</li></ul><p>  <strong>注意</strong></p><ul><li>写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。否则可能引起错误。  </li><li>记忆法  <ul><li>   <strong>l</strong>o<strong>v</strong>e   <strong>ha</strong>te     爱上了讨厌    </li><li>   **lv **包包   非常 <strong>ha</strong>o   </li></ul></li><li>因为叫链接伪类，所以都是 利用交集选择器  a:link    a:hover  </li><li>因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</li><li>实际工作开发中，我们很少写全四个状态，一般我们写法如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;   <span class="hljs-comment">/* a是标签选择器  所有的链接 */</span><br><span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br><span class="hljs-attribute">color</span>: gray;<br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;   <span class="hljs-comment">/* :hover 是链接伪类选择器 鼠标经过 */</span><br><span class="hljs-attribute">color</span>: red; <span class="hljs-comment">/*  鼠标经过的时候，由原来的 灰色 变成了红色 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-6-复合选择器总结"><a href="#1-6-复合选择器总结" class="headerlink" title="1.6 复合选择器总结"></a>1.6 复合选择器总结</h2><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择元素后代</td><td>是选择所有的子孙后代</td><td>较多</td><td>符号是<strong>空格</strong> .nav a</td></tr><tr><td>子代选择器</td><td>选择 最近一级元素</td><td>只选亲儿子</td><td>较少</td><td>符号是**&gt;**   .nav&gt;p</td></tr><tr><td>交集选择器</td><td>选择两个标签交集的部分</td><td>既是 又是</td><td>较少</td><td><strong>没有符号</strong>  p.one</td></tr><tr><td>并集选择器</td><td>选择某些相同样式的选择器</td><td>可以用于集体声明</td><td>较多</td><td>符号是<strong>逗号</strong> .nav, .header</td></tr><tr><td>链接伪类选择器</td><td>给链接更改状态</td><td></td><td>较多</td><td>重点记住 a{} 和 a:hover  实际开发的写法</td></tr></tbody></table><h1 id="2-标签显示模式（display）重点"><a href="#2-标签显示模式（display）重点" class="headerlink" title="2. 标签显示模式（display）重点"></a>2. 标签显示模式（display）重点</h1><p>目标：</p><ul><li>理解<ul><li>标签的三种显示模式</li><li>三种显示模式的特点以及区别</li><li>理解三种显示模式的相互转化</li></ul></li><li>应用<ul><li>实现三种显示模式的相互转化</li></ul></li></ul><h2 id="2-1-什么是标签显示模式"><a href="#2-1-什么是标签显示模式" class="headerlink" title="2.1 什么是标签显示模式"></a>2.1 什么是标签显示模式</h2><ul><li><p>什么是标签的显示模式？</p><p>标签以什么方式进行显示，比如div 自己占一行， 比如span 一行可以放很多个</p></li><li><p>作用： </p><p>我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</p></li><li><p>标签的类型(分类)</p><p>HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</p></li></ul><h2 id="2-2-块级元素-block-level"><a href="#2-2-块级元素-block-level" class="headerlink" title="2.2 块级元素(block-level)"></a>2.2 块级元素(block-level)</h2><ul><li>例：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">常见的块元素有<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>~<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>等，其中<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>标签是最典型的块元素。<br></code></pre></td></tr></table></figure><p><img src="/img/web/css14.jpg"></p><ul><li>块级元素的特点</li></ul><p>（1）比较霸道，自己独占一行</p><p>（2）高度，宽度、外边距以及内边距都可以控制。</p><p>（3）宽度默认是容器（父级宽度）的100%</p><p>（4）是一个容器及盒子，里面可以放行内或者块级元素。</p><ul><li>注意：<ul><li>只有 文字才 能组成段落  因此 p  里面不能放块级元素，特别是 p 不能放div </li><li>同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li></ul></li></ul><h2 id="2-3-行内元素-inline-level"><a href="#2-3-行内元素-inline-level" class="headerlink" title="2.3 行内元素(inline-level)"></a>2.3 行内元素(inline-level)</h2><ul><li>例：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">常见的行内元素有<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>等，其中<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>标签最典型的行内元素。有的地方也成内联元素<br></code></pre></td></tr></table></figure><p><img src="/img/web/css15.jpg"></p><ul><li>行内元素的特点：</li></ul><p>（1）相邻行内元素在一行上，一行可以显示多个。</p><p>（2）高、宽直接设置是无效的。</p><p>（3）默认宽度就是它本身内容的宽度。</p><p>（4）<strong>行内元素只能容纳文本或则其他行内元素。</strong></p><p>  注意：</p><ul><li>链接里面不能再放链接。</li><li>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</li></ul><h2 id="2-4-行内块元素（inline-block）"><a href="#2-4-行内块元素（inline-block）" class="headerlink" title="2.4 行内块元素（inline-block）"></a>2.4 行内块元素（inline-block）</h2><ul><li>例：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">在行内元素中有几个特殊的标签——<span class="hljs-tag">&lt;<span class="hljs-name">img</span> /&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。<br></code></pre></td></tr></table></figure><p><img src="/img/web/css16.jpg"></p><ul><li><p>行内块元素的特点：</p><p>（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个<br>（2）默认宽度就是它本身内容的宽度。<br>（3）高度，行高、外边距以及内边距都可以控制。</p></li></ul><h2 id="2-5-三种模式总结区别"><a href="#2-5-三种模式总结区别" class="headerlink" title="2.5 三种模式总结区别"></a>2.5 三种模式总结区别</h2><table><thead><tr><th>元素模式</th><th>元素排列</th><th>设置样式</th><th>默认宽度</th><th>包含</th></tr></thead><tbody><tr><td>块级元素</td><td>一行只能放一个块级元素</td><td>可以设置宽度高度</td><td>容器的100%</td><td>容器级可以包含任何标签</td></tr><tr><td>行内元素</td><td>一行可以放多个行内元素</td><td>不可以直接设置宽度高度</td><td>它本身内容的宽度</td><td>容纳文本或则其他行内元素</td></tr><tr><td>行内块元素</td><td>一行放多个行内块元素</td><td>可以设置宽度和高度</td><td>它本身内容的宽度</td><td></td></tr></tbody></table><h2 id="2-6-标签显示模式转换-display"><a href="#2-6-标签显示模式转换-display" class="headerlink" title="2.6 标签显示模式转换 display"></a>2.6 标签显示模式转换 display</h2><ul><li>块转行内：display:inline;</li><li>行内转块：display:block;</li><li>块、行内元素转换为行内块： display: inline-block;</li></ul><p>此阶段，我们只需关心这三个，其他的是我们后面的工作。</p><h1 id="3-行高那些事（line-height）"><a href="#3-行高那些事（line-height）" class="headerlink" title="3. 行高那些事（line-height）"></a>3. 行高那些事（line-height）</h1><p>目标</p><ul><li>理解<ul><li>能说出 行高  和 高度  三种关系</li><li>能简单理解为什么行高等于高度单行文字会垂直居中</li></ul></li><li>应用<ul><li>使用行高实现单行文字垂直居中</li><li>能会测量行高</li></ul></li></ul><h2 id="3-1-行高测量"><a href="#3-1-行高测量" class="headerlink" title="3.1 行高测量"></a>3.1 行高测量</h2><p>行高的测量方法：</p><p> <img src="/img/web/css17.jpg"></p><p><img src="/img/web/css18.jpg"></p><h2 id="3-2-单行文本垂直居中"><a href="#3-2-单行文本垂直居中" class="headerlink" title="3.2 单行文本垂直居中"></a>3.2 单行文本垂直居中</h2><p> 行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐。</p><blockquote><p><strong>文字的行高等于盒子的高度。</strong></p></blockquote><p>这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。</p><p>行高   =  上距离 +  内容高度  + 下距离 </p><p> <img src="/img/web/css19.jpg"></p><p>上距离和下距离总是相等的，因此文字看上去是垂直居中的。</p><p><strong>行高和高度的三种关系</strong></p><ul><li>如果 行高 等 高度  文字会 垂直居中</li><li>如果行高 大于 高度   文字会 偏下 </li><li>如果行高小于高度   文字会  偏上 </li></ul><h1 id="4-CSS-背景-background"><a href="#4-CSS-背景-background" class="headerlink" title="4. CSS 背景(background)"></a>4. CSS 背景(background)</h1><p>目标</p><ul><li>理解<ul><li>背景的作用</li><li>css背景图片和插入图片的区别</li></ul></li><li>应用<ul><li>通过css背景属性，给页面元素添加背景样式</li><li>能设置不同的背景图片位置</li></ul></li></ul><h2 id="4-1-背景颜色-color"><a href="#4-1-背景颜色-color" class="headerlink" title="4.1 背景颜色(color)"></a>4.1 背景颜色(color)</h2><ul><li><p>语法：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>:颜色值;   默认的值是 <span class="hljs-built_in">transparent</span>  透明的<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-2-背景图片-image"><a href="#4-2-背景图片-image" class="headerlink" title="4.2 背景图片(image)"></a>4.2 背景图片(image)</h2><ul><li>语法： </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span> : none | url (url) <br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>none</td><td align="center">无背景图（默认的）</td></tr><tr><td>url</td><td align="center">使用绝对或相对地址指定背景图像</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span> : <span class="hljs-built_in">url</span>(<span class="hljs-string">images/demo.png</span>);<br></code></pre></td></tr></table></figure><ul><li>小技巧：  我们提倡 背景图片后面的地址，url不要加引号。</li></ul><h2 id="4-3-背景平铺（repeat）"><a href="#4-3-背景平铺（repeat）" class="headerlink" title="4.3 背景平铺（repeat）"></a>4.3 背景平铺（repeat）</h2><ul><li>语法： </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-repeat</span> : repeat | no-repeat | repeat-x | repeat-y <br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>repeat</td><td align="center">背景图像在纵向和横向上平铺（默认的）</td></tr><tr><td>no-repeat</td><td align="center">背景图像不平铺</td></tr><tr><td>repeat-x</td><td align="center">背景图像在横向上平铺</td></tr><tr><td>repeat-y</td><td align="center">背景图像在纵向平铺</td></tr></tbody></table><h2 id="4-4-背景位置-position-重点"><a href="#4-4-背景位置-position-重点" class="headerlink" title="4.4 背景位置(position) 重点"></a>4.4 背景位置(position) 重点</h2><ul><li>语法： </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-position</span> : length || length<br><br>background-position : position || position <br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th align="center">值</th></tr></thead><tbody><tr><td>length</td><td align="center">百分数 | 由浮点数字和单位标识符组成的长度值</td></tr><tr><td>position</td><td align="center">top | center | bottom | left | center | right   方位名词</td></tr></tbody></table><ul><li>注意：<ul><li>必须先指定background-image属性</li><li>position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</li><li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致</li><li>如果只指定了一个方位名词，另一个值默认居中对齐。</li><li>如果position 后面是精确坐标， 那么第一个，肯定是 x  第二的一定是y</li><li>如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中</li><li>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</li></ul></li></ul><p><strong>实际工作用的最多的，就是背景图片居中对齐了。</strong></p><p>练习1：</p><p>背景大图</p><p>练习2：</p><p>小图片在盒子左侧垂直居中</p><h2 id="4-5-背景附着"><a href="#4-5-背景附着" class="headerlink" title="4.5 背景附着"></a>4.5 背景附着</h2><ul><li><p>背景附着就是解释背景是滚动的还是固定的</p></li><li><p>语法： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 】">background-attachment : scroll | fixed <br></code></pre></td></tr></table></figure></li></ul><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>scroll</td><td align="center">背景图像是随对象内容滚动</td></tr><tr><td>fixed</td><td align="center">背景图像固定</td></tr></tbody></table><h2 id="4-6-背景简写"><a href="#4-6-背景简写" class="headerlink" title="4.6 背景简写"></a>4.6 背景简写</h2><ul><li>background：属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：</li><li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</li><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: transparent <span class="hljs-built_in">url</span>(<span class="hljs-string">image.jpg</span>) repeat-y  scroll center top ;<br></code></pre></td></tr></table></figure><p>案例：</p><p>导航栏案例</p><h2 id="4-7-背景透明-CSS3"><a href="#4-7-背景透明-CSS3" class="headerlink" title="4.7 背景透明(CSS3)"></a>4.7 背景透明(CSS3)</h2><ul><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);<br></code></pre></td></tr></table></figure><ul><li>最后一个参数是alpha 透明度  取值范围 0~1之间</li><li>我们习惯把0.3 的 0 省略掉  这样写  background: rgba(0, 0, 0, .3);</li><li>注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</li><li>因为是CSS3 ，所以 低于 ie9 的版本是不支持的。</li></ul><h2 id="4-8-背景总结"><a href="#4-8-背景总结" class="headerlink" title="4.8 背景总结"></a>4.8 背景总结</h2><table><thead><tr><th>属性</th><th align="left">作用</th><th align="left">值</th></tr></thead><tbody><tr><td>background-color</td><td align="left">背景颜色</td><td align="left">预定义的颜色值/十六进制/RGB代码</td></tr><tr><td>background-image</td><td align="left">背景图片</td><td align="left">url(图片路径)</td></tr><tr><td>background-repeat</td><td align="left">是否平铺</td><td align="left">repeat/no-repeat/repeat-x/repeat-y</td></tr><tr><td>background-position</td><td align="left">背景位置</td><td align="left">length/position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法</td></tr><tr><td>background-attachment</td><td align="left">背景固定还是滚动</td><td align="left">scroll/fixed</td></tr><tr><td>背景简写</td><td align="left">更简单</td><td align="left">背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;  他们没有顺序</td></tr><tr><td>背景透明</td><td align="left">让盒子半透明</td><td align="left">background: rgba(0,0,0,0.3);   后面必须是 4个值</td></tr></tbody></table><h1 id="5-CSS-三大特性"><a href="#5-CSS-三大特性" class="headerlink" title="5. CSS 三大特性"></a>5. CSS 三大特性</h1><p>目标：</p><ul><li>理解<ul><li>能说出css样式冲突采取的原则</li><li>能说出那些常见的样式会有继承</li></ul></li><li>应用<ul><li>能写出CSS优先级的算法</li><li>能会计算常见选择器的叠加值</li></ul></li></ul><h2 id="5-1-CSS层叠性"><a href="#5-1-CSS层叠性" class="headerlink" title="5.1 CSS层叠性"></a>5.1 CSS层叠性</h2><p><img src="/img/web/css20.jpg"></p><ul><li><p>概念：</p><p>所谓层叠性是指多种CSS样式的叠加。</p><p>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p></li><li><p>原则：</p><ul><li>样式冲突，遵循的原则是<strong>就近原则。</strong> 那个样式离着结构近，就执行那个样式。</li><li>样式不冲突，不会层叠</li></ul></li></ul><h2 id="5-2-CSS继承性"><a href="#5-2-CSS继承性" class="headerlink" title="5.2 CSS继承性"></a>5.2 CSS继承性</h2><p><img src="/img/web/css21.jpg"></p><ul><li><p>概念：</p><p>子标签会继承父标签的某些样式，如文本颜色和字号。</p><p> 想要设置一个可继承的属性，只需将它应用于父元素即可。</p></li></ul><p>简单的理解就是：  子承父业。</p><ul><li><strong>注意</strong>：<ul><li>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</li><li>子元素可以继承父元素的样式（<strong>text-，font-，line-这些元素开头的可以继承，以及color属性</strong>）</li></ul></li></ul><h2 id="5-3-CSS优先级（重点）"><a href="#5-3-CSS优先级（重点）" class="headerlink" title="5.3 CSS优先级（重点）"></a>5.3 CSS优先级（重点）</h2><ul><li><p>概念：</p><p>定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，</p><ul><li>选择器相同，则执行层叠性</li><li>选择器不同，就会出现优先级的问题。</li></ul></li></ul><h4 id="1-权重计算公式"><a href="#1-权重计算公式" class="headerlink" title="1). 权重计算公式"></a>1). 权重计算公式</h4><p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p><table><thead><tr><th>标签选择器</th><th>计算权重公式</th></tr></thead><tbody><tr><td>继承或者 *</td><td>0,0,0,0</td></tr><tr><td>每个元素（标签选择器）</td><td>0,0,0,1</td></tr><tr><td>每个类，伪类</td><td>0,0,1,0</td></tr><tr><td>每个ID</td><td>0,1,0,0</td></tr><tr><td>每个行内样式 style=””</td><td>1,0,0,0</td></tr><tr><td>每个!important  重要的</td><td>∞ 无穷大</td></tr></tbody></table><ul><li>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 </li><li>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</li><li>div {<pre><code>color: pink!important;  </code></pre>}</li></ul><h4 id="2-权重叠加"><a href="#2-权重叠加" class="headerlink" title="2). 权重叠加"></a>2). 权重叠加</h4><p>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p><p>就是一个简单的加法计算</p><ul><li><p>div ul  li   ——&gt;      0,0,0,3</p></li><li><p>.nav ul li   ——&gt;      0,0,1,2</p></li><li><p>a:hover      —–—&gt;   0,0,1,1</p></li><li><p>.nav a       ——&gt;      0,0,1,1</p><p>注意： </p></li></ul><ol><li>数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</li></ol><h4 id="3-继承的权重是0"><a href="#3-继承的权重是0" class="headerlink" title="3). 继承的权重是0"></a>3). 继承的权重是0</h4><p>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</p><p>1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。<br>2） 如果没有选中，那么权重是0，因为继承的权重为0.</p><h1 id="6-CSS注释"><a href="#6-CSS注释" class="headerlink" title="6. CSS注释"></a>6. CSS注释</h1><p><strong>CSS注释规则：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*  需要注释的内容  */</span>  进行注释的，即在需要注释的内容前使用 <span class="hljs-string">&quot;/*&quot;</span> 标记开始注释，在内容的结尾使用 <span class="hljs-string">&quot;*/&quot;</span>结束。<br></code></pre></td></tr></table></figure><p>   例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br> <span class="hljs-comment">/* 所有的字体是14像素大小*/</span><br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;                 <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>第01阶段.前端基础.盒子模型</p></blockquote><h1 id="盒子模型（CSS重点）"><a href="#盒子模型（CSS重点）" class="headerlink" title="盒子模型（CSS重点）"></a>盒子模型（CSS重点）</h1><p>css学习三大重点： css 盒子模型   、  浮动  、  定位  </p><p>主题思路：</p><p><img src="/img/web/css23.jpg"></p><p>目标： </p><ul><li>理解：<ul><li>能说出盒子模型有那四部分组成</li><li>能说出内边距的作用以及对盒子的影响</li><li>能说出padding设置不同数值个数分别代表的意思</li><li>能说出块级盒子居中对齐需要的2个条件</li><li>能说出外边距合并的解决方法</li></ul></li><li>应用：<ul><li>能利用边框复合写法给元素添加边框</li><li>能计算盒子的实际大小</li><li>能利用盒子模型布局模块案例</li></ul></li></ul><h2 id="1-看透网页布局的本质"><a href="#1-看透网页布局的本质" class="headerlink" title="1.看透网页布局的本质"></a>1.看透网页布局的本质</h2><p>网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？</p><ul><li>看透网页布局的本质：<ul><li> 首先利用CSS设置好盒子的大小，然后摆放盒子的位置。</li><li> 最后把网页元素比如文字图片等等，放入盒子里面。</li><li> 以上两步 就是网页布局的本质</li></ul></li></ul><p> <img src="/img/web/css24.jpg"></p><p>我们明白了，盒子是网页布局的关键点，所以我们更应该弄明白 这个盒子有什么特点。</p><h2 id="2-盒子模型（Box-Model）"><a href="#2-盒子模型（Box-Model）" class="headerlink" title="2. 盒子模型（Box Model）"></a>2. 盒子模型（Box Model）</h2><ul><li><p>所谓盒子模型：</p><ul><li>就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</li></ul><p><img src="/img/web/css25.jpg"></p><p><strong>老师总结：</strong></p><ul><li>盒子模型有元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。</li><li>盒子里面的文字和图片等元素是 内容区域</li><li>盒子的厚度 我们成为 盒子的边框 </li><li>盒子内容与边框的距离是内边距（类似单元格的 cellpadding)</li><li>盒子与盒子之间的距离是外边距（类似单元格的 cellspacing）</li></ul></li></ul><p><strong>标准盒子模型</strong></p><p> <img src="/img/web/css26.jpg"></p><h2 id="3-盒子边框（border）"><a href="#3-盒子边框（border）" class="headerlink" title="3. 盒子边框（border）"></a>3. 盒子边框（border）</h2><p>​    <img src="/img/web/css27.jpg"></p><ul><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span> : border-width || border-style || border-color <br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th align="center">作用</th></tr></thead><tbody><tr><td>border-width</td><td align="center">定义边框粗细，单位是px</td></tr><tr><td>border-style</td><td align="center">边框的样式</td></tr><tr><td>border-color</td><td align="center">边框颜色</td></tr></tbody></table><ul><li>边框的样式：<ul><li>none：没有边框即忽略所有边框的宽度（默认值）</li><li>solid：边框为单实线(最为常用的)</li><li>dashed：边框为虚线  </li><li>dotted：边框为点线</li></ul></li></ul><h3 id="3-1-边框综合设置"><a href="#3-1-边框综合设置" class="headerlink" title="3.1 边框综合设置"></a>3.1 边框综合设置</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span> : <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span> || <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span> || <span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span> <br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;  没有顺序  <br></code></pre></td></tr></table></figure><h3 id="3-2-盒子边框写法总结表"><a href="#3-2-盒子边框写法总结表" class="headerlink" title="3.2 盒子边框写法总结表"></a>3.2 盒子边框写法总结表</h3><p>很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。</p><table><thead><tr><th align="left">上边框</th><th align="left">下边框</th><th align="left">左边框</th><th align="left">右边框</th></tr></thead><tbody><tr><td align="left">border-top-style:样式;</td><td align="left">border-bottom-style:样式;</td><td align="left">border-left-style:样式;</td><td align="left">border-right-style:样式;</td></tr><tr><td align="left">border-top-width:宽度;</td><td align="left">border- bottom-width:宽度;</td><td align="left">border-left-width:宽度;</td><td align="left">border-right-width:宽度;</td></tr><tr><td align="left">border-top-color:颜色;</td><td align="left">border- bottom-color:颜色;</td><td align="left">border-left-color:颜色;</td><td align="left">border-right-color:颜色;</td></tr><tr><td align="left">border-top:宽度 样式 颜色;</td><td align="left">border-bottom:宽度 样式 颜色;</td><td align="left">border-left:宽度 样式 颜色;</td><td align="left">border-right:宽度 样式 颜色;</td></tr></tbody></table><h3 id="3-3-表格的细线边框"><a href="#3-3-表格的细线边框" class="headerlink" title="3.3 表格的细线边框"></a>3.3 表格的细线边框</h3><p> <img src="/img/web/css28.jpg"></p><ul><li><p>通过表格的<code>cellspacing=&quot;0&quot;</code>,将单元格与单元格之间的距离设置为0，</p></li><li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p></li><li><p>通过css属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>&#123; <span class="hljs-attribute">border-collapse</span>:collapse; &#125;  <br></code></pre></td></tr></table></figure><ul><li>collapse 单词是合并的意思</li><li>border-collapse:collapse; 表示相邻边框合并在一起。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-tag">table</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>&#125;<br><span class="hljs-selector-tag">td</span> &#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br><span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">td</span> &#123;<br><span class="hljs-attribute">border-collapse</span>: collapse;  <span class="hljs-comment">/*合并相邻边框*/</span><br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p> <img src="/img/web/css29.jpg"></p><h2 id="4-内边距（padding）"><a href="#4-内边距（padding）" class="headerlink" title="4. 内边距（padding）"></a>4. 内边距（padding）</h2><p> <img src="/img/web/css30.jpg"></p><h3 id="4-1-内边距："><a href="#4-1-内边距：" class="headerlink" title="4.1 内边距："></a>4.1 内边距：</h3><p>​    padding属性用于设置内边距。 <strong>是指 边框与内容之间的距离。</strong></p><h3 id="4-2-设置"><a href="#4-2-设置" class="headerlink" title="4.2 设置"></a>4.2 设置</h3><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>padding-left</td><td align="left">左内边距</td></tr><tr><td>padding-right</td><td align="left">右内边距</td></tr><tr><td>padding-top</td><td align="left">上内边距</td></tr><tr><td>padding-bottom</td><td align="left">下内边距</td></tr></tbody></table><p>当我们给盒子指定padding值之后， 发生了2件事情：</p><ol><li>内容和边框 有了距离，添加了内边距。</li><li>盒子会变大了。</li></ol><p> <strong>注意：  后面跟几个数值表示的意思是不一样的。</strong></p><p>我们分开写有点麻烦，我们可以不可以简写呢？</p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>1个值</td><td>padding：上下左右内边距;</td></tr><tr><td>2个值</td><td>padding: 上下内边距    左右内边距 ；</td></tr><tr><td>3个值</td><td>padding：上内边距   左右内边距   下内边距；</td></tr><tr><td>4个值</td><td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td></tr></tbody></table><p><img src="/img/web/css31.jpg"></p><p><strong>课堂一练：</strong></p><p>请写出如下内边距：</p><ol><li>要求盒子有一个左边内边距是 5像素</li><li>要求简写的形式写出  一个盒子上下是 25像素   左右是15像素。</li><li>要求简写的形式写出 一个盒子  上内边距是 12像素  下内边距是 0  左内边距是 25像素  右内边距是 10像素</li></ol><h3 id="4-3-课堂案例：-新浪导航"><a href="#4-3-课堂案例：-新浪导航" class="headerlink" title="4.3 课堂案例：  新浪导航"></a>4.3 课堂案例：  新浪导航</h3><p>新浪导航栏的核心就是因为里面的字数不一样多，所以我们不方便给宽度，还是给padding ，撑开盒子的。</p><p> <img src="/img/web/css32.jpg"></p><h3 id="4-4-内盒尺寸计算（元素实际大小）"><a href="#4-4-内盒尺寸计算（元素实际大小）" class="headerlink" title="4.4 内盒尺寸计算（元素实际大小）"></a>4.4 内盒尺寸计算（元素实际大小）</h3><p><img src="/img/web/css33.jpg"></p><ul><li><p>宽度</p><p>Element Height = content height + padding + border （Height为内容高度）</p></li><li><p>高度</p><p>Element Width = content width + padding + border （Width为内容宽度）</p></li><li><p>盒子的实际的大小 =   内容的宽度和高度 +  内边距   +  边框   </p></li></ul><h3 id="4-5-内边距产生的问题"><a href="#4-5-内边距产生的问题" class="headerlink" title="4.5 内边距产生的问题"></a>4.5 内边距产生的问题</h3><ul><li><p>问题</p><p><img src="/img/web/css34.jpg"></p><p>会撑大原来的盒子</p></li><li><p>解决：</p><h6 id="通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小"><a href="#通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小" class="headerlink" title="通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小"></a>通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小</h6><p><img src="/img/web/css35.jpg"></p></li></ul><p><strong>课堂一练</strong></p><ol><li>一个盒子宽度为100， padding为 10， 边框为5像素，问这个盒子实际的宽度的是（）</li></ol><ul><li><p><input checked disabled type="checkbox">  (A) 130</p></li><li><p><input disabled type="checkbox">  (B) 135 </p></li><li><p><input disabled type="checkbox">  (C) 125</p></li><li><p><input disabled type="checkbox">  (D) 115</p><p>100 +  20 + 10 </p></li></ul><ol start="2"><li>关于根据下列代码计算 盒子宽高下列说法正确的是（）</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><br><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br>         <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br><br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000000</span>;<br><br><span class="hljs-attribute">border-top</span>: <span class="hljs-number">5px</span> solid blue;<br><br><span class="hljs-attribute">padding</span>: <span class="hljs-number">50px</span>;<br><br><span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input disabled type="checkbox"> (A) 宽度为200px 高度为200px</li><li><input checked disabled type="checkbox"> (B) 宽度为352px 高度为306px</li><li><input disabled type="checkbox"> (C) 宽度为302px 高度为307px</li><li><input disabled type="checkbox"> (D) 宽度为302px 高度为252px</li></ul><p>w  200 +   150   + 2   =  352</p><p>h   200 +  100 +  6   =  306 </p><h3 id="4-6-padding不影响盒子大小情况"><a href="#4-6-padding不影响盒子大小情况" class="headerlink" title="4.6 padding不影响盒子大小情况"></a>4.6 padding不影响盒子大小情况</h3><blockquote><p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。</p></blockquote><h2 id="5-外边距（margin）"><a href="#5-外边距（margin）" class="headerlink" title="5. 外边距（margin）"></a>5. 外边距（margin）</h2><p><img src="/img/web/css36.jpg"></p><h3 id="5-1-外边距"><a href="#5-1-外边距" class="headerlink" title="5.1 外边距"></a>5.1 外边距</h3><p>​    margin属性用于设置外边距。  margin就是控制<strong>盒子和盒子之间的距离</strong></p><h3 id="5-2-设置："><a href="#5-2-设置：" class="headerlink" title="5.2 设置："></a>5.2 设置：</h3><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>margin-left</td><td align="left">左外边距</td></tr><tr><td>margin-right</td><td align="left">右外边距</td></tr><tr><td>margin-top</td><td align="left">上外边距</td></tr><tr><td>margin-bottom</td><td align="left">下外边距</td></tr></tbody></table><p>margin值的简写 （复合写法）代表意思  跟 padding 完全相同。</p><h3 id="5-3-块级盒子水平居中"><a href="#5-3-块级盒子水平居中" class="headerlink" title="5.3 块级盒子水平居中"></a>5.3 块级盒子水平居中</h3><ul><li>可以让一个块级盒子实现水平居中必须：<ul><li>盒子必须指定了宽度（width）</li><li>然后就给<strong>左右的外边距都设置为auto</strong>，</li></ul></li></ul><p>实际工作中常用这种方式进行网页布局，示例代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.header</span>&#123; <span class="hljs-attribute">width</span>:<span class="hljs-number">960px</span>; <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;&#125;<br></code></pre></td></tr></table></figure><p>常见的写法，以下下三种都可以。</p><ul><li>margin-left: auto;   margin-right: auto;</li><li>margin: auto;</li><li>margin: 0 auto;</li></ul><h3 id="5-4-文字居中和盒子居中区别"><a href="#5-4-文字居中和盒子居中区别" class="headerlink" title="5.4 文字居中和盒子居中区别"></a>5.4 文字居中和盒子居中区别</h3><ol><li> 盒子内的文字水平居中是  text-align: center,  而且还可以让 行内元素和行内块居中对齐</li><li> 块级盒子水平居中  左右margin 改为 auto </li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-align</span>: center; <span class="hljs-comment">/*  文字 行内元素 行内块元素水平居中 */</span><br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> auto;  <span class="hljs-comment">/* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */</span><br></code></pre></td></tr></table></figure><h3 id="5-5-插入图片和背景图片区别"><a href="#5-5-插入图片和背景图片区别" class="headerlink" title="5.5 插入图片和背景图片区别"></a>5.5 插入图片和背景图片区别</h3><ol><li>插入图片 我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin</li><li>背景图片我们一般用于小图标背景 或者 超大背景图片  背景图片 只能通过  background-position</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;  <br><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-comment">/* 插入图片更改大小 width 和 height */</span><br><span class="hljs-attribute">height</span>: <span class="hljs-number">210px</span>;<br><span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;  <span class="hljs-comment">/* 插入图片更改位置 可以用margin 或padding  盒模型 */</span><br><span class="hljs-attribute">margin-left</span>: <span class="hljs-number">50px</span>; <span class="hljs-comment">/* 插入当图片也是一个盒子 */</span><br>&#125;<br><br><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid purple;<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">images/sun.jpg</span>) no-repeat;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">30px</span> <span class="hljs-number">50px</span>; <span class="hljs-comment">/* 背景图片更改位置 我用 background-position */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-6-清除元素的默认内外边距-重要"><a href="#5-6-清除元素的默认内外边距-重要" class="headerlink" title="5.6 清除元素的默认内外边距(重要)"></a>5.6 清除元素的默认内外边距(重要)</h3><p><img src="/img/web/css37.jpg"></p><p>为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除</p><p>代码： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>   <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;         <span class="hljs-comment">/* 清除内边距 */</span><br>   <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;          <span class="hljs-comment">/* 清除外边距 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：  </p><ul><li>行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</li></ul><h3 id="5-7-外边距合并"><a href="#5-7-外边距合并" class="headerlink" title="5.7 外边距合并"></a>5.7 外边距合并</h3><p>使用margin定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><h4 id="1-相邻块元素垂直外边距的合并"><a href="#1-相邻块元素垂直外边距的合并" class="headerlink" title="(1). 相邻块元素垂直外边距的合并"></a>(1). 相邻块元素垂直外边距的合并</h4><ul><li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li><li>下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和</li><li><strong>取两个值中的较大者</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li></ul><p> <img src="/img/web/css38.jpg"></p><p><strong>解决方案：尽量给只给一个盒子添加margin值</strong>。</p><h4 id="2-嵌套块元素垂直外边距的合并（塌陷）"><a href="#2-嵌套块元素垂直外边距的合并（塌陷）" class="headerlink" title="(2). 嵌套块元素垂直外边距的合并（塌陷）"></a>(2). 嵌套块元素垂直外边距的合并（塌陷）</h4><ul><li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li><li>父元素的上外边距会与子元素的上外边距发生合并</li><li>合并后的外边距为两者中的较大者</li></ul><p> <img src="/img/web/css39.jpg"></p><p><strong>解决方案：</strong></p><ol><li>可以为父元素定义上边框。</li><li>可以为父元素定义上内边距</li><li>可以为父元素添加overflow:hidden。</li></ol><p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p><h2 id="6-盒子模型布局稳定性"><a href="#6-盒子模型布局稳定性" class="headerlink" title="6. 盒子模型布局稳定性"></a>6. 盒子模型布局稳定性</h2><ul><li><p>学习完盒子模型，内边距和外边距，什么情况下用内边距，什么情况下用外边距？</p><ul><li>大部分情况下是可以混用的。  就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。</li></ul></li></ul><p>我们根据稳定性来分，建议如下：</p><p>按照 优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。   </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span> &gt;  <span class="hljs-attribute">padding</span>  &gt;   <span class="hljs-attribute">margin</span>   <br></code></pre></td></tr></table></figure><ul><li>原因：<ul><li>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</li><li>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</li><li>width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。</li></ul></li></ul><h2 id="7-ps基本操作以及常用快捷键："><a href="#7-ps基本操作以及常用快捷键：" class="headerlink" title="7. ps基本操作以及常用快捷键："></a>7. ps基本操作以及常用快捷键：</h2><p>因为网页美工大部分效果图都是利用ps 来做的，所以，以后我们大部分切图工作都是在ps里面完成。</p><ul><li>文件–打开 –  可以打开 我们要测量的图片</li><li>ctrl+r 可以打开标尺  或者  视图 –  标尺</li><li>右击标尺，  把里面的单位改为  像素  </li><li>ctrl+ 加号 键  可以 放大  视图  ctrl+ 减号 缩小视图</li><li>按住空格键，  鼠标可以 变成小手 ，拖动 ps 视图</li><li>用选区 拖动  可以 测量 大小 </li><li>ctrl+ d  可以取消选区  或者旁边空白处点击一下也可以取消选区</li></ul><p><img src="/img/web/css40.jpg"></p><h4 id="去掉列表默认的样式"><a href="#去掉列表默认的样式" class="headerlink" title="去掉列表默认的样式"></a>去掉列表默认的样式</h4><p>无序和有序列表前面默认的列表样式，在不同浏览器显示效果不一样，而且也比较难看，所以，我们一般上来就直接去掉这些列表样式就行了。 代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> &#123; <span class="hljs-attribute">list-style</span>: none; &#125;<br></code></pre></td></tr></table></figure><h2 id="9-今日总结"><a href="#9-今日总结" class="headerlink" title="9. 今日总结"></a>9. 今日总结</h2><p><img src="/img/web/css41.jpg"></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展@"></a>拓展@</h1><p>以下我们讲的CSS3部分新属性， 但是我们遵循的原则是，以下内容，不会影响我们页面布局， 只是样式更好看了而已。</p><h2 id="1-圆角边框-CSS3"><a href="#1-圆角边框-CSS3" class="headerlink" title="1.圆角边框(CSS3)"></a>1.圆角边框(CSS3)</h2><ul><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>:length;  <br></code></pre></td></tr></table></figure><ul><li><p>其中每一个值可以为 数值或百分比的形式。 </p></li><li><p>技巧： 让一个正方形  变成圆圈 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br></code></pre></td></tr></table></figure></li></ul><p> <img src="/img/web/css42.jpg"></p><ul><li>以上效果图矩形的圆角， 就不要用 百分比了，因为百分比会是表示高度和宽度的一半。</li><li>而我们这里矩形就只用 用 高度的一半就好了。精确单位。</li></ul><h2 id="2-盒子阴影-CSS3"><a href="#2-盒子阴影-CSS3" class="headerlink" title="2. 盒子阴影(CSS3)"></a>2. 盒子阴影(CSS3)</h2><ul><li>语法:</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>:水平阴影 垂直阴影 模糊距离（虚实）  阴影尺寸（影子大小）  阴影颜色  内/外阴影；<br></code></pre></td></tr></table></figure><p><img src="/img/web/css43.jpg"></p><ul><li>前两个属性是必须写的。其余的可以省略。</li><li>外阴影 (outset) 是默认的 但是不能写           想要内阴影可以写  inset </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;<br><span class="hljs-comment">/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */</span><br><span class="hljs-comment">/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */</span><br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">30px</span>  <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">4</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h1><h2 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h2><p>【强制】 选择器 与 { 之间必须包含空格。</p><p>示例： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.selector</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br></code></pre></td></tr></table></figure><h2 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h2><p>【强制】 并集选择器，每个选择器声明必须独占一行。</p><p>示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* good */</span><br><span class="hljs-selector-class">.post</span>,<br><span class="hljs-selector-class">.page</span>,<br><span class="hljs-selector-class">.comment</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br><br><br><span class="hljs-comment">/* bad */</span><br><span class="hljs-selector-class">.post</span>, <span class="hljs-selector-class">.page</span>, <span class="hljs-selector-class">.comment</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>【建议】 一般情况情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* good */</span><br><span class="hljs-selector-id">#username</span> <span class="hljs-selector-tag">input</span> &#123;&#125;<br><span class="hljs-selector-class">.comment</span> <span class="hljs-selector-class">.avatar</span> &#123;&#125;<br><br><span class="hljs-comment">/* bad */</span><br><span class="hljs-selector-class">.page</span> <span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.login</span>  <span class="hljs-selector-tag">input</span> &#123;&#125;<br><span class="hljs-selector-class">.comment</span> <span class="hljs-selector-tag">div</span> * &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h2><p>【强制】 属性定义必须另起一行。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* good */</span><br><span class="hljs-selector-class">.selector</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* bad */</span><br><span class="hljs-selector-class">.selector</span> &#123; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure><p>【强制】 属性定义后必须以分号结尾。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* good */</span><br><span class="hljs-selector-class">.selector</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* bad */</span><br><span class="hljs-selector-class">.selector</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-浮动-float"><a href="#1-浮动-float" class="headerlink" title="1. 浮动(float)"></a>1. 浮动(float)</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul><li><strong>记忆</strong><ul><li>能够说出 CSS 的布局的三种机制</li></ul></li><li><strong>理解</strong><ul><li>能够说出普通流在布局中的特点</li><li>能够说出我们为什么用浮动</li><li>能够说出我们为什么要清除浮动</li></ul></li><li><strong>应用</strong><ul><li>能够利用浮动完成导航栏案例</li><li>能够清除浮动</li><li>能够使用PS切图工具</li></ul></li></ul><h3 id="1-1-CSS-布局的三种机制"><a href="#1-1-CSS-布局的三种机制" class="headerlink" title="1.1 CSS 布局的三种机制"></a>1.1 CSS 布局的三种机制</h3><blockquote><p>网页布局的核心——就是<strong>用 CSS 来摆放盒子</strong>。</p></blockquote><p>CSS 提供了 <strong>3 种机制</strong>来设置盒子的摆放位置，分别是<strong>普通流</strong>（标准流）、<strong>浮动</strong>和<strong>定位</strong>，其中： </p><ol><li><strong>普通流</strong>（标准流）<ul><li><strong>块级元素</strong>会独占一行，<strong>从上向下</strong>顺序排列；<ul><li>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li></ul></li><li><strong>行内元素</strong>会按照顺序，<strong>从左到右</strong>顺序排列，碰到父元素边缘则自动换行；<ul><li>常用元素：span、a、i、em等</li></ul></li></ul></li><li><strong>浮动</strong><ul><li>让盒子从普通流中<strong>浮</strong>起来,主要作用让多个块级盒子一行显示。</li></ul></li><li><strong>定位</strong><ul><li>将盒子<strong>定</strong>在浏览器的某一个<strong>位</strong>置——CSS 离不开定位，特别是后面的 js 特效。</li></ul></li></ol><h3 id="1-2-为什么需要浮动？"><a href="#1-2-为什么需要浮动？" class="headerlink" title="1.2 为什么需要浮动？"></a>1.2 为什么需要浮动？</h3><p>思考题：</p><p> 我们首先要思考以下2个布局中最常见的问题？</p><ol><li><p>如何让多个盒子(div)水平排列成一行？</p><p><img src="/img/web/css44.jpg"></p></li><li><p>如何实现盒子的左右对齐？</p><p><img src="/img/web/css45.jpg"></p></li></ol><p>虽然我们前面学过行内块（inline-block） 但是他却有自己的缺陷：</p><ol><li>它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。</li><li>它不能实现以上第二个问题，盒子左右对齐 </li></ol><blockquote><p>因为一些网页布局要求，标准流不能满足我们的需要了，因此我们需要浮动来完成网页布局。</p></blockquote><h3 id="1-3-什么是浮动-float"><a href="#1-3-什么是浮动-float" class="headerlink" title="1.3  什么是浮动(float)"></a>1.3  什么是浮动(float)</h3><p><strong>概念</strong>：元素的浮动是指<strong>设置了浮动属性的元素</strong>会</p><ol><li>脱离标准普通流的控制</li><li>移动到指定位置。</li></ol><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</li><li>可以实现盒子的左右对齐等等..</li><li>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。</li></ol><p><img src="/img/web/css46.jpg"></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>在 CSS 中，通过 <code>float</code>  中文，  浮 漏 特    属性定义浮动，语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">float</span>: 属性值; &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>none</strong></td><td>元素不浮动（<strong>默认值</strong>）</td></tr><tr><td><strong>left</strong></td><td>元素向<strong>左</strong>浮动</td></tr><tr><td><strong>right</strong></td><td>元素向<strong>右</strong>浮动</td></tr></tbody></table><h4 id="1-浮动口诀之-浮"><a href="#1-浮动口诀之-浮" class="headerlink" title="1). 浮动口诀之 浮"></a>1). 浮动口诀之 浮</h4><p>浮动——浮<del>浮</del>浮~~~漂浮在普通流的上面。  脱离标准流。 俗称 “脱标”   </p><p> <img src="/img/web/css47.jpg"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.box2</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><ul><li><code>float</code> 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。</li></ul><h4 id="2-浮动口诀之-漏"><a href="#2-浮动口诀之-漏" class="headerlink" title="2).  浮动口诀之 漏"></a>2).  浮动口诀之 漏</h4><p>浮动——漏<del>漏</del>漏~  浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-comment">/* 让第 1 个盒子漂浮起来，不占位置 */</span><br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.box2</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p> 所以，box2下面的其实就是跑到box1盒子下面了， 被box1给压住了，遮挡起来了</p><p>来来来，我们看个立体图</p><p><img src="/img/web/css48.gif"></p><h4 id="3-浮动口诀之-特"><a href="#3-浮动口诀之-特" class="headerlink" title="3). 浮动口诀之 特"></a>3). 浮动口诀之 特</h4><p>浮动——特性  float属性会改变元素display属性。</p><p>任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似。</p><p>体验案例——div 水平排列</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br><br>    <span class="hljs-attribute">background-color</span>: pink;<br><br>    <span class="hljs-comment">/* 转换为行内块元素，可以水平显示，不过 div 之间有间隙，不方便处理 */</span><br><br>    <span class="hljs-comment">/* display: inline-block; */</span><br><br>    <span class="hljs-comment">/* 设置浮动属性，可以让 div 水平排列，并且没有间隙 */</span><br><br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.two</span> &#123;<br><br>    <span class="hljs-attribute">background-color</span>: hotpink;<br><br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="/img/web/css49.jpg"></p><p><strong>注意： 浮动的元素互相贴靠一起的，但是如果父级宽度装不下这些浮动的盒子， 多出的盒子会另起一行对齐</strong></p><h3 id="1-4-浮动-float-小结"><a href="#1-4-浮动-float-小结" class="headerlink" title="1.4 浮动(float)小结"></a>1.4 浮动(float)小结</h3><blockquote><p>我们使用浮动的核心目的——让多个块级盒子在同一行显示。 因为这是我们最常见的一种布局方式</p></blockquote><p><strong>float</strong> —— <strong>浮漏特</strong></p><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>浮</td><td>加了浮动的盒子<strong>是浮起来</strong>的，漂浮在其他标准流盒子的上面。</td></tr><tr><td>漏</td><td>加了浮动的盒子<strong>是不占位置的</strong>，它原来的位置<strong>漏给了标准流的盒子</strong>。</td></tr><tr><td>特</td><td><strong>特别注意</strong>：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙</td></tr></tbody></table><h3 id="1-5-浮动-float-的应用（重要）"><a href="#1-5-浮动-float-的应用（重要）" class="headerlink" title="1.5 浮动(float)的应用（重要）"></a>1.5 浮动(float)的应用（重要）</h3><h4 id="浮动和标准流的父盒子搭配"><a href="#浮动和标准流的父盒子搭配" class="headerlink" title="浮动和标准流的父盒子搭配"></a>浮动和标准流的父盒子搭配</h4><p>我们知道，浮动是脱标的，会影响下面的标准流元素，此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。</p><blockquote><p>一个完整的网页，是 标准流 +  浮动 +  我们后面要讲的定位 一起完成的。</p></blockquote><h4 id="浮动应用案例"><a href="#浮动应用案例" class="headerlink" title="浮动应用案例"></a>浮动应用案例</h4><p><img src="/img/web/css50.jpg"></p><h4 id="导航栏案例"><a href="#导航栏案例" class="headerlink" title="导航栏案例"></a>导航栏案例</h4><p><img src="/img/web/css51.jpg"></p><p>注意，实际重要的导航栏中，我们不会直接用链接a 而是用 li  包含链接(li+a)的做法。</p><ol><li>li+a 语义更清晰，一看这就是有条理的列表型内容。</li><li>如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名</li></ol><h3 id="1-6-浮动-float-的扩展"><a href="#1-6-浮动-float-的扩展" class="headerlink" title="1.6  浮动(float)的扩展"></a>1.6  浮动(float)的扩展</h3><h4 id="1-浮动元素与父盒子的关系"><a href="#1-浮动元素与父盒子的关系" class="headerlink" title="1). 浮动元素与父盒子的关系"></a>1). 浮动元素与父盒子的关系</h4><ul><li>子盒子的浮动参照父盒子对齐</li><li>不会与父盒子的边框重叠，也不会超过父盒子的内边距<br><img src="/img/web/css52.jpg"></li></ul><h4 id="2-浮动元素与兄弟盒子的关系"><a href="#2-浮动元素与兄弟盒子的关系" class="headerlink" title="2). 浮动元素与兄弟盒子的关系"></a>2). 浮动元素与兄弟盒子的关系</h4><p>在一个父级盒子中，如果<strong>前一个兄弟盒子</strong>是：</p><ul><li><strong>浮动</strong>的，那么<strong>当前盒子</strong>会与前一个盒子的顶部对齐；</li><li><strong>普通流</strong>的，那么<strong>当前盒子</strong>会显示在前一个兄弟盒子的下方。 </li></ul><blockquote><p>浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。</p></blockquote><p> <img src="/img/web/css53.jpg"></p><p><strong>建议</strong></p><p><strong>如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</strong></p><h2 id="2-清除浮动"><a href="#2-清除浮动" class="headerlink" title="2. 清除浮动"></a>2. 清除浮动</h2><h3 id="2-1-为什么要清除浮动"><a href="#2-1-为什么要清除浮动" class="headerlink" title="2.1 为什么要清除浮动"></a>2.1 为什么要清除浮动</h3><p>因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。</p><p><img src="/img/web/css54.jpg"></p><p><img src="/img/web/css55.jpg"></p><ul><li>总结：<ul><li>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响</li><li>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></li></ul></li></ul><h3 id="2-2-清除浮动本质"><a href="#2-2-清除浮动本质" class="headerlink" title="2.2 清除浮动本质"></a>2.2 清除浮动本质</h3><p><strong>清除浮动本质：</strong></p><p>​    <strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></p><h3 id="2-3-清除浮动的方法"><a href="#2-3-清除浮动的方法" class="headerlink" title="2.3 清除浮动的方法"></a>2.3 清除浮动的方法</h3><p>在CSS中，clear属性用于清除浮动，在这里，我们先记住清除浮动的方法，具体的原理，等我们学完css会再回头分析。</p><ul><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器&#123;<span class="hljs-attribute">clear</span>:属性值;&#125;   <span class="hljs-attribute">clear</span> 清除  <br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td>right</td><td>不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td>both</td><td>同时清除左右两侧浮动的影响</td></tr></tbody></table><p>但是我们实际工作中， 几乎只用 clear: both;</p><h4 id="1-额外标签法-隔墙法"><a href="#1-额外标签法-隔墙法" class="headerlink" title="1).额外标签法(隔墙法)"></a>1).额外标签法(隔墙法)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">”clear:both”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>，或则其他标签br等亦可。<br></code></pre></td></tr></table></figure><ul><li>优点： 通俗易懂，书写方便</li><li>缺点： 添加许多无意义的标签，结构化较差。</li></ul><h4 id="2-父级添加overflow属性方法"><a href="#2-父级添加overflow属性方法" class="headerlink" title="2).父级添加overflow属性方法"></a>2).父级添加overflow属性方法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">可以给父级添加： <span class="hljs-attribute">overflow</span>为 hidden| <span class="hljs-attribute">auto</span>| scroll  都可以实现。<br></code></pre></td></tr></table></figure><p>优点：  代码简洁</p><p>缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p><h4 id="3-使用after伪元素清除浮动"><a href="#3-使用after伪元素清除浮动" class="headerlink" title="3).使用after伪元素清除浮动"></a>3).使用after伪元素清除浮动</h4><p><strong>:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</strong> </p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>:after &#123;  content: <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-attribute">display</span>: block; <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">clear</span>: both; <span class="hljs-attribute">visibility</span>: hidden;  &#125;   <br><br><span class="hljs-selector-class">.clearfix</span> &#123;*zoom: <span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">/* IE6、7 专有 */</span><br></code></pre></td></tr></table></figure><ul><li>优点： 符合闭合浮动思想  结构语义化正确</li><li>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</li><li>代表网站： 百度、淘宝网、网易等</li></ul><p><img src="/img/web/css56.jpg"></p><h4 id="4-使用双伪元素清除浮动"><a href="#4-使用双伪元素清除浮动" class="headerlink" title="4).使用双伪元素清除浮动"></a>4).使用双伪元素清除浮动</h4><p>使用方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>:before,.clearfix:after &#123; <br>  content:<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>:table; <br>&#125;<br><span class="hljs-selector-class">.clearfix</span>:after &#123;<br> clear:both;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span> &#123;<br>  *zoom:<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优点：  代码更简洁</p></li><li><p>缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p></li><li><p>代表网站： 小米、腾讯等</p></li></ul><h3 id="2-4-清除浮动总结"><a href="#2-4-清除浮动总结" class="headerlink" title="2.4 清除浮动总结"></a>2.4 清除浮动总结</h3><p><strong>什么时候用清除浮动呢？</strong></p><ol><li>父级没高度</li><li>子盒子浮动了</li><li>影响下面布局了，我们就应该清除浮动了。</li></ol><table><thead><tr><th>清除浮动的方式</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td>额外标签法（隔墙法）</td><td align="left">通俗易懂，书写方便</td><td align="left">添加许多无意义的标签，结构化较差。</td></tr><tr><td>父级overflow:hidden;</td><td align="left">书写简单</td><td align="left">溢出隐藏</td></tr><tr><td>父级after伪元素</td><td align="left">结构语义化正确</td><td align="left">由于IE6-7不支持:after，兼容性问题</td></tr><tr><td>父级双伪元素</td><td align="left">结构语义化正确</td><td align="left">由于IE6-7不支持:after，兼容性问题</td></tr></tbody></table><p>后面两种伪元素清除浮动，大家暂且会使用就好， 深入原理，我们后面学完伪元素再讲。</p><h2 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h2><h2 id="3-Photoshop-切图"><a href="#3-Photoshop-切图" class="headerlink" title="3. Photoshop 切图"></a>3. Photoshop 切图</h2><p><strong>常见的图片格式</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> jpg图像格式： <br>JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的<br><span class="hljs-bullet">2.</span> gif图像格式：<br>GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果<br><span class="hljs-bullet">3.</span> png图像格式<br>是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景<br><span class="hljs-bullet">4.</span> PSD图像格式<br>PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。 <br></code></pre></td></tr></table></figure><p>PS切图   可以 分为   利用切片工具切图 以及   利用PS的插件快速切图。</p><h3 id="1-PS切片工具"><a href="#1-PS切片工具" class="headerlink" title="1). PS切片工具"></a>1). PS切片工具</h3><p> <img src="/img/web/css57.jpg"></p><p>ps切图片，分两大步：</p><p><strong>1). 用切片选中图片</strong></p><ul><li><p>利用切片工具手动划出</p></li><li><p>图层菜单—新建基于图层的切片</p></li><li><p>利用辅助线 来切图 –    基于参考线的切片 </p><p> <img src="/img/web/css58.jpg"></p></li></ul><p><strong>2). 导出切片</strong></p><p>  文件菜单   – 存储为web设备所用格式 —-   选择  我们要的图片格式 —-  点存储  —   别忘了选中的切片</p><h4 id="辅助线和切片使用及清除"><a href="#辅助线和切片使用及清除" class="headerlink" title="辅助线和切片使用及清除"></a>辅助线和切片使用及清除</h4><p>视图菜单– 清除 辅助线/ 清除切片</p><h3 id="2-切图插件"><a href="#2-切图插件" class="headerlink" title="2). 切图插件"></a>2). 切图插件</h3><p>Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。</p><p>官网: <a href="http://www.cutterman.cn/zh/cutterman">http://www.cutterman.cn/zh/cutterman</a></p><p>注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。</p><p><img src="/img/web/css59.gif"></p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="定位-position"><a href="#定位-position" class="headerlink" title="定位(position)"></a>定位(position)</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ul><li><strong>理解</strong><ul><li>能说出为什么要用定位</li><li>能说出定位的4种分类</li><li>能说出四种定位的各自特点</li><li>能说出我们为什么常用子绝父相布局</li></ul></li><li><strong>应用</strong><ul><li>能写出淘宝轮播图布局</li></ul></li></ul><h2 id="1-CSS-布局的三种机制"><a href="#1-CSS-布局的三种机制" class="headerlink" title="1. CSS 布局的三种机制"></a>1. CSS 布局的三种机制</h2><blockquote><p>网页布局的核心 —— 就是<strong>用 CSS 来摆放盒子位置</strong>。</p></blockquote><p>CSS 提供了 <strong>3 种机制</strong>来设置盒子的摆放位置，分别是<strong>普通流</strong>、<strong>浮动</strong>和<strong>定位</strong>，其中：</p><ol><li><p><strong>普通流</strong>（<strong>标准流</strong>）</p></li><li><p><strong>浮动</strong></p><ul><li>让盒子从普通流中<strong>浮</strong>起来 —— <strong>让多个盒子(div)水平排列成一行</strong>。</li></ul></li><li><p><strong>定位</strong></p><ul><li>将盒子<strong>定</strong>在某一个<strong>位</strong>置  自由的漂浮在其他盒子的上面  —— CSS 离不开定位，特别是后面的 js 特效。</li></ul></li></ol><h2 id="2-为什么使用定位"><a href="#2-为什么使用定位" class="headerlink" title="2. 为什么使用定位"></a>2. 为什么使用定位</h2><blockquote><p>我们先来看一个效果，同时思考一下<strong>用标准流或浮动能否实现类似的效果</strong>？</p></blockquote><p><strong>1. 小黄色块</strong>在图片上移动，<strong>吸引用户的眼球</strong>。</p><p><img src="/img/web/css60.gif"></p><p><strong>2. 当我们滚动窗口的时候，盒子是固定屏幕某个位置的</strong></p><p><img src="/img/web/css61.jpg"></p><blockquote><p><strong>结论</strong>：要实现以上效果，<strong>标准流</strong>或<strong>浮动</strong>都无法快速实现</p></blockquote><blockquote><p>将盒子<strong>定</strong>在某一个<strong>位</strong>置  自由的漂浮在其他盒子(包括标准流和浮动)的上面 </p></blockquote><p>所以，我们脑海应该有三种布局机制的上下顺序</p><p>标准流在最底层 (海底)  ——-    浮动 的盒子 在 中间层  (海面)  ——-   定位的盒子 在 最上层  （天空）</p><h2 id="3-定位详解"><a href="#3-定位详解" class="headerlink" title="3. 定位详解"></a>3. 定位详解</h2><p>定位也是用来布局的，它有两部分组成：</p><blockquote><p><code>定位 = 定位模式 + 边偏移</code></p></blockquote><h3 id="3-1-边偏移"><a href="#3-1-边偏移" class="headerlink" title="3.1 边偏移"></a>3.1 边偏移</h3><p>简单说， 我们定位的盒子，是通过边偏移来移动位置的。</p><p>在 CSS 中，通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>：（方位名词）</p><table><thead><tr><th>边偏移属性</th><th align="left">示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td align="left"><code>top: 80px</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td align="left"><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td align="left"><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td align="left"><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p><h3 id="3-2-定位模式-position"><a href="#3-2-定位模式-position" class="headerlink" title="3.2  定位模式 (position)"></a>3.2  定位模式 (position)</h3><p>在 CSS 中，通过 <code>position</code> 属性定义元素的<strong>定位模式</strong>，语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">position</span>: 属性值; &#125;<br></code></pre></td></tr></table></figure><p>定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。</p><table><thead><tr><th>值</th><th align="center">语义</th></tr></thead><tbody><tr><td><code>static</code></td><td align="center"><strong>静态</strong>定位</td></tr><tr><td><code>relative</code></td><td align="center"><strong>相对</strong>定位</td></tr><tr><td><code>absolute</code></td><td align="center"><strong>绝对</strong>定位</td></tr><tr><td><code>fixed</code></td><td align="center"><strong>固定</strong>定位</td></tr></tbody></table><p><img src="/img/web/css62.jpg"></p><h4 id="3-2-1-静态定位-static-了解"><a href="#3-2-1-静态定位-static-了解" class="headerlink" title="3.2.1 静态定位(static) - 了解"></a>3.2.1 静态定位(static) - 了解</h4><ul><li><strong>静态定位</strong>是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。</li><li>静态定位 按照标准流特性摆放位置，它没有边偏移。</li><li>静态定位在布局时我们几乎不用的 </li></ul><h4 id="3-2-1-相对定位-relative-重要"><a href="#3-2-1-相对定位-relative-重要" class="headerlink" title="3.2.1 相对定位(relative) - 重要"></a>3.2.1 相对定位(relative) - 重要</h4><ul><li><strong>相对定位</strong>是元素<strong>相对</strong>于它  原来在标准流中的位置 来说的。（自恋型）</li></ul><p><strong>效果图</strong>：</p><p><img src="/img/web/css63.jpg"></p><p>相对定位的特点：（务必记住）</p><ul><li>相对于 自己原来在标准流中位置来移动的</li><li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它。</li></ul><h4 id="3-2-3-绝对定位-absolute-重要"><a href="#3-2-3-绝对定位-absolute-重要" class="headerlink" title="3.2.3 绝对定位(absolute) - 重要"></a>3.2.3 绝对定位(absolute) - 重要</h4><p><strong>绝对定位</strong>是元素以带有定位的父级元素来移动位置 （拼爹型）</p><ol><li><p><strong>完全脱标</strong> —— 完全不占位置；  </p></li><li><p><strong>父元素没有定位</strong>，则以<strong>浏览器</strong>为准定位（Document 文档）。</p><p><img src="/img/web/css64.jpg"></p></li><li><p><strong>父元素要有定位</strong></p><ul><li>将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</li></ul></li></ol><p><img src="/img/web/css65.jpg"></p><p>绝对定位的特点：（务必记住）</p><ul><li>绝对是以带有定位的父级元素来移动位置 （拼爹型） 如果父级都没有定位，则以浏览器文档为准移动位置</li><li>不保留原来的位置，完全是脱标的。</li></ul><p>因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。</p><h5 id="定位口诀-——-子绝父相"><a href="#定位口诀-——-子绝父相" class="headerlink" title="定位口诀 —— 子绝父相"></a>定位口诀 —— 子绝父相</h5><p>刚才咱们说过，绝对定位，要和带有定位的父级搭配使用，那么父级要用什么定位呢？</p><p><strong>子绝父相</strong> —— <strong>子级</strong>是<strong>绝对</strong>定位，<strong>父级</strong>要用<strong>相对</strong>定位。</p><blockquote><p><strong>子绝父相</strong>是使用绝对定位的口诀，要牢牢记住！</p></blockquote><p><strong>疑问</strong>：为什么在布局时，<strong>子级元素</strong>使用<strong>绝对定位</strong>时，<strong>父级元素</strong>就要用<strong>相对定位</strong>呢？</p><p>观察下图，思考一下在布局时，<strong>左右两个方向的箭头图片</strong>以及<strong>父级盒子</strong>的定位方式。</p><p><img src="/img/web/css66.jpg"></p><p><strong>分析</strong>：</p><ol><li><strong>方向箭头</strong>叠加在其他图片上方，应该使用<strong>绝对定位</strong>，因为<strong>绝对定位完全脱标</strong>，完全不占位置。</li><li><strong>父级盒子</strong>应该使用<strong>相对定位</strong>，因为<strong>相对定位不脱标</strong>，后续盒子仍然以标准流的方式对待它。<ul><li>如果父级盒子也使用<strong>绝对定位</strong>，会完全脱标，那么下方的<strong>广告盒子</strong>会上移，这显然不是我们想要的。</li></ul></li></ol><p><strong>结论</strong>：<strong>父级要占有位置，子级要任意摆放</strong>，这就是<strong>子绝父相</strong>的由来。</p><h4 id="3-2-4-固定定位-fixed-重要"><a href="#3-2-4-固定定位-fixed-重要" class="headerlink" title="3.2.4 固定定位(fixed) - 重要"></a>3.2.4 固定定位(fixed) - 重要</h4><p><strong>固定定位</strong>是<strong>绝对定位</strong>的一种特殊形式： （认死理型）   如果说绝对定位是一个矩形 那么 固定定位就类似于正方形</p><ol><li><strong>完全脱标</strong> —— 完全不占位置；</li><li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；<ul><li>跟父元素没有任何关系；单独使用的</li><li>不随滚动条滚动。</li></ul></li></ol><blockquote><p>案例演练：固定定位案例。</p></blockquote><p><img src="/img/web/css67.jpg"></p><p><strong>提示</strong>：IE 6 等低版本浏览器不支持固定定位。</p><h2 id="4-定位-position-的案例"><a href="#4-定位-position-的案例" class="headerlink" title="4. 定位(position)的案例"></a>4. 定位(position)的案例</h2><h3 id="4-1-哈根达斯"><a href="#4-1-哈根达斯" class="headerlink" title="4.1 哈根达斯"></a>4.1 哈根达斯</h3><p><strong>案例截图</strong>：</p><p><img src="/img/web/css68.jpg"></p><h4 id="哈根达斯分析"><a href="#哈根达斯分析" class="headerlink" title="哈根达斯分析"></a>哈根达斯分析</h4><ol><li>一个大的 <code>div</code> 中包含 <code>3</code> 张图片；</li><li>大的 <code>div</code> 水平居中；</li><li><code>2</code> 张小图片<strong>重叠</strong>在<strong>广告</strong>图片上方 —— 脱标，不占位置，需要使用<strong>绝对定位</strong>；</li><li><code>2</code> 张小图片分别显示在<strong>左上角</strong>和<strong>右下角</strong> —— 需要<strong>使用边偏移确定准确位置</strong>。</li></ol><p><strong>案例小结</strong>：</p><ol><li><strong>子绝父相</strong> —— <strong>子元素</strong>使用<strong>绝对定位</strong>，<strong>父元素</strong>使用<strong>相对定位</strong>；</li><li><strong>与浮动的对比</strong>：<ul><li><strong>绝对定位</strong>：脱标，<strong>利用边偏移指定准确位置</strong>；</li><li><strong>浮动</strong>：脱标，不能指定准确位置，<strong>让多个块级元素在一行显示</strong>。</li></ul></li></ol><blockquote><p>课堂练习：模拟老师的随堂案例完成<strong>哈根达斯</strong>案例（5 分钟）。</p></blockquote><h3 id="4-2-仿新浪头部和广告"><a href="#4-2-仿新浪头部和广告" class="headerlink" title="4.2 仿新浪头部和广告"></a>4.2 仿新浪头部和广告</h3><p><img src="/img/web/css69.jpg"></p><h4 id="新浪案例分析"><a href="#新浪案例分析" class="headerlink" title="新浪案例分析"></a>新浪案例分析</h4><ol><li>顶部图片<strong>固定</strong>在浏览器可视窗口顶部，不会随窗口一起滚动；</li><li>左右两侧的广告图片<strong>固定</strong>在浏览器可视窗口的左右两侧，不会随窗口一起滚动；</li><li>注意：<strong>底部的内容图片</strong>初始<strong>显示在顶部图片的下方</strong>，如何解决？</li></ol><h4 id="步骤-1-——-顶部图片和底部内容"><a href="#步骤-1-——-顶部图片和底部内容" class="headerlink" title="步骤 1 —— 顶部图片和底部内容"></a>步骤 1 —— 顶部图片和底部内容</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.top</span> &#123;<br>    <span class="hljs-comment">/* 注意：使用固定定位时，如果盒子中没有内容，需要指定宽度 */</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">44px</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">images/top.png</span>) no-repeat top center;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1002px</span>;<br>    <span class="hljs-comment">/* 顶部的 44px 的 margin 可以让 box 显示在顶部图片下方 */</span><br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">44px</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>在使用固定定位时，如果盒子中没有内容，需要指定宽度</li><li>设置底部内容图片的**顶部 <code>margin</code>**，可以让底部盒子初始显示在顶部图片的下方。</li></ol><h4 id="步骤-2-——-左右两侧广告"><a href="#步骤-2-——-左右两侧广告" class="headerlink" title="步骤 2 —— 左右两侧广告"></a>步骤 2 —— 左右两侧广告</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.ad-left</span>,<br><span class="hljs-selector-class">.ad-right</span> &#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.ad-left</span> &#123;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.ad-right</span> &#123;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：不要同时使用 <code>left</code> 和 <code>right</code> 和边偏移属性。</p><p><strong>案例小结</strong>：</p><ol><li><strong>固定定位</strong>的应用场景：<strong>固定在浏览器可视窗口某个位置的布局</strong>；</li><li>在使用固定和绝对定位时，如果盒子中没有内容，需要指定宽度（稍后就讲）。</li></ol><blockquote><p>课堂练习：模拟老师的随堂案例完成<strong>仿新浪头部和广告</strong>案例（5 分钟）。</p></blockquote><h2 id="5-定位-position-的扩展"><a href="#5-定位-position-的扩展" class="headerlink" title="5. 定位(position)的扩展"></a>5. 定位(position)的扩展</h2><h3 id="5-1-绝对定位的盒子居中"><a href="#5-1-绝对定位的盒子居中" class="headerlink" title="5.1 绝对定位的盒子居中"></a>5.1 绝对定位的盒子居中</h3><blockquote><p><strong>注意</strong>：<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p></blockquote><p>在使用<strong>绝对定位</strong>时要想实现水平居中，可以按照下图的方法：</p><p><img src="/img/web/css70.jpg"></p><ol><li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li><li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li></ol><blockquote><p>案例演示：相对定位案例。</p></blockquote><h4 id="盒子居中定位示意图"><a href="#盒子居中定位示意图" class="headerlink" title="盒子居中定位示意图"></a>盒子居中定位示意图</h4><p><img src="/img/web/css71.jpg"></p><blockquote><p>课堂练习：实现<strong>盒子左中、右中、中上、中下、中中定位</strong>（5 分钟）。</p></blockquote><h3 id="5-2-堆叠顺序（z-index）"><a href="#5-2-堆叠顺序（z-index）" class="headerlink" title="5.2 堆叠顺序（z-index）"></a>5.2 堆叠顺序（z-index）</h3><p>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。</p><p>加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</p><p>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。如下图所示：</p><p><img src="/img/web/css72.jpg"></p><p><code>z-index</code> 的特性如下：</p><ol><li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li><strong>数字后面不能加单位</strong>。</li></ol><p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p><blockquote><p>案例演示：堆叠顺序。</p></blockquote><h3 id="5-3-定位改变display属性"><a href="#5-3-定位改变display属性" class="headerlink" title="5.3 定位改变display属性"></a>5.3 定位改变display属性</h3><p> 前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式:</p><ul><li>可以用inline-block  转换为行内块</li><li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li><li>绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。</li></ul><p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p><blockquote><p>完善新浪导航案例</p></blockquote><p><strong>同时注意：</strong></p><p>浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）</p><p>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p><h2 id="6-综合演练-淘宝轮播图"><a href="#6-综合演练-淘宝轮播图" class="headerlink" title="6. 综合演练 - 淘宝轮播图"></a>6. 综合演练 - 淘宝轮播图</h2><p><img src="/img/web/css73.jpg"></p><h4 id="圆角矩形设置4个角"><a href="#圆角矩形设置4个角" class="headerlink" title="圆角矩形设置4个角"></a>圆角矩形设置4个角</h4><p>圆角矩形可以为4个角分别设置圆度， 但是是有顺序的</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">border-<span class="hljs-built_in">top</span>-<span class="hljs-built_in">left</span>-radius:<span class="hljs-number">20</span>px;<br>border-<span class="hljs-built_in">top</span>-<span class="hljs-built_in">right</span>-radius:<span class="hljs-number">20</span>px;<br>border-<span class="hljs-built_in">bottom</span>-<span class="hljs-built_in">right</span>-radius:<span class="hljs-number">20</span>px;<br>border-<span class="hljs-built_in">bottom</span>-<span class="hljs-built_in">left</span>-radius:<span class="hljs-number">20</span>px;<br></code></pre></td></tr></table></figure><ul><li><p>如果4个角，数值相同</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">15px</span>;<br></code></pre></td></tr></table></figure></li><li><p>里面数值不同，我们也可以按照简写的形式，具体格式如下:</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: 左上角 右上角  右下角  左下角;<br></code></pre></td></tr></table></figure><p>还是遵循的顺时针。</p><h2 id="7-定位小结"><a href="#7-定位小结" class="headerlink" title="7. 定位小结"></a>7. 定位小结</h2><table><thead><tr><th>定位模式</th><th>是否脱标占有位置</th><th align="left">移动位置基准</th><th>模式转换（行内块）</th><th>使用情况</th></tr></thead><tbody><tr><td>静态static</td><td>不脱标，正常模式</td><td align="left">正常模式</td><td>不能</td><td>几乎不用</td></tr><tr><td>相对定位relative</td><td>不脱标，占有位置</td><td align="left">相对自身位置移动</td><td>不能</td><td>基本单独使用</td></tr><tr><td>绝对定位absolute</td><td>完全脱标，不占有位置</td><td align="left">相对于定位父级移动位置</td><td>能</td><td>要和定位父级元素搭配使用</td></tr><tr><td>固定定位fixed</td><td>完全脱标，不占有位置</td><td align="left">相对于浏览器移动位置</td><td>能</td><td>单独使用，不需要父级</td></tr></tbody></table><p><strong>注意</strong>：</p><ol><li><strong>边偏移</strong>需要和<strong>定位模式</strong>联合使用，<strong>单独使用无效</strong>；</li><li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li><li><code>left</code> 和 <code>right</code> 不要同时使用。</li></ol><h2 id="8-学成网定位总结添加"><a href="#8-学成网定位总结添加" class="headerlink" title="8.学成网定位总结添加"></a>8.学成网定位总结添加</h2><p>一个小技巧:</p><p><img src="/img/web/css74.jpg"></p><h2 id="9-网页布局总结"><a href="#9-网页布局总结" class="headerlink" title="9. 网页布局总结"></a>9. 网页布局总结</h2><p>一个完整的网页，有标准流 、 浮动 、 定位 一起完成布局的。每个都有自己的专门用法。</p><h4 id="1-标准流"><a href="#1-标准流" class="headerlink" title="1). 标准流"></a>1). 标准流</h4><p>可以让盒子上下排列 或者 左右排列的</p><h4 id="2-浮动"><a href="#2-浮动" class="headerlink" title="2). 浮动"></a>2). 浮动</h4><p>可以让多个块级元素一行显示  或者 左右对齐盒子   浮动的盒子就是按照顺序左右排列 </p><h4 id="3-定位"><a href="#3-定位" class="headerlink" title="3). 定位"></a>3). 定位</h4><p>定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。</p><h1 id="CSS高级技巧"><a href="#CSS高级技巧" class="headerlink" title="CSS高级技巧"></a>CSS高级技巧</h1><p><strong>目标</strong></p><ul><li>理解<ul><li>能说出元素显示隐藏最常见的写法</li><li>能说出精灵图产生的目的</li><li>能说出去除图片底侧空白缝隙的方法</li></ul></li><li>应用<ul><li>能写出最常见的鼠标样式</li><li>能使用精灵图技术</li><li>能用滑动门做导航栏案例</li></ul></li></ul><h2 id="1-元素的显示与隐藏"><a href="#1-元素的显示与隐藏" class="headerlink" title="1. 元素的显示与隐藏"></a>1. 元素的显示与隐藏</h2><ul><li><p>目的</p><p>让一个元素在页面中消失或者显示出来</p></li><li><p>场景</p><p>类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！</p></li></ul><h3 id="1-1-display-显示（重点）"><a href="#1-1-display-显示（重点）" class="headerlink" title="1.1 display 显示（重点）"></a>1.1 display 显示（重点）</h3><ul><li><p>display 设置或检索对象是否及如何显示。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">display</span>: none 隐藏对象<br><br><span class="hljs-built_in">display</span>：<span class="hljs-built_in">block</span> 除了转换为块级元素之外，同时还有显示元素的意思。<br></code></pre></td></tr></table></figure></li><li><p>特点： 隐藏之后，不再保留位置。</p></li></ul><p><img src="/img/web/css75.jpg"></p><p>实际开发场景：</p><blockquote><p>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p></blockquote><h3 id="1-2-visibility-可见性-了解"><a href="#1-2-visibility-可见性-了解" class="headerlink" title="1.2 visibility 可见性 (了解)"></a>1.2 visibility 可见性 (了解)</h3><ul><li><p>设置或检索是否显示对象。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">visibility</span>：visible ; 　对象可视<br><br><span class="hljs-attribute">visibility</span>：hidden; 　  对象隐藏<br></code></pre></td></tr></table></figure></li><li><p>特点： 隐藏之后，继续保留原有位置。（停职留薪）</p></li></ul><p><img src="/img/web/css76.jpg"></p><h3 id="1-3-overflow-溢出-重点"><a href="#1-3-overflow-溢出-重点" class="headerlink" title="1.3 overflow 溢出(重点)"></a>1.3 overflow 溢出(重点)</h3><ul><li>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</li></ul><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>visible</strong></td><td>不剪切内容也不添加滚动条</td></tr><tr><td><strong>hidden</strong></td><td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td></tr><tr><td><strong>scroll</strong></td><td>不管超出内容否，总是显示滚动条</td></tr><tr><td><strong>auto</strong></td><td>超出自动显示滚动条，不超出不显示滚动条</td></tr></tbody></table><p> <img src="/img/web/css77.jpg"></p><p>实际开发场景：</p><ol><li>清除浮动</li><li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li></ol><h3 id="1-4-显示与隐藏总结"><a href="#1-4-显示与隐藏总结" class="headerlink" title="1.4 显示与隐藏总结"></a>1.4 显示与隐藏总结</h3><table><thead><tr><th>属性</th><th>区别</th><th>用途</th></tr></thead><tbody><tr><td><strong>display</strong></td><td>隐藏对象，不保留位置</td><td>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td></tr><tr><td><strong>visibility</strong></td><td>隐藏对象，保留位置</td><td>使用较少</td></tr><tr><td><strong>overflow</strong></td><td>只是隐藏超出大小的部分</td><td>1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围</td></tr></tbody></table><h2 id="2-CSS用户界面样式"><a href="#2-CSS用户界面样式" class="headerlink" title="2. CSS用户界面样式"></a>2. CSS用户界面样式</h2><ul><li>所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。<ul><li>更改用户的鼠标样式 (滚动条因为兼容性非常差，我们不研究) </li><li>表单轮廓等。</li><li>防止表单域拖拽</li></ul></li></ul><h3 id="2-1-鼠标样式cursor"><a href="#2-1-鼠标样式cursor" class="headerlink" title="2.1 鼠标样式cursor"></a>2.1 鼠标样式cursor</h3><p> 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>default</strong></td><td>小白  默认</td></tr><tr><td><strong>pointer</strong></td><td>小手</td></tr><tr><td><strong>move</strong></td><td>移动</td></tr><tr><td><strong>text</strong></td><td>文本</td></tr><tr><td><strong>not-allowed</strong></td><td>禁止</td></tr></tbody></table><p> 鼠标放我身上查看效果哦：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:default&quot;</span>&gt;</span>我是小白<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:pointer&quot;</span>&gt;</span>我是小手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:move&quot;</span>&gt;</span>我是移动<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:text&quot;</span>&gt;</span>我是文本<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:not-allowed&quot;</span>&gt;</span>我是文本<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-轮廓线-outline"><a href="#2-2-轮廓线-outline" class="headerlink" title="2.2 轮廓线 outline"></a>2.2 轮廓线 outline</h3><p><img src="/img/web/css78.jpg"></p><p> 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline</span> : outline-color ||outline-style || outline-width <br></code></pre></td></tr></table></figure><p> 但是我们都不关心可以设置多少，我们平时都是去掉的。 li  </p><p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;outline: 0;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-防止拖拽文本域resize"><a href="#2-3-防止拖拽文本域resize" class="headerlink" title="2.3 防止拖拽文本域resize"></a>2.3 防止拖拽文本域resize</h3><p><img src="/img/web/css79.jpg"></p><p>实际开发中，我们文本域右下角是不可以拖拽： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;resize: none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-用户界面样式总结"><a href="#2-4-用户界面样式总结" class="headerlink" title="2.4 用户界面样式总结"></a>2.4 用户界面样式总结</h3><table><thead><tr><th>属性</th><th>用途</th><th>用途</th></tr></thead><tbody><tr><td><strong>鼠标样式</strong></td><td>更改鼠标样式cursor</td><td>样式很多，重点记住 pointer</td></tr><tr><td><strong>轮廓线</strong></td><td>表单默认outline</td><td>outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用</td></tr><tr><td>防止拖拽</td><td>主要针对文本域resize</td><td>防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none</td></tr></tbody></table><h2 id="3-vertical-align-垂直对齐"><a href="#3-vertical-align-垂直对齐" class="headerlink" title="3. vertical-align 垂直对齐"></a>3. vertical-align 垂直对齐</h2><ul><li>有宽度的块级元素居中对齐，是margin: 0 auto;</li><li>让文字居中对齐，是 text-align: center;</li></ul><p>但是我们从来没有讲过有垂直居中的属性。</p><p>vertical-align 垂直对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p><p><img src="/img/web/css80.jpg"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">vertical-align</span> : baseline |top |middle |bottom <br></code></pre></td></tr></table></figure><p>设置或检索对象内容的垂直对其方式。</p><ul><li><p>注意：</p><p>vertical-align 不影响块级元素中的内容对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p><p>特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>。</p></li></ul><h3 id="3-1-图片、表单和文字对齐"><a href="#3-1-图片、表单和文字对齐" class="headerlink" title="3.1 图片、表单和文字对齐"></a>3.1 图片、表单和文字对齐</h3><p>所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。</p><p> <img src="/img/web/css81.jpg"></p><p><img src="/img/web/css82.jpg"></p><h3 id="3-2-去除图片底侧空白缝隙"><a href="#3-2-去除图片底侧空白缝隙" class="headerlink" title="3.2 去除图片底侧空白缝隙"></a>3.2 去除图片底侧空白缝隙</h3><p><img src="/img/web/css83.jpg"></p><ul><li><p>原因：</p><p>图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。</p><p>就是图片底侧会有一个空白缝隙。</p></li><li><p>解决的方法就是：  </p><ul><li><p>给img vertical-align:middle | top| bottom等等。  让图片不要和基线对齐。</p><p><img src="/img/web/css84.jpg"></p></li><li><p>给img 添加 display：block; 转换为块级元素就不会存在问题了。</p><p><img src="/img/web/css85.jpg"></p></li></ul></li></ul><h2 id="4-溢出的文字省略号显示"><a href="#4-溢出的文字省略号显示" class="headerlink" title="4. 溢出的文字省略号显示"></a>4. 溢出的文字省略号显示</h2><h3 id="4-1-white-space"><a href="#4-1-white-space" class="headerlink" title="4.1 white-space"></a>4.1 white-space</h3><ul><li>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 </li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">white-<span class="hljs-literal">space</span>:<span class="hljs-keyword">normal</span> ；默认处理方式<br><br>white-<span class="hljs-literal">space</span>:nowrap ；　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。<br></code></pre></td></tr></table></figure><h3 id="4-2-text-overflow-文字溢出"><a href="#4-2-text-overflow-文字溢出" class="headerlink" title="4.2 text-overflow 文字溢出"></a>4.2 text-overflow 文字溢出</h3><ul><li>设置或检索是否使用一个省略标记（…）标示对象内文本的溢出</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">text-overflow : clip ；不显示省略标记（...），而是简单的裁切 <br><br>text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...）<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>一定要首先强制一行内显示，再次和overflow属性  搭配使用</p><p><img src="/img/web/css86.jpg"></p><h3 id="4-3-总结三步曲"><a href="#4-3-总结三步曲" class="headerlink" title="4.3 总结三步曲"></a>4.3 总结三步曲</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*1. 先强制一行内显示文本*/</span><br>    <span class="hljs-attribute">white-space</span>: nowrap;<br><span class="hljs-comment">/*2. 超出的部分隐藏*/</span><br>    <span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-comment">/*3. 文字用省略号替代超出的部分*/</span><br>    <span class="hljs-attribute">text-overflow</span>: ellipsis;<br></code></pre></td></tr></table></figure><h2 id="5-CSS精灵技术（sprite-重点"><a href="#5-CSS精灵技术（sprite-重点" class="headerlink" title="5. CSS精灵技术（sprite) 重点"></a>5. CSS精灵技术（sprite) 重点</h2><h3 id="5-1-为什么需要精灵技术"><a href="#5-1-为什么需要精灵技术" class="headerlink" title="5.1 为什么需要精灵技术"></a>5.1 为什么需要精灵技术</h3><p><img src="/img/web/css87.jpg"></p><p>图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。</p><p>然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。</p><p><strong>pink老师告诉你我们为什么需要精灵技术：</strong></p><blockquote><p> <strong>为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。</strong></p></blockquote><p>出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p><h3 id="5-2-精灵技术讲解"><a href="#5-2-精灵技术讲解" class="headerlink" title="5.2 精灵技术讲解"></a>5.2 精灵技术讲解</h3><p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。</p><p><img src="/img/web/css88.jpg"></p><p>这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。</p><p>我们需要使用CSS的</p><ul><li>background-image、</li><li>background-repeat</li><li>background-position属性进行背景定位，</li><li>其中最关键的是使用background-position 属性精确地定位。</li></ul><h3 id="5-3-精灵技术使用的核心总结"><a href="#5-3-精灵技术使用的核心总结" class="headerlink" title="5.3 精灵技术使用的核心总结"></a>5.3 精灵技术使用的核心总结</h3><p>首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。</p><ol><li>精确测量，每个小背景图片的大小和 位置。</li><li>给盒子指定小背景图片时， 背景定位基本都是 负值。</li></ol><h3 id="5-4-制作精灵图-了解"><a href="#5-4-制作精灵图-了解" class="headerlink" title="5.4 制作精灵图(了解)"></a>5.4 制作精灵图(了解)</h3><p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</p><p>大部分情况下，精灵图都是网页美工做。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。<br>我们可以横向摆放也可以纵向摆放，但是每个图片之间留有适当的空隙<br>在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。<br></code></pre></td></tr></table></figure><p>结束语：   小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。</p><h2 id="6-滑动门"><a href="#6-滑动门" class="headerlink" title="6. 滑动门"></a>6. 滑动门</h2><p>先来体会下现实中的滑动门,或者你可以叫做推拉门：</p><p><img src="/img/web/css89.gif"></p><h3 id="滑动门出现的背景"><a href="#滑动门出现的背景" class="headerlink" title="滑动门出现的背景"></a>滑动门出现的背景</h3><p>制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？</p><p><img src="/img/web/css90.jpg"></p><p>为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。</p><p><a href="http://weixin.qq.com/">http://weixin.qq.com/</a></p><h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h3><p>核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p><p>一般的经典布局都是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>导航栏内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>      <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br><br>    &#125;<br>    <span class="hljs-selector-tag">body</span>&#123;<br>      <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">images/wx.jpg</span>) repeat-x;<br>    &#125;<br>    <span class="hljs-selector-class">.father</span> &#123;<br>      <span class="hljs-attribute">padding-top</span>:<span class="hljs-number">20px</span>;<br>    &#125;<br>    <span class="hljs-selector-tag">li</span> &#123;<br>      <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">16px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">33px</span>;<br>      <span class="hljs-attribute">float</span>: left;<br>      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">33px</span>;<br>      <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>  <span class="hljs-number">10px</span>;<br>      <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./images/to.png</span>) no-repeat left ;<br>    &#125;<br>    <span class="hljs-selector-tag">a</span> &#123;<br>      <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">16px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">33px</span>;<br>      <span class="hljs-attribute">display</span>: inline-block;<br>      <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span>;<br>      <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./images/to.png</span>) no-repeat right ;<br>      <span class="hljs-attribute">text-decoration</span>: none;<br>    &#125;<br>    <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span>,<br>     <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">a</span> &#123;<br>      <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">./images/ao.png</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>总结： </p><ol><li>a 设置 背景左侧，padding撑开合适宽度。    </li><li>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</li><li>之所以a包含span就是因为 整个导航都是可以点击的。</li></ol><h2 id="7-拓展"><a href="#7-拓展" class="headerlink" title="7. 拓展@"></a>7. 拓展@</h2><h3 id="7-1-margin负值之美"><a href="#7-1-margin负值之美" class="headerlink" title="7.1 margin负值之美"></a>7.1 margin负值之美</h3><h4 id="1-负边距-定位：水平垂直居中"><a href="#1-负边距-定位：水平垂直居中" class="headerlink" title="1). 负边距+定位：水平垂直居中"></a>1). 负边距+定位：水平垂直居中</h4><p>咱们前面讲过， 一个绝对定位的盒子， 利用  父级盒子的 50%，  然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。</p><h4 id="2-压住盒子相邻边框"><a href="#2-压住盒子相邻边框" class="headerlink" title="2). 压住盒子相邻边框"></a>2). 压住盒子相邻边框</h4><p><img src="/img/web/css91.jpg"></p><h3 id="7-2-CSS三角形之美"><a href="#7-2-CSS三角形之美" class="headerlink" title="7.2 CSS三角形之美"></a>7.2 CSS三角形之美</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><br><span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>; <br><br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>   <span class="hljs-attribute">line-height</span>:<span class="hljs-number">0</span>；<br>   font-size: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">border-top</span>: <span class="hljs-number">10px</span> solid red;<br><br><span class="hljs-attribute">border-right</span>: <span class="hljs-number">10px</span> solid green;<br><br><span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">10px</span> solid blue;<br><br><span class="hljs-attribute">border-left</span>: <span class="hljs-number">10px</span> solid <span class="hljs-number">#000</span>; <br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>一张图， 你就知道 css 三角是怎么来的了, 做法如下：</p><p> <img src="/img/web/css92.jpg"></p><ol><li>我们用css 边框可以模拟三角效果</li><li>宽度高度为0</li><li>我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了</li><li>为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;</li></ol></h1>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea使用Gradle配置</title>
    <link href="/2017/10/24/Gradle%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    <url>/2017/10/24/Gradle%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关于idea上使用gradle"><a href="#关于idea上使用gradle" class="headerlink" title="关于idea上使用gradle"></a>关于idea上使用gradle</h1><p>​    初次在idea上使用gradle是因为遇到的项目是基于gradle配置的,对于这玩意,我个人感觉比较复杂,因为在国内环境下使用体验很糟糕,各种连不上,以前玩android的时候配置gradle花了很大功夫,很蛋疼.</p><p>​    结果就和我想的一样,国内环境使用这玩意一开始就出现下载gradle7.0下半天没反应,提示连接出错问题,然后找了几个阿里的镜像源,换了手机热点终于下下来了(期间架了梯子都没搞定,但神奇的是联通网开热点竟然就能下了),但接下来解析依赖又出问题,报各种依赖项找不到,或者提示sdk相关问题,这玩意配置上后解析的是android环境,头疼,各种配置init.gradle环境,换依赖项目录都是连接超时或者没有在阿里镜像源找到依赖项,浪费了一整天时间</p><p>​    最后怎么解决的,这也是最蛋疼的一点了,换了两个电脑试,把jdk,idea都换了版本,最后发现得要jdk16+最新版idea下能正常使用,回到最初的网络,竟然所有问题都解决了—–感觉一整天人生都被浪费了</p><h3 id="如何修改镜像源"><a href="#如何修改镜像源" class="headerlink" title="如何修改镜像源"></a>如何修改镜像源</h3><p>阿里旗下维护着一个国内 maven 镜像源，同样适用于 gradle。再一次对阿里表示感谢，到目前为止介绍过 npm、yarn、maven、composer 的国内加速方案全部使用着阿里旗下提供的国内镜像源，感谢为开发者提供的便利</p><h4 id="a-配置只在当前项目生效"><a href="#a-配置只在当前项目生效" class="headerlink" title="a). 配置只在当前项目生效"></a>a). 配置只在当前项目生效</h4><p>在 build.gradle 文件内修改/添加 repositories 配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">repositories &#123;<br>    maven &#123;<br>        url <span class="hljs-string">&quot;http://maven.aliyun.com/nexus/content/groups/public&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-配置全局生效"><a href="#b-配置全局生效" class="headerlink" title="b). 配置全局生效"></a>b). 配置全局生效</h4><p>找到 (用户家目录)/.gradle/init.gradle 文件，如果找不到 init.gradle 文件，自己新建一个</p><p>修改/添加 init.gradle 文件内的 repositories 配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>    repositories &#123;<br>        maven &#123;<br>            url <span class="hljs-string">&quot;http://maven.aliyun.com/nexus/content/groups/public&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="验证是否修改成功"><a href="#验证是否修改成功" class="headerlink" title="验证是否修改成功"></a>验证是否修改成功</h3><p>在 build.gradle 文件内增加一个任务</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task showRepos &#123;<br>    doLast &#123;<br>        repositories.each &#123;<br>            println <span class="hljs-string">&quot;repository: $&#123;it.name&#125; (&#x27;$&#123;it.url&#125;&#x27;)&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行 gradle -q showRepos 任务，如果输出了刚刚配置的地址就说明修改成功，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gradle -q showRepos<br>repository: maven (<span class="hljs-string">&#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot项目打包war</title>
    <link href="/2017/10/24/Springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85war/"/>
    <url>/2017/10/24/Springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85war/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、修改打包形式"><a href="#一、修改打包形式" class="headerlink" title="一、修改打包形式"></a>一、修改打包形式</h2><blockquote><p>在pom.xml里设置 <code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p></blockquote><h2 id="二、移除嵌入式tomcat插件"><a href="#二、移除嵌入式tomcat插件" class="headerlink" title="二、移除嵌入式tomcat插件"></a>二、移除嵌入式tomcat插件</h2><blockquote><p>在pom.xml里找到<code>spring-boot-starter-web</code>依赖节点，在其中添加如下代码，</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 移除嵌入式tomcat插件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三、添加servlet-api的依赖"><a href="#三、添加servlet-api的依赖" class="headerlink" title="三、添加servlet-api的依赖"></a>三、添加servlet-api的依赖</h2><blockquote><p>下面两种方式都可以，任选其一</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.36<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="四、修改启动类，并重写初始化方法"><a href="#四、修改启动类，并重写初始化方法" class="headerlink" title="四、修改启动类，并重写初始化方法"></a>四、修改启动类，并重写初始化方法</h2><blockquote><p>我们平常用main方法启动的方式，都有一个App的启动类，代码如下：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们需要类似于web.xml的配置方式来启动spring上下文了，在Application类的同级添加一个SpringBootStartApplication类，其代码如下:</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootStartApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">SpringApplicationBuilder</span> configure(<span class="hljs-type">SpringApplicationBuilder</span> builder) &#123;<br>        <span class="hljs-comment">// 注意这里要指向原先用main方法执行的Application启动类</span><br>        <span class="hljs-keyword">return</span> builder.sources(<span class="hljs-type">Application</span>.<span class="hljs-keyword">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、打包部署"><a href="#五、打包部署" class="headerlink" title="五、打包部署"></a>五、打包部署</h2><blockquote><p>在项目根目录下（即包含pom.xml的目录），在命令行里输入：<br><code>mvn clean package -Dmaven.test.skip=true</code>即可， 等待打包完成，出现<code>[INFO] BUILD SUCCESS</code>即为打包成功。</p><p>然后把target目录下的war包放到tomcat的webapps目录下，启动tomcat，即可自动解压部署。<br>最后在浏览器中输入</p><blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://localhost:</span>[<span class="hljs-string">端口号</span>]/[打包项目名]/<br></code></pre></td></tr></table></figure></blockquote><p>发布成功</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/2017/10/18/Vue%E5%9F%BA%E7%A1%80/"/>
    <url>/2017/10/18/Vue%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Vue概述"><a href="#1-Vue概述" class="headerlink" title="1. Vue概述"></a>1. Vue概述</h2><p><strong>目标</strong>：MVVM模式应用特点，Vue概念</p><p><strong>小结</strong>：</p><p>MVVM通过视图与模型的双向绑定，简化前端操作。Vue是一款前端渐进式框架，可以提高前端开发效率。</p><h2 id="2-搭建示例工程"><a href="#2-搭建示例工程" class="headerlink" title="2. 搭建示例工程"></a>2. 搭建示例工程</h2><p><strong>目标</strong>：使用IDEA创建示例工程并在工程中通过npm安装下载vue.js</p><p><strong>分析</strong>：</p><p>vue是一个前端框架，也是其实是一个js文件；下载vue.js文件并在页面中引入该js文件。</p><p>vue.js的下载方式：</p><ul><li>可以引用在线的vue.js；</li><li>可以离线下载vue.js；</li><li>npm包资源管理器，可以下载vue.js</li></ul><p><strong>小结</strong>：</p><p>使用了npm的方式安装vue模块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#初始化</span><br>npm init -y<br><br><span class="hljs-comment">#下载vue模块</span><br>npm install vue --save<br></code></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vuejs测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;num++&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125; 非常酷！有&#123;&#123;num&#125;&#125;个学科。<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;黑马&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">num</span>: <span class="hljs-number">1</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-Vue实例生命周期及钩子函数"><a href="#4-Vue实例生命周期及钩子函数" class="headerlink" title="4. Vue实例生命周期及钩子函数"></a>4. Vue实例生命周期及钩子函数</h2><p><strong>目标</strong>：了解Vue实例生命周期，生命周期的钩子函数及created函数常用场景</p><p><strong>分析</strong>：</p><p>在创建vue实例的时候可以指定模板id、数据和方法；而如果要在实例化、模板渲染的过程中需要执行一些其它操作的话；那么可以使用钩子函数。</p><p><strong>小结</strong>：</p><p>钩子函数会在vue实例的各个生命周期阶段自动调用；具体有：beforeCreate，created,beforeMount,mounted,updated,beforeUpdate，destroyed，beforeDestroy</p><p>created钩子函数常用场景：用于初始化数据</p><blockquote><p>钩子函数不要使用箭头函数的方式编写。</p></blockquote><h2 id="5-插值、v-text和v-html"><a href="#5-插值、v-text和v-html" class="headerlink" title="5. 插值、v-text和v-html"></a>5. 插值、v-text和v-html</h2><p><strong>目标</strong>：插值使用场景和要求；v-text和v-html的作用</p><p><strong>小结</strong>：</p><p><strong>插值</strong>可以使用在有需要显示vue实例数据的地方，可以在插值表达式中调用实例的数据属性和函数。</p><p>v-text和v-html的作用：可以将数据在模板中进行显示；<strong>区别</strong>：v-html会对内容中出现的html标签进行渲染，而v-text会将内容当做普遍文本输出到元素里面。</p><h2 id="6-指令-v-model使用"><a href="#6-指令-v-model使用" class="headerlink" title="6. 指令-v-model使用"></a>6. 指令-v-model使用</h2><p><strong>目标</strong>：使用v-model指令实现复选框的双向绑定</p><p><strong>小结</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Java&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;language&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Python&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;language&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Swift&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;language&quot;</span>&gt;</span>Swift<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>        你选择了：&#123;&#123;language.join(&quot;，&quot;)&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">language</span>:[]</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>多个 checkbox 对应一个model时，model的类型是一个数组，单个checkbox值是boolean类型<br>radio对应的值是input的value值<br>input 和 textarea 默认对应的model是字符串<br>select 单选对应字符串，多选对应也是数组</p></blockquote><h2 id="7-指令-v-on使用"><a href="#7-指令-v-on使用" class="headerlink" title="7. 指令-v-on使用"></a>7. 指令-v-on使用</h2><p><strong>目标</strong>：了解v-on指令的语法实现按钮点击后的递增和递减</p><p><strong>分析</strong>：</p><p>在没有使用vue之前；页面标签可以通过设置onXXX响应事件；在vue中可以通过v-on指令响应事件。</p><p><strong>小结</strong>：</p><p>v-on的使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;num++&quot;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement&quot;</span>&gt;</span>减少<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>        num = &#123;&#123;num&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    事件冒泡测试：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: lightblue; width:100px;height:100px&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;print(&#x27;div被点击了&#x27;)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;print(&#x27;点击了button&#x27;)&quot;</span>&gt;</span>点我试试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>阻止默认事件：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;print(&#x27;点击了超链接&#x27;)&quot;</span> &gt;</span>传智播客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">num</span>:<span class="hljs-number">1</span></span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">            <span class="hljs-comment">//递减</span></span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">decrement</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.num--;</span><br><span class="javascript">            &#125;,</span><br><span class="javascript">            <span class="hljs-comment">//打印</span></span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params">str</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(str);</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>事件修饰符</strong>：语法v-on:xxxx.修饰符，常用的修饰符有：</p><p>.stop ：阻止事件冒泡<br>.prevent ：阻止默认事件发生<br>.capture ：使用事件捕获模式<br>.self ：只有元素自身触发事件才执行。（冒泡或捕获的都不执行）<br>.once ：只执行一次</p><h2 id="8-指令v-for使用"><a href="#8-指令v-for使用" class="headerlink" title="8. 指令v-for使用"></a>8. 指令v-for使用</h2><p><strong>目标</strong>：了解v-for指令语法实现对数组、对象的遍历</p><p><strong>分析</strong>：</p><p>实现：可以在vue实例化的时候指定要遍历的数据，然后通过v-for指令在模板中遍历显示数据。一般情况下，要遍历的数据可以通过钩子函数created发送异步请求获取数据。</p><p><strong>小结</strong>：</p><p>可以使用v-for遍历数组、对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(user, index) in users&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>            &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.gender&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, key, index) in person&quot;</span>&gt;</span><br>            &#123;&#123;index&#125;&#125;--&#123;&#123;key&#125;&#125;--&#123;&#123;value&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">users</span>:[</span><br><span class="javascript">                &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;黑马&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">13</span>,<span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;男&quot;</span>&#125;,</span><br><span class="javascript">                &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;传智播客&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">13</span>,<span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;,</span><br><span class="javascript">                &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;酷丁鱼&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;男&quot;</span>&#125;</span><br><span class="javascript">            ],</span><br><span class="javascript">            <span class="hljs-attr">person</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;传智汇&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">13</span>,<span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>:<span class="hljs-string">&quot;中国&quot;</span>&#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>如果遍历的时候需要使用到索引号，可以在循环遍历的位置，添加一个参数；该索引号是从0开始的。</p></blockquote><h2 id="9-指令-v-if和v-show使用"><a href="#9-指令-v-if和v-show使用" class="headerlink" title="9. 指令-v-if和v-show使用"></a>9. 指令-v-if和v-show使用</h2><p><strong>目标</strong>：说出v-if与v-show的区别；通过一个按钮的点击，实现遍历数组结果的显示存在与否并在遍历过程中使用v-if对数据进行判断处理；实现文本内容的隐藏</p><p><strong>分析</strong>：</p><ul><li>v-if：通过一个按钮的点击，实现遍历数组结果的显示存在与否并在遍历过程中使用v-if对数据进行判断处理</li><li>v-show：实现文本内容的隐藏</li></ul><p><strong>小结</strong>：</p><p>v-if在条件不满足的时候元素不会存在；v-show条件不满足的时候只是对元素进行隐藏。</p><h2 id="10-指令-v-bind使用"><a href="#10-指令-v-bind使用" class="headerlink" title="10. 指令-v-bind使用"></a>10. 指令-v-bind使用</h2><p><strong>目标</strong>：了解v-bind语法和作用；实现点击不同按钮切换不同的属性值；使用class属性中的特殊用法实现一个按钮切换背景色</p><p><strong>分析</strong>：</p><p><img src height> 其中src和height的值如果不想写死，而是想获取vue实例中的数据属性值的话；那可以通过使用v-bind实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;vue实例中的数据属性名&quot;</span> <span class="hljs-attr">:height</span>=<span class="hljs-string">&quot;vue实例中的数据属性名&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><p>可以使用v-bind：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;color=&#x27;red&#x27;&quot;</span>&gt;</span>红色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;color=&#x27;blue&#x27;&quot;</span>&gt;</span>蓝色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span><br>        点击按钮改变背景颜色<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;bool=!bool&quot;</span>&gt;</span>点我改变下面色块的颜色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;red:bool, blue:!bool&#125;&quot;</span>&gt;</span><br>        点击按钮改变背景颜色<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">bool</span>:<span class="hljs-literal">true</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>v-bind的作用：可以对所有元素的属性设置vue实例的数据。</p></blockquote><h2 id="11-计算属性的使用"><a href="#11-计算属性的使用" class="headerlink" title="11. 计算属性的使用"></a>11. 计算属性的使用</h2><p><strong>目标</strong>：计算属性的应用场景，实现将一个日期时间值转换为yyyy-MM-dd格式字符串</p><p><strong>分析</strong>：</p><p>一个日期的毫秒值要显示为格式化（yyyy-MM-dd）的日期字符串的话；可以使用computed计算属性里面的方法进行处理。</p><p><strong>小结</strong>：</p><p>计算属性的应用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>        你的生日是：<br>        &#123;&#123;new Date(birthday).getFullYear()&#125;&#125;-&#123;&#123;new Date(birthday).getMonth()+1&#125;&#125;-&#123;&#123;new Date(birthday).getDay()&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>        你的生日是：<br>        &#123;&#123;birth&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">birthday</span>:<span class="hljs-number">1429032123201</span></span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">computed</span>:&#123;</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">birth</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">this</span>.birthday);</span><br><span class="javascript">                <span class="hljs-keyword">return</span> date.getFullYear() + <span class="hljs-string">&quot;-&quot;</span> + (date.getMonth()+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;-&quot;</span> + date.getDay();</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>computed计算属性的应用场景：可以应用在插值或者指令表示式复杂的时候。可以将一些属性数据经过方法处理之后返回。</p><h2 id="12-watch基本和深度监控"><a href="#12-watch基本和深度监控" class="headerlink" title="12. watch基本和深度监控"></a>12. watch基本和深度监控</h2><p><strong>目标</strong>：watch的使用场景；并使用其监听简单属性值及其对象中属性值的变化</p><p><strong>分析</strong>：</p><p>在vue实例中数据属性；因为在页面中修改而产生了变化；可以通过watch监控获取其改变前后的值。</p><p>如果是修改的对象数据属性，可以开启深度监控获取修改后最新的对象数据。如：person.name</p><p><strong>小结</strong>：</p><p>可以如下使用watch进行数据属性的监控：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;person.name&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;person.age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.age++&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>        姓名为：&#123;&#123;person.name&#125;&#125;；年龄为：&#123;&#123;person.age&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">message</span>:<span class="hljs-string">&quot;黑马&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">person</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;heima&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">13</span>&#125;</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">watch</span>:&#123;</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">message</span>(<span class="hljs-params">newValue, oldValue</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;新值：&quot;</span> + newValue + <span class="hljs-string">&quot;；旧值：&quot;</span> + oldValue);</span><br><span class="javascript">            &#125;,</span><br><span class="javascript">            <span class="hljs-attr">person</span>: &#123;</span><br><span class="javascript">                <span class="hljs-comment">//开启深度监控；监控对象中的属性值变化</span></span><br><span class="javascript">                <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>,</span><br><span class="javascript">                <span class="hljs-comment">//可以获取到最新的对象属性数据</span></span><br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params">obj</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name = &quot;</span> + obj.name + <span class="hljs-string">&quot;; age=&quot;</span> + obj.age);</span><br><span class="javascript">                &#125;</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>watch使用场景：可以监控视图中数据的变化而做出响应；如：下拉框列表中，当如果选择了对于的下拉框选项之后，要根据最新的值去加载一些其它数据的话。</p><h2 id="13-组件使用"><a href="#13-组件使用" class="headerlink" title="13. 组件使用"></a>13. 组件使用</h2><p><strong>目标</strong>：了解组件的使用场景；定义点击则计数的组件并使用全局注册和局部注册方式</p><p><strong>分析</strong>：</p><p>可以将通用或者公用的页面模块抽取成vue组件，在vue实例中引用。</p><p><strong>小结</strong>：</p><p>在页面中可以如下实验组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--使用组件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">//定义组件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> counter = &#123;</span><br><span class="javascript">        <span class="hljs-attr">template</span>:<span class="hljs-string">&quot;&lt;button @click=&#x27;num++&#x27;&gt;你点击了&#123;&#123;num&#125;&#125;次&lt;/button&gt;&quot;</span>,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">num</span>:<span class="hljs-number">0</span>&#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">//全局注册组件：在所有的vue实例中都可以使用组件</span></span><br><span class="javascript">    <span class="hljs-comment">//参数1：组件名称，参数2：具体的组件</span></span><br><span class="javascript">    <span class="hljs-comment">//Vue.component(&quot;counter&quot;, counter);</span></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">counter</span>: counter</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>组件使用场景：在项目需要重用某个模块（头部、尾部、新闻。。。）的时候，可以将模块抽取成组件，其它页面中注册组件并引用。</p><ul><li>全局注册：在任何vue实例中都可以引用，如：一般网站的头部导航菜单</li><li>局部注册：可以在有需要的页面引入组件，如：商城网站首页页面中各种活动模块</li></ul><h2 id="14-父组件向子组件通信"><a href="#14-父组件向子组件通信" class="headerlink" title="14. 父组件向子组件通信"></a>14. 父组件向子组件通信</h2><p><strong>目标</strong>：父组件与子组件通信的意义；实现父组件将简单字符串和对象更新到子组件</p><p><strong>小结</strong>：</p><p>组件通信意义：父子组件之间数据的交换，能够及时更新组件内容。</p><ul><li>父组件将简单字符串更新传递到子组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--使用组件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">introduce</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">introduce</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">//定义组件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> introduce = &#123;</span><br><span class="javascript">        <span class="hljs-attr">template</span>:<span class="hljs-string">&quot;&lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;&quot;</span>,</span><br><span class="javascript">        <span class="hljs-comment">//定义接收父组件的属性</span></span><br><span class="javascript">        <span class="hljs-attr">props</span>:[<span class="hljs-string">&quot;title&quot;</span>]</span><br><span class="javascript">    &#125;;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">//全局注册组件：在所有的vue实例中都可以使用组件</span></span><br><span class="javascript">    <span class="hljs-comment">//参数1：组件名称，参数2：具体的组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&quot;introduce&quot;</span>, introduce);</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;父组件的msg属性数据内容&quot;</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>父组件将数组更新传递到子组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--使用组件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">my-list</span> <span class="hljs-attr">:items</span>=<span class="hljs-string">&quot;lessons&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">//定义组件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> myList = &#123;</span><br><span class="javascript">        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="javascript">            &lt;ul&gt;</span></span><br><span class="hljs-string"><span class="javascript">            &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.id&#125;&#125;--&#123;&#123;item.name&#125;&#125;&lt;/li&gt;</span></span><br><span class="hljs-string"><span class="javascript">&lt;/ul&gt;</span></span><br><span class="hljs-string"><span class="javascript">        `</span>,</span><br><span class="javascript">        <span class="hljs-comment">//定义接收父组件的属性</span></span><br><span class="javascript">        <span class="hljs-attr">props</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">items</span>:&#123;</span><br><span class="javascript">                <span class="hljs-comment">//数据类型，如果是数组则是Array，如果是对象则是Object</span></span><br><span class="javascript">                <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>,</span><br><span class="javascript">                <span class="hljs-comment">//默认值</span></span><br><span class="javascript">                <span class="hljs-attr">default</span>:[]</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;父组件的msg属性数据内容&quot;</span>,</span><br><span class="javascript">             :[</span><br><span class="javascript">                &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Java&quot;</span>&#125;,</span><br><span class="javascript">                &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Php&quot;</span>&#125;,</span><br><span class="javascript">                &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;前端&quot;</span>&#125;</span><br><span class="javascript">            ]</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">            myList</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="15-子组件向父组件通信"><a href="#15-子组件向父组件通信" class="headerlink" title="15. 子组件向父组件通信"></a>15. 子组件向父组件通信</h2><p><strong>目标</strong>：在子组件中点击对应按钮实现父组件中属性数据的改变</p><p><strong>小结</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>num = &#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--使用组件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span> @<span class="hljs-attr">plus</span>=<span class="hljs-string">&quot;numPlus&quot;</span> @<span class="hljs-attr">reduce</span>=<span class="hljs-string">&quot;numReduce&quot;</span> <span class="hljs-attr">:snum</span>=<span class="hljs-string">&quot;num&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">//定义组件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> counter = &#123;</span><br><span class="javascript">        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="javascript">            &lt;div&gt;</span></span><br><span class="hljs-string"><span class="javascript">            &lt;button @click=&#x27;incrNum&#x27;&gt;+&lt;/button&gt;</span></span><br><span class="hljs-string"><span class="javascript">            &lt;button @click=&#x27;decrNum&#x27;&gt;-&lt;/button&gt;</span></span><br><span class="hljs-string"><span class="javascript">            &lt;/div&gt;</span></span><br><span class="hljs-string"><span class="javascript">        `</span>,</span><br><span class="javascript">        <span class="hljs-attr">props</span>:[<span class="hljs-string">&quot;snum&quot;</span>],</span><br><span class="javascript">        <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">            <span class="hljs-comment">//递增</span></span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">incrNum</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-comment">//调用到父组件中的方法</span></span><br><span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;plus&quot;</span>);</span><br><span class="javascript">            &#125;,</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">decrNum</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-comment">//调用到父组件中的方法</span></span><br><span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;reduce&quot;</span>);</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">//全局注册组件：在所有的vue实例中都可以使用组件</span></span><br><span class="javascript">    <span class="hljs-comment">//参数1：组件名称，参数2：具体的组件</span></span><br><span class="javascript">    <span class="hljs-comment">//Vue.component(&quot;counter&quot;, counter);</span></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">counter</span>: counter</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">num</span>:<span class="hljs-number">0</span></span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">numPlus</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.num++;</span><br><span class="javascript">            &#125;,</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">numReduce</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.num--;</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="16-axios概述"><a href="#16-axios概述" class="headerlink" title="16. axios概述"></a>16. axios概述</h2><p><strong>目标</strong>：axios的用途及了解常见方法</p><p><strong>小结</strong>：</p><p>axios的作用：<strong>发送异步请求获取数据</strong>。常见的方法：<strong>get、post</strong>；在发送的时候可以指定参数（地址、请求方式和请求头部信息）；返回数据结构（<strong>data</strong>/status/statusText/headers/config）</p><h2 id="17-axios方法及get、post方法使用"><a href="#17-axios方法及get、post方法使用" class="headerlink" title="17. axios方法及get、post方法使用"></a>17. axios方法及get、post方法使用</h2><p><strong>目标</strong>：使用axios方法获取数据并在页面中将数据遍历显示；切换改为get/post方法实现数据加载</p><p><strong>小结</strong>：</p><p>可以使用axios获取对应服务器数据；如果不是同一个服务的数据则可能会出现跨域请求；需要在响应的服务器上配置跨域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vuejs测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(user, index) in users&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>            &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.gender&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript">            <span class="hljs-attr">users</span>:[]</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">//初始化加载数据</span></span><br><span class="javascript">            axios.post(<span class="hljs-string">&quot;data.json&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(res);</span><br><span class="javascript">                <span class="hljs-comment">//将数据赋值到vue实例中的数据属性users；</span></span><br><span class="javascript">                <span class="hljs-comment">//不能使用this，在axios回调函数中表示窗口，不是vue实例</span></span><br><span class="javascript">                app.users = res.data;</span><br><span class="javascript">            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>alert(err));</span><br><span class="javascript"></span><br><span class="javascript">            axios.get(<span class="hljs-string">&quot;http://localhost/user/8&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(res.data);</span><br><span class="javascript">            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>alert(err));</span><br><span class="javascript"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="javascript">            axios.get(&quot;data.json&quot;).then(res=&gt;&#123;</span></span><br><span class="hljs-comment"><span class="javascript">                console.log(res);</span></span><br><span class="hljs-comment"><span class="javascript">                //将数据赋值到vue实例中的数据属性users；</span></span><br><span class="hljs-comment"><span class="javascript">                //不能使用this，在axios回调函数中表示窗口，不是vue实例</span></span><br><span class="hljs-comment"><span class="javascript">                app.users = res.data;</span></span><br><span class="hljs-comment"><span class="javascript">            &#125;).catch(err=&gt;alert(err));</span></span><br><span class="hljs-comment"><span class="javascript">*/</span></span><br><span class="javascript"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="javascript">            axios(&#123;</span></span><br><span class="hljs-comment"><span class="javascript">                url:&quot;data.json&quot;,</span></span><br><span class="hljs-comment"><span class="javascript">                method:&quot;get&quot;</span></span><br><span class="hljs-comment"><span class="javascript">            &#125;).then(res=&gt;&#123;</span></span><br><span class="hljs-comment"><span class="javascript">                console.log(res);</span></span><br><span class="hljs-comment"><span class="javascript">                //将数据赋值到vue实例中的数据属性users；</span></span><br><span class="hljs-comment"><span class="javascript">                //不能使用this，在axios回调函数中表示窗口，不是vue实例</span></span><br><span class="hljs-comment"><span class="javascript">                app.users = res.data;</span></span><br><span class="hljs-comment"><span class="javascript">            &#125;).catch(err=&gt;alert(err));</span></span><br><span class="hljs-comment"><span class="javascript">*/</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>跨域：在前端js中如果发送异步请求的话，请求的地址与当前服务器的ip或者端口号不同都是跨域请求，可以使用如下方式在服务器端进行配置：</p></blockquote><p><img src="/img/cphoto/vue01.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2017/10/14/SpringBoot/"/>
    <url>/2017/10/14/SpringBoot/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Spring-Boot概述"><a href="#1-Spring-Boot概述" class="headerlink" title="1. Spring Boot概述"></a>1. Spring Boot概述</h2><p><strong>目标</strong>：了解Spring Boot是什么，有什么作用</p><p><strong>小结</strong>：</p><p>Spring Boot是一个便捷搭建 基于spring工程的脚手架；作用是帮助开发人员快速搭建大型的spring 项目。简化工程的配置，依赖管理；实现开发人员把时间都集中在业务开发上。</p><h2 id="2-Spring-Boot入门"><a href="#2-Spring-Boot入门" class="headerlink" title="2. Spring Boot入门"></a>2. Spring Boot入门</h2><p><strong>目标</strong>：能够使用Spring Boot搭建项目</p><p><strong>分析</strong>：</p><p>需求：可以在浏览器中访问<a href="http://localhost:8080/hello%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6">http://localhost:8080/hello输出一串字符</a></p><p>实现步骤：</p><ol><li>创建工程；</li><li>添加依赖（启动器依赖，spring-boot-starter-web）；</li><li>创建启动类；</li><li>创建处理器Controller；</li><li>测试</li></ol><p><strong>小结</strong>：</p><p>Spring Boot工程可以通过添加启动器依赖和创建启动引导类实现快速创建web工程。</p><blockquote><p>spring-boot-starter-web默认的应用服务器端口是8080</p></blockquote><h2 id="3-Java代码方式配置"><a href="#3-Java代码方式配置" class="headerlink" title="3. Java代码方式配置"></a>3. Java代码方式配置</h2><p><strong>目标</strong>：可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring</p><p><strong>分析</strong>：</p><p>需求：使用Java代码配置数据库连接池，并可以在处理器中注入并使用</p><p>步骤：</p><ol><li>添加依赖；</li><li>创建数据库；</li><li>创建数据库连接参数的配置文件jdbc.properties；</li><li>创建配置类；</li><li>改造处理器类注入数据源并使用</li></ol><p><strong>小结</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.config;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span><br>    String driverClassName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    String username;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    String password;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setDriverClassName(driverClassName);<br>        dataSource.setUrl(url);<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-Spring-Boot属性注入方式"><a href="#4-Spring-Boot属性注入方式" class="headerlink" title="4. Spring Boot属性注入方式"></a>4. Spring Boot属性注入方式</h2><p><strong>目标</strong>：能够使用@ConfigurationProperties实现Spring Boot配置文件配置项读取和应用</p><p><strong>分析</strong>：</p><p>需求：将配置文件中的配置项读取到一个对象中；</p><p>实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将Spring Boot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。</p><p>实现步骤：</p><ol><li>创建配置项类JdbcProperties类，在该类名上面添加@ConfigurationProperties；</li><li>将jdbc.properties修改名称为application.properties；</li><li>将JdbcProperties对象注入到JdbcConfig；</li><li>测试</li></ol><p><strong>小结</strong>：</p><ul><li>使用@ConfigurationProperties编写配置项类将配置文件中的配置项设置到对象中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUrl</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> url;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUrl</span><span class="hljs-params">(String url)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.url = url;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDriverClassName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> driverClassName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDriverClassName</span><span class="hljs-params">(String driverClassName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.driverClassName = driverClassName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.password = password;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>使用@ConfigurationProperties在方法上面使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-多个yml文件配置"><a href="#5-多个yml文件配置" class="headerlink" title="5. 多个yml文件配置"></a>5. 多个yml文件配置</h2><p><strong>目标</strong>：可以将多个yml文件在application.yml文件中配置激活</p><p><strong>分析</strong>：</p><p>yaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。</p><p>1）yml配置文件的特征：</p><ol><li>树状层级结构展示配置项；</li><li>配置项之间如果有关系的话需要分行空两格；</li><li>配置项如果有值的话，那么需要在 <code>:</code>之后空一格再写配置项值；</li></ol><p>将application.properties配置文件修改为application.yml的话：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">jdbc:</span><br>  <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/heima</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br><br><span class="hljs-attr">key:</span><br>  <span class="hljs-attr">abc:</span> <span class="hljs-string">cba</span><br>  <span class="hljs-attr">def:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">g</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">h</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">j</span><br></code></pre></td></tr></table></figure><p>2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。</p><p>3）如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。</p><p><strong>小结</strong>：</p><p>在多个配置文件时，需要将这些文件在application.yml文件中进行激活：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#激活配置文件;需要指定其它的配置文件名称</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">abc,def</span><br></code></pre></td></tr></table></figure><h2 id="6-自动配置原理"><a href="#6-自动配置原理" class="headerlink" title="6. 自动配置原理"></a>6. 自动配置原理</h2><p><strong>目标</strong>：了解Spring Boot项目的配置加载流程</p><p><strong>小结</strong>：</p><ul><li>在 <code>META-INF\spring.fatories</code>文件中定义了很多自动配置类；可以根据在pom.xml文件中添加的 启动器依赖自动配置组件</li><li>通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数</li></ul><p><img src="/img/cphoto/springboot01.jpg"></p><h2 id="7-lombok应用"><a href="#7-lombok应用" class="headerlink" title="7. lombok应用"></a>7. lombok应用</h2><p><strong>目标</strong>：使用lombok的注解实现pojo类的简化</p><p><strong>分析</strong>：</p><p>使用Spring Boot整合SSM工程；需要使用到数据库数据。</p><ul><li><p>将数据库表数据导入到数据库中（springboot_test）；</p></li><li><p>编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。</p><p>lombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。</p><ol><li>在IDEA中安装lombok插件；</li><li>添加lombok对应的依赖到项目pom.xml文件；</li><li>改造实体类使用lombok注解</li></ol></li></ul><p><strong>小结</strong>：</p><p>在Bean上使用：<br>@Data ：自动提供getter和setter、hashCode、equals、toString等方法<br>@Getter：自动提供getter方法<br>@Setter：自动提供setter方法<br>@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。</p><h2 id="8-Spring-Boot整合-SpringMVC端口和静态资源"><a href="#8-Spring-Boot整合-SpringMVC端口和静态资源" class="headerlink" title="8. Spring Boot整合-SpringMVC端口和静态资源"></a>8. Spring Boot整合-SpringMVC端口和静态资源</h2><p><strong>目标</strong>：可以修改tomcat的端口和访问项目中的静态资源</p><p><strong>分析</strong>：</p><ul><li><p>修改tomcat端口</p><p>查询**Properties，设置配置项（前缀+类变量名）到application配置文件中</p></li><li><p>访问项目中的静态资源</p><p>静态资源放置的位置；放置静态资源并访问这些资源</p></li></ul><p><strong>小结</strong>：</p><ul><li>修改项目tomcat端口：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#tomcat端口</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><ul><li><p>在spring boot项目中静态资源可以放置在如下目录：</p><p><img src="/img/cphoto/springboot02.jpg"> </p></li></ul><h2 id="9-Spring-Boot整合-SpringMVC拦截器"><a href="#9-Spring-Boot整合-SpringMVC拦截器" class="headerlink" title="9.Spring Boot整合-SpringMVC拦截器"></a>9.Spring Boot整合-SpringMVC拦截器</h2><p><strong>目标</strong>：可以在Spring Boot项目中配置自定义SpringMVC拦截器</p><p><strong>分析</strong>：</p><ol><li>编写拦截器（实现HandlerInterceptor）；</li><li>编写配置类实现 WebMvcConfigurer，在该类中添加各种组件；</li><li>测试</li></ol><p><strong>小结</strong>：</p><p>可以在spring boot项目中通过配置类添加各种组件；如果要添加拦截器的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.config;<br><br><span class="hljs-keyword">import</span> com.itheima.interceptor.MyInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-comment">//注册拦截器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyInterceptor <span class="hljs-title">myInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyInterceptor();<br>    &#125;<br><br>    <span class="hljs-comment">//添加拦截器到spring mvc拦截器链</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(myInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="10-Spring-Boot整合-事务和连接池"><a href="#10-Spring-Boot整合-事务和连接池" class="headerlink" title="10. Spring Boot整合-事务和连接池"></a>10. Spring Boot整合-事务和连接池</h2><p><strong>目标</strong>：配置Spring Boot自带默认的hikari数据库连接池和使用@Transactional注解进行事务配置</p><p><strong>分析</strong>：</p><ul><li><p>事务配置</p><ol><li>添加事务相关的启动器依赖，mysql相关依赖；</li><li>编写业务类UserService使用事务注解@Transactional</li></ol></li><li><p>数据库连接池hikari配置</p><p>只需要在application配置文件中指定数据库相关参数</p></li></ul><p><strong>小结</strong>：</p><ul><li>事务配置；只需要添加jdbc启动器依赖</li><li>数据库连接池使用默认的hikari，在配置文件中配置如下：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/springboot_test</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br><br></code></pre></td></tr></table></figure><h2 id="11-Spring-Boot整合-Mybatis"><a href="#11-Spring-Boot整合-Mybatis" class="headerlink" title="11. Spring Boot整合-Mybatis"></a>11. Spring Boot整合-Mybatis</h2><p><strong>目标</strong>：配置Mybatis在Spring Boot工程中的整合包，设置mybatis的实体类别名，输出执行sql语句配置项</p><p><strong>分析</strong>：</p><ol><li>添加启动器依赖；</li><li>配置Mybatis：实体类别名包，日志，映射文件等；</li><li>配置MapperScan</li></ol><p><strong>小结</strong>：</p><ul><li><p>添加mybatis官方对于spring boot的一个启动器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mybatis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <br></code></pre></td></tr></table></figure></li><li><p>配置mybatis</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-comment"># 实体类别名包路径</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.itheima.pojo</span><br>  <span class="hljs-comment"># 映射文件路径</span><br>  <span class="hljs-comment"># mapper-locations: classpath:mappers/*.xml</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure></li><li><p>设置启动器类中的mapper扫描</p><p><img src="/img/cphoto/springboot03.jpg"></p></li></ul><h2 id="12-Spring-Boot整合-通用Mapper"><a href="#12-Spring-Boot整合-通用Mapper" class="headerlink" title="12. Spring Boot整合-通用Mapper"></a>12. Spring Boot整合-通用Mapper</h2><p><strong>目标</strong>：配置通用Mapper组件到Spring Boot项目中并使用Mapper<T>接口</T></p><p><strong>分析</strong>：</p><p>通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。</p><ol><li>添加启动器依赖；</li><li>改造UserMapper继承Mapper<User>；</User></li><li>修改启动引导类Application中的Mapper扫描注解；</li><li>修改User实体类添加jpa注解；</li><li>改造UserService实现业务功能；</li></ol><p><strong>小结</strong>：</p><blockquote><p>在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解</p></blockquote><h2 id="13-Spring-Boot整合测试"><a href="#13-Spring-Boot整合测试" class="headerlink" title="13. Spring Boot整合测试"></a>13. Spring Boot整合测试</h2><p><strong>目标</strong>：可以访问处理器对应路径将数据库中的数据根据id查询</p><p><strong>分析</strong>：</p><ol><li>改造HelloController，注入UserService利用其方法实现查询；</li><li>启动项目进行测试 <a href="http://localhost/user/%E7%94%A8%E6%88%B7id">http://localhost/user/用户id</a> –&gt; <a href="http://localhost/user/8">http://localhost/user/8</a></li></ol><p><strong>小结</strong>：</p><p>修改了HelloController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据用户id查询用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 用户id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> userService.queryById(id);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="14-Spring-Boot整合-Junit"><a href="#14-Spring-Boot整合-Junit" class="headerlink" title="14. Spring Boot整合-Junit"></a>14. Spring Boot整合-Junit</h2><p><strong>目标</strong>：在Spring Boot项目中使用Junit进行单元测试UserService的方法</p><p><strong>分析</strong>：</p><ol><li>添加启动器依赖spring-boot-starter-test；</li><li>编写测试类</li></ol><p><strong>小结</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryById</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = userService.queryById(<span class="hljs-number">8L</span>);<br>        System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUserName(<span class="hljs-string">&quot;test2&quot;</span>);<br>        user.setName(<span class="hljs-string">&quot;test2&quot;</span>);<br>        user.setAge(<span class="hljs-number">13</span>);<br>        user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        user.setSex(<span class="hljs-number">1</span>);<br>        user.setCreated(<span class="hljs-keyword">new</span> Date());<br>        userService.saveUser(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest</p></blockquote><h2 id="15-Spring-Boot整合-redis"><a href="#15-Spring-Boot整合-redis" class="headerlink" title="15. Spring Boot整合-redis"></a>15. Spring Boot整合-redis</h2><p><strong>目标</strong>：在Spring Boot项目中使用Junit测试RedisTemplate的使用</p><p><strong>分析</strong>：</p><ol><li>添加启动器依赖；spring-boot-starter-data-redis</li><li>配置application.yml中修改redis的连接参数；（redis需要启动）</li><li>编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set）</li></ol><p><strong>小结</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//string 字符串</span><br>        <span class="hljs-comment">//redisTemplate.opsForValue().set(&quot;str&quot;, &quot;heima&quot;);</span><br>        redisTemplate.boundValueOps(<span class="hljs-string">&quot;str&quot;</span>).set(<span class="hljs-string">&quot;heima&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;str = &quot;</span> + redisTemplate.opsForValue().get(<span class="hljs-string">&quot;str&quot;</span>));<br><br>        <span class="hljs-comment">//hash 散列</span><br>        redisTemplate.boundHashOps(<span class="hljs-string">&quot;h_key&quot;</span>).put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;heima&quot;</span>);<br>        redisTemplate.boundHashOps(<span class="hljs-string">&quot;h_key&quot;</span>).put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">13</span>);<br>        <span class="hljs-comment">//获取所有域</span><br>        Set set = redisTemplate.boundHashOps(<span class="hljs-string">&quot;h_key&quot;</span>).keys();<br>        System.out.println(<span class="hljs-string">&quot; hash散列的所有域：&quot;</span> + set);<br>        <span class="hljs-comment">//获取所有值</span><br>        List list = redisTemplate.boundHashOps(<span class="hljs-string">&quot;h_key&quot;</span>).values();<br>        System.out.println(<span class="hljs-string">&quot; hash散列的所有域的值：&quot;</span> + list);<br><br>        <span class="hljs-comment">//list 列表</span><br>        redisTemplate.boundListOps(<span class="hljs-string">&quot;l_key&quot;</span>).leftPush(<span class="hljs-string">&quot;c&quot;</span>);<br>        redisTemplate.boundListOps(<span class="hljs-string">&quot;l_key&quot;</span>).leftPush(<span class="hljs-string">&quot;b&quot;</span>);<br>        redisTemplate.boundListOps(<span class="hljs-string">&quot;l_key&quot;</span>).leftPush(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-comment">//获取全部元素</span><br>        list = redisTemplate.boundListOps(<span class="hljs-string">&quot;l_key&quot;</span>).range(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot; list列表中的所有元素：&quot;</span> + list);<br><br>        <span class="hljs-comment">// set 集合</span><br>        redisTemplate.boundSetOps(<span class="hljs-string">&quot;s_key&quot;</span>).add(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        set = redisTemplate.boundSetOps(<span class="hljs-string">&quot;s_key&quot;</span>).members();<br>        System.out.println(<span class="hljs-string">&quot; set集合中的所有元素：&quot;</span> + set);<br><br>        <span class="hljs-comment">// sorted set 有序集合</span><br>        redisTemplate.boundZSetOps(<span class="hljs-string">&quot;z_key&quot;</span>).add(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">30</span>);<br>        redisTemplate.boundZSetOps(<span class="hljs-string">&quot;z_key&quot;</span>).add(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">20</span>);<br>        redisTemplate.boundZSetOps(<span class="hljs-string">&quot;z_key&quot;</span>).add(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">10</span>);<br>        set = redisTemplate.boundZSetOps(<span class="hljs-string">&quot;z_key&quot;</span>).range(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot; zset有序集合中的所有元素：&quot;</span> + set);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="16-Spring-Boot项目部署"><a href="#16-Spring-Boot项目部署" class="headerlink" title="16. Spring Boot项目部署"></a>16. Spring Boot项目部署</h2><p><strong>目标</strong>：将Spring Boot项目使用maven指令打成jar包并运行测试</p><p><strong>分析</strong>：</p><ol><li>需要添加打包组件将项目中的资源、配置、依赖包打到一个jar包中；可以使用maven的<code>package</code>；</li><li>部署：java -jar 包名</li></ol><p><strong>小结</strong>：</p><ul><li><p>添加打包组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>部署运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar 包名<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/2017/10/12/Dubbo/"/>
    <url>/2017/10/12/Dubbo/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式RPC框架Apache-Dubbo"><a href="#分布式RPC框架Apache-Dubbo" class="headerlink" title="分布式RPC框架Apache Dubbo"></a>分布式RPC框架Apache Dubbo</h1><h2 id="1-软件架构的演进过程"><a href="#1-软件架构的演进过程" class="headerlink" title="1. 软件架构的演进过程"></a>1. 软件架构的演进过程</h2><p>软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程，下面我们分别了解一下这几个架构。</p><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><p><img src="/img/cphoto/dubbo01.jpg"></p><p>架构说明：</p><p>​      全部功能集中在一个项目内（All in one）。</p><p>架构优点：</p><p>​      架构简单，前期开发成本低、开发周期短，适合小型项目。</p><p>架构缺点：</p><p>​       全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。</p><p>​       技术栈受限，只能使用一种语言开发。</p><p>​       系统性能扩展只能通过扩展集群节点，成本高。</p><h3 id="1-2-垂直架构"><a href="#1-2-垂直架构" class="headerlink" title="1.2 垂直架构"></a>1.2 垂直架构</h3><p><img src="/img/cphoto/dubbo02.jpg"></p><p>架构说明：       </p><p>​      按照业务进行切割，形成小的单体项目。</p><p>架构优点：</p><p>​      技术栈可扩展（不同的系统可以用不同的编程语言编写）。</p><p>架构缺点：</p><p>​       功能集中在一个项目中，不利于开发、扩展、维护。</p><p>​       系统扩张只能通过集群的方式。</p><p>​       项目之间功能冗余、数据冗余、耦合性强。</p><h3 id="1-3-SOA架构"><a href="#1-3-SOA架构" class="headerlink" title="1.3 SOA架构"></a>1.3 SOA架构</h3><p>SOA全称为Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。</p><p>站在功能的角度，把业务逻辑抽象成可复用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。</p><p><img src="/img/cphoto/dubbo03.jpg"></p><p>架构说明：</p><p>​      将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。</p><p>架构优点：</p><p>​       重复功能或模块抽取为服务，提高开发效率。</p><p>​       可重用性高。</p><p>​       可维护性高。</p><p>架构缺点：</p><p>​       各系统之间业务不同，很难确认功能或模块是重复的。</p><p>​       抽取服务的粒度大。</p><p>​       系统和服务之间耦合度高。</p><h3 id="1-4-微服务架构"><a href="#1-4-微服务架构" class="headerlink" title="1.4 微服务架构"></a>1.4 微服务架构</h3><p><img src="/img/cphoto/dubbo04.jpg"></p><p>架构说明：</p><p>​       将系统服务层完全独立出来，抽取为一个一个的微服务。</p><p>​       抽取的粒度更细，遵循单一原则。</p><p>​       采用轻量级框架协议传输。</p><p>架构优点：</p><p>​       服务拆分粒度更细，有利于提高开发效率。 </p><p>​       可以针对不同服务制定对应的优化方案。</p><p>​       适用于互联网时代，产品迭代周期更短。</p><p>架构缺点：</p><p>​      粒度太细导致服务太多，维护成本高。</p><p>​      分布式系统开发的技术成本高，对团队的挑战大。</p><h2 id="2-Apache-Dubbo概述"><a href="#2-Apache-Dubbo概述" class="headerlink" title="2. Apache Dubbo概述"></a>2. Apache Dubbo概述</h2><h3 id="2-1-Dubbo简介"><a href="#2-1-Dubbo简介" class="headerlink" title="2.1 Dubbo简介"></a>2.1 Dubbo简介</h3><p>Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。</p><p><strong>什么是RPC？</strong></p><p>RPC全称为remote procedure call，即<strong>远程过程调用</strong>。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。</p><p>需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。</p><p>RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。</p><p>Dubbo官网地址：<a href="http://dubbo.apache.org/">http://dubbo.apache.org</a></p><p>Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><h3 id="2-2-Dubbo架构"><a href="#2-2-Dubbo架构" class="headerlink" title="2.2 Dubbo架构"></a>2.2 Dubbo架构</h3><p>Dubbo架构图（Dubbo官方提供）如下：</p><p><img src="/img/cphoto/dubbo05.jpg"></p><p>节点角色说明：</p><table><thead><tr><th>节点</th><th>角色名称</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><p>虚线都是异步访问，实线都是同步访问<br>蓝色虚线:在启动时完成的功能<br>红色虚线(实线)都是程序运行过程中执行的功能</p><p>调用关系说明:</p><ol start="0"><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="3-服务注册中心Zookeeper"><a href="#3-服务注册中心Zookeeper" class="headerlink" title="3. 服务注册中心Zookeeper"></a>3. 服务注册中心Zookeeper</h2><p>通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。</p><h3 id="3-1-Zookeeper介绍"><a href="#3-1-Zookeeper介绍" class="headerlink" title="3.1 Zookeeper介绍"></a>3.1 Zookeeper介绍</h3><p>Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。</p><p>为了便于理解Zookeeper的树型目录服务，我们先来看一下我们电脑的文件系统(也是一个树型目录结构)：</p><p><img src="/img/cphoto/dubbo06.jpg"></p><p>我的电脑可以分为多个盘符（例如C、D、E等），每个盘符下可以创建多个目录，每个目录下面可以创建文件，也可以创建子目录，最终构成了一个树型结构。通过这种树型结构的目录，我们可以将文件分门别类的进行存放，方便我们后期查找。而且磁盘上的每个文件都有一个唯一的访问路径，例如：C:\Windows\itcast\hello.txt。</p><p>Zookeeper树型目录服务：</p><p><img src="/img/cphoto/dubbo07.jpg"></p><p>流程说明：</p><ul><li>服务提供者(Provider)启动时: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li>服务消费者(Consumer)启动时: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li>监控中心(Monitor)启动时: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址</li></ul><h3 id="3-2-安装Zookeeper"><a href="#3-2-安装Zookeeper" class="headerlink" title="3.2 安装Zookeeper"></a>3.2 安装Zookeeper</h3><p>下载地址：<a href="http://archive.apache.org/dist/zookeeper/">http://archive.apache.org/dist/zookeeper/</a></p><p>本课程使用的Zookeeper版本为3.4.6，下载完成后可以获得名称为zookeeper-3.4.6.tar.gz的压缩文件。</p><p>安装步骤：</p><p>第一步：安装 jdk（略）<br>第二步：把 zookeeper 的压缩包（zookeeper-3.4.6.tar.gz）上传到 linux 系统<br>第三步：解压缩压缩包<br>​    tar -zxvf zookeeper-3.4.6.tar.gz<br>第四步：进入zookeeper-3.4.6目录，创建data目录<br>​    mkdir data<br>第五步：进入conf目录 ，把zoo_sample.cfg 改名为zoo.cfg<br>​    cd conf<br>​    mv zoo_sample.cfg zoo.cfg<br>第六步：打开zoo.cfg文件,  修改data属性：dataDir=/root/zookeeper-3.4.6/data</p><h3 id="3-3-启动、停止Zookeeper"><a href="#3-3-启动、停止Zookeeper" class="headerlink" title="3.3 启动、停止Zookeeper"></a>3.3 启动、停止Zookeeper</h3><p>进入Zookeeper的bin目录，启动服务命令<br> ./zkServer.sh start</p><p>停止服务命令<br>./zkServer.sh stop</p><p>查看服务状态：<br>./zkServer.sh status</p><h2 id="4-Dubbo快速入门"><a href="#4-Dubbo快速入门" class="headerlink" title="4. Dubbo快速入门"></a>4. Dubbo快速入门</h2><p>Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。</p><h3 id="4-1-服务提供方开发"><a href="#4-1-服务提供方开发" class="headerlink" title="4.1 服务提供方开发"></a>4.1 服务提供方开发</h3><p>开发步骤：</p><p>（1）创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- dubbo相关 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.sgroschupf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.12.1.GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 指定端口 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 请求路径 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）配置web.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">web-app</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta"> <span class="hljs-meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta"> <span class="hljs-meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>（3）创建服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.service;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）创建服务实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.service.impl;<br><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.annotation.Service;<br><span class="hljs-keyword">import</span> com.itheima.service.HelloService;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：服务实现类上使用的Service注解是Dubbo提供的，用于对外发布服务</p><p>（5）在src/main/resources下创建applicationContext-service.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://code.alibabatech.com/schema/dubbo</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbodemo_provider&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://192.168.134.129:2181&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 注册  协议和port   端口默认是20880 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20881&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:protocol</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:annotation</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.itheima.service.impl&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（6）启动服务</p><p>tomcat7:run</p><h3 id="4-2-服务消费方开发"><a href="#4-2-服务消费方开发" class="headerlink" title="4.2 服务消费方开发"></a>4.2 服务消费方开发</h3><p>开发步骤：</p><p>（1）创建maven工程（打包方式为war）dubbodemo_consumer，pom.xml配置和上面服务提供者相同，只需要将Tomcat插件的端口号改为8082即可</p><p>（2）配置web.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">web-app</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta"> <span class="hljs-meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta"> <span class="hljs-meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext-web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）将服务提供者工程中的HelloService接口复制到当前工程</p><p>（4）编写Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.controller;<br><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;<br><span class="hljs-keyword">import</span> com.itheima.service.HelloService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@Reference</span><br>    <span class="hljs-keyword">private</span> HelloService helloService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-comment">//远程调用</span><br>        String result = helloService.sayHello(name);<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解</p><p>（5）在src/main/resources下创建applicationContext-web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://code.alibabatech.com/schema/dubbo</span></span><br><span class="hljs-string"><span class="hljs-tag">http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbodemo-consumer&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://192.168.134.129:2181&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 扫描的方式暴露接口  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:annotation</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.itheima.controller&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（6）运行测试</p><p>tomcat7:run启动</p><p>在浏览器输入<a href="http://localhost:8082/demo/hello.do?name=Jack%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C">http://localhost:8082/demo/hello.do?name=Jack，查看浏览器输出结果</a></p><p><strong>思考一：</strong>上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？</p><p><strong>答：</strong>这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。</p><p><strong>思考二：</strong>在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？</p><p><strong>答：</strong>Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。</p><p><strong>思考三：</strong>上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？</p><p><strong>答：</strong>Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。</p><h2 id="5-Dubbo管理控制台"><a href="#5-Dubbo管理控制台" class="headerlink" title="5. Dubbo管理控制台"></a>5. Dubbo管理控制台</h2><p>我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。</p><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h3><p>安装步骤：</p><p>（1）将资料中的dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下</p><p>（2）启动tomcat，此war文件会自动解压</p><p>（3）修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号</p><p>​    dubbo.registry.address=zookeeper://192.168.134.129:2181<br>​    dubbo.admin.root.password=root<br>​    dubbo.admin.guest.password=guest</p><p>（4）重启tomcat</p><h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><p>操作步骤：</p><p>（1）访问<a href="http://localhost:8080/dubbo-admin-2.6.0/%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D(root)%E5%92%8C%E5%AF%86%E7%A0%81(root)">http://localhost:8080/dubbo-admin-2.6.0/，输入用户名(root)和密码(root)</a></p><p><img src="/img/cphoto/dubbo08.jpg"></p><p>（2）启动服务提供者工程和服务消费者工程，可以在查看到对应的信息</p><p><img src="/img/cphoto/dubbo09.jpg"></p><h2 id="6-Dubbo相关配置说明"><a href="#6-Dubbo相关配置说明" class="headerlink" title="6. Dubbo相关配置说明"></a>6. Dubbo相关配置说明</h2><h3 id="6-1-包扫描"><a href="#6-1-包扫描" class="headerlink" title="6.1 包扫描"></a>6.1 包扫描</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:annotation</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.itheima.service&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。</p><p>如果不使用包扫描，也可以通过如下配置的方式来发布服务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.HelloServiceImpl&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.api.HelloService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;helloService&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>作为服务消费者，可以通过如下配置来引用服务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.api.HelloService&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>上面这种方式发布和引用服务，一个配置项(<a href="dubbo:service">dubbo:service</a>、<a href="dubbo:reference">dubbo:reference</a>)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。</p><h3 id="6-2-协议"><a href="#6-2-协议" class="headerlink" title="6.2 协议"></a>6.2 协议</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>一般在服务提供者一方配置，可以指定使用的协议名称和端口号。</p><p>其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。</p><p>推荐使用的是dubbo协议。</p><p>dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p><p>也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 多协议配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rmi&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;1099&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.api.HelloService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;dubbo&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.api.DemoService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;rmi&quot;</span> /&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="6-3-启动时检查"><a href="#6-3-启动时检查" class="headerlink" title="6.3 启动时检查"></a>6.3 启动时检查</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:consumer</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。</p><p>建议在开发阶段将check值设置为false，在生产环境下改为true。</p><h3 id="6-4-负载均衡"><a href="#6-4-负载均衡" class="headerlink" title="6.4 负载均衡"></a>6.4 负载均衡</h3><p>负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。</p><p>在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。</p><p>配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-comment">//在服务消费者一方配置负载均衡策略</span><br>    <span class="hljs-meta">@Reference(check = false,loadbalance = &quot;random&quot;)</span><br>    <span class="hljs-keyword">private</span> HelloService helloService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-comment">//远程调用</span><br>        String result = helloService.sayHello(name);<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在服务提供者一方配置负载均衡</span><br><span class="hljs-meta">@Service(loadbalance = &quot;random&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过启动多个服务提供者来观察Dubbo负载均衡效果。</p><p>注意：因为我们是在一台机器上启动多个服务提供者，所以需要修改tomcat的端口号和Dubbo服务的端口号来防止端口冲突。</p><p>在实际生产环境中，多个服务提供者是分别部署在不同的机器上，所以不存在端口冲突问题。</p><h2 id="7-解决Dubbo无法发布被事务代理的Service问题"><a href="#7-解决Dubbo无法发布被事务代理的Service问题" class="headerlink" title="7. 解决Dubbo无法发布被事务代理的Service问题"></a>7. 解决Dubbo无法发布被事务代理的Service问题</h2><p>前面我们已经完成了Dubbo的入门案例，通过入门案例我们可以看到通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。</p><p>但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。</p><h3 id="7-1-问题展示"><a href="#7-1-问题展示" class="headerlink" title="7.1 问题展示"></a>7.1 问题展示</h3><p>在入门案例的服务提供者dubbodemo_provider工程基础上进行展示</p><p>操作步骤：</p><p>（1）在pom.xml文件中增加maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 事务管理器  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--开启事务控制的注解支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>上面连接的数据库可以自行创建</p><p>（3）在HelloServiceImpl类上加入@Transactional注解</p><p>（4）启动服务提供者和服务消费者，并访问</p><p><img src="/img/cphoto/dubbo10.jpg"></p><p>上面的错误为没有可用的服务提供者</p><p>查看dubbo管理控制台发现服务并没有发布，如下：</p><p><img src="/img/cphoto/dubbo11.jpg"></p><p>可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过AnnotationBean的postProcessAfterInitialization方法进行处理</p><p><img src="/img/cphoto/dubbo12.jpg"></p><h3 id="7-2-解决方案"><a href="#7-2-解决方案" class="headerlink" title="7.2 解决方案"></a>7.2 解决方案</h3><p>通过上面的断点调试可以看到，在HelloServiceImpl类上加入事务注解后，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$Proxy35，导致Dubbo在进行包匹配时没有成功（因为我们在发布服务时扫描的包为com.itheima.service），所以后面真正发布服务的代码没有执行。</p><p>解决方式操作步骤：</p><p>（1）修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启事务控制的注解支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/dubbo13.jpg"></p><p>（2）修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(interfaceClass = HelloService.class)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是HelloService接口，如下：</p><p><img src="/img/cphoto/dubbo14.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2017/10/10/SpringMVC/"/>
    <url>/2017/10/10/SpringMVC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Spring与Web环境集成"><a href="#1-Spring与Web环境集成" class="headerlink" title="1. Spring与Web环境集成"></a>1. Spring与Web环境集成</h2><h3 id="1-1-ApplicationContext应用上下文获取方式"><a href="#1-1-ApplicationContext应用上下文获取方式" class="headerlink" title="1.1 ApplicationContext应用上下文获取方式"></a>1.1 ApplicationContext应用上下文获取方式</h3><p>应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p><p>在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</p><h3 id="1-2-Spring提供获取应用上下文的工具"><a href="#1-2-Spring提供获取应用上下文的工具" class="headerlink" title="1.2 Spring提供获取应用上下文的工具"></a>1.2 Spring提供获取应用上下文的工具</h3><p>上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。</p><p>所以我们需要做的只有两件事：</p><p>①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）</p><p>②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext</p><h3 id="1-3-导入Spring集成web的坐标"><a href="#1-3-导入Spring集成web的坐标" class="headerlink" title="1.3 导入Spring集成web的坐标"></a>1.3 导入Spring集成web的坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-配置ContextLoaderListener监听器"><a href="#1-4-配置ContextLoaderListener监听器" class="headerlink" title="1.4 配置ContextLoaderListener监听器"></a>1.4 配置ContextLoaderListener监听器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--全局参数--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--Spring的监听器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span><br>       org.springframework.web.context.ContextLoaderListener<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-通过工具获得应用上下文对象"><a href="#1-5-通过工具获得应用上下文对象" class="headerlink" title="1.5 通过工具获得应用上下文对象"></a>1.5 通过工具获得应用上下文对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext applicationContext =    <br>    WebApplicationContextUtils.getWebApplicationContext(servletContext);<br>    Object obj = applicationContext.getBean(<span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>知识要点</strong></p><p>Spring集成web环境步骤</p><p>​      ①配置ContextLoaderListener监听器</p><p>​      ②使用WebApplicationContextUtils获得应用上下文</p><h2 id="2-SpringMVC的简介"><a href="#2-SpringMVC的简介" class="headerlink" title="2. SpringMVC的简介"></a>2. SpringMVC的简介</h2><h3 id="2-1-SpringMVC概述"><a href="#2-1-SpringMVC概述" class="headerlink" title="2.1 SpringMVC概述"></a>2.1 SpringMVC概述</h3><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p><p>SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。</p><h3 id="2-3-SpringMVC快速入门"><a href="#2-3-SpringMVC快速入门" class="headerlink" title="2.3 SpringMVC快速入门"></a>2.3 SpringMVC快速入门</h3><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p><p><strong>开发步骤</strong></p><p>①导入SpringMVC相关坐标</p><p>②配置SpringMVC核心控制器DispathcerServlet</p><p>③创建Controller类和视图页面</p><p>④使用注解配置Controller类中业务方法的映射地址</p><p>⑤配置SpringMVC核心文件 spring-mvc.xml</p><p>⑥客户端发起请求测试</p><p><strong>代码实现</strong></p><p>①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--Spring坐标--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-comment">&lt;!--SpringMVC坐标--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Servlet坐标--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Jsp坐标--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②在web.xml配置SpringMVC的核心控制器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>③创建Controller和业务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickController</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">quickMethod</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;quickMethod running.....&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③创建视图页面index.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;html&gt;<br>&lt;body&gt;<br>    &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>④配置注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickController</span> </span>&#123;<br><span class="hljs-meta">@RequestMapping(&quot;/quick&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">quickMethod</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;quickMethod running.....&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⑤创建spring-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans.xsd </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/mvc   </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/context   </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置注解扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.itheima&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>⑥访问测试地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://localhost:8080/itheima_springmvc1/quick <br></code></pre></td></tr></table></figure><p>控制台打印</p><p><img src="/img/cphoto/springmvc01.jpg"></p><p>页面显示</p><p><img src="/img/cphoto/springmvc02.jpg"></p><p>2.3 SpringMVC流程图示</p><p><img src="/img/cphoto/springmvc03.jpg"></p><p>2.4 知识要点</p><p>SpringMVC的开发步骤 </p><p>   ①导入SpringMVC相关坐标</p><p>   ②配置SpringMVC核心控制器DispathcerServlet</p><p>   ③创建Controller类和视图页面</p><p>   ④使用注解配置Controller类中业务方法的映射地址</p><p>   ⑤配置SpringMVC核心文件 spring-mvc.xml</p><p>   ⑥客户端发起请求测试</p><h2 id="3-SpringMVC的组件解析"><a href="#3-SpringMVC的组件解析" class="headerlink" title="3. SpringMVC的组件解析"></a>3. SpringMVC的组件解析</h2><h3 id="3-1-SpringMVC的执行流程"><a href="#3-1-SpringMVC的执行流程" class="headerlink" title="3.1 SpringMVC的执行流程"></a>3.1 SpringMVC的执行流程</h3><p><img src="/img/cphoto/springmvc04.jpg"></p><p>①用户发送请求至前端控制器DispatcherServlet。</p><p>②DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p><p>③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p><p>④DispatcherServlet调用HandlerAdapter处理器适配器。</p><p>⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p><p>⑥Controller执行完成返回ModelAndView。</p><p>⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p><p>⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p><p>⑨ViewReslover解析后返回具体View。</p><p>⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。</p><h3 id="3-2-SpringMVC组件解析"><a href="#3-2-SpringMVC组件解析" class="headerlink" title="3.2 SpringMVC组件解析"></a>3.2 SpringMVC组件解析</h3><ol><li><strong>前端控制器：DispatcherServlet</strong></li></ol><p>​    用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由</p><p>它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p><ol start="2"><li><strong>处理器映射器：HandlerMapping</strong></li></ol><p>​    HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的</p><p>映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><ol start="3"><li><strong>处理器适配器：HandlerAdapter</strong></li></ol><p>​    通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理</p><p>器进行执行。</p><ol start="4"><li><strong>处理器：Handler</strong></li></ol><p>​    它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由</p><p>Handler 对具体的用户请求进行处理。</p><ol start="5"><li><strong>视图解析器：View Resolver</strong></li></ol><p>​    View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p><ol start="6"><li><strong>视图：View</strong></li></ol><p>​    SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p><h3 id="3-3-SpringMVC注解解析"><a href="#3-3-SpringMVC注解解析" class="headerlink" title="3.3 SpringMVC注解解析"></a>3.3 SpringMVC注解解析</h3><p>@RequestMapping</p><p>作用：用于建立请求 URL 和处理请求方法之间的对应关系</p><p>位置：</p><p>​      类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录</p><p>​      方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</p><p>属性：</p><p>​      value：用于指定请求的URL。它和path属性的作用是一样的</p><p>​      method：用于指定请求的方式</p><p>​      params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样</p><p>例如：</p><p>​      params = {“accountName”}，表示请求参数必须有accountName</p><p>​      params = {“moeny!100”}，表示请求参数中money不能是100</p><p>1.mvc命名空间引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;<br>约束地址：http://www.springframework.org/schema/context<br>        http://www.springframework.org/schema/context/spring-context.xsd<br>        http://www.springframework.org/schema/mvc <br>        http://www.springframework.org/schema/mvc/spring-mvc.xsd<br></code></pre></td></tr></table></figure><p>2.<br>组件扫描</p><p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。</p><h3 id="3-4-SpringMVC的XML配置解析"><a href="#3-4-SpringMVC的XML配置解析" class="headerlink" title="3.4 SpringMVC的XML配置解析"></a>3.4 SpringMVC的XML配置解析</h3><p>SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.web.servlet.ViewResolver</span>=<span class="hljs-string">org.springframework.web.servlet.view.InternalResourceViewResolver</span><br></code></pre></td></tr></table></figure><p>翻看该解析器源码，可以看到该解析器的默认设置，如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">REDIRECT_URL_PREFIX</span> = <span class="hljs-string">&quot;redirect:&quot;  --重定向前缀</span><br><span class="hljs-attr">FORWARD_URL_PREFIX</span> = <span class="hljs-string">&quot;forward:&quot;    --转发前缀（默认值）</span><br><span class="hljs-attr">prefix</span> = <span class="hljs-string">&quot;&quot;;     --视图名称前缀</span><br><span class="hljs-attr">suffix</span> = <span class="hljs-string">&quot;&quot;;     --视图名称后缀</span><br></code></pre></td></tr></table></figure><ol><li>视图解析器</li></ol><p>我们可以通过属性注入的方式修改视图的的前后缀</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置内部资源视图解析器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-知识要点"><a href="#3-5-知识要点" class="headerlink" title="3.5 知识要点"></a>3.5 知识要点</h3><p><strong>SpringMVC的相关组件</strong> </p><p>前端控制器：DispatcherServlet</p><p>处理器映射器：HandlerMapping</p><p>处理器适配器：HandlerAdapter</p><p>处理器：Handler</p><p>视图解析器：View Resolver</p><p>视图：View</p><p><strong>SpringMVC的注解和配置</strong> </p><p>请求映射注解：@RequestMapping</p><p>视图解析器配置：</p><p>REDIRECT_URL_PREFIX = “redirect:”  </p><p>FORWARD_URL_PREFIX = “forward:”    </p><p>prefix = “”;     </p><p>suffix = “”;     </p><h1 id="SpringMVC的请求和响应"><a href="#SpringMVC的请求和响应" class="headerlink" title="SpringMVC的请求和响应"></a>SpringMVC的请求和响应</h1><h2 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h2><h3 id="01-SpringMVC的数据响应-数据响应方式-理解"><a href="#01-SpringMVC的数据响应-数据响应方式-理解" class="headerlink" title="01-SpringMVC的数据响应-数据响应方式(理解)"></a>01-SpringMVC的数据响应-数据响应方式(理解)</h3><ol><li>   页面跳转</li></ol><p>直接返回字符串</p><p>通过ModelAndView对象返回</p><p>2） 回写数据 </p><p>直接返回字符串</p><p>返回对象或集合    </p><h3 id="02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）"><a href="#02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）" class="headerlink" title="02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）"></a>02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）</h3><p><img src="/img/cphoto/springmvc05.jpg"></p><h3 id="03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1-应用"><a href="#03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1-应用" class="headerlink" title="03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)"></a>03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)</h3><p>在Controller中方法返回ModelAndView对象，并且设置视图名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">save2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            Model:模型 作用封装数据</span><br><span class="hljs-comment">            View：视图 作用展示数据</span><br><span class="hljs-comment">         */</span><br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>        <span class="hljs-comment">//设置模型数据</span><br>        modelAndView.addObject(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;itcast&quot;</span>);<br>        <span class="hljs-comment">//设置视图名称</span><br>        modelAndView.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2-应用"><a href="#04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2-应用" class="headerlink" title="04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)"></a>04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)</h3><p>n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@RequestMapping(value=&quot;/quick3&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">save3</span><span class="hljs-params">(ModelAndView modelAndView)</span></span>&#123;<br>        modelAndView.addObject(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>);<br>        modelAndView.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br><span class="hljs-meta">@RequestMapping(value=&quot;/quick4&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save4</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;博学谷&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="05-SpringMVC的数据响应-页面跳转-返回ModelAndView3-应用"><a href="#05-SpringMVC的数据响应-页面跳转-返回ModelAndView3-应用" class="headerlink" title="05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)"></a>05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)</h3><p>在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick5&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save5</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>        request.setAttribute(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;酷丁鱼&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="06-SpringMVC的数据响应-回写数据-直接回写字符串-应用"><a href="#06-SpringMVC的数据响应-回写数据-直接回写字符串-应用" class="headerlink" title="06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)"></a>06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)</h3><p>通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void</p><p>将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick7&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span>  <span class="hljs-comment">//告知SpringMVC框架 不进行视图跳转 直接进行数据响应</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save7</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello itheima&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value=&quot;/quick6&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save6</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        response.getWriter().print(<span class="hljs-string">&quot;hello itcast&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="07-SpringMVC的数据响应-回写数据-直接回写json格式字符串-应用"><a href="#07-SpringMVC的数据响应-回写数据-直接回写json格式字符串-应用" class="headerlink" title="07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)"></a>07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick8&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save8</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;\&quot;username\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick9&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUsername(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        user.setAge(<span class="hljs-number">30</span>);<br>        <span class="hljs-comment">//使用json的转换工具将对象转换成json格式字符串在返回</span><br>        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        String json = objectMapper.writeValueAsString(user);<br><br>        <span class="hljs-keyword">return</span> json;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="08-SpringMVC的数据响应-回写数据-返回对象或集合-应用"><a href="#08-SpringMVC的数据响应-回写数据-返回对象或集合-应用" class="headerlink" title="08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)"></a>08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)</h3><p>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;messageConverters&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick10&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-comment">//期望SpringMVC自动将User转换成json格式的字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">save10</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUsername(<span class="hljs-string">&quot;lisi2&quot;</span>);<br>        user.setAge(<span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="09-SpringMVC的数据响应-回写数据-返回对象或集合2-应用"><a href="#09-SpringMVC的数据响应-回写数据-返回对象或集合2-应用" class="headerlink" title="09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)"></a>09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)</h3><p>在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</p><p>使用<code>&lt;mvc:annotation-driven /&gt;</code>自动加载 RequestMappingHandlerMapping（处理映射器）和</p><p>RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用</p><p><code>&lt;mvc:annotation-driven /&gt;</code>替代注解处理器和适配器的配置。</p><p>同时使用<code>&lt;mvc:annotation-driven /&gt;</code></p><p>默认底层就会集成jackson进行对象或集合的json格式字符串的转换</p><h3 id="10-SpringMVC的数据响应-知识要点小结-理解，记忆"><a href="#10-SpringMVC的数据响应-知识要点小结-理解，记忆" class="headerlink" title="10-SpringMVC的数据响应-知识要点小结(理解，记忆)"></a>10-SpringMVC的数据响应-知识要点小结(理解，记忆)</h3><p>1） 页面跳转</p><p>直接返回字符串</p><p>通过ModelAndView对象返回</p><p>2） 回写数据 </p><p>直接返回字符串</p><p>HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回</p><p>返回对象或集合 </p><p>@ResponseBody+<code>&lt;mvc:annotation-driven/&gt;   </code></p><h2 id="SpringMVC的请求"><a href="#SpringMVC的请求" class="headerlink" title="SpringMVC的请求"></a>SpringMVC的请求</h2><h3 id="11-SpringMVC的请求-获得请求参数-请求参数类型-理解"><a href="#11-SpringMVC的请求-获得请求参数-请求参数类型-理解" class="headerlink" title="11-SpringMVC的请求-获得请求参数-请求参数类型(理解)"></a>11-SpringMVC的请求-获得请求参数-请求参数类型(理解)</h3><p>客户端请求参数的格式是：name=value&amp;name=value……</p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数</p><p>基本类型参数</p><p>POJO类型参数</p><p>数组类型参数</p><p>集合类型参数</p><h3 id="12-SpringMVC的请求-获得请求参数-获得基本类型参数-应用"><a href="#12-SpringMVC的请求-获得请求参数-获得基本类型参数-应用" class="headerlink" title="12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)"></a>12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)</h3><p>Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换；</p><p>自动的类型转换是指从String向其他类型的转换</p><p><code>http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick11&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save11</span><span class="hljs-params">(String username,<span class="hljs-keyword">int</span> age)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br>        System.out.println(age);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="13-SpringMVC的请求-获得请求参数-获得POJO类型参数-应用"><a href="#13-SpringMVC的请求-获得请求参数-获得POJO类型参数-应用" class="headerlink" title="13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)"></a>13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)</h3><p>Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.domain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick12&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save12</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(user);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="14-SpringMVC的请求-获得请求参数-获得数组类型参数-应用"><a href="#14-SpringMVC的请求-获得请求参数-获得数组类型参数-应用" class="headerlink" title="14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)"></a>14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)</h3><p>Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick13&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save13</span><span class="hljs-params">(String[] strs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(Arrays.asList(strs));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="15-SpringMVC的请求-获得请求参数-获得集合类型参数1-应用"><a href="#15-SpringMVC的请求-获得请求参数-获得集合类型参数1-应用" class="headerlink" title="15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)"></a>15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)</h3><p>获得集合参数时，要将集合参数包装到一个POJO中才可以。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick14&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>        &lt;%--表明是第一个User对象的username age--%&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[0].username&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[0].age&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[1].username&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[1].age&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>    &lt;/form&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.domain;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VO</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;User&gt; userList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserList</span><span class="hljs-params">(List&lt;User&gt; userList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userList = userList;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VO&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;userList=&quot;</span> + userList +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick14&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save14</span><span class="hljs-params">(VO vo)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(vo);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="16-SpringMVC的请求-获得请求参数-获得集合类型参数2-应用"><a href="#16-SpringMVC的请求-获得请求参数-获得集合类型参数2-应用" class="headerlink" title="16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)"></a>16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)</h3><p>当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;script src=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> userList = <span class="hljs-keyword">new</span> Array();<br>        userList.push(&#123;username:<span class="hljs-string">&quot;zhangsan&quot;</span>,age:<span class="hljs-number">18</span>&#125;);<br>        userList.push(&#123;username:<span class="hljs-string">&quot;lisi&quot;</span>,age:<span class="hljs-number">28</span>&#125;);<br><br>        $.ajax(&#123;<br>            type:<span class="hljs-string">&quot;POST&quot;</span>,<br>            url:<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;</span>,<br>            data:JSON.stringify(userList),<br>            contentType:<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span><br>        &#125;);<br><br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick15&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save15</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(userList);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="17-SpringMVC的请求-获得请求参数-静态资源访问的开启-应用"><a href="#17-SpringMVC的请求-获得请求参数-静态资源访问的开启-应用" class="headerlink" title="17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)"></a>17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)</h3><p>当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：</p><p>•在spring-mvc.xml配置文件中指定放行的资源</p><p>​     <code>&lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; </code></p><p>•使用<code>&lt;mvc:default-servlet-handler/&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开发资源的访问--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;</span><br><span class="hljs-comment">    &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器-应用"><a href="#18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器-应用" class="headerlink" title="18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)"></a>18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)</h3><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置全局过滤的filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="19-SpringMVC的请求-获得请求参数-参数绑定注解-RequestParam-应用"><a href="#19-SpringMVC的请求-获得请求参数-参数绑定注解-RequestParam-应用" class="headerlink" title="19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)"></a>19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)</h3><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/quick16&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick16&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save16</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;)</span> String username)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取-应用"><a href="#20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取-应用" class="headerlink" title="20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)"></a>20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)</h3><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p><p>GET：用于获取资源</p><p>POST：用于新建资源</p><p>PUT：用于更新资源</p><p>DELETE：用于删除资源  </p><p>例如：</p><p>/user/1    GET ：       得到 id = 1 的 user</p><p>/user/1   DELETE：  删除 id = 1 的 user</p><p>/user/1    PUT：       更新 id = 1 的 user</p><p>/user       POST：      新增 user</p><p>上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。</p><p><code>http://localhost:8080/itheima_springmvc1/quick17/zhangsan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick17/&#123;name&#125;&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save17</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value=&quot;name&quot;)</span> String username)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="21-SpringMVC的请求-获得请求参数-自定义类型转换器-应用"><a href="#21-SpringMVC的请求-获得请求参数-自定义类型转换器-应用" class="headerlink" title="21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)"></a>21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)</h3><p>SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</p><p>但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String dateStr)</span> </span>&#123;<br>        <span class="hljs-comment">//将日期字符串转换成日期对象 返回</span><br>        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        Date date = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            date = format.parse(dateStr);<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> date;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick18&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save18</span><span class="hljs-params">(Date date)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(date);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="22-SpringMVC的请求-获得请求参数-获得Servlet相关API-应用"><a href="#22-SpringMVC的请求-获得请求参数-获得Servlet相关API-应用" class="headerlink" title="22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)"></a>22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)</h3><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p><p>HttpServletRequest</p><p>HttpServletResponse</p><p>HttpSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick19&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save19</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(request);<br>        System.out.println(response);<br>        System.out.println(session);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="23-SpringMVC的请求-获得请求参数-获得请求头信息-应用"><a href="#23-SpringMVC的请求-获得请求参数-获得请求头信息-应用" class="headerlink" title="23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)"></a>23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)</h3><p>使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)</p><p>@RequestHeader注解的属性如下：</p><p>value：请求头的名称</p><p>required：是否必须携带此请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick20&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save20</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(value = &quot;User-Agent&quot;,required = false)</span> String user_agent)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(user_agent);<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用@CookieValue可以获得指定Cookie的值</p><p>@CookieValue注解的属性如下：</p><p>value：指定cookie的名称</p><p>required：是否必须携带此cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick21&quot;)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save21</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;JSESSIONID&quot;)</span> String jsessionId)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       System.out.println(jsessionId);<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的文件上传"><a href="#SpringMVC的文件上传" class="headerlink" title="SpringMVC的文件上传"></a>SpringMVC的文件上传</h1><h3 id="1-SpringMVC的请求-文件上传-客户端表单实现-应用"><a href="#1-SpringMVC的请求-文件上传-客户端表单实现-应用" class="headerlink" title="1-SpringMVC的请求-文件上传-客户端表单实现(应用)"></a>1-SpringMVC的请求-文件上传-客户端表单实现(应用)</h3><p>文件上传客户端表单需要满足：</p><p>表单项type=“file”</p><p>表单的提交方式是post  </p><p>表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data”</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick22&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>        名称&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>&gt;&lt;br/&gt;<br>        文件<span class="hljs-number">1</span>&lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;uploadFile&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>    &lt;/form&gt;<br></code></pre></td></tr></table></figure><h3 id="2-SpringMVC的请求-文件上传-文件上传的原理-理解"><a href="#2-SpringMVC的请求-文件上传-文件上传的原理-理解" class="headerlink" title="2-SpringMVC的请求-文件上传-文件上传的原理(理解)"></a>2-SpringMVC的请求-文件上传-文件上传的原理(理解)</h3><p><img src="/img/cphoto/springmvc06.jpg"></p><h3 id="3-SpringMVC的请求-文件上传-单文件上传的代码实现1-应用"><a href="#3-SpringMVC的请求-文件上传-单文件上传的代码实现1-应用" class="headerlink" title="3-SpringMVC的请求-文件上传-单文件上传的代码实现1(应用)"></a>3-SpringMVC的请求-文件上传-单文件上传的代码实现1(应用)</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置多媒体解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置文件上传解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UYF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;500000&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>后台程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick22&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save22</span><span class="hljs-params">(String username, MultipartFile uploadFile)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br>       System.out.println(uploadFile);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-SpringMVC的请求-文件上传-单文件上传的代码实现2-应用"><a href="#4-SpringMVC的请求-文件上传-单文件上传的代码实现2-应用" class="headerlink" title="4-SpringMVC的请求-文件上传-单文件上传的代码实现2(应用)"></a>4-SpringMVC的请求-文件上传-单文件上传的代码实现2(应用)</h3><p>完成文件上传</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick22&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save22</span><span class="hljs-params">(String username, MultipartFile uploadFile)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br>        <span class="hljs-comment">//获得上传文件的名称</span><br>        String originalFilename = uploadFile.getOriginalFilename();<br>        uploadFile.transferTo(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\upload\\&quot;</span>+originalFilename));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="5-SpringMVC的请求-文件上传-多文件上传的代码实现-应用"><a href="#5-SpringMVC的请求-文件上传-多文件上传的代码实现-应用" class="headerlink" title="5-SpringMVC的请求-文件上传-多文件上传的代码实现(应用)"></a>5-SpringMVC的请求-文件上传-多文件上传的代码实现(应用)</h3><p>多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick23&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>        名称&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>&gt;&lt;br/&gt;<br>        文件<span class="hljs-number">1</span>&lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;uploadFile&quot;</span>&gt;&lt;br/&gt;<br>        文件<span class="hljs-number">2</span>&lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;uploadFile&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>    &lt;/form&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick23&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save23</span><span class="hljs-params">(String username, MultipartFile[] uploadFile)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br>        <span class="hljs-keyword">for</span> (MultipartFile multipartFile : uploadFile) &#123;<br>            String originalFilename = multipartFile.getOriginalFilename();<br>            multipartFile.transferTo(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\upload\\&quot;</span>+originalFilename));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="6-SpringMVC的请求-知识要点-理解，记忆"><a href="#6-SpringMVC的请求-知识要点-理解，记忆" class="headerlink" title="6-SpringMVC的请求-知识要点(理解，记忆)"></a>6-SpringMVC的请求-知识要点(理解，记忆)</h3><p><img src="/img/cphoto/springmvc07.jpg"></p><h1 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h1><h2 id="01-SpringMVC拦截器-拦截器的作用-理解"><a href="#01-SpringMVC拦截器-拦截器的作用-理解" class="headerlink" title="01-SpringMVC拦截器-拦截器的作用(理解)"></a>01-SpringMVC拦截器-拦截器的作用(理解)</h2><p>Spring MVC 的拦截器类似于 Servlet  开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p><p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</p><h2 id="02-SpringMVC拦截器-interceptor和filter区别-理解，记忆"><a href="#02-SpringMVC拦截器-interceptor和filter区别-理解，记忆" class="headerlink" title="02-SpringMVC拦截器-interceptor和filter区别(理解，记忆)"></a>02-SpringMVC拦截器-interceptor和filter区别(理解，记忆)</h2><p>关于interceptor和filter的区别，如图所示：</p><p><img src="/img/cphoto/springmvc08.jpg"></p><h2 id="03-SpringMVC拦截器-快速入门-应用"><a href="#03-SpringMVC拦截器-快速入门-应用" class="headerlink" title="03-SpringMVC拦截器-快速入门(应用)"></a>03-SpringMVC拦截器-快速入门(应用)</h2><p>自定义拦截器很简单，只有如下三步：</p><p>①创建拦截器类实现HandlerInterceptor接口</p><p>②配置拦截器</p><p>③测试拦截器的拦截效果</p><p>编写拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-comment">//在目标方法执行之前 执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;preHandle.....&quot;</span>);<br>&#125;<br>    <span class="hljs-comment">//在目标方法执行之后 视图对象返回之前执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;postHandle...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//在流程都执行完毕后 执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterCompletion....&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>配置：在SpringMVC的配置文件中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--对哪些资源执行拦截操作--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.interceptor.MyInterceptor1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>编写测试程序测试：</p><p>编写Controller,发请求到controller,跳转页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/target&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;目标资源执行......&quot;</span>);<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>        modelAndView.addObject(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;itcast&quot;</span>);<br>        modelAndView.setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;html&gt;<br>&lt;body&gt;<br>&lt;h2&gt;Hello World! $&#123;name&#125;&lt;/h2&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="04-SpringMVC拦截器-快速入门详解-应用"><a href="#04-SpringMVC拦截器-快速入门详解-应用" class="headerlink" title="04-SpringMVC拦截器-快速入门详解(应用)"></a>04-SpringMVC拦截器-快速入门详解(应用)</h2><p>拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么?</p><p>再编写一个拦截器2，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-comment">//在目标方法执行之前 执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;preHandle22222.....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//在目标方法执行之后 视图对象返回之前执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;postHandle2222...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//在流程都执行完毕后 执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterCompletion2222....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置拦截器2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--对哪些资源执行拦截操作--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.interceptor.MyInterceptor2&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--对哪些资源执行拦截操作--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.interceptor.MyInterceptor1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>结论：</p><p>当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源</p><p>多个拦截器情况下，配置在前的先执行，配置在后的后执行</p><p>拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion</p><h2 id="05-SpringMVC拦截器-知识小结-记忆"><a href="#05-SpringMVC拦截器-知识小结-记忆" class="headerlink" title="05-SpringMVC拦截器-知识小结(记忆)"></a>05-SpringMVC拦截器-知识小结(记忆)</h2><p>拦截器中的方法说明如下</p><p><img src="/img/cphoto/springmvc09.jpg"></p><h2 id="06-SpringMVC拦截器-用户登录权限控制分析-理解"><a href="#06-SpringMVC拦截器-用户登录权限控制分析-理解" class="headerlink" title="06-SpringMVC拦截器-用户登录权限控制分析(理解)"></a>06-SpringMVC拦截器-用户登录权限控制分析(理解)</h2><p>在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作</p><p>需求图：</p><p><img src="/img/cphoto/springmvc10.jpg"></p><h2 id="07-SpringMVC拦截器-用户登录权限控制代码实现1-应用"><a href="#07-SpringMVC拦截器-用户登录权限控制代码实现1-应用" class="headerlink" title="07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)"></a>07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)</h2><p>判断用户是否登录  本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源</p><p>先编写拦截器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivilegeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//逻辑：判断用户是否登录  本质：判断session中有没有user</span><br>        HttpSession session = request.getSession();<br>        User user = (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//没有登录</span><br>            response.sendRedirect(request.getContextPath()+<span class="hljs-string">&quot;/login.jsp&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//放行  访问目标资源</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置权限拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--配置对哪些资源执行拦截操作--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="08-SpringMVC拦截器-用户登录权限控制代码实现2-应用"><a href="#08-SpringMVC拦截器-用户登录权限控制代码实现2-应用" class="headerlink" title="08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)"></a>08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)</h2><p>在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面</p><p>在UserController中编写登陆逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username,String password,HttpSession session)</span></span>&#123;<br>        User user = userService.login(username,password);<br>        <span class="hljs-keyword">if</span>(user!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//登录成功  将user存储到session</span><br>            session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/index.jsp&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login.jsp&quot;</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>service层代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//service层</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;<br>            User user = userDao.findByUsernameAndPassword(username,password);<br>            <span class="hljs-keyword">return</span> user;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>dao层代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//dao层</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findByUsernameAndPassword</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> EmptyResultDataAccessException</span>&#123;<br>        User user = jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from sys_user where username=? and password=?&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class), username, password);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置权限拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--配置对哪些资源执行拦截操作--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--配置哪些资源排除拦截操作--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/user/login&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="09-SpringMVC拦截器-用户登录权限控制代码实现3-应用"><a href="#09-SpringMVC拦截器-用户登录权限控制代码实现3-应用" class="headerlink" title="09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)"></a>09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)</h2><p>JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？</p><p>在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller</p><p>因此改造登陆的业务层代码,添加异常的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            User user = userDao.findByUsernameAndPassword(username,password);<br>            <span class="hljs-keyword">return</span> user;<br>        &#125;<span class="hljs-keyword">catch</span> (EmptyResultDataAccessException e)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-SpringMVC异常处理机制"><a href="#1-SpringMVC异常处理机制" class="headerlink" title="1. SpringMVC异常处理机制"></a>1. SpringMVC异常处理机制</h2><h3 id="1-1-异常处理的思路"><a href="#1-1-异常处理的思路" class="headerlink" title="1.1 异常处理的思路"></a>1.1 异常处理的思路</h3><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理</p><h3 id="1-2-异常处理两种方式"><a href="#1-2-异常处理两种方式" class="headerlink" title="1.2 异常处理两种方式"></a>1.2 异常处理两种方式</h3><p>① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</p><p>② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器</p><h3 id="1-3-简单异常处理器SimpleMappingExceptionResolver"><a href="#1-3-简单异常处理器SimpleMappingExceptionResolver" class="headerlink" title="1.3 简单异常处理器SimpleMappingExceptionResolver"></a>1.3 简单异常处理器SimpleMappingExceptionResolver</h3><p>SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置简单映射异常处理器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">“defaultErrorView”</span> <span class="hljs-attr">value</span>=<span class="hljs-string">“error”/</span>&gt;</span>   默认错误视图<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">“exceptionMappings”</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>异常类型                             错误视图<br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;com.itheima.exception.MyException&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.ClassCastException&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-自定义异常处理步骤"><a href="#1-4-自定义异常处理步骤" class="headerlink" title="1.4 自定义异常处理步骤"></a>1.4 自定义异常处理步骤</h3><p>①创建异常处理器类实现HandlerExceptionResolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, </span></span><br><span class="hljs-params"><span class="hljs-function">    HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;<br>    <span class="hljs-comment">//处理异常的代码实现</span><br>    <span class="hljs-comment">//创建ModelAndView对象</span><br>    ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(); <br>    modelAndView.setViewName(<span class="hljs-string">&quot;exceptionPage&quot;</span>);<br>    <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②配置异常处理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exceptionResolver&quot;</span>        </span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.exception.MyExceptionResolver&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>③编写异常页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>这是一个最终异常的显示页面<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>④测试异常跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/quick22&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickMethod22</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ParseException </span>&#123;<br>    SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>); <br>    simpleDateFormat.parse(<span class="hljs-string">&quot;abcde&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-知识要点"><a href="#1-5-知识要点" class="headerlink" title="1.5 知识要点"></a>1.5 知识要点</h3><p>异常处理方式</p><pre><code>配置简单异常处理器SimpleMappingExceptionResolver自定义异常处理器</code></pre><p>自定义异常处理步骤</p><pre><code>①创建异常处理器类实现HandlerExceptionResolver②配置异常处理器③编写异常页面④测试异常跳转</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h1 id="Spring练习"><a href="#Spring练习" class="headerlink" title="Spring练习"></a>Spring练习</h1><h2 id="01-Spring练习-环境搭建步骤分析-理解"><a href="#01-Spring练习-环境搭建步骤分析-理解" class="headerlink" title="01-Spring练习-环境搭建步骤分析(理解)"></a>01-Spring练习-环境搭建步骤分析(理解)</h2><p>案例环境搭建步骤：</p><p>①创建工程（Project&amp;Module）</p><p>②导入静态页面（见资料jsp页面）</p><p>③导入需要坐标（见资料中的pom.xml）</p><p>④创建包结构（controller、service、dao、domain、utils）</p><p>⑤导入数据库脚本（见资料test.sql）</p><p>⑥创建POJO类（见资料User.java和Role.java）</p><p>创建配置文件（applicationContext.xml,spring-mvc.xml,jdbc.properties,log4j.properties）</p><h2 id="02-Spring练习-环境搭建实现1-应用"><a href="#02-Spring练习-环境搭建实现1-应用" class="headerlink" title="02-Spring练习-环境搭建实现1(应用)"></a>02-Spring练习-环境搭建实现1(应用)</h2><p>创建工程,导入jsp，添加项目依赖</p><p>创建包结构，导入数据库脚本，导入POJO</p><h2 id="03-Spring练习-环境搭建实现2-应用"><a href="#03-Spring练习-环境搭建实现2-应用" class="headerlink" title="03-Spring练习-环境搭建实现2(应用)"></a>03-Spring练习-环境搭建实现2(应用)</h2><p>创建Spring的核心配置文件applicationContext.xml</p><p>创建SpringMVC核心配置文件spring-mvc.xml</p><p>创建数据库配置文件jdbc.properties</p><p>拷贝日志配置文件log4j.properties</p><p>配置web.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--全局的初始化参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Spring的监听器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--SpringMVC的前端控制器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="04-Spring练习-环境搭建实现3-应用"><a href="#04-Spring练习-环境搭建实现3-应用" class="headerlink" title="04-Spring练习-环境搭建实现3(应用)"></a>04-Spring练习-环境搭建实现3(应用)</h2><p>配置springm-mvc.xml：注解驱动，视图解析器，静态资源的开放</p><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1、mvc注解驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--2、配置视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/pages/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--3、静态资源权限开放--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="05-Spring练习-环境搭建实现4-应用"><a href="#05-Spring练习-环境搭建实现4-应用" class="headerlink" title="05-Spring练习-环境搭建实现4(应用)"></a>05-Spring练习-环境搭建实现4(应用)</h2><p>配置applicationContext.xml：加载propertiest,配置数据源对象，配置JdbcTemplate对象</p><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--1、加载jdbc.properties--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--2、配置数据源对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--3、配置JdbcTemplate对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="06-Spring练习-用户表和角色表的分析-理解"><a href="#06-Spring练习-用户表和角色表的分析-理解" class="headerlink" title="06-Spring练习-用户表和角色表的分析(理解)"></a>06-Spring练习-用户表和角色表的分析(理解)</h2><p>分析用户和角色在数据库设计中的表关系：多对多关系，关系如图所示：</p><p><img src="/2017/10/10/SpringMVC/1.png"></p><h2 id="07-Spring练习-角色列表展示分析-理解"><a href="#07-Spring练习-角色列表展示分析-理解" class="headerlink" title="07-Spring练习-角色列表展示分析(理解)"></a>07-Spring练习-角色列表展示分析(理解)</h2><p>需求：角色列表展示，需求如图所示：</p><p><img src="/2017/10/10/SpringMVC/2.png"></p><p>完成该功能的思路和步骤为：</p><p>①点击角色管理菜单发送请求到服务器端（修改角色管理菜单的url地址）</p><p>②创建RoleController和list()方法</p><p>③创建RoleService和list()方法</p><p>④创建RoleDao和findAll()方法</p><p>⑤使用JdbcTemplate完成查询操作</p><p>⑥将查询数据存储到modelAndView中</p><p>⑦转发到role-list.jsp页面进行展示</p><h2 id="08-Spring练习-角色列表展示-controller层实现-应用"><a href="#08-Spring练习-角色列表展示-controller层实现-应用" class="headerlink" title="08-Spring练习-角色列表展示-controller层实现(应用)"></a>08-Spring练习-角色列表展示-controller层实现(应用)</h2><p>1：修改左侧菜单链接地址</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;ul <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;treeview-menu&quot;</span>&gt;<br><br>&lt;li&gt;&lt;a<br>href=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/list&quot;</span>&gt; &lt;i<br><span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;fa fa-circle-o&quot;</span>&gt;&lt;/i&gt; 用户管理<br>&lt;/a&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;a<br>href=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/role/list&quot;</span>&gt; &lt;i<br><span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;fa fa-circle-o&quot;</span>&gt;&lt;/i&gt; 角色管理<br>&lt;/a&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;a<br>href=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/pages/syslog-list.jsp&quot;</span>&gt; &lt;i<br><span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;fa fa-circle-o&quot;</span>&gt;&lt;/i&gt; 访问日志<br>&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>Controller层代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/role&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleService roleService;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">list</span><span class="hljs-params">()</span></span>&#123;<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>        List&lt;Role&gt; roleList = roleService.list();<br>        <span class="hljs-comment">//设置模型</span><br>        modelAndView.addObject(<span class="hljs-string">&quot;roleList&quot;</span>,roleList);<br>        <span class="hljs-comment">//设置视图</span><br>        modelAndView.setViewName(<span class="hljs-string">&quot;role-list&quot;</span>);<br>        System.out.println(roleList);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="09-Spring练习-角色列表展示-service和dao层实现-应用"><a href="#09-Spring练习-角色列表展示-service和dao层实现-应用" class="headerlink" title="09-Spring练习-角色列表展示-service和dao层实现(应用)"></a>09-Spring练习-角色列表展示-service和dao层实现(应用)</h2><p>service层代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RoleService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RoleDao roleDao;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoleDao</span><span class="hljs-params">(RoleDao roleDao)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roleDao = roleDao;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Role&gt; roleList = roleDao.findAll();<br>        <span class="hljs-keyword">return</span> roleList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dao层代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RoleDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJdbcTemplate</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.jdbcTemplate = jdbcTemplate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Role&gt; roleList = jdbcTemplate.query(<span class="hljs-string">&quot;select * from sys_role&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Role&gt;(Role.class));<br>        <span class="hljs-keyword">return</span> roleList;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="10-Spring练习-角色列表展示-配置实现-应用"><a href="#10-Spring练习-角色列表展示-配置实现-应用" class="headerlink" title="10-Spring练习-角色列表展示-配置实现(应用)"></a>10-Spring练习-角色列表展示-配置实现(应用)</h2><p>配置spring-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--4、组件扫描  扫描Controller--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.itheima.controller&quot;</span>/&gt;</span><br><br></code></pre></td></tr></table></figure><p>配置applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置RoleService--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.RoleServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;roleDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;roleDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置RoleDao--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.RoleDaoImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="11-Spring练习-角色列表展示-页面展示-应用"><a href="#11-Spring练习-角色列表展示-页面展示-应用" class="headerlink" title="11-Spring练习-角色列表展示-页面展示(应用)"></a>11-Spring练习-角色列表展示-页面展示(应用)</h2><p>在role-list.jsp中将数据取出来并展示,核心代码如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:forEach items=<span class="hljs-string">&quot;$&#123;roleList&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;<br>&lt;tr&gt;<br>&lt;td&gt;&lt;input name=<span class="hljs-string">&quot;ids&quot;</span> type=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;&lt;/td&gt;<br>&lt;td&gt;$&#123;role.id&#125;&lt;/td&gt;<br>&lt;td&gt;$&#123;role.roleName&#125;&lt;/td&gt;<br>&lt;td&gt;$&#123;role.roleDesc&#125;&lt;/td&gt;<br>&lt;td <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;<br>&lt;a href=<span class="hljs-string">&quot;javascript:void(0);&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;btn bg-olive btn-xs&quot;</span>&gt;删除&lt;/a&gt;<br>&lt;/td&gt;<br>&lt;/tr&gt;<br>&lt;/c:forEach&gt;<br><br></code></pre></td></tr></table></figure><h2 id="12-Spring练习-角色的添加操作-应用"><a href="#12-Spring练习-角色的添加操作-应用" class="headerlink" title="12-Spring练习-角色的添加操作(应用)"></a>12-Spring练习-角色的添加操作(应用)</h2><p>需求：添加角色，需求图如下：</p><p><img src="/2017/10/10/SpringMVC/3.png"></p><p>操作步骤如下：</p><p>①点击列表页面新建按钮跳转到角色添加页面</p><p>②输入角色信息，点击保存按钮，表单数据提交服务器</p><p>③编写RoleController的save()方法</p><p>④编写RoleService的save()方法</p><p>⑤编写RoleDao的save()方法</p><p>⑥使用JdbcTemplate保存Role数据到sys_role</p><p>⑦跳转回角色列表页面</p><p>controller代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(Role role)</span></span>&#123;<br>        roleService.save(role);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/role/list&quot;</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>service代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Role role)</span> </span>&#123;<br>        roleDao.save(role);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>dao代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Role role)</span> </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;insert into sys_role values(?,?,?)&quot;</span>,<span class="hljs-keyword">null</span>,role.getRoleName(),role.getRoleDesc());<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>为了解决post提交中文乱码问题，需要在web.xml中配置全局乱码过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--解决乱码的过滤器--&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>测试，完成该功能。</p><h2 id="13-Spring练习-用户列表展示1-应用"><a href="#13-Spring练习-用户列表展示1-应用" class="headerlink" title="13-Spring练习-用户列表展示1(应用)"></a>13-Spring练习-用户列表展示1(应用)</h2><p>需求：查询用户列表，需求图如下：</p><p><img src="/2017/10/10/SpringMVC/4.png"></p><p>完成该功能的操作步骤：</p><p>①点击用户管理菜单发送请求到服务器端（修改用户管理菜单的url地址）</p><p>②创建UserController和list()方法</p><p>③创建UserService和list()方法</p><p>④创建UserDao和findAll()方法</p><p>⑤使用JdbcTemplate完成查询操作</p><p>⑥将查询数据存储到modelAndView中</p><p>⑦转发到user-list.jsp页面进行展示</p><p>跟查询角色列表一样，查询用户列表，创建UserController,UserService,UserDao,User实体等结构，编写各层代码并配置</p><p>用户列表Controller,service,dao层代码如下：</p><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">list</span><span class="hljs-params">()</span></span>&#123;<br>        List&lt;User&gt; userList = userService.list();<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>        modelAndView.addObject(<span class="hljs-string">&quot;userList&quot;</span>,userList);<br>        modelAndView.setViewName(<span class="hljs-string">&quot;user-list&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>service:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = userDao.findAll();<br>        <span class="hljs-comment">//封装userList中的每一个User的roles数据</span><br>        <span class="hljs-keyword">return</span> userList;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>dao:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = jdbcTemplate.query(<span class="hljs-string">&quot;select * from sys_user&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class));<br>        <span class="hljs-keyword">return</span> userList;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="14-Spring练习-用户列表展示2-应用"><a href="#14-Spring练习-用户列表展示2-应用" class="headerlink" title="14-Spring练习-用户列表展示2(应用)"></a>14-Spring练习-用户列表展示2(应用)</h2><p>查询用户的时候关联查询出该用户所具有的所有角色信息,需要完善查询用户的service层代码</p><p>1，在角色的dao中添加方法，根据用户id查询角色列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在角色dao中根据用户id查询用户具有的角色信息</span><br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">findRoleByUserId</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>        List&lt;Role&gt; roles = jdbcTemplate.query(<span class="hljs-string">&quot;select * from sys_user_role ur,sys_role r where ur.roleId=r.id and ur.userId=?&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Role&gt;(Role.class), id);<br>        <span class="hljs-keyword">return</span> roles;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>完善userservcie层代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在查询用户的service中关联查询用户具有的角色</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = userDao.findAll();<br>        <span class="hljs-comment">//封装userList中的每一个User的roles数据</span><br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            <span class="hljs-comment">//获得user的id</span><br>            Long id = user.getId();<br>            <span class="hljs-comment">//将id作为参数 查询当前userId对应的Role集合数据</span><br>            List&lt;Role&gt; roles = roleDao.findRoleByUserId(id);<br>            user.setRoles(roles);<br>        &#125;<br>        <span class="hljs-keyword">return</span> userList;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>查询用户的时候关联查询出该用户所具有的所有角色信息，前端jsp页面核心代码</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:forEach items=<span class="hljs-string">&quot;$&#123;userList&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;<br>&lt;tr&gt;<br>&lt;td&gt;&lt;input name=<span class="hljs-string">&quot;ids&quot;</span> type=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;&lt;/td&gt;<br>&lt;td&gt;$&#123;user.id&#125;&lt;/td&gt;<br>&lt;td&gt;$&#123;user.username&#125;&lt;/td&gt;<br>&lt;td&gt;$&#123;user.email&#125;&lt;/td&gt;<br>&lt;td&gt;$&#123;user.phoneNum&#125;&lt;/td&gt;<br>&lt;td <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;<br>&lt;c:forEach items=<span class="hljs-string">&quot;$&#123;user.roles&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;<br>&amp;nbsp;&amp;nbsp;$&#123;role.roleName&#125;<br>&lt;/c:forEach&gt;<br>&lt;/td&gt;<br>&lt;td <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;<br>&lt;a href=<span class="hljs-string">&quot;javascript:void(0);&quot;</span> onclick=<span class="hljs-string">&quot;delUser(&#x27;$&#123;user.id&#125;&#x27;)&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;btn bg-olive btn-xs&quot;</span>&gt;删除&lt;/a&gt;<br>&lt;/td&gt;<br>&lt;/tr&gt;<br>&lt;/c:forEach&gt;<br><br></code></pre></td></tr></table></figure><h2 id="15-Spring练习-用户添加操作-添加页面展示-应用"><a href="#15-Spring练习-用户添加操作-添加页面展示-应用" class="headerlink" title="15-Spring练习-用户添加操作-添加页面展示(应用)"></a>15-Spring练习-用户添加操作-添加页面展示(应用)</h2><p>需求：添加用户，需求图如下：</p><p><img src="/2017/10/10/SpringMVC/5.png"></p><p>新建用户时，点击新建按钮先去到添加用户的页面user-add.jsp,在添加用户页面需要展示可供选择的角色信息，因此来到添加页面时需要查询所有的角色信息并展示</p><p>去到user-add.jsp页面时先查询所有角色信息的controller代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/saveUI&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">saveUI</span><span class="hljs-params">()</span></span>&#123;<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>        List&lt;Role&gt; roleList = roleService.list();<br>        modelAndView.addObject(<span class="hljs-string">&quot;roleList&quot;</span>,roleList);<br>        modelAndView.setViewName(<span class="hljs-string">&quot;user-add&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因为查询所有角色信息的service层和dao层代码在之前角色列表展示功能的时候已经写了，因此只需调用即可，</p><p>在user-add.jsp页面展示所有角色信息的核心代码</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-md-10 data&quot;</span>&gt;<br>&lt;c:forEach items=<span class="hljs-string">&quot;$&#123;roleList&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;<br>&lt;input <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;&quot;</span> type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;roleIds&quot;</span> value=<span class="hljs-string">&quot;$&#123;role.id&#125;&quot;</span>&gt;$&#123;role.roleName&#125;<br>&lt;/c:forEach&gt;<br>&lt;/div&gt;<br><br></code></pre></td></tr></table></figure><h2 id="16-Spring练习-用户添加操作-添加数据到数据库-应用"><a href="#16-Spring练习-用户添加操作-添加数据到数据库-应用" class="headerlink" title="16-Spring练习-用户添加操作-添加数据到数据库(应用)"></a>16-Spring练习-用户添加操作-添加数据到数据库(应用)</h2><p>添加用户页面有两部分数据，一部分属于用户基础数据需要插入到用户表user中，另一部分是用户的角色数据，需要插入到中间表sys_user_role中</p><p>user-add.jsp页面提交数据到controller完成数据添加操作的controller层和service层代码分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//controller层代码</span><br><span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(User user,Long[] roleIds)</span></span>&#123;<br>        userService.save(user,roleIds);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/list&quot;</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//service层代码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(User user, Long[] roleIds)</span> </span>&#123;<br>        <span class="hljs-comment">//第一步 向sys_user表中存储数据</span><br>        Long userId = userDao.save(user);<br>        <span class="hljs-comment">//第二步 向sys_user_role 关系表中存储多条数据</span><br>        userDao.saveUserRoleRel(userId,roleIds);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>dao层代码因为还需要重新构建，因此学完下一个章节后重新编写，因为这里留下了一个问题，在dao层操作后如何获得自增的主键id值呢?</p><h2 id="17-Spring练习-用户添加操作-添加数据到数据库2-应用"><a href="#17-Spring练习-用户添加操作-添加数据到数据库2-应用" class="headerlink" title="17-Spring练习-用户添加操作-添加数据到数据库2(应用)"></a>17-Spring练习-用户添加操作-添加数据到数据库2(应用)</h2><p>添加用户时用户分配的角色信息应存储到中间表sys_user_role表中，需要用户的id，角色的id，而角色的id由前台页面点选的，用户的id应该是在保存操作由mysql主键自动生成的，那如何获取mysql自增的主键值呢？</p><p>使用JdbcTemplate执行插入操作时获取mysql自增的主键值：</p><p>添加操作的dao层代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUserRoleRel</span><span class="hljs-params">(Long userId, Long[] roleIds)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Long roleId : roleIds) &#123;<br>            jdbcTemplate.update(<span class="hljs-string">&quot;insert into sys_user_role values(?,?)&quot;</span>,userId,roleId);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="18-Spring练习-删除用户操作-应用"><a href="#18-Spring练习-删除用户操作-应用" class="headerlink" title="18-Spring练习-删除用户操作(应用)"></a>18-Spring练习-删除用户操作(应用)</h2><p>删除用户功能的需求如图所示:</p><p><img src="/2017/10/10/SpringMVC/6.png"></p><p>操作步骤如下：</p><p>①点击用户列表的删除按钮，发送请求到服务器端</p><p>②编写UserController的del()方法</p><p>③编写UserService的del()方法</p><p>⑤编写UserDao的delUserRoleRel()方法</p><p>⑥跳回当前用户列表页面</p><p>完成用户的删除操作，不仅要删除用户表数据，同时需要将用户和角色的关联表数据进行删除：</p><p>controller代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/del/&#123;userId&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> Long userId)</span></span>&#123;<br>        userService.del(userId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/list&quot;</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>service代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(Long userId)</span> </span>&#123;<br>        <span class="hljs-comment">//1、删除sys_user_role关系表</span><br>        userDao.delUserRoleRel(userId);<br>        <span class="hljs-comment">//2、删除sys_user表</span><br>        userDao.del(userId);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>dao代码:不仅要删除用户表数据，同时需要将用户和角色的关联表数据进行删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delUserRoleRel</span><span class="hljs-params">(Long userId)</span> </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;delete from sys_user_role where userId=?&quot;</span>,userId);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(Long userId)</span> </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;delete from sys_user where id=?&quot;</span>,userId);<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2017/10/09/Mybatis/"/>
    <url>/2017/10/09/Mybatis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-1-MyBatis-框架概述"><a href="#1-1-MyBatis-框架概述" class="headerlink" title="1.1 MyBatis 框架概述"></a>1.1 MyBatis 框架概述</h2><blockquote><p>mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</p><p>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p><p>采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p><p>为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。</p></blockquote><h2 id="1-2-JDBC-编程的分析"><a href="#1-2-JDBC-编程的分析" class="headerlink" title="1.2 JDBC 编程的分析"></a>1.2 JDBC 编程的分析</h2><h3 id="1-2-1-jdbc-程序的回顾"><a href="#1-2-1-jdbc-程序的回顾" class="headerlink" title="1.2.1 jdbc 程序的回顾"></a>1.2.1 jdbc 程序的回顾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Connection connection = <span class="hljs-keyword">null</span>;<br>        PreparedStatement preparedStatement = <span class="hljs-keyword">null</span>;<br>        ResultSet resultSet = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//加载数据库驱动</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            <span class="hljs-comment">//通过驱动管理类获取数据库连接</span><br>            connection = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/eesy_jdbc?useSSL=false&amp;serverTimeZone=Shanghai/Asia&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-comment">//定义sql语句 ?表示占位符</span><br>            String sql = <span class="hljs-string">&quot;select * from account where id = ?&quot;</span>;<br>            <span class="hljs-comment">//获取预处理statement</span><br>            preparedStatement = connection.prepareStatement(sql);<br>            <span class="hljs-comment">//设置参数，第一个参数为sql语句中参数的序号，第二个参数为设置的参数值</span><br><span class="hljs-comment">//            preparedStatement.setInt(1,1);</span><br>            preparedStatement.setLong(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//向数据库发出sql执行查询，查询出结果集</span><br>            resultSet = preparedStatement.executeQuery();<br>            <span class="hljs-comment">//遍历结果集</span><br>            <span class="hljs-keyword">while</span> (resultSet.next())&#123;<br>                System.out.println(resultSet.getString(<span class="hljs-string">&quot;id&quot;</span>)+<span class="hljs-string">&quot; &quot;</span>+resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>)+ <span class="hljs-string">&quot; &quot;</span> + resultSet.getString(<span class="hljs-string">&quot;money&quot;</span>));<br>            &#125;<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放资源</span><br>            <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    resultSet.close();<br>                &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (preparedStatement != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    preparedStatement.close();<br>                &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    connection.close();<br>                &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上边使用 jdbc 的原始方法（未经封装）实现了查询数据库表记录的操作。</p><h3 id="1-2-2-jdbc问题分析"><a href="#1-2-2-jdbc问题分析" class="headerlink" title="1.2.2 jdbc问题分析"></a>1.2.2 jdbc问题分析</h3><blockquote><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java<br>代码。</p><p>3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能<br>多也可能少，修改 sql 还要修改代码，系统不易维护。</p><p>4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记<br>录封装成 pojo 对象解析比较方便</p></blockquote><h1 id="2-Mybatis框架快速入门"><a href="#2-Mybatis框架快速入门" class="headerlink" title="2 Mybatis框架快速入门"></a>2 Mybatis框架快速入门</h1><h2 id="2-1-Mybatis-框架开发的准备"><a href="#2-1-Mybatis-框架开发的准备" class="headerlink" title="2.1 Mybatis 框架开发的准备"></a>2.1 Mybatis 框架开发的准备</h2><h3 id="2-1-1-Mybatis官方文档"><a href="#2-1-1-Mybatis官方文档" class="headerlink" title="2.1.1 Mybatis官方文档"></a>2.1.1 Mybatis官方文档</h3><p><a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p><h2 id="2-2-搭建Mybatis开发环境"><a href="#2-2-搭建Mybatis开发环境" class="headerlink" title="2.2 搭建Mybatis开发环境"></a>2.2 搭建Mybatis开发环境</h2><h3 id="2-2-1-创建maven工程"><a href="#2-2-1-创建maven工程" class="headerlink" title="2.2.1 创建maven工程"></a>2.2.1 创建maven工程</h3><h3 id="2-2-2-添加Mybatis的坐标"><a href="#2-2-2-添加Mybatis的坐标" class="headerlink" title="2.2.2 添加Mybatis的坐标"></a>2.2.2 添加Mybatis的坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zjw<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>day01_eesy_01mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-3-编写User实体类"><a href="#2-2-3-编写User实体类" class="headerlink" title="2.2.3 编写User实体类"></a>2.2.3 编写User实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBirthday</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> birthday;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.birthday = birthday;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, birthday=&quot;</span> + birthday +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-4-编写持久层接口IUserDao"><a href="#2-2-4-编写持久层接口IUserDao" class="headerlink" title="2.2.4 编写持久层接口IUserDao"></a>2.2.4 编写持久层接口IUserDao</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.dao;<br><br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-5-编写持久层的映射文件IUserDao-xml"><a href="#2-2-5-编写持久层的映射文件IUserDao-xml" class="headerlink" title="2.2.5 编写持久层的映射文件IUserDao.xml"></a>2.2.5 编写持久层的映射文件IUserDao.xml</h3><p>要求：<br>创建位置：必须和持久层接口在相同的包中。<br>名称：必须以持久层接口名称命名文件名，扩展名是.xml</p><p><img src="/img/cphoto/mybatis01.jpg"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  配置查询所有  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>        select * from user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-6-编写SqlMapConfig-xml配置文件"><a href="#2-2-6-编写SqlMapConfig-xml配置文件" class="headerlink" title="2.2.6 编写SqlMapConfig.xml配置文件"></a>2.2.6 编写SqlMapConfig.xml配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- mybatis的主配置文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  配置环境  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置mysql的环境  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 配置事务的类型 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 配置数据源(连接池) --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 配置连接数据库的4个基本信息 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/eesy?serviceTimezone=Asia/Shanghai<span class="hljs-symbol">&amp;amp;</span>useSSL=false<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/zjw/dao/IUserDao.xml&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-7-编写测试类"><a href="#2-2-7-编写测试类" class="headerlink" title="2.2.7 编写测试类"></a>2.2.7 编写测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.test;<br><br><span class="hljs-keyword">import</span> com.zjw.dao.IUserDao;<br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//1.读取配置文件</span><br>        InputStream in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//2.创建SqlSessionFactory工厂</span><br>        SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        SqlSessionFactory factory = builder.build(in);<br>        <span class="hljs-comment">//3.使用工厂生产SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//4.使用SqlSession创建Dao接口的代理对象</span><br>        IUserDao userDao = session.getMapper(IUserDao.class);<br>        <span class="hljs-comment">//5.使用代理对象执行方法</span><br>        List&lt;User&gt; users = userDao.findAll();<br>        <span class="hljs-keyword">for</span> (User user: users) &#123;<br>            System.out.println(user);<br>        &#125;<br>        <span class="hljs-comment">//6.释放资源</span><br>        session.close();<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><blockquote><p>通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得更为简单，只需要编写一个 mybatis 配置文件就够了。）</p><p>但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等</p><p>这些问题我们在自定义 mybatis 框架的章节，通过层层剥离的方式，给大家讲解。</p><p>请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有一个认识。</p></blockquote><h2 id="2-4-补充（基于注解的mybatis使用）"><a href="#2-4-补充（基于注解的mybatis使用）" class="headerlink" title="2.4 补充（基于注解的mybatis使用）"></a>2.4 补充（基于注解的mybatis使用）</h2><h3 id="2-4-1-在持久层接口中添加注解"><a href="#2-4-1-在持久层接口中添加注解" class="headerlink" title="2.4.1 在持久层接口中添加注解"></a>2.4.1 在持久层接口中添加注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.dao;<br><br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-2-修改SqlMapConfig-xml"><a href="#2-4-2-修改SqlMapConfig-xml" class="headerlink" title="2.4.2 修改SqlMapConfig.xml"></a>2.4.2 修改SqlMapConfig.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-comment">&lt;!--  指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件</span><br><span class="hljs-comment">    如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名</span><br><span class="hljs-comment">  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;mapper resource=&quot;com/zjw/dao/IUserDao.xml&quot; /&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-3-注意事项"><a href="#2-4-3-注意事项" class="headerlink" title="2.4.3 注意事项"></a>2.4.3 注意事项</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">在使用基于注解的 Mybatis 配置时，请移除 <span class="hljs-keyword">xml</span> <span class="hljs-title">的映射配置（IUserDao</span>.xml）。<br></code></pre></td></tr></table></figure><h1 id="3-基于代理Dao实现CRUD操作"><a href="#3-基于代理Dao实现CRUD操作" class="headerlink" title="3 基于代理Dao实现CRUD操作"></a>3 基于代理Dao实现CRUD操作</h1><p><strong>使用要求：</strong></p><blockquote><p>1、持久层接口和持久层接口的映射配置必须在相同的包下。</p><p>2、持久层映射配置中 mapper 标签的 namespace 属性取值必须是持久层接口的全限定类名。</p><p>3、SQL 语句的配置标签<select>,<insert>,<delete>,<update>的 id 属性必须和持久层接口的方法名相同。</update></delete></insert></select></p></blockquote><h2 id="3-1-根据id查询"><a href="#3-1-根据id查询" class="headerlink" title="3.1 根据id查询"></a>3.1 根据id查询</h2><h3 id="3-1-1-在持久层接口中添加findById方法"><a href="#3-1-1-在持久层接口中添加findById方法" class="headerlink" title="3.1.1 在持久层接口中添加findById方法"></a>3.1.1 在持久层接口中添加findById方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Integer userId)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-1-2-在用户的映射配置文件中配置"><a href="#3-1-2-在用户的映射配置文件中配置" class="headerlink" title="3.1.2 在用户的映射配置文件中配置"></a>3.1.2 在用户的映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--查询用户--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>    select * from user where id = #&#123;userId&#125; ;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>resultType属性</code>: 用于指定结果集的类型</p><p><code>parameterType属性</code>:用于指定传入参数的类型</p><p><code>sql语句中使用#&#123;&#125;字符</code>：<br>它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。<br>具体的数据是由#{}里面的内容决定的。</p><p><code>#&#123;&#125;中内容的写法</code>：<br>由于数据类型是基本类型，所以此处可以随意写。</p><h3 id="3-1-3-在测试类添加测试"><a href="#3-1-3-在测试类添加测试" class="headerlink" title="3.1.3 在测试类添加测试"></a>3.1.3 在测试类添加测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.test;<br><br><span class="hljs-keyword">import</span> com.zjw.dao.IUserDao;<br><span class="hljs-keyword">import</span> com.zjw.domain.QueryVo;<br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        userDao = session.getMapper(IUserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testfindById</span><span class="hljs-params">()</span></span>&#123;<br>        User user = userDao.findById(<span class="hljs-number">50</span>);<br>        System.out.println(user);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-保存操作"><a href="#3-2-保存操作" class="headerlink" title="3.2 保存操作"></a>3.2 保存操作</h2><h3 id="3-2-1-在持久层接口中添加新增方法"><a href="#3-2-1-在持久层接口中添加新增方法" class="headerlink" title="3.2.1 在持久层接口中添加新增方法"></a>3.2.1 在持久层接口中添加新增方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-在用户䣌映射配置文件中配置"><a href="#3-2-2-在用户䣌映射配置文件中配置" class="headerlink" title="3.2.2 在用户䣌映射配置文件中配置"></a>3.2.2 在用户䣌映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--保存用户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>        insert into user(username,address,birthday,sex) values (#&#123;userName&#125;,#&#123;userAddress&#125;,#&#123;userBirthday&#125;,#&#123;userSex&#125;) ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>细节：</strong></p><p><strong>parameterType 属性：</strong></p><blockquote><p>代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。</p></blockquote><p><strong>sql 语句中使用#{}字符：</strong></p><blockquote><p>它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。<br>具体的数据是由#{}里面的内容决定的。</p></blockquote><p><strong>#{}中内容的写法：</strong><br>由于我们保存方法的参数是 一个 User 对象，此处要写 User 对象中的属性名称。<br>它用的是 ognl 表达式。<br><code>ognl 表达式</code>：</p><blockquote><p>它是 apache 提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言</p><p>它是按照一定的语法格式来获取数据的。</p><p>语法格式就是使用 #{对象.对象}的方式</p><p>#{user.username}它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用getUsername()方法把值取出来。但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user.而直接写 username。</p></blockquote><h3 id="3-2-3-在测试类中的测试方法"><a href="#3-2-3-在测试类中的测试方法" class="headerlink" title="3.2.3 在测试类中的测试方法"></a>3.2.3 在测试类中的测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试保存操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveUser</span><span class="hljs-params">()</span></span>&#123;<br><br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setUserName(<span class="hljs-string">&quot;朱俊伟1231231232&quot;</span>);<br>    user.setUserAddress(<span class="hljs-string">&quot;河南&quot;</span>);<br>    user.setUserBirthday(<span class="hljs-keyword">new</span> Date());<br>    user.setUserSex(<span class="hljs-string">&quot;男&quot;</span>);<br><br>    userDao.saveUser(user);<br>&#125;<br><br>  <br></code></pre></td></tr></table></figure><blockquote><p>打开 Mysql 数据库发现并没有添加任何记录，原因是什么？</p><p>这一点和 jdbc 是一样的，我们在实现增删改时一定要去控制事务的提交，那么在 mybatis 中如何控制事务提交呢？</p><p>可以使用:session.commit();来实现事务提交。加入事务提交后的代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@After</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    session.commit();<br>    session.close();<br>    in.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-4-问题扩展：新增用户id的返回值"><a href="#3-2-4-问题扩展：新增用户id的返回值" class="headerlink" title="3.2.4 问题扩展：新增用户id的返回值"></a>3.2.4 问题扩展：新增用户id的返回值</h3><blockquote><p>新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--保存用户后返回id--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUserReturnId&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;AFTER&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        select LAST_INSERT_ID();<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    insert into user(username,address,birthday,sex) values (#&#123;userName&#125;,#&#123;userAddress&#125;,#&#123;userBirthday&#125;,#&#123;userSex&#125;) ;<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br> /**<br> * 测试保存返回id操作<br> * @throws IOException<br> */<br>@Test<br>public void testSaveUserReturnId()&#123;<br><br>    User user = new User();<br>    user.setUserName(&quot;testInsert id&quot;);<br>    user.setUserAddress(&quot;河南&quot;);<br>    user.setUserBirthday(new Date());<br>    user.setUserSex(&quot;男&quot;);<br><br>    System.out.println(user);//插入前打印无id<br>    userDao.saveUserReturnId(user);<br>    System.out.println(user);//插入后打印有id<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-用户更新"><a href="#3-3-用户更新" class="headerlink" title="3.3 用户更新"></a>3.3 用户更新</h2><h3 id="3-3-1-在持久层接口中添加更新方法"><a href="#3-3-1-在持久层接口中添加更新方法" class="headerlink" title="3.3.1 在持久层接口中添加更新方法"></a>3.3.1 在持久层接口中添加更新方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-2-在用户的映射配置文件中配置"><a href="#3-3-2-在用户的映射配置文件中配置" class="headerlink" title="3.3.2 在用户的映射配置文件中配置"></a>3.3.2 在用户的映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--更新用户--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>    update user set username=#&#123;userName&#125;,address=#&#123;userAddress&#125;,birthday=#&#123;userBirthday&#125;,sex=#&#123;userSex&#125; where id=#&#123;userId&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-3-3-加入更新的测试方法"><a href="#3-3-3-加入更新的测试方法" class="headerlink" title="3.3.3 加入更新的测试方法"></a>3.3.3 加入更新的测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试更新操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdateUser</span><span class="hljs-params">()</span></span>&#123;<br><br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setUserId(<span class="hljs-number">50</span>);<br>    user.setUserName(<span class="hljs-string">&quot;王二&quot;</span>);<br>    user.setUserAddress(<span class="hljs-string">&quot;河南11111111&quot;</span>);<br>    user.setUserBirthday(<span class="hljs-keyword">new</span> Date());<br>    user.setUserSex(<span class="hljs-string">&quot;男&quot;</span>);<br><br>    userDao.updateUser(user);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-用户删除"><a href="#3-4-用户删除" class="headerlink" title="3.4 用户删除"></a>3.4 用户删除</h2><h3 id="3-4-1-在持久层接口中添加删除方法"><a href="#3-4-1-在持久层接口中添加删除方法" class="headerlink" title="3.4.1 在持久层接口中添加删除方法"></a>3.4.1 在持久层接口中添加删除方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(Integer userId)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-4-2-在用户的映射配置文件中配置"><a href="#3-4-2-在用户的映射配置文件中配置" class="headerlink" title="3.4.2 在用户的映射配置文件中配置"></a>3.4.2 在用户的映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--删除用户--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    delete from user where id = #&#123;userId&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-4-3-加入删除的测试方法"><a href="#3-4-3-加入删除的测试方法" class="headerlink" title="3.4.3 加入删除的测试方法"></a>3.4.3 加入删除的测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试删除操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>    userDao.deleteUser(<span class="hljs-number">48</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-用户模糊查询"><a href="#3-5-用户模糊查询" class="headerlink" title="3.5 用户模糊查询"></a>3.5 用户模糊查询</h2><h3 id="3-5-1-在持久层接口最终添加模糊查询方法"><a href="#3-5-1-在持久层接口最终添加模糊查询方法" class="headerlink" title="3.5.1 在持久层接口最终添加模糊查询方法"></a>3.5.1 在持久层接口最终添加模糊查询方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据名字模糊查询用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> userName</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String userName)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-2-在用户的映射配置文件中配置"><a href="#3-5-2-在用户的映射配置文件中配置" class="headerlink" title="3.5.2 在用户的映射配置文件中配置"></a>3.5.2 在用户的映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--根据名字模糊查询用户--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--使用的占位符，推荐使用，不过参数要加上%--&gt;</span><br>    <span class="hljs-comment">&lt;!-- select * from user where username like #&#123;userName&#125;;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--使用的是字符串拼接，参数不用加%，但是会有sql注入问题--&gt;</span><br>    select * from user where username like &#x27;%$&#123;value&#125;%&#x27;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-3-加入模糊查询的测试方法"><a href="#3-5-3-加入模糊查询的测试方法" class="headerlink" title="3.5.3 加入模糊查询的测试方法"></a>3.5.3 加入模糊查询的测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试根据名字模糊查询用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindByName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//使用#&#123;&#125; , 需要加%</span><br><span class="hljs-comment">//        List&lt;User&gt; userList = userDao.findByName(&quot;%王%&quot;);</span><br>        <span class="hljs-comment">//使用$&#123;&#125; , 不用加%</span><br>        List&lt;User&gt; userList = userDao.findByName(<span class="hljs-string">&quot;王&quot;</span>);<br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-4-和-的区别"><a href="#3-5-4-和-的区别" class="headerlink" title="3.5.4 #{}和${}的区别"></a>3.5.4 #{}和${}的区别</h3><p><strong>#{}表示一个占位符号</strong><br>通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。</p><p><strong>${}表示拼接 sql 串</strong><br>通过${}可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换,${}可以接收简<br>单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值,${}括号中只能是 value。</p><h2 id="3-6-查询使用聚合函数"><a href="#3-6-查询使用聚合函数" class="headerlink" title="3.6 查询使用聚合函数"></a>3.6 查询使用聚合函数</h2><h3 id="3-6-1在持久层接口中添加模糊查询方法"><a href="#3-6-1在持久层接口中添加模糊查询方法" class="headerlink" title="3.6.1在持久层接口中添加模糊查询方法"></a>3.6.1在持久层接口中添加模糊查询方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询用户的所有记录数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTotal</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-6-2-在用户的映射配置文件中配置"><a href="#3-6-2-在用户的映射配置文件中配置" class="headerlink" title="3.6.2 在用户的映射配置文件中配置"></a>3.6.2 在用户的映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findTotal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span> &gt;</span><br>    select count(*) from user;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-6-3-加入聚合查询的测试方法"><a href="#3-6-3-加入聚合查询的测试方法" class="headerlink" title="3.6.3 加入聚合查询的测试方法"></a>3.6.3 加入聚合查询的测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询用户的条数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindTotal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> total = userDao.findTotal();<br>    System.out.println(total);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-7-Mybatis与JDBC编程的比较"><a href="#3-7-Mybatis与JDBC编程的比较" class="headerlink" title="3.7 Mybatis与JDBC编程的比较"></a>3.7 Mybatis与JDBC编程的比较</h2><blockquote><p>1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>解决：<br>在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。</p><p>2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。<br>解决：<br>将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。</p><p>3.向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。<br>解决：<br>Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。</p><p>4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。<br>解决：<br>Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的类型</p></blockquote><h1 id="4-Mybatis的参数深入"><a href="#4-Mybatis的参数深入" class="headerlink" title="4 Mybatis的参数深入"></a>4 Mybatis的参数深入</h1><h2 id="4-1-parameterType配置参数"><a href="#4-1-parameterType配置参数" class="headerlink" title="4.1 parameterType配置参数"></a>4.1 parameterType配置参数</h2><h3 id="4-1-1-使用说明"><a href="#4-1-1-使用说明" class="headerlink" title="4.1.1 使用说明"></a>4.1.1 使用说明</h3><blockquote><p>我们在上一章节中已经介绍了 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类，本章节将介绍如何使用实体类的包装类作为参数传递。</p></blockquote><h3 id="4-1-2-注意事项"><a href="#4-1-2-注意事项" class="headerlink" title="4.1.2 注意事项"></a>4.1.2 注意事项</h3><blockquote><p>基本类型和String我们可以直接写类型名称，也可以使用包名.类名的方式，例如：java.lang.String。<br>实体类类型，目前我们只能使用全限定类名。<br>究其原因，是 mybaits 在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。在今天课程的最后一个章节中将讲解如何注册实体类的别名。</p></blockquote><p>在 mybatis 的官方文档的说明(<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases</a>)</p><p><img src="/img/cphoto/mybatis02.jpg"></p><p>这些都是支持的默认别名。我们也可以从源码角度来看它们分别都是如何定义出来的。<br>可以参考 TypeAliasRegistery.class 的源码。</p><h2 id="4-2-传递pojo包装对象"><a href="#4-2-传递pojo包装对象" class="headerlink" title="4.2 传递pojo包装对象"></a>4.2 传递pojo包装对象</h2><blockquote><p>开发中通过pojo传递查询条件，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</p><p>Pojo 类中包含 pojo。</p><p>需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。</p></blockquote><h3 id="4-2-1-编写QueryVo"><a href="#4-2-1-编写QueryVo" class="headerlink" title="4.2.1 编写QueryVo"></a>4.2.1 编写QueryVo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryVo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> User user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-编写持久层接口"><a href="#4-2-2-编写持久层接口" class="headerlink" title="4.2.2 编写持久层接口"></a>4.2.2 编写持久层接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据queryVo中的条件查询用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findUserByVo</span><span class="hljs-params">(QueryVo queryVo)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-持久层接口的映射文件"><a href="#4-2-3-持久层接口的映射文件" class="headerlink" title="4.2.3 持久层接口的映射文件"></a>4.2.3 持久层接口的映射文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--根据queryVo的添加查询用户--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findUserByVo&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.zjw.domain.QueryVo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--ognl表达式：</span><br><span class="hljs-comment">        user：QueryVo类中的属性</span><br><span class="hljs-comment">    --&gt;</span><br>    select * from user where username like #&#123;user.userName&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-2-4-测试包装类作为参数"><a href="#4-2-4-测试包装类作为参数" class="headerlink" title="4.2.4 测试包装类作为参数"></a>4.2.4 测试包装类作为参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试QueryVo查询用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindUserByVo</span><span class="hljs-params">()</span></span>&#123;<br>    QueryVo queryVo = <span class="hljs-keyword">new</span> QueryVo();<br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setUserName(<span class="hljs-string">&quot;%王%&quot;</span>);<br>    queryVo.setUser(user);<br><br>    List&lt;User&gt; userList = userDao.findUserByVo(queryVo);<br>    <span class="hljs-keyword">for</span> (User u : userList) &#123;<br>        System.out.println(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Mybatis的输出结果封装"><a href="#5-Mybatis的输出结果封装" class="headerlink" title="5 Mybatis的输出结果封装"></a>5 Mybatis的输出结果封装</h1><h2 id="5-1-resultType配置结果类型"><a href="#5-1-resultType配置结果类型" class="headerlink" title="5.1 resultType配置结果类型"></a>5.1 resultType配置结果类型</h2><blockquote><p> resultType 属性可以指定结果集的类型，它支持基本类型和实体类类型。</p><p>  我们在前面的 CRUD 案例中已经对此属性进行过应用了。</p><p>  需要注意的是，它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。例如：我们的实体类此时必须是全限定类名（今天最后一个章节会讲解如何配置实体类的别名）</p><p>  同时，当是实体类名称是，还有一个要求，实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装。</p></blockquote><h3 id="5-1-1-特殊情况（属性名和列名不一致）"><a href="#5-1-1-特殊情况（属性名和列名不一致）" class="headerlink" title="5.1.1 特殊情况（属性名和列名不一致）"></a>5.1.1 特殊情况（属性名和列名不一致）</h3><h4 id="5-1-1-1-数据库，User类"><a href="#5-1-1-1-数据库，User类" class="headerlink" title="5.1.1.1 数据库，User类"></a>5.1.1.1 数据库，User类</h4><p><img src="/img/cphoto/mybatis03.jpg"></p><h4 id="5-1-1-2-Dao接口"><a href="#5-1-1-2-Dao接口" class="headerlink" title="5.1.1.2 Dao接口"></a>5.1.1.2 Dao接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h4 id="5-1-1-3-映射配置"><a href="#5-1-1-3-映射配置" class="headerlink" title="5.1.1.3 映射配置"></a>5.1.1.3 映射配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--查询所有--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>    select  * from user;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="5-1-1-4-测试查询结果"><a href="#5-1-1-4-测试查询结果" class="headerlink" title="5.1.1.4 测试查询结果"></a>5.1.1.4 测试查询结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;User&gt; users = userDao.findAll();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br>User&#123;userId=<span class="hljs-keyword">null</span>, userName=<span class="hljs-string">&#x27;老王&#x27;</span>, userAddress=<span class="hljs-string">&#x27;null&#x27;</span>, userSex=<span class="hljs-string">&#x27;null&#x27;</span>, userBirthday=<span class="hljs-keyword">null</span>&#125;<br>User&#123;userId=<span class="hljs-keyword">null</span>, userName=<span class="hljs-string">&#x27;小二王&#x27;</span>, userAddress=<span class="hljs-string">&#x27;null&#x27;</span>, userSex=<span class="hljs-string">&#x27;null&#x27;</span>, userBirthday=<span class="hljs-keyword">null</span>&#125;<br>User&#123;userId=<span class="hljs-keyword">null</span>, userName=<span class="hljs-string">&#x27;小二王&#x27;</span>, userAddress=<span class="hljs-string">&#x27;null&#x27;</span>, userSex=<span class="hljs-string">&#x27;null&#x27;</span>, userBirthday=<span class="hljs-keyword">null</span>&#125;<br>User&#123;userId=<span class="hljs-keyword">null</span>, userName=<span class="hljs-string">&#x27;传智播客&#x27;</span>, userAddress=<span class="hljs-string">&#x27;null&#x27;</span>, userSex=<span class="hljs-string">&#x27;null&#x27;</span>, userBirthday=<span class="hljs-keyword">null</span>&#125;<br>User&#123;userId=<span class="hljs-keyword">null</span>, userName=<span class="hljs-string">&#x27;老王&#x27;</span>, userAddress=<span class="hljs-string">&#x27;null&#x27;</span>, userSex=<span class="hljs-string">&#x27;null&#x27;</span>, userBirthday=<span class="hljs-keyword">null</span>&#125;<br>User&#123;userId=<span class="hljs-keyword">null</span>, userName=<span class="hljs-string">&#x27;testInsert id&#x27;</span>, userAddress=<span class="hljs-string">&#x27;null&#x27;</span>, userSex=<span class="hljs-string">&#x27;null&#x27;</span>, userBirthday=<span class="hljs-keyword">null</span>&#125;<br>User&#123;userId=<span class="hljs-keyword">null</span>, userName=<span class="hljs-string">&#x27;mybatis annotation&#x27;</span>, userAddress=<span class="hljs-string">&#x27;null&#x27;</span>, userSex=<span class="hljs-string">&#x27;null&#x27;</span>, userBirthday=<span class="hljs-keyword">null</span>&#125;<br></code></pre></td></tr></table></figure><p>发现名称有值，因为windows系统不区分大小写。其他值均为null.<br>可以通过给列名取别名实现封装。也可以使用resultMap结果类型。</p><h4 id="5-1-1-5-修改映射配置"><a href="#5-1-1-5-修改映射配置" class="headerlink" title="5.1.1.5 修改映射配置"></a>5.1.1.5 修改映射配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>    select  id as userId,<br>            username as userName,<br>            birthday as userBirthday,<br>            sex as userSex,<br>            address as userAddress<br>    from user;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过给列名取别名可以实现封装，但是太麻烦！</p><h2 id="5-2-resultMap结果类型"><a href="#5-2-resultMap结果类型" class="headerlink" title="5.2 resultMap结果类型"></a>5.2 resultMap结果类型</h2><blockquote><p> resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。</p><p> 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。</p></blockquote><h3 id="5-2-1-定义resultMap"><a href="#5-2-1-定义resultMap" class="headerlink" title="5.2.1 定义resultMap"></a>5.2.1 定义resultMap</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userAddress&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userBirthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userSex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>id 标签</strong>：用于指定主键字段<br><strong>result 标签</strong>：用于指定非主键字段<br><strong>column 属性</strong>：用于指定数据库列名<br><strong>property 属性</strong>：用于指定实体类属性名称</p><h3 id="5-2-2-映射配置"><a href="#5-2-2-映射配置" class="headerlink" title="5.2.2 映射配置"></a>5.2.2 映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--查询所有--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    select  * from user;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用resultMap属性指定我们定义的id</p></blockquote><h1 id="6-Mybatis传统Dao层开发-了解"><a href="#6-Mybatis传统Dao层开发-了解" class="headerlink" title="6 Mybatis传统Dao层开发[了解]"></a>6 Mybatis传统Dao层开发[了解]</h1><blockquote><p>使用 Mybatis 开发 Dao，通常有两个方法，即原始 Dao 开发方式和 Mapper 接口代理开发方式。而现在主流的开发方式是接口代理开发方式，这种方式总体上更加简便。我们的课程讲解也主要以接口代理开发方式为主。在第二章节已经给大家介绍了基于代理方式的 dao 开发，现在给大家介绍一下基于传统编写 Dao 实现类的开发方式。</p></blockquote><h2 id="6-1-Mybatis实现Dao的传统开发方式"><a href="#6-1-Mybatis实现Dao的传统开发方式" class="headerlink" title="6.1 Mybatis实现Dao的传统开发方式"></a>6.1 Mybatis实现Dao的传统开发方式</h2><h3 id="6-1-1-持久层Dao接口"><a href="#6-1-1-持久层Dao接口" class="headerlink" title="6.1.1 持久层Dao接口"></a>6.1.1 持久层Dao接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.dao;<br><br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveUserReturnId</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(Integer userId)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Integer userId)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据名字模糊查询用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String userName)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询用户的所有记录数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTotal</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-1-2-持久层Dao实现类"><a href="#6-1-2-持久层Dao实现类" class="headerlink" title="6.1.2 持久层Dao实现类"></a>6.1.2 持久层Dao实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.dao.impl;<br><br><span class="hljs-keyword">import</span> com.zjw.dao.IUserDao;<br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserDaoImpl</span><span class="hljs-params">(SqlSessionFactory factory)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.factory = factory ;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//1、获取SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//2、调用SqlSession中的方法，实现查询列表</span><br>        List&lt;User&gt; users = session.selectList(<span class="hljs-string">&quot;com.zjw.dao.IUserDao.findAll&quot;</span>);<span class="hljs-comment">//参数就是能获取配置信息的key(namespace+id)</span><br>        <span class="hljs-comment">//3、释放资源</span><br>        session.close();<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-comment">//1、获取SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//2、调用SqlSession中的方法，实现保存用户操作</span><br>        session.insert(<span class="hljs-string">&quot;com.zjw.dao.IUserDao.saveUser&quot;</span>,user);<span class="hljs-comment">//参数就是能获取配置信息的key(namespace+id),要操作的对象</span><br>        <span class="hljs-comment">//3、释放资源</span><br>        session.commit();<br>        session.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUserReturnId</span><span class="hljs-params">(User user)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-comment">//1、获取SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//2、调用SqlSession中的方法，实现保存用户操作</span><br>        session.update(<span class="hljs-string">&quot;com.zjw.dao.IUserDao.updateUser&quot;</span>,user);<span class="hljs-comment">//参数就是能获取配置信息的key(namespace+id)</span><br>        <span class="hljs-comment">//3、释放资源</span><br>        session.commit();<br>        session.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>        <span class="hljs-comment">//1、获取SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//2、调用SqlSession中的方法，实现保存用户操作</span><br>        session.delete(<span class="hljs-string">&quot;com.zjw.dao.IUserDao.deleteUser&quot;</span>,userId);<span class="hljs-comment">//参数就是能获取配置信息的key(namespace+id)</span><br>        <span class="hljs-comment">//3、释放资源</span><br>        session.commit();<br>        session.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findById</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>        <span class="hljs-comment">//1、获取SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//2、调用SqlSession中的方法，实现保存用户操作</span><br>        User user = session.selectOne(<span class="hljs-string">&quot;com.zjw.dao.IUserDao.findById&quot;</span>, userId);<span class="hljs-comment">//参数就是能获取配置信息的key(namespace+id)</span><br>        <span class="hljs-comment">//3、释放资源</span><br>        session.close();<br>        <span class="hljs-keyword">return</span> user ;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String userName)</span> </span>&#123;<br>        <span class="hljs-comment">//1、获取SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//2、调用SqlSession中的方法，实现保存用户操作</span><br>        List&lt;User&gt; users = session.selectList(<span class="hljs-string">&quot;com.zjw.dao.IUserDao.findByName&quot;</span>, userName);<span class="hljs-comment">//参数就是能获取配置信息的key(namespace+id)</span><br>        <span class="hljs-comment">//3、释放资源</span><br>        session.close();<br>        <span class="hljs-keyword">return</span> users ;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTotal</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//1、获取SqlSession对象</span><br>        SqlSession session = factory.openSession();<br>        <span class="hljs-comment">//2、调用SqlSession中的方法，实现保存用户操作</span><br>        <span class="hljs-keyword">int</span> count = session.selectOne(<span class="hljs-string">&quot;com.zjw.dao.IUserDao.findTotal&quot;</span>);<span class="hljs-comment">//参数就是能获取配置信息的key(namespace+id)</span><br>        <span class="hljs-comment">//3、释放资源</span><br>        session.close();<br>        <span class="hljs-keyword">return</span> count ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-1-3-持久层映射配置"><a href="#6-1-3-持久层映射配置" class="headerlink" title="6.1.3 持久层映射配置"></a>6.1.3 持久层映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询所有--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span> &gt;</span><br>        select  * from user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--保存用户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>        insert into user(username,address,birthday,sex) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;birthday&#125;,#&#123;sex&#125;) ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--保存用户后返回id--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUserReturnId&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;AFTER&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>            select LAST_INSERT_ID();<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>        insert into user(username,address,birthday,sex) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;birthday&#125;,#&#123;sex&#125;) ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--更新用户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>        update user set username=#&#123;username&#125;,address=#&#123;address&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125; where id=#&#123;id&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--删除用户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        delete from user where id = #&#123;userId&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询用户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>        select * from user where id = #&#123;userId&#125; ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据名字模糊查询用户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.zjw.domain.User&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--使用的占位符，推荐使用，不过参数要加上%--&gt;</span><br>        select * from user where username like #&#123;userName&#125;;<br><br>        <span class="hljs-comment">&lt;!--使用的是字符串拼接，参数不用加%，但是会有sql注入问题--&gt;</span><br>        <span class="hljs-comment">&lt;!-- select * from user where username like &#x27;%$&#123;value&#125;%&#x27;;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findTotal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span> &gt;</span><br>        select count(*) from user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-1-4-测试类"><a href="#6-1-4-测试类" class="headerlink" title="6.1.4 测试类"></a>6.1.4 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.test;<br><br><span class="hljs-keyword">import</span> com.zjw.dao.IUserDao;<br><span class="hljs-keyword">import</span> com.zjw.dao.impl.UserDaoImpl;<br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成dao对象</span><br>        userDao = <span class="hljs-keyword">new</span> UserDaoImpl(factory);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//释放资源</span><br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; users = userDao.findAll();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试保存操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveUser</span><span class="hljs-params">()</span></span>&#123;<br><br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUsername(<span class="hljs-string">&quot;testInsert user...&quot;</span>);<br>        user.setAddress(<span class="hljs-string">&quot;河南&quot;</span>);<br>        user.setBirthday(<span class="hljs-keyword">new</span> Date());<br>        user.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br><br>        userDao.saveUser(user);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试保存返回id操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveUserReturnId</span><span class="hljs-params">()</span></span>&#123;<br><br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUsername(<span class="hljs-string">&quot;testInsert user...&quot;</span>);<br>        user.setAddress(<span class="hljs-string">&quot;河南&quot;</span>);<br>        user.setBirthday(<span class="hljs-keyword">new</span> Date());<br>        user.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br><br>        userDao.saveUser(user);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试更新操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdateUser</span><span class="hljs-params">()</span></span>&#123;<br><br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setId(<span class="hljs-number">50</span>);<br>        user.setUsername(<span class="hljs-string">&quot;朱俊伟111&quot;</span>);<br>        user.setAddress(<span class="hljs-string">&quot;河南11111111&quot;</span>);<br>        user.setBirthday(<span class="hljs-keyword">new</span> Date());<br>        user.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br><br>        userDao.updateUser(user);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试删除操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>        userDao.deleteUser(<span class="hljs-number">53</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testfindById</span><span class="hljs-params">()</span></span>&#123;<br>        User user = userDao.findById(<span class="hljs-number">50</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试根据名字模糊查询用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindByName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//使用#&#123;&#125; , 需要加%</span><br>        List&lt;User&gt; userList = userDao.findByName(<span class="hljs-string">&quot;%王%&quot;</span>);<br>        <span class="hljs-comment">//使用$&#123;&#125; , 不用加%</span><br><span class="hljs-comment">//        List&lt;User&gt; userList = userDao.findByName(&quot;王&quot;);</span><br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询用户的条数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindTotal</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> total = userDao.findTotal();<br>        System.out.println(total);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-SqlMapConfig-xml配置文件"><a href="#7-SqlMapConfig-xml配置文件" class="headerlink" title="7 SqlMapConfig.xml配置文件"></a>7 SqlMapConfig.xml配置文件</h1><h2 id="7-1-配置内容"><a href="#7-1-配置内容" class="headerlink" title="7.1 配置内容"></a>7.1 配置内容</h2><h3 id="7-1-1-SqlMapConfig-xml中配置的内容和顺序"><a href="#7-1-1-SqlMapConfig-xml中配置的内容和顺序" class="headerlink" title="7.1.1 SqlMapConfig.xml中配置的内容和顺序"></a>7.1.1 SqlMapConfig.xml中配置的内容和顺序</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">properties（属性）</span><br><span class="ruby"></span>      -<span class="ruby">-property</span><br><span class="ruby"></span>-<span class="ruby">settings（全局配置参数）</span><br><span class="ruby"></span>      -<span class="ruby">-setting</span><br><span class="ruby"></span>-<span class="ruby">typeAliases（类型别名）</span><br><span class="ruby"></span>      -<span class="ruby">-typeAliase</span><br><span class="ruby"></span>      -<span class="ruby">-package</span><br><span class="ruby"></span>-<span class="ruby">typeHandlers（类型处理器）</span><br><span class="ruby"></span>-<span class="ruby">objectFactory（对象工厂）</span><br><span class="ruby"></span>-<span class="ruby">plugins（插件）</span><br><span class="ruby"></span>-<span class="ruby">environments（环境集合属性对象）</span><br><span class="ruby"></span>      -<span class="ruby">-environment（环境子属性对象）</span><br><span class="ruby"></span>            -<span class="ruby">--transactionManager（事务管理）</span><br><span class="ruby"></span>            -<span class="ruby">--dataSource（数据源）</span><br><span class="ruby"></span>-<span class="ruby">mappers（映射器）</span><br><span class="ruby"></span>      -<span class="ruby">-mapper</span><br><span class="ruby"></span>      -<span class="ruby">-package</span><br></code></pre></td></tr></table></figure><h2 id="7-2-properties-属性"><a href="#7-2-properties-属性" class="headerlink" title="7.2 properties(属性)"></a>7.2 properties(属性)</h2><blockquote><p>在使用properties配置标签时，我们可以采用两种方式指定属性配置。</p></blockquote><h3 id="7-2-1-第一种"><a href="#7-2-1-第一种" class="headerlink" title="7.2.1 第一种"></a>7.2.1 第一种</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc.driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc.url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/eesy&quot;</span>/&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc.username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc.password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-2-2-第二种"><a href="#7-2-2-第二种" class="headerlink" title="7.2.2 第二种"></a>7.2.2 第二种</h3><h4 id="7-2-2-1-在classpath下定义properties文件"><a href="#7-2-2-1-在classpath下定义properties文件" class="headerlink" title="7.2.2.1 在classpath下定义properties文件"></a>7.2.2.1 在classpath下定义properties文件</h4><p><img src="/img/cphoto/mybatis04.jpg"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/eesy?serviceTimezone=Asia/Shanghai&amp;useSSL=false</span><br><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h4 id="7-2-2-2-properties标签配置"><a href="#7-2-2-2-properties标签配置" class="headerlink" title="7.2.2.2 properties标签配置"></a>7.2.2.2 properties标签配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&lt;properties url=&quot;file:///E:\code\IdeaProjects\mybatis\day02_eesy_01mybatisCRUD\src\main\resources\jdbcConfig.properties&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbcConfig.properties&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-2-3-此时我们的dataSource标签就编程了引用上面的配置"><a href="#7-2-3-此时我们的dataSource标签就编程了引用上面的配置" class="headerlink" title="7.2.3 此时我们的dataSource标签就编程了引用上面的配置"></a>7.2.3 此时我们的dataSource标签就编程了引用上面的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-3-typeAliases-类型别名"><a href="#7-3-typeAliases-类型别名" class="headerlink" title="7.3 typeAliases(类型别名)"></a>7.3 typeAliases(类型别名)</h2><blockquote><p>在前面我们讲的 Mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发</p></blockquote><h3 id="7-3-1-自定义别名"><a href="#7-3-1-自定义别名" class="headerlink" title="7.3.1 自定义别名"></a>7.3.1 自定义别名</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  使用typeAliases配置别名，它只能配置domain中的类的别名  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- typeiAlias用于配置别名。type属性指定的是实体类全限定类名。alias属性指定别名，当指定了别名就再区分大小写  --&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;typeAlias type=&quot;com.zjw.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.zjw.domain&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-4-mappers-映射器"><a href="#7-4-mappers-映射器" class="headerlink" title="7.4 mappers(映射器)"></a>7.4 mappers(映射器)</h2><h3 id="7-4-1-resource"><a href="#7-4-1-resource" class="headerlink" title="7.4.1 resource"></a>7.4.1 resource</h3><blockquote><p>使用相对于类路径的资源</p></blockquote><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/zjw/dao/IUserDao.xml&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-4-2-class"><a href="#7-4-2-class" class="headerlink" title="7.4.2 class"></a>7.4.2 class</h3><blockquote><p>使用mapper接口类路径</p></blockquote><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zjw.dao.UserDao&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</p></blockquote><h3 id="7-4-3-package"><a href="#7-4-3-package" class="headerlink" title="7.4.3 package"></a>7.4.3 package</h3><blockquote><p>注册指定包下的所有mapper接口</p></blockquote><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.zjw.dao&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</p></blockquote><h1 id="Mybatis连接池与事务深入"><a href="#Mybatis连接池与事务深入" class="headerlink" title="Mybatis连接池与事务深入"></a>Mybatis连接池与事务深入</h1><h2 id="1-1-Mybatis的连接池技术"><a href="#1-1-Mybatis的连接池技术" class="headerlink" title="1.1 Mybatis的连接池技术"></a>1.1 Mybatis的连接池技术</h2><blockquote><p>我们在前面的 WEB 课程中也学习过类似的连接池技术，而在 Mybatis 中也有连接池技术，但是它采用的是自己的连接池技术。在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过来实现 Mybatis 中连接池的配置.</p></blockquote><h3 id="1-1-1-Mybatis连接池的分类"><a href="#1-1-1-Mybatis连接池的分类" class="headerlink" title="1.1.1 Mybatis连接池的分类"></a>1.1.1 Mybatis连接池的分类</h3><p>在 Mybatis 中我们将它的数据源 dataSource 分为以下几类：</p><p><img src="/img/cphoto/mybatis05.jpg"></p><p>可以看出 Mybatis 将它自己的数据源分为三类：</p><table><thead><tr><th>数据源</th><th>说明</th></tr></thead><tbody><tr><td>UNPOOLED</td><td>不使用连接池的数据源</td></tr><tr><td>POOLED</td><td>使用连接池的数据源</td></tr><tr><td>JNDI</td><td>使用 JNDI 实现的数据源</td></tr></tbody></table><h3 id="1-1-2-Mybatis中数据源的配置"><a href="#1-1-2-Mybatis中数据源的配置" class="headerlink" title="1.1.2 Mybatis中数据源的配置"></a>1.1.2 Mybatis中数据源的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MyBatis 在初始化时，根据的 type 属性来创建相应类型的的数据源 DataSource，即：</p><p>**type=”POOLED”**：MyBatis 会创建 PooledDataSource 实例</p><p><strong>type=”UNPOOLED”</strong> ： MyBatis 会创建 UnpooledDataSource 实例</p><p>**type=”JNDI”**：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用</p><h2 id="1-2-Mybatis-的事务控制"><a href="#1-2-Mybatis-的事务控制" class="headerlink" title="1.2 Mybatis 的事务控制"></a>1.2 Mybatis 的事务控制</h2><h3 id="1-2-1-JDBC中事务的回顾"><a href="#1-2-1-JDBC中事务的回顾" class="headerlink" title="1.2.1 JDBC中事务的回顾"></a>1.2.1 JDBC中事务的回顾</h3><blockquote><p>在 JDBC 中我们可以通过手动方式将事务的提交改为手动方式，通过 setAutoCommit()方法就可以调整。</p></blockquote><p>通过 JDK 文档，我们找到该方法如下：<br><img src="/img/cphoto/mybatis06.jpg"></p><p>那么我们的 Mybatis 框架因为是对 JDBC 的封装，所以 Mybatis 框架的事务控制方式，本身也是用 JDBC 的setAutoCommit()方法来设置事务提交方式的。</p><h3 id="1-2-2-Mybatis中事务提交方式"><a href="#1-2-2-Mybatis中事务提交方式" class="headerlink" title="1.2.2 Mybatis中事务提交方式"></a>1.2.2 Mybatis中事务提交方式</h3><p>运行之前写的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        userDao = session.getMapper(IUserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试保存操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveUser</span><span class="hljs-params">()</span></span>&#123;<br><br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUserName(<span class="hljs-string">&quot;朱俊伟1231231232&quot;</span>);<br>        user.setUserAddress(<span class="hljs-string">&quot;河南&quot;</span>);<br>        user.setUserBirthday(<span class="hljs-keyword">new</span> Date());<br>        user.setUserSex(<span class="hljs-string">&quot;男&quot;</span>);<br><br>        userDao.saveUser(user);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/mybatis07.jpg"></p><blockquote><p>这是我们的 Connection 的整个变化过程，通过分析我们能够发现之前的 CUD 操作过程中，我们都要手动进行事务的提交，原因是 setAutoCommit()方法，在执行时它的值被设置为 false 了，所以我们在 CUD 操作中，必须通过 sqlSession.commit()方法来执行提交操作。</p></blockquote><h3 id="1-2-3-Mybatis自动提交事务的设置"><a href="#1-2-3-Mybatis自动提交事务的设置" class="headerlink" title="1.2.3 Mybatis自动提交事务的设置"></a>1.2.3 Mybatis自动提交事务的设置</h3><blockquote><p>通过上面的研究和分析，现在我们一起思考，为什么 CUD 过程中必须使用 sqlSession.commit()提交事务？主要原因就是在连接池中取出的连接，都会将调用 connection.setAutoCommit(false)方法，这样我们就必须使用 sqlSession.commit()方法，相当于使用了 JDBC 中的connection.commit()方法实现事务提交。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br><span class="hljs-comment">//        session = factory.openSession();</span><br>        <span class="hljs-comment">//设置为自动提交事务</span><br>        session = factory.openSession(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        userDao = session.getMapper(IUserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//关闭手动提交</span><br><span class="hljs-comment">//        session.commit();</span><br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试保存操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveUser</span><span class="hljs-params">()</span></span>&#123;<br><br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUserName(<span class="hljs-string">&quot;朱俊伟1231231232&quot;</span>);<br>        user.setUserAddress(<span class="hljs-string">&quot;河南&quot;</span>);<br>        user.setUserBirthday(<span class="hljs-keyword">new</span> Date());<br>        user.setUserSex(<span class="hljs-string">&quot;男&quot;</span>);<br><br>        userDao.saveUser(user);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-Mybatis的动态SQL语句"><a href="#2-Mybatis的动态SQL语句" class="headerlink" title="2 Mybatis的动态SQL语句"></a>2 Mybatis的动态SQL语句</h1><blockquote><p>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。</p></blockquote><p>参考的官方文档，描述<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">动态SQL</a>如下：</p><p><img src="/img/cphoto/mybatis08.jpg"></p><h2 id="2-1-if标签"><a href="#2-1-if标签" class="headerlink" title="2.1 if标签"></a>2.1 if标签</h2><blockquote><p>我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p></blockquote><h3 id="2-1-1-持久层Dao接口"><a href="#2-1-1-持久层Dao接口" class="headerlink" title="2.1.1 持久层Dao接口"></a>2.1.1 持久层Dao接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据传入参数条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> user 查询的条件：有可能有用户名，有可能有性别，也有可能有地址，还有可能都有</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findUserByCondition</span><span class="hljs-params">(User user)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-映射配置"><a href="#2-1-2-映射配置" class="headerlink" title="2.1.2 映射配置"></a>2.1.2 映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--根据条件查询用户--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findUserByCondition&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br><br>    select * from user where 1=1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userName != null&quot;</span>&gt;</span><br>        and username = #&#123;userName&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userSex != null&quot;</span>&gt;</span><br>        and sex = #&#123;userSex&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong><if>标签的 test 属性中写的是对象的属性名，如果是包装类的对象要使用 OGNL 表达式的写法。<br>另外要注意 where 1=1 的作用~！</if></p><h3 id="2-1-3-测试"><a href="#2-1-3-测试" class="headerlink" title="2.1.3 测试"></a>2.1.3 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据传入参数查询用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindByCondition</span><span class="hljs-params">()</span></span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setUserName(<span class="hljs-string">&quot;老王&quot;</span>);<br>    user.setUserSex(<span class="hljs-string">&quot;女&quot;</span>);<br>    List&lt;User&gt; userList = userDao.findUserByCondition(user);<br>    <span class="hljs-keyword">for</span> (User u : userList) &#123;<br>        System.out.println(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-where标签"><a href="#2-2-where标签" class="headerlink" title="2.2 where标签"></a>2.2 where标签</h2><blockquote><p>为了简化上面 where 1=1 的条件拼装，我们可以采用<where>标签来简化开发。</where></p></blockquote><h3 id="2-2-1-持久层Dao映射配置"><a href="#2-2-1-持久层Dao映射配置" class="headerlink" title="2.2.1 持久层Dao映射配置"></a>2.2.1 持久层Dao映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--根据条件查询用户--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findUserByCondition&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br><br>    select * from user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userName != null&quot;</span>&gt;</span><br>            and username = #&#123;userName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userSex != null&quot;</span>&gt;</span><br>            and sex = #&#123;userSex&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-3-foeach标签"><a href="#2-3-foeach标签" class="headerlink" title="2.3 foeach标签"></a>2.3 foeach标签</h2><h3 id="2-3-1-需求"><a href="#2-3-1-需求" class="headerlink" title="2.3.1 需求"></a>2.3.1 需求</h3><blockquote><p>传入多个 id 查询用户信息，用下边两个 sql 实现：</p><p>SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND (id =10 OR id =89 OR id=16)</p><p>SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16)</p><p>这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。</p><p>这样我们将如何进行参数的传递？</p></blockquote><h3 id="2-3-1-在QueryVo中加入一个List集合用于封装参数"><a href="#2-3-1-在QueryVo中加入一个List集合用于封装参数" class="headerlink" title="2.3.1 在QueryVo中加入一个List集合用于封装参数"></a>2.3.1 在QueryVo中加入一个List集合用于封装参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryVo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> User user;<br><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; ids;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getIds</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ids;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIds</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ids = ids;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-持久层Dao接口"><a href="#2-3-2-持久层Dao接口" class="headerlink" title="2.3.2 持久层Dao接口"></a>2.3.2 持久层Dao接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *根据queryVo中的id集合，查询用户信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findUserByInIds</span><span class="hljs-params">(QueryVo queryVo)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-3-映射配置文件"><a href="#2-3-3-映射配置文件" class="headerlink" title="2.3.3 映射配置文件"></a>2.3.3 映射配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--根据传入的id集合查询用户信息--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findUserByInIds&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;QueryVo&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    select * from user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ids != null and ids.size()&gt;0&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;and id in (&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;uid&quot;</span>&gt;</span><br>                #&#123;uid&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-4-测试文件"><a href="#2-3-4-测试文件" class="headerlink" title="2.3.4 测试文件"></a>2.3.4 测试文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据queryVo中的id集合，查询用户信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindUserByInIds</span><span class="hljs-params">()</span></span>&#123;<br>    QueryVo queryVo = <span class="hljs-keyword">new</span> QueryVo();<br>    List&lt;Integer&gt; ids = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    ids.add(<span class="hljs-number">41</span>);<br>    ids.add(<span class="hljs-number">42</span>);<br>    ids.add(<span class="hljs-number">46</span>);<br>    queryVo.setIds(ids);<br>    List&lt;User&gt; userList = userDao.findUserByInIds(queryVo);<br>    <span class="hljs-keyword">for</span> (User u : userList) &#123;<br>        System.out.println(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-Mybatis中简化编写的SQL片段"><a href="#2-4-Mybatis中简化编写的SQL片段" class="headerlink" title="2.4 Mybatis中简化编写的SQL片段"></a>2.4 Mybatis中简化编写的SQL片段</h2><blockquote><p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。</p></blockquote><h3 id="2-4-1-定义代码片段"><a href="#2-4-1-定义代码片段" class="headerlink" title="2.4.1 定义代码片段"></a>2.4.1 定义代码片段</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  抽取重复的语句代码片段  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;defaultSql&quot;</span>&gt;</span><br>      select * from user<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-2-引用代码片段"><a href="#2-4-2-引用代码片段" class="headerlink" title="2.4.2 引用代码片段"></a>2.4.2 引用代码片段</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  配置查询所有操作  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;defaultSql&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  根据 id 查询  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;UsEr&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;defaultSql&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>      where id = #&#123;uid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="3-Mybatis多表查询之一对多"><a href="#3-Mybatis多表查询之一对多" class="headerlink" title="3 Mybatis多表查询之一对多"></a>3 Mybatis多表查询之一对多</h1><blockquote><p>本次案例主要以最为简单的用户和账户的模型来分析 Mybatis 多表关系。用户为 User 表，账户为 Account表。一个用户（User）可以有多个账户（Account）。</p></blockquote><p>具体关系如下:</p><p><img src="/img/cphoto/mybatis09.jpg"></p><h2 id="3-1-一对一查询（多对一）"><a href="#3-1-一对一查询（多对一）" class="headerlink" title="3.1 一对一查询（多对一）"></a>3.1 一对一查询（多对一）</h2><p>需求</p><blockquote><p>查询所有账户信息，关联查询下单用户信息。</p></blockquote><p>注意：</p><blockquote><p>因为一个账户信息只能供某个用户使用，所以从查询账户信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的账户信息则为一对多查询，因为一个用户可以有多个账户。</p></blockquote><h3 id="3-1-1-方式一"><a href="#3-1-1-方式一" class="headerlink" title="3.1.1 方式一"></a>3.1.1 方式一</h3><h4 id="3-1-1-1-定义账户信息的实体类"><a href="#3-1-1-1-定义账户信息的实体类" class="headerlink" title="3.1.1.1 定义账户信息的实体类"></a>3.1.1.1 定义账户信息的实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> Integer uid;<br>    <span class="hljs-keyword">private</span> Double money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUid</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> uid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUid</span><span class="hljs-params">(Integer uid)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.uid = uid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(Double money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Account&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, uid=&quot;</span> + uid +<br>                <span class="hljs-string">&quot;, money=&quot;</span> + money +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写sql语句</p><blockquote><p>实现查询账户信息时，也要查询账户所对应的用户信息。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>account.<span class="hljs-operator">*</span>,<br>user.username,<br>user.address<br><span class="hljs-keyword">FROM</span> `account`,`<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">WHERE</span> account.uid <span class="hljs-operator">=</span> user.id;<br></code></pre></td></tr></table></figure><h4 id="3-1-1-3-定义AccountUser类"><a href="#3-1-1-3-定义AccountUser类" class="headerlink" title="3.1.1.3 定义AccountUser类"></a>3.1.1.3 定义AccountUser类</h4><blockquote><p>为了能够封装上面 SQL 语句的查询结果，定义 AccountCustomer 类中要包含账户信息同时还要包含用户信息，所以我们要在定义 AccountUser 类时可以继承 User 类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String address ;<br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString()+<span class="hljs-string">&quot;  AccountUser&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-1-4-定义账户的持久层-Dao-接口"><a href="#3-1-1-4-定义账户的持久层-Dao-接口" class="headerlink" title="3.1.1.4 定义账户的持久层 Dao 接口"></a>3.1.1.4 定义账户的持久层 Dao 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 账户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAccountDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *-查询所有账户同时包含用户地址和名字</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;AccountUser&gt; <span class="hljs-title">findAllAccount</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-1-5-定义-AccountDao-xml-文件中的查询配置信息"><a href="#3-1-1-5-定义-AccountDao-xml-文件中的查询配置信息" class="headerlink" title="3.1.1.5 定义 AccountDao.xml 文件中的查询配置信息"></a>3.1.1.5 定义 AccountDao.xml 文件中的查询配置信息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IAccountDao&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询所有账户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;accountUser&quot;</span>&gt;</span><br>      SELECT<br>account.*,<br>user.username,<br>user.address<br>      FROM `account`,`user`<br>      WHERE account.uid = user.id;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong><br> 因为上面查询的结果中包含了账户信息同时还包含了用户信息，所以我们的返回值类型 returnType的值设置为 AccountUser 类型，这样就可以接收账户信息和用户信息了。</p><h4 id="创建-AccountTest-测试类"><a href="#创建-AccountTest-测试类" class="headerlink" title="创建 AccountTest 测试类"></a>创建 AccountTest 测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br>    <span class="hljs-keyword">private</span> IAccountDao accountDao;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        accountDao = session.getMapper(IAccountDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有账户同时包含用户地址和名字</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAllAccount</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;AccountUser&gt; accountUsers = accountDao.findAllAccount();<br>        <span class="hljs-keyword">for</span> (AccountUser accountUser : accountUsers) &#123;<br>            System.out.println(accountUser);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-1-7-小结"><a href="#3-1-1-7-小结" class="headerlink" title="3.1.1.7 小结"></a>3.1.1.7 小结</h4><blockquote><p>定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。</p></blockquote><h3 id="3-1-2-方式二"><a href="#3-1-2-方式二" class="headerlink" title="3.1.2 方式二"></a>3.1.2 方式二</h3><blockquote><p> 使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。</p><p>通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。</p></blockquote><h4 id="3-1-2-1-修改-Account-类"><a href="#3-1-2-1-修改-Account-类" class="headerlink" title="3.1.2.1 修改 Account 类"></a>3.1.2.1 修改 Account 类</h4><p>在 Account 类中加入 User 类的对象作为 Account 类的一个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> Integer uid;<br>    <span class="hljs-keyword">private</span> Double money;<br>    <span class="hljs-keyword">private</span> User user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUid</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> uid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUid</span><span class="hljs-params">(Integer uid)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.uid = uid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(Double money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Account&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, uid=&quot;</span> + uid +<br>                <span class="hljs-string">&quot;, money=&quot;</span> + money +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-2-修改-AccountDao-接口中的方法"><a href="#3-1-2-2-修改-AccountDao-接口中的方法" class="headerlink" title="3.1.2.2 修改 AccountDao 接口中的方法"></a>3.1.2.2 修改 AccountDao 接口中的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 账户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAccountDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有账户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><br>第二种方式，将返回值改 为了 Account 类型。<br>因为 Account 类中包含了一个 User 类的对象，它可以封装账户所对应的用户信息。</p><h4 id="3-1-2-3-重新定义-AccountDao-xml-文件"><a href="#3-1-2-3-重新定义-AccountDao-xml-文件" class="headerlink" title="3.1.2.3 重新定义 AccountDao.xml 文件"></a>3.1.2.3 重新定义 AccountDao.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IAccountDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountUserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Account&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;aid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;money&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询所有账户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;accountUserMap&quot;</span>&gt;</span><br>        select <br>            u.*,<br>            a.id aid,<br>            a.uid,<br>            a.money <br>        from account a,<br>            user u <br>        where u.id = a.uid;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-4-在-AccountTest-类中加入测试方法"><a href="#3-1-2-4-在-AccountTest-类中加入测试方法" class="headerlink" title="3.1.2.4 在 AccountTest 类中加入测试方法"></a>3.1.2.4 在 AccountTest 类中加入测试方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试查询操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">//使用代理对象执行方法</span><br>    List&lt;Account&gt; accounts = accountDao.findAll();<br>    <span class="hljs-keyword">for</span> (Account account : accounts) &#123;<br>        System.out.println(account);<br>        System.out.println(account.getUser());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-一对多查询"><a href="#3-2-一对多查询" class="headerlink" title="3.2 一对多查询"></a>3.2 一对多查询</h2><p><strong>需求：</strong></p><blockquote><p>查询所有用户信息及用户关联的账户信息。</p></blockquote><p><strong>分析：</strong></p><blockquote><p>用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，我们想到了左外连接查询比较合适。</p></blockquote><h1 id="3-2-1-编写-SQL-语句"><a href="#3-2-1-编写-SQL-语句" class="headerlink" title="3.2.1 编写 SQL 语句"></a>3.2.1 编写 SQL 语句</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>u.<span class="hljs-operator">*</span>, <br>acc.id id,<br>acc.uid,<br>acc.money<br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">user</span> u<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> account acc <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> acc.uid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> u.id<br></code></pre></td></tr></table></figure><h3 id="3-2-2-User-类加入-List-Account"><a href="#3-2-2-User-类加入-List-Account" class="headerlink" title="3.2.2 User 类加入 List Account"></a>3.2.2 User 类加入 List Account</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Date birthday;<br><br>    <span class="hljs-comment">//建立一对多的关系</span><br>    <span class="hljs-keyword">private</span> List&lt;Account&gt; accounts;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Account&gt; <span class="hljs-title">getAccounts</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> accounts;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccounts</span><span class="hljs-params">(List&lt;Account&gt; accounts)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.accounts = accounts;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBirthday</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> birthday;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.birthday = birthday;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, birthday=&quot;</span> + birthday +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-3-用户持久层-Dao-接口中加入查询方法"><a href="#3-2-3-用户持久层-Dao-接口中加入查询方法" class="headerlink" title="3.2.3 用户持久层 Dao 接口中加入查询方法"></a>3.2.3 用户持久层 Dao 接口中加入查询方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="用户持久层Dao映射文件配置"><a href="#用户持久层Dao映射文件配置" class="headerlink" title="用户持久层Dao映射文件配置"></a>用户持久层Dao映射文件配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserAccountMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;accounts&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Account&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;aid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;money&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--查询所有--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserAccountMap&quot;</span>&gt;</span><br>        select  u.*,a.id aid,a.uid uid,a.money from user u LEFT JOIN account a ON u.id = a.uid;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-5-测试方法"><a href="#3-2-5-测试方法" class="headerlink" title="3.2.5 测试方法"></a>3.2.5 测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        userDao = session.getMapper(IUserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;User&gt; users = userDao.findAll();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            System.out.println(user);<br>            List&lt;Account&gt; accounts = user.getAccounts();<br>            <span class="hljs-keyword">for</span> (Account account : accounts) &#123;<br>                System.out.println(account);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-Mybatis-多表查询之多对多"><a href="#4-Mybatis-多表查询之多对多" class="headerlink" title="4 Mybatis 多表查询之多对多"></a>4 Mybatis 多表查询之多对多</h1><h2 id="4-1-实现-Role-到-User-多对多"><a href="#4-1-实现-Role-到-User-多对多" class="headerlink" title="4.1 实现 Role 到 User 多对多"></a>4.1 实现 Role 到 User 多对多</h2><blockquote><p>通过前面的学习，我们使用 Mybatis 实现一对多关系的维护。多对多关系其实我们看成是双向的一对多关系。</p></blockquote><h3 id="4-1-1-用户与角色的关系模型"><a href="#4-1-1-用户与角色的关系模型" class="headerlink" title="4.1.1 用户与角色的关系模型"></a>4.1.1 用户与角色的关系模型</h3><p><img src="/img/cphoto/mybatis10.jpg"></p><h3 id="4-1-2-业务要求"><a href="#4-1-2-业务要求" class="headerlink" title="4.1.2 业务要求"></a>4.1.2 业务要求</h3><p><strong>需求：</strong></p><blockquote><p>实现查询所有对象并且加载它所分配的用户信息。</p></blockquote><p><strong>分析：</strong></p><blockquote><p>查询角色我们需要用到 Role 表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中间表(USER_ROLE 表)才能关联到用户信息。</p></blockquote><h3 id="4-1-3-编写角色实体类"><a href="#4-1-3-编写角色实体类" class="headerlink" title="4.1.3 编写角色实体类"></a>4.1.3 编写角色实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer roleId;<br>    <span class="hljs-keyword">private</span> String roleName;<br>    <span class="hljs-keyword">private</span> String roleDesc;<br><br>    <span class="hljs-keyword">private</span> List&lt;User&gt; users;<br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Role&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;roleId=&quot;</span> + roleId +<br>                <span class="hljs-string">&quot;, roleName=&#x27;&quot;</span> + roleName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, roleDesc=&#x27;&quot;</span> + roleDesc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getUsers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsers</span><span class="hljs-params">(List&lt;User&gt; users)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.users = users;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getRoleId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> roleId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoleId</span><span class="hljs-params">(Integer roleId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roleId = roleId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRoleName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> roleName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoleName</span><span class="hljs-params">(String roleName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roleName = roleName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRoleDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> roleDesc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoleDesc</span><span class="hljs-params">(String roleDesc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roleDesc = roleDesc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-4-编写-Role-持久层接口"><a href="#4-1-4-编写-Role-持久层接口" class="headerlink" title="4.1.4 编写 Role 持久层接口"></a>4.1.4 编写 Role 持久层接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRoleDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有角色</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Role&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-5-编写映射文件"><a href="#4-1-5-编写映射文件" class="headerlink" title="4.1.5 编写映射文件"></a>4.1.5 编写映射文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IRoleDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;RoleMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Role&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;role_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleDesc&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;role_desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--查询所有--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;RoleMap&quot;</span>&gt;</span><br>            SELECT<br>                r.id rid,<br>                r.ROLE_NAME role_name,<br>                r.role_desc,<br>                u.*<br>            FROM<br>                role r<br>                LEFT JOIN user_role ur ON r.id = ur.rid<br>                LEFT JOIN user u ON ur.uid = u.id;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-1-6-编写测试类"><a href="#4-1-6-编写测试类" class="headerlink" title="4.1.6 编写测试类"></a>4.1.6 编写测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.test;<br><br><span class="hljs-keyword">import</span> com.zjw.dao.IRoleDao;<br><span class="hljs-keyword">import</span> com.zjw.dao.IUserDao;<br><span class="hljs-keyword">import</span> com.zjw.domain.Role;<br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IRoleDao roleDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        roleDao = session.getMapper(IRoleDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;Role&gt; roles = roleDao.findAll();<br>        <span class="hljs-keyword">for</span> (Role role : roles) &#123;<br>            System.out.println(role);<br>            System.out.println(role.getUsers());<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-实现-User-到-Role-多对多"><a href="#4-2-实现-User-到-Role-多对多" class="headerlink" title="4.2 实现 User 到 Role 多对多"></a>4.2 实现 User 到 Role 多对多</h2><h3 id="4-2-1-业务要求"><a href="#4-2-1-业务要求" class="headerlink" title="4.2.1 业务要求"></a>4.2.1 业务要求</h3><blockquote><p>查询用户的时候查询出其角色。</p></blockquote><h3 id="4-2-2-编写User实体类"><a href="#4-2-2-编写User实体类" class="headerlink" title="4.2.2 编写User实体类"></a>4.2.2 编写User实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Date birthday;<br><br>    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getRoles</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> roles;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoles</span><span class="hljs-params">(List&lt;Role&gt; roles)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roles = roles;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBirthday</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> birthday;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.birthday = birthday;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, birthday=&quot;</span> + birthday +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-编写-User-持久层接口"><a href="#4-2-3-编写-User-持久层接口" class="headerlink" title="4.2.3 编写 User 持久层接口"></a>4.2.3 编写 User 持久层接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-编写映射文件"><a href="#4-2-4-编写映射文件" class="headerlink" title="4.2.4 编写映射文件"></a>4.2.4 编写映射文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserAccountMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--建立用户和角色的对应关系--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roles&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Role&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;role_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleDesc&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;role_desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--查询所有--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserAccountMap&quot;</span>&gt;</span><br>        SELECT<br>            u.*,<br>            r.id rid,<br>            r.role_name,<br>            r.role_desc<br>        FROM<br>            user u<br>            LEFT JOIN user_role ur ON u.id = ur.uid<br>            LEFT JOIN role r ON ur.rid = r.id;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-2-5-编写测试类"><a href="#4-2-5-编写测试类" class="headerlink" title="4.2.5 编写测试类"></a>4.2.5 编写测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.test;<br><br><span class="hljs-keyword">import</span> com.zjw.dao.IUserDao;<br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        userDao = session.getMapper(IUserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;User&gt; users = userDao.findAll();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            System.out.println(user);<br>            System.out.println(user.getRoles());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Mybatis-延迟加载策略"><a href="#Mybatis-延迟加载策略" class="headerlink" title="Mybatis 延迟加载策略"></a>Mybatis 延迟加载策略</h1><blockquote><p>通过前面的学习，我们已经掌握了 Mybatis 中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载.</p></blockquote><h2 id="1-1-何为延迟加载"><a href="#1-1-何为延迟加载" class="headerlink" title="1.1 何为延迟加载"></a>1.1 何为延迟加载</h2><p><strong>延迟加载：</strong></p><blockquote><p>就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.</p></blockquote><p><strong>好处：</strong></p><blockquote><p>先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p></blockquote><p><strong>坏处：</strong></p><blockquote><p>因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。</p></blockquote><h2 id="1-2-实现需求"><a href="#1-2-实现需求" class="headerlink" title="1.2 实现需求"></a>1.2 实现需求</h2><p><strong>需求：</strong></p><blockquote><p>查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。</p><p>mybatis 第三天实现多表操作时，我们使用了 resultMap 来实现一对一，一对多，多对多关系的操作。主要是通过 association、collection 实现一对一及一对多映射。association、collection 具备延迟加载功能。</p></blockquote><h2 id="1-3-使用-assocation-实现延迟加载"><a href="#1-3-使用-assocation-实现延迟加载" class="headerlink" title="1.3 使用 assocation 实现延迟加载"></a>1.3 使用 assocation 实现延迟加载</h2><p><strong>需求：</strong></p><blockquote><p>查询账户信息同时查询用户信息。</p></blockquote><h3 id="1-3-1-账户的持久层-DAO-接口"><a href="#1-3-1-账户的持久层-DAO-接口" class="headerlink" title="1.3.1 账户的持久层 DAO 接口"></a>1.3.1 账户的持久层 DAO 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 账户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAccountDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有账户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-账户的持久层映射文件"><a href="#1-3-2-账户的持久层映射文件" class="headerlink" title="1.3.2 账户的持久层映射文件"></a>1.3.2 账户的持久层映射文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IAccountDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountUserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Account&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;money&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;</span><br><span class="hljs-comment">            &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="hljs-comment">            &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;</span><br><span class="hljs-comment">            &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;</span><br><span class="hljs-comment">            &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="hljs-comment">            &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;</span><br><span class="hljs-comment">        &lt;/association&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            一对一的关系映射，配置封装User的内容</span><br><span class="hljs-comment">            select属性指定的内容，查询用户的唯一标识</span><br><span class="hljs-comment">            column属性指定的内容，用户根据id查询时，所需参数的值</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao.findById&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><br><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询所有账户--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;accountUserMap&quot;</span>&gt;</span><br>        select * from account ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-3-用户的持久层接口和映射文件"><a href="#1-3-3-用户的持久层接口和映射文件" class="headerlink" title="1.3.3 用户的持久层接口和映射文件"></a>1.3.3 用户的持久层接口和映射文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Integer userId)</span></span>;<br><br>&#125;<br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!DOCTYPE mapper<br>        PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br>        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;<br>&lt;mapper namespace=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;<br><br>    &lt;resultMap id=<span class="hljs-string">&quot;UserAccountMap&quot;</span> type=<span class="hljs-string">&quot;User&quot;</span>&gt;<br>        &lt;id property=<span class="hljs-string">&quot;id&quot;</span> column=<span class="hljs-string">&quot;id&quot;</span>&gt;&lt;/id&gt;<br>        &lt;result property=<span class="hljs-string">&quot;address&quot;</span> column=<span class="hljs-string">&quot;address&quot;</span>&gt;&lt;/result&gt;<br>        &lt;result property=<span class="hljs-string">&quot;username&quot;</span> column=<span class="hljs-string">&quot;username&quot;</span>&gt;&lt;/result&gt;<br>        &lt;result property=<span class="hljs-string">&quot;sex&quot;</span> column=<span class="hljs-string">&quot;sex&quot;</span>&gt;&lt;/result&gt;<br>        &lt;result property=<span class="hljs-string">&quot;birthday&quot;</span> column=<span class="hljs-string">&quot;birthday&quot;</span>&gt;&lt;/result&gt;<br>    &lt;/resultMap&gt;<br>    <br>    &lt;!--查询用户--&gt;<br>    &lt;select id=<span class="hljs-string">&quot;findById&quot;</span> parameterType=<span class="hljs-string">&quot;Integer&quot;</span> resultType=<span class="hljs-string">&quot;User&quot;</span>&gt;<br>        select * from user where id = #&#123;userId&#125; ;<br>    &lt;/select&gt;<br><br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-4-开启-Mybatis-的延迟加载策略"><a href="#1-3-4-开启-Mybatis-的延迟加载策略" class="headerlink" title="1.3.4 开启 Mybatis 的延迟加载策略"></a>1.3.4 开启 Mybatis 的延迟加载策略</h3><p>我们需要在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-5-编写测试只查账户信息不查用户信息。"><a href="#1-3-5-编写测试只查账户信息不查用户信息。" class="headerlink" title="1.3.5 编写测试只查账户信息不查用户信息。"></a>1.3.5 编写测试只查账户信息不查用户信息。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br>    <span class="hljs-keyword">private</span> IAccountDao accountDao;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        accountDao = session.getMapper(IAccountDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;Account&gt; accounts = accountDao.findAll();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="/img/cphoto/mybatis11.jpg"></p><p>我们发现，因为本次只是将 Account 对象查询出来放入 List 集合中，并没有涉及到 User 对象，所以就没有发出 SQL 语句查询账户所关联的 User 对象的查询。</p><h2 id="1-4-使用-Collection-实现延迟加载"><a href="#1-4-使用-Collection-实现延迟加载" class="headerlink" title="1.4 使用 Collection 实现延迟加载"></a>1.4 使用 Collection 实现延迟加载</h2><blockquote><p>同样我们也可以在一对多关系配置的结点中配置延迟加载策略。<br><collection>结点中也有 select 属性，column 属性。</collection></p></blockquote><p><strong>需求：</strong></p><blockquote><p>完成加载用户对象时，查询该用户所拥有的账户信息。</p></blockquote><h3 id="1-4-1-在-User-实体类中加入-List-Account-属性"><a href="#1-4-1-在-User-实体类中加入-List-Account-属性" class="headerlink" title="1.4.1 在 User 实体类中加入 List Account 属性"></a>1.4.1 在 User 实体类中加入 List Account 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.domain;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Date birthday;<br><br>    <span class="hljs-comment">//建立一对多的关系</span><br>    <span class="hljs-keyword">private</span> List&lt;Account&gt; accounts;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Account&gt; <span class="hljs-title">getAccounts</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> accounts;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccounts</span><span class="hljs-params">(List&lt;Account&gt; accounts)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.accounts = accounts;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBirthday</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> birthday;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.birthday = birthday;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, birthday=&quot;</span> + birthday +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-2编写用户和账户持久层接口的方法"><a href="#1-4-2编写用户和账户持久层接口的方法" class="headerlink" title="1.4.2编写用户和账户持久层接口的方法"></a>1.4.2编写用户和账户持久层接口的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据用户id查询用户的所有账户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> uid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAccountByUid</span><span class="hljs-params">(Integer uid)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="1-4-3-编写用户持久层映射配置"><a href="#1-4-3-编写用户持久层映射配置" class="headerlink" title="1.4.3 编写用户持久层映射配置"></a>1.4.3 编写用户持久层映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserAccountMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><br>         <span class="hljs-comment">&lt;!-- collection 是用于建立一对多中集合属性的对应关系</span><br><span class="hljs-comment">            ofType 用于指定集合元素的数据类型</span><br><span class="hljs-comment">            select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称）</span><br><span class="hljs-comment">            column 是用于指定使用哪个字段的值作为条件查询</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;accounts&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Account&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.zjw.dao.IAccountDao.findAccountByUid&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--查询所有--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserAccountMap&quot;</span>&gt;</span><br>        select  * from user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-4-编写账户持久层映射配置"><a href="#1-4-4-编写账户持久层映射配置" class="headerlink" title="1.4.4 编写账户持久层映射配置"></a>1.4.4 编写账户持久层映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAccountByUid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Account&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span><br>      select ac.* from account ac where ac.uid = #&#123;uid&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-5-测试只加载用户信息"><a href="#1-4-5-测试只加载用户信息" class="headerlink" title="1.4.5 测试只加载用户信息"></a>1.4.5 测试只加载用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        userDao = session.getMapper(IUserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;User&gt; users = userDao.findAll();<br><span class="hljs-comment">//        for (User user : users) &#123;</span><br><span class="hljs-comment">//            System.out.println(user);</span><br><span class="hljs-comment">//            List&lt;Account&gt; accounts = user.getAccounts();</span><br><span class="hljs-comment">//            for (Account account : accounts) &#123;</span><br><span class="hljs-comment">//                System.out.println(account);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/mybatis12.jpg"></p><p>我们发现并没有加载 Account 账户信息.</p><h1 id="2-Mybatis-缓存"><a href="#2-Mybatis-缓存" class="headerlink" title="2 Mybatis 缓存"></a>2 Mybatis 缓存</h1><blockquote><p>像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。</p></blockquote><p>Mybatis 中缓存分为一级缓存，二级缓存。<br><img src="/img/cphoto/mybatis13.jpg"></p><h2 id="2-1-Mybatis-一级缓存"><a href="#2-1-Mybatis-一级缓存" class="headerlink" title="2.1 Mybatis 一级缓存"></a>2.1 Mybatis 一级缓存</h2><h3 id="2-1-1-证明一级缓存的存在"><a href="#2-1-1-证明一级缓存的存在" class="headerlink" title="2.1.1 证明一级缓存的存在"></a>2.1.1 证明一级缓存的存在</h3><blockquote><p>一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。</p></blockquote><h3 id="2-1-2-编写用户持久层Dao接口"><a href="#2-1-2-编写用户持久层Dao接口" class="headerlink" title="2.1.2 编写用户持久层Dao接口"></a>2.1.2 编写用户持久层Dao接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户的持久层接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Integer userId)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-编写用户持久层映射文件"><a href="#2-1-2-编写用户持久层映射文件" class="headerlink" title="2.1.2 编写用户持久层映射文件"></a>2.1.2 编写用户持久层映射文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据id查询用户 (查询支持cache)</span><br><span class="hljs-comment">        好像开启了cache就不用配置useCache了，默认就是true</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span><br>        select * from user u where u.id = #&#123;userId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-3-编写测试方法"><a href="#2-1-3-编写测试方法" class="headerlink" title="2.1.3 编写测试方法"></a>2.1.3 编写测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjw.test;<br><br><span class="hljs-keyword">import</span> com.zjw.dao.IUserDao;<br><span class="hljs-keyword">import</span> com.zjw.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br>        <span class="hljs-comment">//使用工厂生成SqlSession对象</span><br>        session = factory.openSession();<br>        <span class="hljs-comment">//使用SqlSession穿过将Dao接口的代理对象</span><br>        userDao = session.getMapper(IUserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        session.commit();<br>        session.close();<br>        in.close();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//使用代理对象执行方法</span><br>        List&lt;User&gt; users = userDao.findAll();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            System.out.println(user);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试一级缓存</span><br><span class="hljs-comment">     * 可以发现拿到的是同一个对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit(),close()方法时，一级缓存会给清空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindUserById</span><span class="hljs-params">()</span></span>&#123;<br>        User user1 = userDao.findById(<span class="hljs-number">41</span>);<br>        User user2 = userDao.findById(<span class="hljs-number">41</span>);<br><br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user1 == user2);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试一级缓存</span><br><span class="hljs-comment">     * 关闭session可以清空一级缓存</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindUserById2</span><span class="hljs-params">()</span></span>&#123;<br>        User user1 = userDao.findById(<span class="hljs-number">41</span>);<br>        <span class="hljs-comment">//关闭session</span><br>        session.close(); <span class="hljs-comment">//close可以清空缓存</span><br>        session = factory.openSession();<br>        userDao = session.getMapper(IUserDao.class);<br><br><span class="hljs-comment">//        session.clearCache();//clearCache也可以清空缓存</span><br><br>        User user2 = userDao.findById(<span class="hljs-number">41</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user1 == user2);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试一级缓存</span><br><span class="hljs-comment">     * clearCache清空一级缓存</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindUserById3</span><span class="hljs-params">()</span></span>&#123;<br>        User user1 = userDao.findById(<span class="hljs-number">41</span>);<br>        session.clearCache();<span class="hljs-comment">//clearCache也可以清空缓存</span><br><br>        User user2 = userDao.findById(<span class="hljs-number">41</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user1 == user2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>testFindUserById()<br><img src="/img/cphoto/mybatis14.jpg"></p><blockquote><p>我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id 为 41 的记录时，并没有发出 sql 语句从数据库中查询数据，而是从一级缓存中查询。</p></blockquote><p><strong>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()，clearCache()等方法时，就会清空一级缓存。</strong><br><img src="/img/cphoto/mybatis15.jpg"></p><p>testFindUserById2()<br><img src="/img/cphoto/mybatis16.jpg"></p><p>testFindUserById3()<br><img src="/img/cphoto/mybatis17.jpg"></p><blockquote><p>testFindUserById2(),testFindUserById3()方法分别进行了session关闭和清空缓存，发现一级缓存没有了，会接着查询数据库。</p></blockquote><h3 id="2-1-4-一级缓存失效的四种情况"><a href="#2-1-4-一级缓存失效的四种情况" class="headerlink" title="2.1.4 一级缓存失效的四种情况"></a>2.1.4 一级缓存失效的四种情况</h3><ul><li>sqlsession变了 缓存失效</li><li>sqlsession不变,查询条件不同，一级缓存失效</li><li>sqlsession不变,中间发生了增删改操作，一级缓存失效</li><li>sqlsession不变,手动清除缓存，一级缓存失效</li></ul><h2 id="2-2-Mybatis-二级缓存"><a href="#2-2-Mybatis-二级缓存" class="headerlink" title="2.2 Mybatis 二级缓存"></a>2.2 Mybatis 二级缓存</h2><blockquote><p>二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</p></blockquote><h3 id="2-2-1-二级缓存结构图"><a href="#2-2-1-二级缓存结构图" class="headerlink" title="2.2.1 二级缓存结构图"></a>2.2.1 二级缓存结构图</h3><p><img src="/img/cphoto/mybatis18.jpg"></p><p>首先开启 mybatis 的二级缓存。</p><p>sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。</p><p>如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。</p><p>sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</p><h3 id="2-2-2-二级缓存的开启与关闭"><a href="#2-2-2-二级缓存的开启与关闭" class="headerlink" title="2.2.2 二级缓存的开启与关闭"></a>2.2.2 二级缓存的开启与关闭</h3><h4 id="2-2-2-1-第一步：在-SqlMapConfig-xml-文件开启二级缓存"><a href="#2-2-2-1-第一步：在-SqlMapConfig-xml-文件开启二级缓存" class="headerlink" title="2.2.2.1 第一步：在 SqlMapConfig.xml 文件开启二级缓存"></a>2.2.2.1 第一步：在 SqlMapConfig.xml 文件开启二级缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--开启二级缓存，默认是开启的--&gt;<br>&lt;settings&gt;<br>    &lt;setting name=<span class="hljs-string">&quot;cacheEnabled&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>&lt;/settings&gt;<br></code></pre></td></tr></table></figure><blockquote><p>因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。</p></blockquote><h4 id="2-2-2-2-第二步：配置相关的-Mapper-映射文件"><a href="#2-2-2-2-第二步：配置相关的-Mapper-映射文件" class="headerlink" title="2.2.2.2 第二步：配置相关的 Mapper 映射文件"></a>2.2.2.2 第二步：配置相关的 Mapper 映射文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zjw.dao.IUserDao&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启user支持二级缓存--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据id查询用户 (查询支持cache)</span><br><span class="hljs-comment">        好像开启了cache就不用配置useCache了，默认就是true</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span><br>        select * from user u where u.id = #&#123;userId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-3-第三步：配置-statement-上面的-useCache-属性"><a href="#2-2-2-3-第三步：配置-statement-上面的-useCache-属性" class="headerlink" title="2.2.2.3 第三步：配置 statement 上面的 useCache 属性"></a>2.2.2.3 第三步：配置 statement 上面的 useCache 属性</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>      select * from user u where u.id = #&#123;userId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将 UserDao.xml 映射文件中的<select>标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。<br><strong>注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。默认为true</strong></select></p><h3 id="2-2-3-二级缓存测试"><a href="#2-2-3-二级缓存测试" class="headerlink" title="2.2.3 二级缓存测试"></a>2.2.3 二级缓存测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondLeveCacheTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> InputStream in ;<br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBuilder builder;<br>    <span class="hljs-keyword">private</span> SqlSessionFactory factory ;<br>    <span class="hljs-keyword">private</span> SqlSession session ;<br>    <span class="hljs-keyword">private</span> IUserDao userDao ;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        in = Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//创建SqlSessionFactory工厂</span><br>        builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        factory = builder.build(in);<br><span class="hljs-comment">//        //使用工厂生成SqlSession对象</span><br><span class="hljs-comment">//        session = factory.openSession();</span><br><span class="hljs-comment">//        //使用SqlSession穿过将Dao接口的代理对象</span><br><span class="hljs-comment">//        userDao = session.getMapper(IUserDao.class);</span><br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><span class="hljs-comment">//        session.commit();</span><br><span class="hljs-comment">//        session.close();</span><br>        in.close();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试二级缓存</span><br><span class="hljs-comment">     * SqlSessionFactory级别的缓存</span><br><span class="hljs-comment">     * 二级缓存的使用步骤：</span><br><span class="hljs-comment">     *  第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）</span><br><span class="hljs-comment">     *  第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）</span><br><span class="hljs-comment">     *  第三步：让当前的操作支持二级缓存（在select标签中配置）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindUserById</span><span class="hljs-params">()</span></span>&#123;<br><br>        SqlSession session1 = factory.openSession();<br>        IUserDao userDao1 = session1.getMapper(IUserDao.class);<br>        User user1 = userDao1.findById(<span class="hljs-number">41</span>);<br>        System.out.println(user1);<br>        <span class="hljs-comment">//关闭一级缓存</span><br>        session1.close();<br><br>        SqlSession session2 = factory.openSession();<br>        IUserDao userDao2 = session2.getMapper(IUserDao.class);<br>        User user2 = userDao2.findById(<span class="hljs-number">41</span>);<br>        System.out.println(user2);<br><br>        System.out.println(user1 == user2);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-4-二级缓存注意事项"><a href="#2-2-4-二级缓存注意事项" class="headerlink" title="2.2.4 二级缓存注意事项"></a>2.2.4 二级缓存注意事项</h3><blockquote><p>当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Date birthday;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有序列化会报错<code>NotSerializableException</code></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2017/10/08/Git/"/>
    <url>/2017/10/08/Git/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git分布式版本控制工具"><a href="#Git分布式版本控制工具" class="headerlink" title="Git分布式版本控制工具"></a>Git分布式版本控制工具</h2><h2 id="1-Git概述"><a href="#1-Git概述" class="headerlink" title="1. Git概述"></a>1. Git概述</h2><h3 id="1-1-Git历史"><a href="#1-1-Git历史" class="headerlink" title="1.1 Git历史"></a>1.1 Git历史</h3><p>Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 </p><p>他们对新的系统制订了若干目标：</p><p>速度</p><p> 简单的设计</p><p> 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</p><p> 完全分布式</p><p> 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p><h3 id="1-2-Git与SVN对比"><a href="#1-2-Git与SVN对比" class="headerlink" title="1.2 Git与SVN对比"></a>1.2 Git与SVN对比</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。</p><p>集中式版本控制工具缺点：</p><p>  服务器单点故障</p><p>  容错性差</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%871.png" alt="1559580034272"></p><p>Git是分布式版本控制系统（Distributed Version Control System，简称 DVCS） ，分为两种类型的仓库：</p><p>本地仓库和远程仓库</p><p>本地仓库：是在开发人员自己电脑上的Git仓库        </p><p>远程仓库：是在远程服务器上的Git仓库</p><p>Clone：克隆，就是将远程仓库复制到本地</p><p>Push：推送，就是将本地仓库代码上传到远程仓库</p><p>Pull：拉取，就是将远程仓库代码下载到本地仓库</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%872.png" alt="1559580115132"></p><h3 id="1-3-Git工作流程"><a href="#1-3-Git工作流程" class="headerlink" title="1.3 Git工作流程"></a>1.3 Git工作流程</h3><p>工作流程如下：</p><p>1．从远程仓库中克隆代码到本地仓库</p><p>2．从本地仓库中checkout代码然后进行代码修改</p><p>3．在提交前先将代码提交到暂存区</p><p>4．提交到本地仓库。本地仓库中保存修改的各个历史版本</p><p>5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%873.png" alt="1559580145716"></p><h3 id="1-4-Git下载与安装"><a href="#1-4-Git下载与安装" class="headerlink" title="1.4 Git下载与安装"></a>1.4 Git下载与安装</h3><p>下载地址： <a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%874.png" alt="1559580189784"></p><p>下载完成后可以得到如下安装文件：</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%875.png" alt="1559580208972"></p><h2 id="2-Git代码托管服务"><a href="#2-Git代码托管服务" class="headerlink" title="2. Git代码托管服务"></a>2. Git代码托管服务</h2><h3 id="2-1-常用的Git代码托管服务"><a href="#2-1-常用的Git代码托管服务" class="headerlink" title="2.1 常用的Git代码托管服务"></a>2.1 常用的Git代码托管服务</h3><p>前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p><p>gitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub</p><p>码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快</p><p>GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务</p><h3 id="2-2-在码云注册账号"><a href="#2-2-在码云注册账号" class="headerlink" title="2.2 在码云注册账号"></a>2.2 在码云注册账号</h3><p>要想使用码云的相关服务，需要注册账号（地址： <a href="https://gitee.com/signup">https://gitee.com/signup</a> ）</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%876.png" alt="1559580306570"></p><h3 id="2-3-登录码云并创建Git远程仓库"><a href="#2-3-登录码云并创建Git远程仓库" class="headerlink" title="2.3 登录码云并创建Git远程仓库"></a>2.3 登录码云并创建Git远程仓库</h3><p>注册完成后就可以使用刚刚注册的邮箱进行登录（地址： <a href="https://gitee.com/login">https://gitee.com/login</a> ）</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%877.png" alt="1559580325617"></p><p>登录成功后就可以创建Git远程仓库</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%878.png" alt="1559580374460"></p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%879.png" alt="1559580393455"></p><p>创建完成后可以查看仓库信息</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8710.png" alt="1559580419103"></p><p>每个Git远程仓库都会对应一个网络地址，可以点击克隆/下载按钮弹出窗口并点击复制按钮获得这个网络地址</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8711.png" alt="1559580453747"></p><p>我们当前创建的Git远程仓库对应的地址为：<a href="https://gitee.com/ChuanZhiBoKe/myGitRepo.git">https://gitee.com/ChuanZhiBoKe/myGitRepo.git</a></p><h3 id="2-4-邀请其他用户成为仓库成员"><a href="#2-4-邀请其他用户成为仓库成员" class="headerlink" title="2.4 邀请其他用户成为仓库成员"></a>2.4 邀请其他用户成为仓库成员</h3><p>前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8712.png" alt="1559580505858"></p><h2 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3. Git常用命令"></a>3. Git常用命令</h2><h3 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h3><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><p>设置用户信息 </p><p>   git config –global user.name “itcast”</p><p>   git config –global user.email “<a href="mailto:&#x68;&#x65;&#108;&#x6c;&#111;&#x40;&#105;&#x74;&#x63;&#97;&#115;&#x74;&#46;&#x63;&#110;">&#x68;&#x65;&#108;&#x6c;&#111;&#x40;&#105;&#x74;&#x63;&#97;&#115;&#x74;&#46;&#x63;&#110;</a>”</p><p>查看配置信息</p><p>   git config –list</p><p>   git config user.name</p><p>通过上面的命令设置的信息会保存在~/.gitconfig文件中</p><h3 id="3-2-获取Git仓库"><a href="#3-2-获取Git仓库" class="headerlink" title="3.2 获取Git仓库"></a>3.2 获取Git仓库</h3><p>要使用Git对我们的代码进行版本控制，首先需要获得Git仓库</p><p>获取Git仓库通常有两种方式：</p><p>  在本地初始化一个Git仓库</p><p>  从远程仓库克隆</p><h4 id="3-2-1在本地初始化一个Git仓库"><a href="#3-2-1在本地初始化一个Git仓库" class="headerlink" title="3.2.1在本地初始化一个Git仓库"></a>3.2.1在本地初始化一个Git仓库</h4><p>执行步骤如下：</p><ol><li><p>在电脑的任意位置创建一个空目录（例如repo1）作为我们的本地Git仓库</p></li><li><p>进入这个目录中，点击右键打开Git bash窗口</p></li><li><p>执行命令git init</p></li></ol><p>如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8713.png" alt="1559580617566"></p><h4 id="3-2-2从远程仓库克隆"><a href="#3-2-2从远程仓库克隆" class="headerlink" title="3.2.2从远程仓库克隆"></a>3.2.2从远程仓库克隆</h4><p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地</p><p>命令形式为：git clone 远程Git仓库地址 </p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8714.png" alt="1559580646080"></p><h3 id="3-3工作目录、暂存区以及版本库概念"><a href="#3-3工作目录、暂存区以及版本库概念" class="headerlink" title="3.3工作目录、暂存区以及版本库概念"></a>3.3工作目录、暂存区以及版本库概念</h3><p>为了更好的学习Git，我们需要了解Git相关的一些概念，这些概念在后面的学习中会经常提到</p><p>版本库：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等</p><p>工作目录（工作区）：包含.git文件夹的目录就是工作目录，主要用于存放开发的代码</p><p>暂存区：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8715.png" alt="1559580676137"></p><h3 id="3-4-Git工作目录下文件的两种状态"><a href="#3-4-Git工作目录下文件的两种状态" class="headerlink" title="3.4 Git工作目录下文件的两种状态"></a>3.4 Git工作目录下文件的两种状态</h3><p>Git工作目录下的文件存在两种状态：</p><p>  untracked 未跟踪（未被纳入版本控制）</p><p>  tracked 已跟踪（被纳入版本控制）</p><p>​        Unmodified 未修改状态</p><p>​        Modified 已修改状态</p><p>​        Staged 已暂存状态</p><p>这些文件的状态会随着我们执行Git的命令发生变化</p><h3 id="3-5-本地仓库操作"><a href="#3-5-本地仓库操作" class="headerlink" title="3.5 本地仓库操作"></a>3.5 本地仓库操作</h3><p>git status 查看文件状态</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8716.png" alt="1559614899701"></p><p>也可以使用git status –s 使输出信息更加简洁</p><p>​                                           <img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8717.png" alt="1559614973026"></p><p>git add 将未跟踪的文件加入暂存区</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8718.png" alt="1559615003252"></p><p>将新创建的文件加入暂存区后查看文件状态</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8719.png" alt="1559615033227"></p><p>git reset 将暂存区的文件取消暂存</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8720.png" alt="1559615050490"></p><p>将文件取消暂存后查看文件状态</p><p>​    <img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8721.png" alt="1559615064841"></p><p>git commit 将暂存区的文件修改提交到本地仓库</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8722.png" alt="1559615080939"></p><p>git rm 删除文件</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8723.png" alt="1559615094669"></p><p>删除文件后查看文件状态</p><p>                                                <img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8724.png" alt="1559615111361"></p><p>上面删除的只是工作区的文件，需要提交到本地仓库</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8725.png" alt="1559615137062"></p><p>将文件添加至忽略列表</p><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># no .a files</span><br>*<span class="hljs-string">.a</span><br><span class="hljs-comment"># but do track lib.a, even though you&#x27;re ignoring .a files above</span><br>!lib.a<br><span class="hljs-comment"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="hljs-string">/TODO</span><br><span class="hljs-comment"># ignore all files in the build/ directory</span><br>build/<br><span class="hljs-comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br>doc/*<span class="hljs-string">.txt</span><br><span class="hljs-comment"># ignore all .pdf files in the doc/ directory</span><br>doc/**/*<span class="hljs-string">.pdf</span><br></code></pre></td></tr></table></figure><p>git log 查看日志记录</p><p>​                                 <img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8726.png" alt="1559615190571"></p><h3 id="3-6-远程仓库操作"><a href="#3-6-远程仓库操作" class="headerlink" title="3.6 远程仓库操作"></a>3.6 远程仓库操作</h3><p>前面执行的命令操作都是针对的本地仓库，本章节我们会学习关于远程仓库的一些操作，具体包括：</p><h4 id="3-6-1查看远程仓库"><a href="#3-6-1查看远程仓库" class="headerlink" title="3.6.1查看远程仓库"></a>3.6.1查看远程仓库</h4><p>如果想查看已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8727.png" alt="1559617010082"></p><h4 id="3-6-2-添加远程仓库"><a href="#3-6-2-添加远程仓库" class="headerlink" title="3.6.2 添加远程仓库"></a>3.6.2 添加远程仓库</h4><p>运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个可以引用的简写</url></shortname></p><p>​                              <img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8728.png" alt="1559617027057"></p><h4 id="3-6-3-从远程仓库克隆"><a href="#3-6-3-从远程仓库克隆" class="headerlink" title="3.6.3 从远程仓库克隆"></a>3.6.3 从远程仓库克隆</h4><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等），而不仅仅是复制工作所需要的文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>克隆仓库的命令格式是 git clone [url] </p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8729.png" alt="1559617051229"></p><h4 id="3-6-4-移除无效的远程仓库"><a href="#3-6-4-移除无效的远程仓库" class="headerlink" title="3.6.4 移除无效的远程仓库"></a>3.6.4 移除无效的远程仓库</h4><p>如果因为一些原因想要移除一个远程仓库 ，可以使用 git remote rm</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8730.png" alt="1559617071094"></p><p>注意：此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库</p><h4 id="3-6-5-从远程仓库中抓取与拉取"><a href="#3-6-5-从远程仓库中抓取与拉取" class="headerlink" title="3.6.5 从远程仓库中抓取与拉取"></a>3.6.5 从远程仓库中抓取与拉取</h4><p>git fetch 是从远程仓库获取最新版本到本地仓库，不会自动merge</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8731.png" alt="1559617112262"></p><p>git pull 是从远程仓库获取最新版本并merge到本地仓库</p><p><img src="/2017/10/08/Git/32.png" alt="1559617127844"></p><p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories</p><h4 id="3-6-6-推送到远程仓库"><a href="#3-6-6-推送到远程仓库" class="headerlink" title="3.6.6 推送到远程仓库"></a>3.6.6 推送到远程仓库</h4><p>当你想分享你的代码时，可以将其推送到远程仓库。 命令形式：git git push [remote-name][branch-name]</p><p><img src="/2017/10/08/Git/../../AppData/Roaming/Typora/typora-user-images/1559617154309.png" alt="1559617154309"></p><h3 id="3-7-Git分支"><a href="#3-7-Git分支" class="headerlink" title="3.7 Git分支"></a>3.7 Git分支</h3><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。</p><p>在本章节我们会学习到关于分支的相关命令，具体如下：</p><h4 id="3-7-1-查看分支"><a href="#3-7-1-查看分支" class="headerlink" title="3.7.1 查看分支"></a>3.7.1 查看分支</h4><p># 列出所有本地分支</p><p>$ git branch</p><p># 列出所有远程分支</p><p>$ git branch -r</p><p># 列出所有本地分支和远程分支</p><p>$ git branch -a</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8733.png" alt="1559617419855"></p><h4 id="3-7-2-创建分支"><a href="#3-7-2-创建分支" class="headerlink" title="3.7.2 创建分支"></a>3.7.2 创建分支</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8734.png" alt="1559617439442"></p><h4 id="3-7-3-切换分支"><a href="#3-7-3-切换分支" class="headerlink" title="3.7.3 切换分支"></a>3.7.3 切换分支</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8735.png" alt="1559617458282"></p><p>​    </p><h4 id="3-7-4-推送至远程仓库分支"><a href="#3-7-4-推送至远程仓库分支" class="headerlink" title="3.7.4 推送至远程仓库分支"></a>3.7.4 推送至远程仓库分支</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8736.png" alt="1559617505369"></p><h4 id="3-7-5-合并分支"><a href="#3-7-5-合并分支" class="headerlink" title="3.7.5 合并分支"></a>3.7.5 合并分支</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8737.png" alt="1559617538380"></p><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8738.png" alt="1559617557838"></p><h4 id="3-7-5-删除分支"><a href="#3-7-5-删除分支" class="headerlink" title="3.7.5 删除分支"></a>3.7.5 删除分支</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8739.png" alt="1559617599269"></p><p>如果要删除的分支中进行了一些开发动作，此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-D</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8740.png" alt="1559617620953"></p><p>注：如果要删除远程仓库中的分支，可以使用命令git push<br>origin –d branchName</p><h2 id="4-在IDEA中使用Git"><a href="#4-在IDEA中使用Git" class="headerlink" title="4. 在IDEA中使用Git"></a>4. 在IDEA中使用Git</h2><h3 id="4-1-在IDEA中配置Git"><a href="#4-1-在IDEA中配置Git" class="headerlink" title="4.1 在IDEA中配置Git"></a>4.1 在IDEA中配置Git</h3><p>安装好IntelliJ IDEA后，如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径。</p><p>选择File→Settings打开设置窗口，找到Version Control下的git选项：</p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8741.png" alt="1559619887418"></p><p>选择git的安装目录后可以点击“Test”按钮测试是否正确配置</p><p>​                       <img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8742.png" alt="1559619915169"></p><h3 id="4-2-在IDEA中使用Git"><a href="#4-2-在IDEA中使用Git" class="headerlink" title="4.2 在IDEA中使用Git"></a>4.2 在IDEA中使用Git</h3><h4 id="4-2-1在IDEA中创建工程并将工程添加至Git"><a href="#4-2-1在IDEA中创建工程并将工程添加至Git" class="headerlink" title="4.2.1在IDEA中创建工程并将工程添加至Git"></a>4.2.1在IDEA中创建工程并将工程添加至Git</h4><p><img src="/2017/10/08/Git/../../AppData/Roaming/Typora/typora-user-images/1559619986255.png" alt="1559619986255"></p><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8744.png" alt="1559620003251"></p><p>​                                  将项目添加至Git管理后，可以从IDEA的工具栏上看到Git操作的按钮</p><h4 id="4-2-2-将文件添加到暂存区"><a href="#4-2-2-将文件添加到暂存区" class="headerlink" title="4.2.2 将文件添加到暂存区"></a>4.2.2 将文件添加到暂存区</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8745.png" alt="1559620213702"></p><h4 id="4-2-3-提交文件"><a href="#4-2-3-提交文件" class="headerlink" title="4.2.3 提交文件"></a>4.2.3 提交文件</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8746.png" alt="1559620242587"></p><h4 id="4-2-4-将代码推送到远程仓库"><a href="#4-2-4-将代码推送到远程仓库" class="headerlink" title="4.2.4 将代码推送到远程仓库"></a>4.2.4 将代码推送到远程仓库</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8747.png" alt="1559620258317"></p><h4 id="4-2-5-从远程仓库克隆工程到本地"><a href="#4-2-5-从远程仓库克隆工程到本地" class="headerlink" title="4.2.5 从远程仓库克隆工程到本地"></a>4.2.5 从远程仓库克隆工程到本地</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8748.png" alt="1559620271237"></p><h4 id="4-2-6-从远程拉取代码"><a href="#4-2-6-从远程拉取代码" class="headerlink" title="4.2.6 从远程拉取代码"></a>4.2.6 从远程拉取代码</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8749.png" alt="1559620286937"></p><h4 id="4-2-7-版本对比"><a href="#4-2-7-版本对比" class="headerlink" title="4.2.7 版本对比"></a>4.2.7 版本对比</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8750.png" alt="1559620300302"></p><h4 id="4-2-8-创建分支"><a href="#4-2-8-创建分支" class="headerlink" title="4.2.8 创建分支"></a>4.2.8 创建分支</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8751.png" alt="1559620312520"></p><h4 id="4-2-9-切换分支"><a href="#4-2-9-切换分支" class="headerlink" title="4.2.9 切换分支"></a>4.2.9 切换分支</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8752.png" alt="1559620325257"></p><h4 id="4-2-10-分支合并"><a href="#4-2-10-分支合并" class="headerlink" title="4.2.10 分支合并"></a>4.2.10 分支合并</h4><p><img src="/2017/10/08/Git/%E5%9B%BE%E7%89%8753.png" alt="1559620338050"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2017/10/08/Spring/"/>
    <url>/2017/10/08/Spring/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-spring概述"><a href="#1-spring概述" class="headerlink" title="1. spring概述"></a>1. spring概述</h2><h3 id="1-1-Spring是什么（理解）"><a href="#1-1-Spring是什么（理解）" class="headerlink" title="1.1 Spring是什么（理解）"></a>1.1 Spring是什么（理解）</h3><p>Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。</p><p>提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架</p><h3 id="1-2-Spring发展历程-（了解）"><a href="#1-2-Spring发展历程-（了解）" class="headerlink" title="1.2 Spring发展历程 （了解）"></a>1.2 Spring发展历程 （了解）</h3><p>Rod Johnson （ Spring 之父）</p><p>2017  年<br>9 月份发布了 Spring 的最新版本 Spring5.0<br>通用版（GA）</p><h3 id="1-3-Spring的优势（理解）"><a href="#1-3-Spring的优势（理解）" class="headerlink" title="1.3 Spring的优势（理解）"></a>1.3 Spring的优势（理解）</h3><p>方便解耦，简化开发</p><p>AOP 编程的支持</p><p>声明式事务的支持</p><p>方便程序的测试</p><h3 id="1-4-Spring的体系结构（了解）"><a href="#1-4-Spring的体系结构（了解）" class="headerlink" title="1.4 Spring的体系结构（了解）"></a>1.4 Spring的体系结构（了解）</h3><p><img src="/img/cphoto/spring01.jpg"></p><h2 id="2-spring快速入门"><a href="#2-spring快速入门" class="headerlink" title="2. spring快速入门"></a>2. spring快速入门</h2><h3 id="2-1-Spring程序开发步骤"><a href="#2-1-Spring程序开发步骤" class="headerlink" title="2.1 Spring程序开发步骤"></a>2.1 Spring程序开发步骤</h3><p>①导入 Spring 开发的基本包坐标</p><p>②编写 Dao 接口和实现类</p><p>③创建 Spring 核心配置文件</p><p>④在 Spring 配置文件中配置 UserDaoImpl</p><p>⑤使用 Spring 的 API 获得 Bean 实例</p><h3 id="2-2-导入Spring开发的基本包坐标"><a href="#2-2-导入Spring开发的基本包坐标" class="headerlink" title="2.2 导入Spring开发的基本包坐标"></a>2.2 导入Spring开发的基本包坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-comment">&lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="2-3-编写Dao接口和实现类"><a href="#2-3-编写Dao接口和实现类" class="headerlink" title="2.3 编写Dao接口和实现类"></a>2.3 编写Dao接口和实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserDao save method running....&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-创建Spring核心配置文件"><a href="#2-4-创建Spring核心配置文件" class="headerlink" title="2.4 创建Spring核心配置文件"></a>2.4 创建Spring核心配置文件</h3><p>在类路径下（resources）创建applicationContext.xml配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>                xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>xsi:schemaLocation=<span class="hljs-string">&quot;</span><br><span class="hljs-string">    http://www.springframework.org/schema/beans                   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="2-5-在Spring配置文件中配置UserDaoImpl"><a href="#2-5-在Spring配置文件中配置UserDaoImpl" class="headerlink" title="2.5 在Spring配置文件中配置UserDaoImpl"></a>2.5 在Spring配置文件中配置UserDaoImpl</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>                <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans                   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="2-6-使用Spring的API获得Bean实例"><a href="#2-6-使用Spring的API获得Bean实例" class="headerlink" title="2.6 使用Spring的API获得Bean实例"></a>2.6 使用Spring的API获得Bean实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>ApplicationContext applicationContext = <span class="hljs-keyword">new</span>  <br>             ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>             UserDao userDao = (UserDao) applicationContext.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);    userDao.save();<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="3-Spring配置文件"><a href="#3-Spring配置文件" class="headerlink" title="3. Spring配置文件"></a>3. Spring配置文件</h2><h3 id="3-1-Bean标签基本配置"><a href="#3-1-Bean标签基本配置" class="headerlink" title="3.1 Bean标签基本配置"></a>3.1 Bean标签基本配置</h3><p>用于配置对象交由Spring 来创建。</p><p>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p><p>基本属性：</p><p>id：Bean实例在Spring容器中的唯一标识</p><p>class：Bean的全限定名称</p><h3 id="3-2-Bean标签范围配置"><a href="#3-2-Bean标签范围配置" class="headerlink" title="3.2 Bean标签范围配置"></a>3.2 Bean标签范围配置</h3><p>scope:指对象的作用范围，取值如下： </p><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例的</td></tr><tr><td>prototype</td><td>多例的</td></tr><tr><td>request</td><td>WEB   项目中，Spring   创建一个   Bean   的对象，将对象存入到   request   域中</td></tr><tr><td>session</td><td>WEB   项目中，Spring   创建一个   Bean   的对象，将对象存入到   session   域中</td></tr><tr><td>global   session</td><td>WEB   项目中，应用在   Portlet   环境，如果没有   Portlet   环境那么globalSession   相当于   session</td></tr></tbody></table><p>1）当scope的取值为singleton时</p><p>​      Bean的实例化个数：1个</p><p>​      Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</p><p>​      Bean的生命周期：</p><p>对象创建：当应用加载，创建容器时，对象就被创建了</p><p>对象运行：只要容器在，对象一直活着</p><p>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</p><p>2）当scope的取值为prototype时</p><p>​      Bean的实例化个数：多个</p><p>​      Bean的实例化时机：当调用getBean()方法时实例化Bean</p><p>对象创建：当使用对象时，创建新的对象实例</p><p>对象运行：只要对象在使用中，就一直活着</p><p>对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了</p><h3 id="3-3-Bean生命周期配置"><a href="#3-3-Bean生命周期配置" class="headerlink" title="3.3 Bean生命周期配置"></a>3.3 Bean生命周期配置</h3><p>init-method：指定类中的初始化方法名称</p><p>destroy-method：指定类中销毁方法名称</p><h3 id="3-4-Bean实例化三种方式"><a href="#3-4-Bean实例化三种方式" class="headerlink" title="3.4 Bean实例化三种方式"></a>3.4 Bean实例化三种方式</h3><p>1） 使用无参构造方法实例化</p><p>​      它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>2） 工厂静态方法实例化</p><p>​      工厂的静态方法返回Bean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactoryBean</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDao <span class="hljs-title">createUserDao</span><span class="hljs-params">()</span></span>&#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDaoImpl();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.factory.StaticFactoryBean&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createUserDao&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>3） 工厂实例方法实例化</p><p>​      工厂的非静态方法返回Bean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicFactoryBean</span> </span>&#123;  <br><span class="hljs-function"><span class="hljs-keyword">public</span> UserDao <span class="hljs-title">createUserDao</span><span class="hljs-params">()</span></span>&#123;        <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDaoImpl(); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;factoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.factory.DynamicFactoryBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;factoryBean&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createUserDao&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-Bean的依赖注入入门"><a href="#3-5-Bean的依赖注入入门" class="headerlink" title="3.5 Bean的依赖注入入门"></a>3.5 Bean的依赖注入入门</h3><p>①创建 UserService，UserService 内部在调用 UserDao的save() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>         ApplicationContext applicationContext = <span class="hljs-keyword">new</span> <br>                 ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);                  UserDao userDao = (UserDao) applicationContext.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);<br>          userDao.save();<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>②将 UserServiceImpl 的创建权交给 Spring</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>③从 Spring 容器中获得 UserService 进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>UserService userService = (UserService) applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>userService.save();<br></code></pre></td></tr></table></figure><h3 id="3-6-Bean的依赖注入概念"><a href="#3-6-Bean的依赖注入概念" class="headerlink" title="3.6 Bean的依赖注入概念"></a>3.6 Bean的依赖注入概念</h3><p>依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</p><p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</p><p>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p><p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。</p><p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</p><h3 id="3-7-Bean的依赖注入方式"><a href="#3-7-Bean的依赖注入方式" class="headerlink" title="3.7 Bean的依赖注入方式"></a>3.7 Bean的依赖注入方式</h3><p>①构造方法</p><p>​      创建有参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>ApplicationContext applicationContext = <span class="hljs-keyword">new</span> <br>                 ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);       UserDao userDao = (UserDao) applicationContext.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);    <br>          userDao.save();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>​      配置Spring容器调用有参构造时进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②set方法</p><p>​      在UserServiceImpl中添加setUserDao方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userDao = userDao;  <br>        &#125; <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;      <br>    userDao.save();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​      配置Spring容器调用set方法进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>set方法:P命名空间注入</p><p>​      P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：</p><p>​      首先，需要引入P命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br></code></pre></td></tr></table></figure><p>其次，需要修改注入方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span> <span class="hljs-attr">p:userDao-</span></span><br><span class="hljs-tag"> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-8-Bean的依赖注入的数据类型"><a href="#3-8-Bean的依赖注入的数据类型" class="headerlink" title="3.8 Bean的依赖注入的数据类型"></a>3.8 Bean的依赖注入的数据类型</h3><p>上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p><p>注入数据的三种数据类型 </p><p>普通数据类型</p><p>引用数据类型</p><p>集合数据类型</p><p>其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。</p><p><strong>Bean的依赖注入的数据类型</strong></p><p>（1）普通数据类型的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-keyword">private</span> String company;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCompany</span><span class="hljs-params">(String company)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.company = company;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(company+<span class="hljs-string">&quot;===&quot;</span>+age);<br>        System.out.println(<span class="hljs-string">&quot;UserDao save method running....&quot;</span>);   <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;company&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;传智播客&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;15&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）集合数据类型（List<String>）的注入</String></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-keyword">private</span> List&lt;String&gt; strList;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStrList</span><span class="hljs-params">(List&lt;String&gt; strList)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.strList = strList;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(strList);<br>        System.out.println(<span class="hljs-string">&quot;UserDao save method running....&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;strList&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>aaa<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>bbb<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>ccc<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）集合数据类型（List<User>）的注入</User></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-keyword">private</span> List&lt;User&gt; userList;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserList</span><span class="hljs-params">(List&lt;User&gt; userList)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.userList = userList;  <br> &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(userList);<br>System.out.println(<span class="hljs-string">&quot;UserDao save method running....&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;u1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;u2&quot;</span>/&gt;</span>       <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）集合数据类型（ Map&lt;String,User&gt; ）的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String,User&gt; userMap;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserMap</span><span class="hljs-params">(Map&lt;String, User&gt; userMap)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.userMap = userMap;<br>    &#125;    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;      <br>System.out.println(userMap);<br>System.out.println(<span class="hljs-string">&quot;UserDao save method running....&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>            <br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;user1&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;u1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;u2&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（5）集合数据类型（Properties）的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Properties properties;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.properties = properties;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(properties);<br>System.out.println(<span class="hljs-string">&quot;UserDao save method running....&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>aaa<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>bbb<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;p3&quot;</span>&gt;</span>ccc<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-9-引入其他配置文件（分模块开发）"><a href="#3-9-引入其他配置文件（分模块开发）" class="headerlink" title="3.9 引入其他配置文件（分模块开发）"></a>3.9 引入其他配置文件（分模块开发）</h3><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-spring相关API"><a href="#4-spring相关API" class="headerlink" title="4. spring相关API"></a>4. spring相关API</h2><h3 id="4-1-ApplicationContext的继承体系"><a href="#4-1-ApplicationContext的继承体系" class="headerlink" title="4.1 ApplicationContext的继承体系"></a>4.1 ApplicationContext的继承体系</h3><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p><h3 id="4-2-ApplicationContext的实现类"><a href="#4-2-ApplicationContext的实现类" class="headerlink" title="4.2 ApplicationContext的实现类"></a>4.2 ApplicationContext的实现类</h3><p>1）ClassPathXmlApplicationContext </p><p>​      它是从类的根路径下加载配置文件 推荐使用这种</p><p>2）FileSystemXmlApplicationContext </p><p>​      它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p><p>3）AnnotationConfigApplicationContext</p><p>​      当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p><h3 id="4-3-getBean-方法使用"><a href="#4-3-getBean-方法使用" class="headerlink" title="4.3 getBean()方法使用"></a>4.3 getBean()方法使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;  <br>assertBeanFactoryActive();   <br><span class="hljs-keyword">return</span> getBeanFactory().getBean(name);<br>&#125;<br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;       assertBeanFactoryActive();<br><span class="hljs-keyword">return</span> getBeanFactory().getBean(requiredType);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</p><p>当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错</p><p><strong>getBean()方法使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext applicationContext = <span class="hljs-keyword">new</span> <br>            ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>  UserService userService1 = (UserService) applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>  UserService userService2 = applicationContext.getBean(UserService.class);<br></code></pre></td></tr></table></figure><h2 id="1-Spring配置数据源"><a href="#1-Spring配置数据源" class="headerlink" title="1.Spring配置数据源"></a>1.Spring配置数据源</h2><h3 id="1-1-数据源（连接池）的作用"><a href="#1-1-数据源（连接池）的作用" class="headerlink" title="1.1 数据源（连接池）的作用"></a>1.1 数据源（连接池）的作用</h3><p>数据源(连接池)是提高程序性能如出现的</p><p>事先实例化数据源，初始化部分连接资源</p><p>使用连接资源时从数据源中获取</p><p>使用完毕后将连接资源归还给数据源</p><p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p><p><strong>开发步骤</strong></p><p>①导入数据源的坐标和数据库驱动坐标</p><p>②创建数据源对象</p><p>③设置数据源的基本连接数据</p><p>④使用数据源获取连接资源和归还连接资源</p><h3 id="1-2-数据源的手动创建"><a href="#1-2-数据源的手动创建" class="headerlink" title="1.2 数据源的手动创建"></a>1.2 数据源的手动创建</h3><p>①导入c3p0和druid的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- C3P0连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Druid连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>①导入mysql数据库驱动坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.39<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②创建C3P0连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testC3P0</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">//创建数据源</span><br>ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br><span class="hljs-comment">//设置数据库连接参数</span><br>    dataSource.setDriverClass(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);                                  dataSource.setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);<br>    dataSource.setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>    dataSource.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><span class="hljs-comment">//获得连接对象</span><br>Connection connection = dataSource.getConnection();<br>System.out.println(connection);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>②创建Druid连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDruid</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//创建数据源</span><br>    DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>    <span class="hljs-comment">//设置数据库连接参数</span><br>    dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>); <br>    dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);   <br>    dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>    dataSource.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>    <span class="hljs-comment">//获得连接对象</span><br>    Connection connection = dataSource.getConnection();    <br>    System.out.println(connection);<br>&#125;<br></code></pre></td></tr></table></figure><p>③提取jdbc.properties配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>④读取jdbc.properties配置文件创建连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testC3P0ByProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//加载类路径下的jdbc.properties</span><br>    ResourceBundle rb = ResourceBundle.getBundle(<span class="hljs-string">&quot;jdbc&quot;</span>);<br>    ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource(); <br>    dataSource.setDriverClass(rb.getString(<span class="hljs-string">&quot;jdbc.driver&quot;</span>));   <br>    dataSource.setJdbcUrl(rb.getString(<span class="hljs-string">&quot;jdbc.url&quot;</span>)); <br>    dataSource.setUser(rb.getString(<span class="hljs-string">&quot;jdbc.username&quot;</span>)); <br>    dataSource.setPassword(rb.getString(<span class="hljs-string">&quot;jdbc.password&quot;</span>));<br>    Connection connection = dataSource.getConnection();   <br>    System.out.println(connection);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Spring配置数据源"><a href="#1-3-Spring配置数据源" class="headerlink" title="1.3 Spring配置数据源"></a>1.3 Spring配置数据源</h3><p>可以将DataSource的创建权交由Spring容器去完成</p><p>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的</p><p>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试从容器当中获取数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext applicationContext = <span class="hljs-keyword">new</span> <br>           ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>               DataSource dataSource = (DataSource) <br>applicationContext.getBean(<span class="hljs-string">&quot;dataSource&quot;</span>);<br>Connection connection = dataSource.getConnection();<br>System.out.println(connection);<br></code></pre></td></tr></table></figure><h3 id="1-4-抽取jdbc配置文件"><a href="#1-4-抽取jdbc配置文件" class="headerlink" title="1.4 抽取jdbc配置文件"></a>1.4 抽取jdbc配置文件</h3><p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p><p>首先，需要引入context命名空间和约束路径：</p><p>命名空间：xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a></p><p>约束路径：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br>​                       </p><p>​                   <a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-知识要点"><a href="#1-5-知识要点" class="headerlink" title="1.5 知识要点"></a>1.5 知识要点</h3><p>Spring容器加载properties文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;xx.properties&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;key&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-Spring注解开发"><a href="#2-Spring注解开发" class="headerlink" title="2. Spring注解开发"></a>2. Spring注解开发</h2><h3 id="2-1-Spring原始注解"><a href="#2-1-Spring原始注解" class="headerlink" title="2.1 Spring原始注解"></a>2.1 Spring原始注解</h3><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 </p><p>Spring原始注解主要是替代<Bean>的配置</Bean></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td>使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td>使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td>使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td>相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestroy</td><td>使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table><p>注意：</p><p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--注解的组件扫描--&gt;<br>&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.itheima&quot;</span>&gt;&lt;/context:component-scan&gt;<br></code></pre></td></tr></table></figure><p>使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Component(&quot;userDao&quot;)</span><br><span class="hljs-meta">@Repository(&quot;userDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;save running... ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化</p><p>使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Component(&quot;userService&quot;)</span><br><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">/*@Autowired</span><br><span class="hljs-comment">    @Qualifier(&quot;userDao&quot;)*/</span><br>    <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;       <br>     userDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用@Value进行字符串的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository(&quot;userDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;注入普通数据&quot;)</span><br>    <span class="hljs-keyword">private</span> String str;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(str);<br>        System.out.println(driver);<br>        System.out.println(<span class="hljs-string">&quot;save running... ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用@Scope标注Bean的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Scope(&quot;prototype&quot;)</span><br><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>   <span class="hljs-comment">//此处省略代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;初始化方法....&quot;</span>);<br>&#125;<br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;销毁方法.....&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Spring新注解"><a href="#2-2-Spring新注解" class="headerlink" title="2.2 Spring新注解"></a>2.2 Spring新注解</h3><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p><p>非自定义的Bean的配置：<bean></bean></p><p>加载properties文件的配置：<a href="context:property-placeholder">context:property-placeholder</a></p><p>组件扫描的配置：<a href="context:component-scan">context:component-scan</a></p><p>引入其他文件：<import></import></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个 Spring   配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring   在初始化容器时要扫描的包。   作用和在 Spring   的 xml 配置文件中的   &lt;context:component-scan   base-package=”com.itheima”/&gt;一样</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到   Spring   容器中</td></tr><tr><td>@PropertySource</td><td>用于加载.properties   文件中的配置</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table><p>@Configuration</p><p>@ComponentScan</p><p>@Import</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-meta">@Import(&#123;DataSourceConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@PropertySource</p><p>@value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br></code></pre></td></tr></table></figure><p>@Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name=&quot;dataSource&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> PropertyVetoException </span>&#123; <br>    ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource(); <br>    dataSource.setDriverClass(driver);<br>    dataSource.setJdbcUrl(url);<br>    dataSource.setUser(username);<br>    dataSource.setPassword(password);<br>    <span class="hljs-keyword">return</span> dataSource;<br>&#125; <br></code></pre></td></tr></table></figure><p>测试加载核心配置类创建Spring容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAnnoConfiguration</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>ApplicationContext applicationContext = <span class="hljs-keyword">new</span> <br>          AnnotationConfigApplicationContext(SpringConfiguration.class);    UserService userService = (UserService)    <br>    applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>    userService.save();<br>    DataSource dataSource = (DataSource) <br>    applicationContext.getBean(<span class="hljs-string">&quot;dataSource&quot;</span>);<br>    Connection connection = dataSource.getConnection(); <br>    System.out.println(connection);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3-Spring整合Junit"><a href="#3-Spring整合Junit" class="headerlink" title="3. Spring整合Junit"></a>3. Spring整合Junit</h2><h3 id="3-1-原始Junit测试Spring的问题"><a href="#3-1-原始Junit测试Spring的问题" class="headerlink" title="3.1 原始Junit测试Spring的问题"></a>3.1 原始Junit测试Spring的问题</h3><p>在测试类中，每个测试方法都有以下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br>IAccountService as = ac.getBean(<span class="hljs-string">&quot;accountService&quot;</span>,IAccountService.class);<br></code></pre></td></tr></table></figure><p>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p><h3 id="3-2-上述问题解决思路"><a href="#3-2-上述问题解决思路" class="headerlink" title="3.2 上述问题解决思路"></a>3.2 上述问题解决思路</h3><p>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它</p><p>将需要进行测试Bean直接在测试类中进行注入</p><h3 id="3-3-Spring集成Junit步骤"><a href="#3-3-Spring集成Junit步骤" class="headerlink" title="3.3 Spring集成Junit步骤"></a>3.3 Spring集成Junit步骤</h3><p>①导入spring集成Junit的坐标</p><p>②使用@Runwith注解替换原来的运行期</p><p>③使用@ContextConfiguration指定配置文件或配置类</p><p>④使用@Autowired注入需要测试的对象</p><p>⑤创建测试方法进行测试</p><h3 id="3-4-Spring集成Junit代码实现"><a href="#3-4-Spring集成Junit代码实现" class="headerlink" title="3.4 Spring集成Junit代码实现"></a>3.4 Spring集成Junit代码实现</h3><p>①导入spring集成Junit的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②使用@Runwith注解替换原来的运行期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringJunitTest</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>③使用@ContextConfiguration指定配置文件或配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-comment">//加载spring核心配置文件</span><br><span class="hljs-comment">//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span><br><span class="hljs-comment">//加载spring核心配置类</span><br><span class="hljs-meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringJunitTest</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>④使用@Autowired注入需要测试的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringJunitTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>&#125;<br></code></pre></td></tr></table></figure><p>⑤创建测试方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringJunitTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserService</span><span class="hljs-params">()</span></span>&#123;<br>    userService.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring集成Junit步骤</p><p>①导入spring集成Junit的坐标</p><p>②使用@Runwith注解替换原来的运行期</p><p>③使用@ContextConfiguration指定配置文件或配置类</p><p>④使用@Autowired注入需要测试的对象</p><p>⑤创建测试方法进行测试</p><h3 id="1-Spring-的-AOP-简介"><a href="#1-Spring-的-AOP-简介" class="headerlink" title="1.Spring 的 AOP 简介"></a>1.Spring 的 AOP 简介</h3><h4 id="1-1-什么是-AOP"><a href="#1-1-什么是-AOP" class="headerlink" title="1.1 什么是 AOP"></a>1.1 什么是 AOP</h4><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h4 id="1-2-AOP-的作用及其优势"><a href="#1-2-AOP-的作用及其优势" class="headerlink" title="1.2 AOP 的作用及其优势"></a>1.2 AOP 的作用及其优势</h4><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p><p>优势：减少重复代码，提高开发效率，并且便于维护</p><h4 id="1-3-AOP-的底层实现"><a href="#1-3-AOP-的底层实现" class="headerlink" title="1.3 AOP 的底层实现"></a>1.3 AOP 的底层实现</h4><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><h4 id="1-4-AOP-的动态代理技术"><a href="#1-4-AOP-的动态代理技术" class="headerlink" title="1.4 AOP 的动态代理技术"></a>1.4 AOP 的动态代理技术</h4><p>常用的动态代理技术</p><p>JDK 代理 : 基于接口的动态代理技术</p><p>cglib 代理：基于父类的动态代理技术</p><p><img src="/img/cphoto/spring02.jpg"></p><h4 id="1-5-JDK-的动态代理"><a href="#1-5-JDK-的动态代理" class="headerlink" title="1.5 JDK 的动态代理"></a>1.5 JDK 的动态代理</h4><p>①目标类接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TargetInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>②目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Target running....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③动态代理代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Target target = <span class="hljs-keyword">new</span> Target(); <span class="hljs-comment">//创建目标对象</span><br><span class="hljs-comment">//创建代理对象</span><br>TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass()<br>.getClassLoader(),target.getClass().getInterfaces(),<span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> </span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;前置增强代码...&quot;</span>);<br>                Object invoke = method.invoke(target, args);<br>                System.out.println(<span class="hljs-string">&quot;后置增强代码...&quot;</span>);<br>                <span class="hljs-keyword">return</span> invoke;<br>            &#125;<br>        &#125;<br>);<br></code></pre></td></tr></table></figure><p>④  调用代理对象的方法测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试,当调用接口的任何方法时，代理对象的代码都无序修改</span><br>proxy.method();<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/spring03.jpg"></p><h4 id="1-6-cglib-的动态代理"><a href="#1-6-cglib-的动态代理" class="headerlink" title="1.6 cglib 的动态代理"></a>1.6 cglib 的动态代理</h4><p>①目标类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Target running....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②动态代理代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Target target = <span class="hljs-keyword">new</span> Target(); <span class="hljs-comment">//创建目标对象</span><br>Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();   <span class="hljs-comment">//创建增强器</span><br>enhancer.setSuperclass(Target.class); <span class="hljs-comment">//设置父类</span><br>enhancer.setCallback(<span class="hljs-keyword">new</span> MethodInterceptor() &#123; <span class="hljs-comment">//设置回调</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, </span></span><br><span class="hljs-params"><span class="hljs-function">    MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置代码增强....&quot;</span>);<br>        Object invoke = method.invoke(target, objects);<br>        System.out.println(<span class="hljs-string">&quot;后置代码增强....&quot;</span>);<br>        <span class="hljs-keyword">return</span> invoke;<br>    &#125;<br>&#125;);<br>Target proxy = (Target) enhancer.create(); <span class="hljs-comment">//创建代理对象</span><br><br></code></pre></td></tr></table></figure><p>③调用代理对象的方法测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试,当调用接口的任何方法时，代理对象的代码都无序修改</span><br>proxy.method();<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/spring03.jpg"></p><h4 id="1-7-AOP-相关概念"><a href="#1-7-AOP-相关概念" class="headerlink" title="1.7 AOP 相关概念"></a>1.7 AOP 相关概念</h4><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p><p>在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：</p><ul><li><p>Target（目标对象）：代理的目标对象</p></li><li><p>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类</p></li><li><p>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点</p></li><li><p>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义</p></li><li><p>Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知</p></li><li><p>Aspect（切面）：是切入点和通知（引介）的结合</p></li><li><p>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</p></li></ul><p>1.8 AOP 开发明确的事项</p><p>1.8 AOP 开发明确的事项</p><h4 id="1-8-AOP-开发明确的事项"><a href="#1-8-AOP-开发明确的事项" class="headerlink" title="1.8 AOP 开发明确的事项"></a>1.8 AOP 开发明确的事项</h4><h5 id="1-需要编写的内容"><a href="#1-需要编写的内容" class="headerlink" title="1)需要编写的内容"></a>1)需要编写的内容</h5><ul><li><p>编写核心业务代码（目标类的目标方法）</p></li><li><p>编写切面类，切面类中有通知(增强功能方法)</p></li><li><p>在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p></li></ul><h5 id="2）AOP-技术实现的内容"><a href="#2）AOP-技术实现的内容" class="headerlink" title="2）AOP 技术实现的内容"></a>2）AOP 技术实现的内容</h5><p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><h5 id="3）AOP-底层使用哪种代理方式"><a href="#3）AOP-底层使用哪种代理方式" class="headerlink" title="3）AOP 底层使用哪种代理方式"></a>3）AOP 底层使用哪种代理方式</h5><p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p><h4 id="1-9-知识要点"><a href="#1-9-知识要点" class="headerlink" title="1.9 知识要点"></a>1.9 知识要点</h4><ul><li><p>aop：面向切面编程</p></li><li><p>aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理</p></li><li><p>aop的重点概念：</p><pre><code>Pointcut（切入点）：被增强的方法Advice（通知/ 增强）：封装增强业务逻辑的方法Aspect（切面）：切点+通知Weaving（织入）：将切点与通知结合的过程</code></pre></li><li><p>开发明确事项：</p><pre><code>谁是切点（切点表达式配置）谁是通知（切面类中的增强方法）将切点和通知进行织入配置</code></pre></li></ul><h3 id="2-基于-XML-的-AOP-开发"><a href="#2-基于-XML-的-AOP-开发" class="headerlink" title="2. 基于 XML 的 AOP 开发"></a>2. 基于 XML 的 AOP 开发</h3><h4 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1 快速入门"></a>2.1 快速入门</h4><p>①导入 AOP 相关坐标</p><p>②创建目标接口和目标类（内部有切点）</p><p>③创建切面类（内部有增强方法）</p><p>④将目标类和切面类的对象创建权交给 spring</p><p>⑤在 applicationContext.xml 中配置织入关系</p><p>⑥测试代码</p><p>①导入 AOP 相关坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- aspectj的织入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②创建目标接口和目标类（内部有切点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TargetInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Target running....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③创建切面类（内部有增强方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">//前置增强方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置代码增强.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>④将目标类和切面类的对象创建权交给 spring</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置目标类--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;target&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.aop.Target&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--配置切面类--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.aop.MyAspect&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>⑤在 applicationContext.xml 中配置织入关系</p><p>导入aop命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>⑤在 applicationContext.xml 中配置织入关系</p><p>配置切点表达式和前置增强的织入关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(public void com.itheima.aop.Target.method())&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:before</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>⑥测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TargetInterface target;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        target.method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⑦测试结果</p><p><img src="/img/cphoto/spring11.jpg"></p><h1 id="SpringMVC的请求和响应"><a href="#SpringMVC的请求和响应" class="headerlink" title="SpringMVC的请求和响应"></a>SpringMVC的请求和响应</h1><h2 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h2><h3 id="01-SpringMVC的数据响应-数据响应方式-理解"><a href="#01-SpringMVC的数据响应-数据响应方式-理解" class="headerlink" title="01-SpringMVC的数据响应-数据响应方式(理解)"></a>01-SpringMVC的数据响应-数据响应方式(理解)</h3><ol><li>   页面跳转</li></ol><p>直接返回字符串</p><p>通过ModelAndView对象返回</p><p>2） 回写数据 </p><p>直接返回字符串</p><p>返回对象或集合    </p><h3 id="02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）"><a href="#02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）" class="headerlink" title="02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）"></a>02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）</h3><p><img src="/img/cphoto/spring12.jpg"></p><h3 id="03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1-应用"><a href="#03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1-应用" class="headerlink" title="03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)"></a>03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)</h3><p>在Controller中方法返回ModelAndView对象，并且设置视图名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">save2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            Model:模型 作用封装数据</span><br><span class="hljs-comment">            View：视图 作用展示数据</span><br><span class="hljs-comment">         */</span><br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>        <span class="hljs-comment">//设置模型数据</span><br>        modelAndView.addObject(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;itcast&quot;</span>);<br>        <span class="hljs-comment">//设置视图名称</span><br>        modelAndView.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2-应用"><a href="#04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2-应用" class="headerlink" title="04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)"></a>04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)</h3><p>n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@RequestMapping(value=&quot;/quick3&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">save3</span><span class="hljs-params">(ModelAndView modelAndView)</span></span>&#123;<br>        modelAndView.addObject(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>);<br>        modelAndView.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br><span class="hljs-meta">@RequestMapping(value=&quot;/quick4&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save4</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;博学谷&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="05-SpringMVC的数据响应-页面跳转-返回ModelAndView3-应用"><a href="#05-SpringMVC的数据响应-页面跳转-返回ModelAndView3-应用" class="headerlink" title="05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)"></a>05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)</h3><p>在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick5&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save5</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>        request.setAttribute(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;酷丁鱼&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="06-SpringMVC的数据响应-回写数据-直接回写字符串-应用"><a href="#06-SpringMVC的数据响应-回写数据-直接回写字符串-应用" class="headerlink" title="06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)"></a>06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)</h3><p>通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void</p><p>将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick7&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span>  <span class="hljs-comment">//告知SpringMVC框架 不进行视图跳转 直接进行数据响应</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save7</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello itheima&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value=&quot;/quick6&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save6</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        response.getWriter().print(<span class="hljs-string">&quot;hello itcast&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="07-SpringMVC的数据响应-回写数据-直接回写json格式字符串-应用"><a href="#07-SpringMVC的数据响应-回写数据-直接回写json格式字符串-应用" class="headerlink" title="07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)"></a>07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick8&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save8</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;\&quot;username\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick9&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUsername(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        user.setAge(<span class="hljs-number">30</span>);<br>        <span class="hljs-comment">//使用json的转换工具将对象转换成json格式字符串在返回</span><br>        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        String json = objectMapper.writeValueAsString(user);<br><br>        <span class="hljs-keyword">return</span> json;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="08-SpringMVC的数据响应-回写数据-返回对象或集合-应用"><a href="#08-SpringMVC的数据响应-回写数据-返回对象或集合-应用" class="headerlink" title="08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)"></a>08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)</h3><p>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;messageConverters&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick10&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-comment">//期望SpringMVC自动将User转换成json格式的字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">save10</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setUsername(<span class="hljs-string">&quot;lisi2&quot;</span>);<br>        user.setAge(<span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="09-SpringMVC的数据响应-回写数据-返回对象或集合2-应用"><a href="#09-SpringMVC的数据响应-回写数据-返回对象或集合2-应用" class="headerlink" title="09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)"></a>09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)</h3><p>在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</p><p>使用<code>&lt;mvc:annotation-driven /&gt;</code>自动加载 RequestMappingHandlerMapping（处理映射器）和</p><p>RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用</p><p><code>&lt;mvc:annotation-driven /&gt;</code>替代注解处理器和适配器的配置。</p><p>同时使用<code>&lt;mvc:annotation-driven /&gt;</code></p><p>默认底层就会集成jackson进行对象或集合的json格式字符串的转换</p><h3 id="10-SpringMVC的数据响应-知识要点小结-理解，记忆"><a href="#10-SpringMVC的数据响应-知识要点小结-理解，记忆" class="headerlink" title="10-SpringMVC的数据响应-知识要点小结(理解，记忆)"></a>10-SpringMVC的数据响应-知识要点小结(理解，记忆)</h3><p>1） 页面跳转</p><p>直接返回字符串</p><p>通过ModelAndView对象返回</p><p>2） 回写数据 </p><p>直接返回字符串</p><p>HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回</p><p>返回对象或集合 </p><p>@ResponseBody+<code>&lt;mvc:annotation-driven/&gt;   </code></p><h2 id="SpringMVC的请求"><a href="#SpringMVC的请求" class="headerlink" title="SpringMVC的请求"></a>SpringMVC的请求</h2><h3 id="11-SpringMVC的请求-获得请求参数-请求参数类型-理解"><a href="#11-SpringMVC的请求-获得请求参数-请求参数类型-理解" class="headerlink" title="11-SpringMVC的请求-获得请求参数-请求参数类型(理解)"></a>11-SpringMVC的请求-获得请求参数-请求参数类型(理解)</h3><p>客户端请求参数的格式是：name=value&amp;name=value……</p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数</p><p>基本类型参数</p><p>POJO类型参数</p><p>数组类型参数</p><p>集合类型参数</p><h3 id="12-SpringMVC的请求-获得请求参数-获得基本类型参数-应用"><a href="#12-SpringMVC的请求-获得请求参数-获得基本类型参数-应用" class="headerlink" title="12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)"></a>12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)</h3><p>Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换；</p><p>自动的类型转换是指从String向其他类型的转换</p><p><code>http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick11&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save11</span><span class="hljs-params">(String username,<span class="hljs-keyword">int</span> age)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br>        System.out.println(age);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="13-SpringMVC的请求-获得请求参数-获得POJO类型参数-应用"><a href="#13-SpringMVC的请求-获得请求参数-获得POJO类型参数-应用" class="headerlink" title="13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)"></a>13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)</h3><p>Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.domain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick12&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save12</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(user);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="14-SpringMVC的请求-获得请求参数-获得数组类型参数-应用"><a href="#14-SpringMVC的请求-获得请求参数-获得数组类型参数-应用" class="headerlink" title="14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)"></a>14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)</h3><p>Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick13&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save13</span><span class="hljs-params">(String[] strs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(Arrays.asList(strs));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="15-SpringMVC的请求-获得请求参数-获得集合类型参数1-应用"><a href="#15-SpringMVC的请求-获得请求参数-获得集合类型参数1-应用" class="headerlink" title="15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)"></a>15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)</h3><p>获得集合参数时，要将集合参数包装到一个POJO中才可以。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick14&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>        &lt;%--表明是第一个User对象的username age--%&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[0].username&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[0].age&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[1].username&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;userList[1].age&quot;</span>&gt;&lt;br/&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>    &lt;/form&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.domain;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VO</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;User&gt; userList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserList</span><span class="hljs-params">(List&lt;User&gt; userList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userList = userList;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VO&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;userList=&quot;</span> + userList +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick14&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save14</span><span class="hljs-params">(VO vo)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(vo);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="16-SpringMVC的请求-获得请求参数-获得集合类型参数2-应用"><a href="#16-SpringMVC的请求-获得请求参数-获得集合类型参数2-应用" class="headerlink" title="16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)"></a>16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)</h3><p>当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;script src=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> userList = <span class="hljs-keyword">new</span> Array();<br>        userList.push(&#123;username:<span class="hljs-string">&quot;zhangsan&quot;</span>,age:<span class="hljs-number">18</span>&#125;);<br>        userList.push(&#123;username:<span class="hljs-string">&quot;lisi&quot;</span>,age:<span class="hljs-number">28</span>&#125;);<br><br>        $.ajax(&#123;<br>            type:<span class="hljs-string">&quot;POST&quot;</span>,<br>            url:<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;</span>,<br>            data:JSON.stringify(userList),<br>            contentType:<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span><br>        &#125;);<br><br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick15&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save15</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(userList);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="17-SpringMVC的请求-获得请求参数-静态资源访问的开启-应用"><a href="#17-SpringMVC的请求-获得请求参数-静态资源访问的开启-应用" class="headerlink" title="17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)"></a>17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)</h3><p>当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：</p><p>•在spring-mvc.xml配置文件中指定放行的资源</p><p>​     <code>&lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; </code></p><p>•使用<code>&lt;mvc:default-servlet-handler/&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开发资源的访问--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;</span><br><span class="hljs-comment">    &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器-应用"><a href="#18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器-应用" class="headerlink" title="18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)"></a>18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)</h3><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置全局过滤的filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="19-SpringMVC的请求-获得请求参数-参数绑定注解-RequestParam-应用"><a href="#19-SpringMVC的请求-获得请求参数-参数绑定注解-RequestParam-应用" class="headerlink" title="19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)"></a>19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)</h3><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/quick16&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick16&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save16</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;)</span> String username)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取-应用"><a href="#20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取-应用" class="headerlink" title="20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)"></a>20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)</h3><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p><p>GET：用于获取资源</p><p>POST：用于新建资源</p><p>PUT：用于更新资源</p><p>DELETE：用于删除资源  </p><p>例如：</p><p>/user/1    GET ：       得到 id = 1 的 user</p><p>/user/1   DELETE：  删除 id = 1 的 user</p><p>/user/1    PUT：       更新 id = 1 的 user</p><p>/user       POST：      新增 user</p><p>上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。</p><p><code>http://localhost:8080/itheima_springmvc1/quick17/zhangsan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick17/&#123;name&#125;&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save17</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value=&quot;name&quot;)</span> String username)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(username);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="21-SpringMVC的请求-获得请求参数-自定义类型转换器-应用"><a href="#21-SpringMVC的请求-获得请求参数-自定义类型转换器-应用" class="headerlink" title="21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)"></a>21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)</h3><p>SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</p><p>但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String dateStr)</span> </span>&#123;<br>        <span class="hljs-comment">//将日期字符串转换成日期对象 返回</span><br>        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        Date date = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            date = format.parse(dateStr);<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> date;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick18&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save18</span><span class="hljs-params">(Date date)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(date);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="22-SpringMVC的请求-获得请求参数-获得Servlet相关API-应用"><a href="#22-SpringMVC的请求-获得请求参数-获得Servlet相关API-应用" class="headerlink" title="22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)"></a>22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)</h3><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p><p>HttpServletRequest</p><p>HttpServletResponse</p><p>HttpSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick19&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save19</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(request);<br>        System.out.println(response);<br>        System.out.println(session);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="23-SpringMVC的请求-获得请求参数-获得请求头信息-应用"><a href="#23-SpringMVC的请求-获得请求参数-获得请求头信息-应用" class="headerlink" title="23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)"></a>23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)</h3><p>使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)</p><p>@RequestHeader注解的属性如下：</p><p>value：请求头的名称</p><p>required：是否必须携带此请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick20&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save20</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(value = &quot;User-Agent&quot;,required = false)</span> String user_agent)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(user_agent);<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用@CookieValue可以获得指定Cookie的值</p><p>@CookieValue注解的属性如下：</p><p>value：指定cookie的名称</p><p>required：是否必须携带此cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/quick21&quot;)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save21</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;JSESSIONID&quot;)</span> String jsessionId)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       System.out.println(jsessionId);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-XML-配置-AOP-详解"><a href="#2-2-XML-配置-AOP-详解" class="headerlink" title="2.2 XML 配置 AOP 详解"></a>2.2 XML 配置 AOP 详解</h4><h5 id="1-切点表达式的写法"><a href="#1-切点表达式的写法" class="headerlink" title="1) 切点表达式的写法"></a>1) 切点表达式的写法</h5><p>表达式语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution([修饰符] 返回值类型 包名.类名.方法名(参数))<br></code></pre></td></tr></table></figure><ul><li><p>访问修饰符可以省略</p></li><li><p>返回值类型、包名、类名、方法名可以使用星号*  代表任意</p></li><li><p>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</p></li><li><p>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p></li></ul><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">execution(public void com.itheima.aop.Target.method())<br>execution(void com.itheima.aop.Target.*(..))<br>execution(* com.itheima.aop.*.*(..))<br>execution(* com.itheima.aop..*.*(..))<br>execution(* *..*.*(..))<br></code></pre></td></tr></table></figure><h5 id="2-通知的类型"><a href="#2-通知的类型" class="headerlink" title="2) 通知的类型"></a>2) 通知的类型</h5><p>通知的配置语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt;<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/spring04.jpg"></p><h5 id="3-切点表达式的抽取"><a href="#3-切点表达式的抽取" class="headerlink" title="3) 切点表达式的抽取"></a>3) 切点表达式的抽取</h5><p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myAspect&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myPointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.itheima.aop.*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:before</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-知识要点"><a href="#2-3-知识要点" class="headerlink" title="2.3 知识要点"></a>2.3 知识要点</h4><ul><li>aop织入的配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">“切面类”</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">“通知方法名称”</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">“切点表达式</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:before</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知</li><li>切点表达式的写法：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">execution([修饰符] 返回值类型 包名.类名.方法名(参数))<br></code></pre></td></tr></table></figure><h3 id="3-基于注解的-AOP-开发"><a href="#3-基于注解的-AOP-开发" class="headerlink" title="3.基于注解的 AOP 开发"></a>3.基于注解的 AOP 开发</h3><h4 id="3-1-快速入门"><a href="#3-1-快速入门" class="headerlink" title="3.1 快速入门"></a>3.1 快速入门</h4><p>基于注解的aop开发步骤：</p><p>①创建目标接口和目标类（内部有切点）</p><p>②创建切面类（内部有增强方法）</p><p>③将目标类和切面类的对象创建权交给 spring</p><p>④在切面类中使用注解配置织入关系</p><p>⑤在配置文件中开启组件扫描和 AOP 的自动代理</p><p>⑥测试</p><p>①创建目标接口和目标类（内部有切点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TargetInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Target running....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②创建切面类（内部有增强方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">//前置增强方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置代码增强.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③将目标类和切面类的对象创建权交给 spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;target&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Target running....&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component(&quot;myAspect&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置代码增强.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>④在切面类中使用注解配置织入关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;myAspect&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置代码增强.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⑤在配置文件中开启组件扫描和 AOP 的自动代理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--组件扫描--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.itheima.aop&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--aop的自动代理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>⑥测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TargetInterface target;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        target.method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⑦测试结果</p><p><img src="/img/cphoto/spring04.jpg"></p><h4 id="3-2-注解配置-AOP-详解"><a href="#3-2-注解配置-AOP-详解" class="headerlink" title="3.2 注解配置 AOP 详解"></a>3.2 注解配置 AOP 详解</h4><h5 id="1-注解通知的类型"><a href="#1-注解通知的类型" class="headerlink" title="1) 注解通知的类型"></a>1) 注解通知的类型</h5><p>通知的配置语法：@通知注解(“切点表达式”)</p><p><img src="/img/cphoto/spring05.jpg"></p><h5 id="2-切点表达式的抽取"><a href="#2-切点表达式的抽取" class="headerlink" title="2) 切点表达式的抽取"></a>2) 切点表达式的抽取</h5><p>同 xml配置<br>aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">@<span class="hljs-meta">@Component(&quot;myAspect&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Before(&quot;MyAspect.myPoint()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置代码增强.....&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPoint</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-知识要点"><a href="#3-3-知识要点" class="headerlink" title="3.3 知识要点"></a>3.3 知识要点</h4><ul><li>注解aop开发步骤</li></ul><p>①使用@Aspect标注切面类</p><p>②使用@通知注解标注通知方法</p><p>③在配置文件中配置aop自动代理<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></p><ul><li>通知注解类型</li></ul><p><img src="/img/cphoto/spring06.jpg"></p><h1 id="JdbcTemplate基本使用"><a href="#JdbcTemplate基本使用" class="headerlink" title="JdbcTemplate基本使用"></a>JdbcTemplate基本使用</h1><h2 id="01-JdbcTemplate基本使用-概述-了解"><a href="#01-JdbcTemplate基本使用-概述-了解" class="headerlink" title="01-JdbcTemplate基本使用-概述(了解)"></a>01-JdbcTemplate基本使用-概述(了解)</h2><p>JdbcTemplate是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。</p><h2 id="02-JdbcTemplate基本使用-开发步骤-理解"><a href="#02-JdbcTemplate基本使用-开发步骤-理解" class="headerlink" title="02-JdbcTemplate基本使用-开发步骤(理解)"></a>02-JdbcTemplate基本使用-开发步骤(理解)</h2><p>①导入spring-jdbc和spring-tx坐标</p><p>②创建数据库表和实体</p><p>③创建JdbcTemplate对象</p><p>④执行数据库操作</p><h2 id="03-JdbcTemplate基本使用-快速入门代码实现-应用"><a href="#03-JdbcTemplate基本使用-快速入门代码实现-应用" class="headerlink" title="03-JdbcTemplate基本使用-快速入门代码实现(应用)"></a>03-JdbcTemplate基本使用-快速入门代码实现(应用)</h2><p>导入spring-jdbc和spring-tx坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itheima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itheima_spring_jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>itheima_spring_jdbc Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>创建数据库表和实体</p><p><img src="/img/cphoto/spring07.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.domain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String getNa <span class="hljs-title">me</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(<span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Account&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, money=&quot;</span> + money +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建JdbcTemplate对象</p><p>执行数据库操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-comment">//测试JdbcTemplate开发步骤</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> PropertyVetoException </span>&#123;<br>        <span class="hljs-comment">//创建数据源对象</span><br>        ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>        dataSource.setDriverClass(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        dataSource.setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);<br>        dataSource.setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        dataSource.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate();<br>        <span class="hljs-comment">//设置数据源对象  知道数据库在哪</span><br>        jdbcTemplate.setDataSource(dataSource);<br>        <span class="hljs-comment">//执行操作</span><br>        <span class="hljs-keyword">int</span> row = jdbcTemplate.update(<span class="hljs-string">&quot;insert into account values(?,?)&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">5000</span>);<br>        System.out.println(row);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="04-JdbcTemplate基本使用-spring产生模板对象分析-理解"><a href="#04-JdbcTemplate基本使用-spring产生模板对象分析-理解" class="headerlink" title="04-JdbcTemplate基本使用-spring产生模板对象分析(理解)"></a>04-JdbcTemplate基本使用-spring产生模板对象分析(理解)</h2><p>我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。</p><h2 id="05-JdbcTemplate基本使用-spring产生模板对象代码实现-应用"><a href="#05-JdbcTemplate基本使用-spring产生模板对象代码实现-应用" class="headerlink" title="05-JdbcTemplate基本使用-spring产生模板对象代码实现(应用)"></a>05-JdbcTemplate基本使用-spring产生模板对象代码实现(应用)</h2><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--数据源对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--jdbc模板对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-comment">//测试Spring产生jdbcTemplate对象</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> PropertyVetoException </span>&#123;<br>       ApplicationContext app = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>       JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);<br>       <span class="hljs-keyword">int</span> row = jdbcTemplate.update(<span class="hljs-string">&quot;insert into account values(?,?)&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">5000</span>);<br>       System.out.println(row);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="06-JdbcTemplate基本使用-spring产生模板对象代码实现（抽取jdbc-properties）-应用"><a href="#06-JdbcTemplate基本使用-spring产生模板对象代码实现（抽取jdbc-properties）-应用" class="headerlink" title="06-JdbcTemplate基本使用-spring产生模板对象代码实现（抽取jdbc.properties）(应用)"></a>06-JdbcTemplate基本使用-spring产生模板对象代码实现（抽取jdbc.properties）(应用)</h2><p>将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>配置文件修改为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--加载jdbc.properties--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--数据源对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--jdbc模板对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="07-JdbcTemplate基本使用-常用操作-更新操作-应用"><a href="#07-JdbcTemplate基本使用-常用操作-更新操作-应用" class="headerlink" title="07-JdbcTemplate基本使用-常用操作-更新操作(应用)"></a>07-JdbcTemplate基本使用-常用操作-更新操作(应用)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> com.itheima.domain.Account;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateCRUDTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <br><span class="hljs-comment">//修改更新</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;update account set money=? where name=?&quot;</span>,<span class="hljs-number">10000</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//删除</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span></span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;delete from account where name=?&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="08-JdbcTemplate基本使用-常用操作-查询操作-应用"><a href="#08-JdbcTemplate基本使用-常用操作-查询操作-应用" class="headerlink" title="08-JdbcTemplate基本使用-常用操作-查询操作(应用)"></a>08-JdbcTemplate基本使用-常用操作-查询操作(应用)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> com.itheima.domain.Account;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateCRUDTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <br><span class="hljs-comment">//聚合查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQueryCount</span><span class="hljs-params">()</span></span>&#123;<br>        Long count = jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select count(*) from account&quot;</span>, Long.class);<br>        System.out.println(count);<br>    &#125;<br><span class="hljs-comment">//查询一个</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQueryOne</span><span class="hljs-params">()</span></span>&#123;<br>        Account account = jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from account where name=?&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class), <span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(account);<br>    &#125;<br><span class="hljs-comment">//查询所有</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQueryAll</span><span class="hljs-params">()</span></span>&#123;<br>        List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="hljs-string">&quot;select * from account&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class));<br>        System.out.println(accountList);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="09-JdbcTemplate基本使用-知识要点-理解，记忆"><a href="#09-JdbcTemplate基本使用-知识要点-理解，记忆" class="headerlink" title="09-JdbcTemplate基本使用-知识要点(理解，记忆)"></a>09-JdbcTemplate基本使用-知识要点(理解，记忆)</h2><p>①导入spring-jdbc和spring-tx坐标</p><p>②创建数据库表和实体</p><p>③创建JdbcTemplate对象</p><pre><code>        JdbcTemplate jdbcTemplate = newJdbcTemplate();              jdbcTemplate.setDataSource(dataSource);</code></pre><p>④执行数据库操作</p><pre><code>更新操作：    jdbcTemplate.update (sql,params)查询操作：    jdbcTemplate.query (sql,Mapper,params)jdbcTemplate.queryForObject(sql,Mapper,params)</code></pre><h1 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h1><h2 id="1-编程式事务控制相关对象"><a href="#1-编程式事务控制相关对象" class="headerlink" title="1. 编程式事务控制相关对象"></a>1. 编程式事务控制相关对象</h2><h3 id="1-1-PlatformTransactionManager"><a href="#1-1-PlatformTransactionManager" class="headerlink" title="1.1 PlatformTransactionManager"></a>1.1 PlatformTransactionManager</h3><p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p><p><img src="/img/cphoto/spring08.jpg"></p><p>注意：</p><p>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager </p><p>Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager</p><h3 id="1-2-TransactionDefinition"><a href="#1-2-TransactionDefinition" class="headerlink" title="1.2 TransactionDefinition"></a>1.2 TransactionDefinition</h3><p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：</p><p><img src="/img/cphoto/spring09.jpg"></p><h4 id="1-事务隔离级别"><a href="#1-事务隔离级别" class="headerlink" title="1. 事务隔离级别"></a>1. 事务隔离级别</h4><p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p><ul><li><p>ISOLATION_DEFAULT</p></li><li><p>ISOLATION_READ_UNCOMMITTED</p></li><li><p>ISOLATION_READ_COMMITTED</p></li><li><p>ISOLATION_REPEATABLE_READ</p></li><li><p>ISOLATION_SERIALIZABLE</p></li></ul><h4 id="2-事务传播行为"><a href="#2-事务传播行为" class="headerlink" title="2. 事务传播行为"></a>2. 事务传播行为</h4><ul><li><p><strong>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</strong></p></li><li><p><strong>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</strong></p></li><li><p>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</p></li><li><p>REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</p></li><li><p>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p></li><li><p>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</p></li><li><p>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</p></li><li><p>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</p></li><li><p>是否只读：建议查询时设置为只读</p></li></ul><h3 id="1-3-TransactionStatus"><a href="#1-3-TransactionStatus" class="headerlink" title="1.3 TransactionStatus"></a>1.3 TransactionStatus</h3><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p><p><img src="/img/cphoto/spring10.jpg"></p><h3 id="1-4-知识要点"><a href="#1-4-知识要点" class="headerlink" title="1.4 知识要点"></a>1.4 知识要点</h3><p>编程式事务控制三大对象</p><ul><li><p>PlatformTransactionManager</p></li><li><p>TransactionDefinition</p></li><li><p>TransactionStatus</p></li></ul><h2 id="2-基于-XML-的声明式事务控制"><a href="#2-基于-XML-的声明式事务控制" class="headerlink" title="2 基于 XML 的声明式事务控制"></a>2 基于 XML 的声明式事务控制</h2><h3 id="2-1-什么是声明式事务控制"><a href="#2-1-什么是声明式事务控制" class="headerlink" title="2.1 什么是声明式事务控制"></a>2.1 什么是声明式事务控制</h3><p>Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p><p><strong>声明式事务处理的作用</strong></p><ul><li><p>事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</p></li><li><p>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p></li></ul><p><strong>注意：Spring 声明式事务控制底层就是AOP。</strong></p><h3 id="2-2-声明式事务控制的实现"><a href="#2-2-声明式事务控制的实现" class="headerlink" title="2.2 声明式事务控制的实现"></a>2.2 声明式事务控制的实现</h3><p>声明式事务控制明确事项：</p><ul><li><p>谁是切点？</p></li><li><p>谁是通知？</p></li><li><p>配置切面？</p></li></ul><p>①引入tx命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/tx </span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>②配置事务增强</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--平台事务管理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--事务增强配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><p>③配置事务 AOP 织入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--事务的aop增强--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myPointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>④测试事务控制转账业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(String outMan, String inMan, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>    accountDao.out(outMan,money);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    accountDao.in(inMan,money);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-切点方法的事务参数的配置"><a href="#2-3-切点方法的事务参数的配置" class="headerlink" title="2.3 切点方法的事务参数的配置"></a>2.3 切点方法的事务参数的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--事务增强配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<a href="tx:method">tx:method</a> 代表切点方法的事务参数的配置，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transfer&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;REPEATABLE_READ&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;-1&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>name：切点方法名称</p></li><li><p>isolation:事务的隔离级别</p></li><li><p>propogation：事务的传播行为</p></li><li><p>timeout：超时时间</p></li><li><p>read-only：是否只读</p></li></ul><h3 id="2-4-知识要点"><a href="#2-4-知识要点" class="headerlink" title="2.4 知识要点"></a>2.4 知识要点</h3><p><strong>声明式事务控制的配置要点</strong></p><ul><li><p>平台事务管理器配置</p></li><li><p>事务通知的配置</p></li><li><p>事务aop织入的配置</p></li></ul><h2 id="3-基于注解的声明式事务控制"><a href="#3-基于注解的声明式事务控制" class="headerlink" title="3 基于注解的声明式事务控制"></a>3 基于注解的声明式事务控制</h2><h3 id="3-1-使用注解配置声明式事务控制"><a href="#3-1-使用注解配置声明式事务控制" class="headerlink" title="3.1 使用注解配置声明式事务控制"></a>3.1 使用注解配置声明式事务控制</h3><ol><li>编写 AccoutDao</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository(&quot;accountDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountDao</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">(String outMan, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;update account set money=money-? where name=?&quot;</span>,money,outMan);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(String inMan, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;update account set money=money+? where name=?&quot;</span>,money,inMan);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>编写 AccoutService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;accountService&quot;)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountDao accountDao;<br>    <span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(String outMan, String inMan, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        accountDao.out(outMan,money);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>        accountDao.in(inMan,money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>编写 applicationContext.xml 配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;<br><span class="hljs-comment">&lt;!--组件扫描--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.itheima&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--事务的注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-注解配置声明式事务控制解析"><a href="#3-2-注解配置声明式事务控制解析" class="headerlink" title="3.2 注解配置声明式事务控制解析"></a>3.2 注解配置声明式事务控制解析</h3><p>①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</p><p>②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p><p>③使用在方法上，不同的方法可以采用不同的事务参数配置。</p><p>④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt;</p><h3 id="3-3-知识要点-1"><a href="#3-3-知识要点-1" class="headerlink" title="3.3 知识要点"></a>3.3 知识要点</h3><p><strong>注解声明式事务控制的配置要点</strong></p><ul><li><p>平台事务管理器配置（xml方式）</p></li><li><p>事务通知的配置（@Transactional注解配置）</p></li><li><p>事务注解驱动的配置 <a href="tx:annotation-driven/">tx:annotation-driven/</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2017/10/06/Nginx/"/>
    <url>/2017/10/06/Nginx/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、正向代理(Forward Proxy)</p><p>一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下： 正 向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代 理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。如下图1.1</p><p><img src="/img/cphoto/nginx04.jpg" alt="图1.1"><br>从上面的概念中，我们看出，文中所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】<br>这就是正向代理的意义所在。而为什么要用代理服务器去代替访问方【用户A】去访问服务器B呢？这就要从代理服务器使用的意义说起。</p><p>使用正向代理服务器作用主要有以下几点：<br>1、访问本无法访问的服务器B，如下图1.2</p><p><img src="/img/cphoto/nginx05.jpg" alt="图1.2"></p><p>  我们抛除复杂的网络路由情节来看图1.2，假设图中路由器从左到右命名为R1,R2假 设最初用户A要访问服务器B需要经过R1和R2路由器这样一个路由节点，如果路由器R1或者路由器R2发生故障，那么就无法访问服务器B了。但是如果用户 A让代理服务器Z去代替自己访问服务器B，由于代理服务器Z没有在路由器R1或R2节点中，而是通过其它的路由节点访问服务器B，那么用户A就可以得到服 务器B的数据了。现实中的例子就是“翻墙”。不过自从VPN技术被广泛应用外，“翻墙”不但使用了传统的正向代理技术，有的还使用了VPN技术。</p><p>2、加速访问服务器B</p><p>这种说法目前不像以前那么流行了，主要是带宽流量的飞速发展。早期的正向代理中，很多人使用正向代理就是提速。还是如图1.2 假设用户A到服务器B，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。而用户A到代理服务器Z，从代理服务器Z到服务器B都是高带宽链路。那么很显然就可以加速访问服务器B了。</p><p>3、Cache作用<br>Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术。还如上图所示，如果在用户A访问服务器B某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。这一技术在Cache中术语就叫Cache命中。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。<br>4、客户端访问授权<br>这方面的内容现今使用的还是比较多的，例如一些公司采用ISA SERVER做为正向代理服务器来授权用户是否有权限访问互联网，挼下图1.3  （图1.3）</p><p><img src="/img/cphoto/nginx05.jpg" alt="图 1.3"></p><p>防火墙作为网关，用来过滤外网对其的访问。假设用户A和用户B都设置了代理服务器，用户A允许访问互联网，而用户B不允许访问互联网（这个在代理服 务器Z上做限制）这样用户A因为授权，可以通过代理服务器访问到服务器B，而用户B因为没有被代理服务器Z授权，所以访问服务器B时，数据包会被直接丢 弃。</p><p>5、隐藏访问者的行踪</p><p>如下图1.4 我们可以看出服务器B并不知道访问自己的实际是用户A，因为代理服务器Z代替用户A去直接与服务器B进行交互。如果代理服务器Z被用户A完全控制（或不完全控制），会惯以“肉鸡”术语称呼。<br> （图1.4） 我 们总结一下 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内 容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p><p>二、反向代理（reverse proxy）<br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 使用反向代理服务器的作用如下：<br>1、保护和隐藏原始资源服务器如下图2.1 </p><p><img src="/img/cphoto/nginx05.jpg" alt="图2.1"></p><p>用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。</p><p>2、负载均衡如下图2.2 </p><p><img src="/img/cphoto/nginx08.jpg" alt="图2.2"></p><p>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。<br>当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。如下图2.3</p><p><img src="/img/cphoto/nginx09.jpg" alt="图2.3"></p><p>（图2.3）<br>我们并不是讲解CDN，所以去掉了CDN最关键的核心技术智能DNS。只是展示CDN技术实际上利用的正是反向代理原理这块。</p><p>反向代理结论与正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p><p>基本上，网上做正反向代理的程序很多，能做正向代理的软件大部分也可以做反向代理。开源软件中最流行的就是squid，既可以做正向代理，也有很多人用来做反向代理的前端服务器。另外MS ISA也可以用来在WINDOWS平台下做正向代理。反向代理中最主要的实践就是WEB服务，近些年来最火的就是Nginx了。网上有人说NGINX不能做正向代理，其实是不对的。NGINX也可以做正向代理，不过用的人比较少了。</p><p>三、透明代理</p><p>   如果把正向代理、反向代理和透明代理按照人类血缘关系来划分的话。那么正向代理和透明代理是很明显堂亲关系，而正向代理和反向代理就是表亲关系了 。<br>   透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。 透明代理实践的例子就是时下很多公司使用的行为管理软件。如下图3.1</p><p><img src="/img/cphoto/nginx10.jpg" alt="图3.1"></p><p> （图3.1）<br>用户A和用户B并不知道行为管理设备充当透明代理行为，当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。        </p><h4 id="为什么使用Nginx"><a href="#为什么使用Nginx" class="headerlink" title="为什么使用Nginx:"></a>为什么使用Nginx:</h4><p>背景:</p><p>互联网飞速发展的今天,大用户量高并发已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢？这是一些中小网站急需解决的问题。用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的，为了解决这个问题引入了负载均衡方法。负载均衡就是一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。</p><p>负载均衡服务器分为两种一种是通过硬件实现的负载均衡服务器，简称硬负载例如：f5。另一种是通过软件来实现的负载均衡，简称软负载:例如apache和nginx。硬负载和软负载相比前者作用的网络层次比较多可以作用到socket接口的数据链路层对发出的请求进行分组转发但是价格成本比较贵，而软负载作用的层次在http协议层之上可以对http请求进行分组转发并且因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。</p><h3 id="使用Nginx完成负载均衡"><a href="#使用Nginx完成负载均衡" class="headerlink" title="使用Nginx完成负载均衡:"></a>使用Nginx完成负载均衡:</h3><p>完成Nginx负载均衡,那么需要先来介绍Tomcat的安装和配置,我们首先要来配置Tomcat完成集群的配置.因为我们没有多台服务器运行Tomcat.那么我们可以模拟在一台服务器上运行多个Tomcat程序.</p><h4 id="使用Tomcat配置Tomcat集群"><a href="#使用Tomcat配置Tomcat集群" class="headerlink" title="使用Tomcat配置Tomcat集群:"></a>使用Tomcat配置Tomcat集群:</h4><p>步骤一:下载Tomcat:</p><p><a href="http://tomcat.apache.org/download-70.cgi">http://tomcat.apache.org/download-70.cgi</a></p><p>步骤二:安装和配置Tomcat:</p><p>直接将下载后的Tomcat解压在本地磁盘:解压两个分别命名为tomcat1和tomcat2.</p><p>分别完成如下配置:(需要将tomcat带有端口号的地方改成不同的端口即可.)分别打开两个tomcat的conf下的server.xml</p><p><strong>tomcat1/conf/server.xml</strong></p><p><img src="/img/cphoto/nginx11.jpg"></p><p><strong>tomcat2/conf/server.xml</strong></p><p><img src="/img/cphoto/nginx12.jpg"> </p><h3 id="1-1-1-Nginx的安装和部署"><a href="#1-1-1-Nginx的安装和部署" class="headerlink" title="1.1.1  Nginx的安装和部署:"></a>1.1.1  Nginx的安装和部署:</h3><h4 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装:"></a>Nginx的安装:</h4><p>将nginx-1.8.0.zip解压包某个盘符下运行</p><p>双击nginx.exe即可运行:打开浏览器<a href="http://localhost/">http://localhost:80</a></p><p>说明安装成功!!!</p><p>关闭nginx需要使用:</p><p>相当于找到nginx进程kill。</p><p>nginx -s stop</p><p>重新加载配置文件:</p><p>nginx -s reload</p><p>可以不关闭nginx的情况下更新配置文件.</p><h4 id="Nginx的负载均衡的配置"><a href="#Nginx的负载均衡的配置" class="headerlink" title="Nginx的负载均衡的配置:"></a>Nginx的负载均衡的配置:</h4><p>打开C:\nginx-1.8.0\conf\nginx.conf这个文件:</p><p><img src="/img/cphoto/nginx13.jpg"></p><p>***** 通过以上的配置我们已经可以通过访问<a href="http://www.taoge.com访问到不同的tomcat来分担服务器端的压力.**请求负载过程中会话信息不能丢失.****那么需要在多个tomcat****中session****需要共享/">www.taoge.com访问到不同的tomcat来分担服务器端的压力.**请求负载过程中会话信息不能丢失.****那么需要在多个tomcat****中session****需要共享</a>.**</p><p>***** <strong>配置Tomcat<strong><strong>的session</strong></strong>共享可以有三种解决方案:</strong></p><p>第一种是以负载均衡服务器本身提供的session共享策略，每种服务期的配置是不一样的并且nginx本身是没有的。</p><p>第二种是利用web容器本身的session共享策略来配置共享。针对于weblogic这种方式还是靠普的。但是针对于tomcat这种方式存在很大的缺陷，主要因为是依靠广播方式来实现的session复制，会浪费很多带宽导致整个网络反映缓慢。官网也建议这种方式最好不要超过4台tomcat,具体的内容可参考/webapps/docs/cluster-howto.html里面有详细的说明。下面是具体的配置过程</p><p>第三种是Tomcat集群+redis的Session共享配置方法.</p><p>在这里我们以第二种方式为例:</p><h4 id="配置Tomcat中session的共享"><a href="#配置Tomcat中session的共享" class="headerlink" title="配置Tomcat中session的共享:"></a>配置Tomcat中session的共享:</h4><p>*<em>步骤一:<strong><strong>修改server.xml</strong></strong>文件，最简单的集群配置只需要将节点中注释掉的下面这句取消注释即可：</em>*</p><p>Xml代码：</p>  <Cluster classname="org.apache.catalina.ha.tcp.SimpleTcpCluster"> <p>使用这样方法配置的集群会将Session同步到所在网段上的所有配置了集群属性的实例上(此处讲所在网段可能不准确，是使用Membership 的address和port来区分的。tomcat集群的实例如果在Membership配置中有相同的address和port值的tomcat被分到同一个集群里边。他们的session是相互共享的，同一个session的集群被称为一个cluster。可以配置多个cluster，但是cluster和cluster之间的session是不共享的)。也就是说如果该广播地址下的所有Tomcat实例都会共享Session，那么假如有几个互不相关的集群，就可能造成Session复制浪费，所以为了避免浪费就需要对节点多做点设置了，如下：</p><p>Xml代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">Cluster</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;</span>&gt;</span>  <br><br>​    <span class="hljs-tag">&lt;<span class="hljs-name">Channel</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.tribes.group.GroupChannel&quot;</span>&gt;</span>  <br><br>​      <span class="hljs-tag">&lt;<span class="hljs-name">Membership</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.tribes.membership.McastService&quot;</span>  </span><br><span class="hljs-tag"></span><br><span class="hljs-tag">​        <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;228.0.0.4&quot;</span>  </span><br><span class="hljs-tag"></span><br><span class="hljs-tag">​        <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;45564&quot;</span>  </span><br><span class="hljs-tag"></span><br><span class="hljs-tag">​        <span class="hljs-attr">frequency</span>=<span class="hljs-string">&quot;500&quot;</span>  </span><br><span class="hljs-tag"></span><br><span class="hljs-tag">​        <span class="hljs-attr">dropTime</span>=<span class="hljs-string">&quot;3000&quot;</span>/&gt;</span>  <br><br>​    <span class="hljs-tag">&lt;/<span class="hljs-name">Channel</span>&gt;</span>  <br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Cluster</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>加了一个Channel，里面包了个Membership，咱们要关注的就是membership的port属性和address属性，不同的集群设置不同的port值或address值，从目前的使用来看，基本上是隔离开了。</p><p>*<em>步骤二:<strong><strong>修改项目的web.xml</strong></strong>文件：</em>*</p><p>web.xml文件的修改很简单：只需要在节点中添加这个节点<distributable>就可以了。</distributable></p><p>OK，有了这二步就实现了Tomcat的集群和Session的共享了。</p></Cluster>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim命令</title>
    <link href="/2017/10/04/Vim%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/10/04/Vim%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vim命令合集"><a href="#Vim命令合集" class="headerlink" title="Vim命令合集"></a>Vim命令合集</h1><h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</p><h2 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h2><p>在命令行窗口中输入以下命令即可<br>vim 直接启动vim<br>vim filename 打开vim并创建名为filename的文件</p><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><p>打开单个文件<br>vim file<br>同时打开多个文件<br>vim file1 file2 file3 …<br>在vim窗口中打开一个新文件<br>:open file<br>在新窗口中打开文件<br>:split file<br>切换到下一个文件<br>:bn<br>切换到上一个文件<br>:bp<br>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。<br>:args<br>打开远程文件，比如ftp或者share folder<br>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a><br>:e \qadrive\test\1.txt</p><h2 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h2><p>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i键进入） 左下角显示–INSERT–<br>可视模式（不知道如何进入） 左下角显示–VISUAL–</p><h2 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h2><p>% 括号匹配</p><h2 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h2><p>i 在当前位置生前插入<br>I 在当前行首插入<br>a 在当前位置后插入<br>A 在当前行尾插入<br>o 在当前行之后插入一行<br>O 在当前行之前插入一行</p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>/text　　查找text，按n健查找下一个，按N健查找前一个。<br>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。<br>vim中有一些特殊字符在查找时需要转义　　.<em>[]^%/?~$<br>:set ignorecase　　忽略大小写的查找<br>:set noignorecase　　不忽略大小写的查找<br>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按</em>或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。<br>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。<br>:set nohlsearch　　关闭高亮搜索显示<br>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。<br>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。<br>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>ra 将当前字符替换为a，当期字符即光标所在字符。<br>s/old/new/ 用old替换new，替换当前行的第一个匹配<br>s/old/new/g 用old替换new，替换当前行的所有匹配<br>%s/old/new/ 用old替换new，替换所有行的第一个匹配<br>%s/old/new/g 用old替换new，替换整个文件的所有匹配<br>:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。<br>ddp 交换光标所在行和其下紧邻的一行。</p><h2 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h2><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符<br>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。<br>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以## 代替l命令。<br>b 向后移动一个单词 2b 向后移动2个单词<br>e，同w，只不过是光标停在单词尾部<br>ge，同b，光标停在单词尾部。<br>^ 移动到本行第一个非空白字符上。<br>0（数字0）移动到本行第一个字符上，<br><HOME> 移动到本行第一个字符。同0健。<br>$ 移动到行尾 3$ 移动到下面3行的行尾<br>gg 移动到文件头。 = [[<br>G（shift + g） 移动到文件尾。 = ]]<br>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。<br>F 同f，反向查找。<br>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。<br>Ctrl + e 向下滚动一行<br>Ctrl + y 向上滚动一行<br>Ctrl + d 向下滚动半屏<br>Ctrl + u 向上滚动半屏<br>Ctrl + f 向下滚动一屏<br>Ctrl + b 向上滚动一屏</HOME></Esc></p><h2 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h2><p>u 撤销（Undo）<br>U 撤销对整行的操作<br>Ctrl + r 重做（Redo），即撤销的撤销。</p><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><p>x 删除当前字符<br>3x 删除当前光标开始向后三个字符<br>X 删除当前字符的前一个字符。X=dh<br>dl 删除当前字符， dl=x<br>dh 删除前一个字符<br>dd 删除当前行<br>dj 删除上一行<br>dk 删除下一行<br>10d 删除当前行开始的10行。<br>D 删除当前字符至行尾。D=d$<br>d$ 删除当前字符之后的所有字符（本行）<br>kdgg 删除当前行之前所有行（不包括当前行）<br>jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）<br>:1,10d 删除1-10行<br>:11,$d 删除11行及以后所有的行<br>:1,$d 删除所有行<br>J(shift + j)　　删除两行之间的空行，实际上是合并两行。</p><h2 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h2><p>yy 拷贝当前行<br>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。<br>p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。<br>shift+p 在当前行前粘贴<br>:1,10 co 20 将1-10行插入到第20行之后。<br>:1,$ co $ 将整个文件复制一份并添加到文件尾部。<br>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制<br>ddp交换当前行和其下一行<br>xp交换当前字符和其后一个字符</p><h2 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h2><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切<br>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴<br>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。<br>:1, 10 m 20 将第1-10行移动到第20行之后。</p><h2 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h2><p>:wq 保存并退出<br>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件。</p><h2 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h2><p>:split或new 打开一个新窗口，光标停在顶层的窗口上<br>:split file或:new file 用新窗口打开文件<br>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。<br>Ctrl+ww 移动到下一个窗口<br>Ctrl+wj 移动到下方的窗口<br>Ctrl+wk 移动到上方的窗口</p><h2 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h2><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。<br>:q 如果是最后一个被关闭的窗口，那么将退出vim。<br>ZZ 保存并退出。<br>关闭所有窗口，只保留当前窗口<br>:only</p><h2 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h2><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。<br>执行shell命令<br>:!command<br>:!ls 列出当前目录下文件<br>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。<br>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。<br>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p><h2 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h2><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#<br>3,5 s/^/#/g 注释第3-5行<br>3,5 s/^#//g 解除3-5行的注释<br>1,$ s/^/#/g 注释整个文档。<br>:%s/^/#/g 注释整个文档，此法更快。</p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>:help or F1 显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起<br>:help <Esc> 特殊键的帮助用&lt;&gt;扩起<br>:help -t Vim启动参数的帮助用-<br>：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</Esc></Esc></p><h2 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h2><p>. 重复前一次命令<br>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看<br>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。<br>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。<br>Vim教程<br>在Unix系统上<br>$ vimtutor<br>在Windows系统上<br>:help tutor</p><p>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p><h1 id="vi命令"><a href="#vi命令" class="headerlink" title="vi命令"></a>vi命令</h1><p>vi使用方法详细介绍</p><p>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 </p><h2 id="1、vi的基本概念"><a href="#1、vi的基本概念" class="headerlink" title="1、vi的基本概念"></a>1、vi的基本概念</h2><p>　　基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：<br>    1) 命令行模式command mode）<br>　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>    2) 插入模式（Insert mode）<br>　　只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>    3) 底行模式（last line mode）<br>　　将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 </p><blockquote><p>不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 </p></blockquote><h2 id="2、vi的基本操作"><a href="#2、vi的基本操作" class="headerlink" title="2、vi的基本操作"></a>2、vi的基本操作</h2><p>a) 进入vi<br>   　在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：<br>　　　$ vi myfile<br>　　不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ </p><p>b) 切换至插入模式（Insert mode）编辑文件<br>　　在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 </p><p>c) Insert 的切换<br>　　您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 </p><dl><dt>d) 退出vi及保存文件<br>　　在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如：<br>: w filename （输入 「w filename」将文章以指定的文件名filename保存）<br>: wq (输入「wq」，存盘并退出vi)</dt><dd>q! (输入q!， 不存盘强制退出vi) </dd></dl><h2 id="3、命令行模式（command-mode）功能键"><a href="#3、命令行模式（command-mode）功能键" class="headerlink" title="3、命令行模式（command mode）功能键"></a>3、命令行模式（command mode）功能键</h2><p>1）. 插入模式<br>       按「i」切换进入插入模式「insert mode」，按”i”进入插入模式后是从光标当前位置开始输入文件；<br>　　按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；<br>　　按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 </p><p>2）. 从插入模式切换为命令行模式<br>      按「ESC」键。 </p><p>3）. 移动光标<br>　　vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。<br>　　按「ctrl」+「b」：屏幕往”后”移动一页。<br>　　按「ctrl」+「f」：屏幕往”前”移动一页。<br>　　按「ctrl」+「u」：屏幕往”后”移动半页。<br>　　按「ctrl」+「d」：屏幕往”前”移动半页。<br>　　按数字「0」：移到文章的开头。<br>　　按「G」：移动到文章的最后。<br>　　按「$」：移动到光标所在行的”行尾”。<br>　　按「^」：移动到光标所在行的”行首”<br>　　按「w」：光标跳到下个字的开头<br>　　按「e」：光标跳到下个字的字尾<br>　　按「b」：光标回到上个字的开头<br>　　按「#l」：光标移到该行的第#个位置，如：5l,56l。 </p><p>4）. 删除文字<br>　　「x」：每按一次，删除光标所在位置的”后面”一个字符。<br>　　「#x」：例如，「6x」表示删除光标所在位置的”后面”6个字符。<br>　　「X」：大写的X，每按一次，删除光标所在位置的”前面”一个字符。<br>　　「#X」：例如，「20X」表示删除光标所在位置的”前面”20个字符。<br>　　「dd」：删除光标所在行。<br>　　「#dd」：从光标所在行开始删除#行 </p><p>5）. 复制<br>　　「yw」：将光标所在之处到字尾的字符复制到缓冲区中。<br>　　「#yw」：复制#个字到缓冲区<br>　　「yy」：复制光标所在行到缓冲区。<br>　　「#yy」：例如，「6yy」表示拷贝从光标所在的该行”往下数”6行文字。<br>　　「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能。 </p><p>6）. 替换<br>　　「r」：替换光标所在处的字符。<br>　　「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 </p><p>7）. 回复上一次操作<br>　　「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次”u”可以执行多次回复。 </p><p>8）. 更改<br>　　「cw」：更改光标所在处的字到字尾处<br>　　「c#w」：例如，「c3w」表示更改3个字 </p><p>9）. 跳至指定的行<br>　　「ctrl」+「g」列出光标所在行的行号。<br>　　「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 </p><h2 id="4、Last-line-mode下命令简介"><a href="#4、Last-line-mode下命令简介" class="headerlink" title="4、Last line mode下命令简介"></a>4、Last line mode下命令简介</h2><p>　　在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 </p><p>A) 列出行号 </p><p>　「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 </p><p>B) 跳到文件中的某一行 </p><p>　「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 </p><p>C) 查找字符 </p><p>　「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 </p><p>　「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 </p><p>D) 保存文件 </p><p>　「w」：在冒号输入字母「w」就可以将文件保存起来。 </p><p>E) 离开vi </p><p>　「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 </p><p>　「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 </p><h2 id="5、vi命令列表"><a href="#5、vi命令列表" class="headerlink" title="5、vi命令列表"></a>5、vi命令列表</h2><p>1、下表列出命令模式下的一些键的功能： </p><p>h<br>左移光标一个字符 </p><p>l<br>右移光标一个字符 </p><p>k<br>光标上移一行 </p><p>j<br>光标下移一行 </p><p>^<br>光标移动至行首 </p><p>0<br>数字”0”，光标移至文章的开头 </p><p>G<br>光标移至文章的最后 </p><p>$<br>光标移动至行尾 </p><p>Ctrl+f<br>向前翻屏 </p><p>Ctrl+b<br>向后翻屏 </p><p>Ctrl+d<br>向前翻半屏 </p><p>Ctrl+u<br>向后翻半屏 </p><p>i<br>在光标位置前插入字符 </p><p>a<br>在光标所在位置的后一个字符开始增加 </p><p>o<br>插入新的一行，从行首开始输入 </p><p>ESC<br>从输入状态退至命令状态 </p><p>x<br>删除光标后面的字符 </p><p>#x<br>删除光标后的＃个字符 </p><p>X<br>(大写X)，删除光标前面的字符 </p><p>#X<br>删除光标前面的#个字符 </p><p>dd<br>删除光标所在的行 </p><p>#dd<br>删除从光标所在行数的#行 </p><p>yw<br>复制光标所在位置的一个字 </p><p>#yw<br>复制光标所在位置的#个字 </p><p>yy<br>复制光标所在位置的一行 </p><p>#yy<br>复制从光标所在行数的#行 </p><p>p<br>粘贴 </p><p>u<br>取消操作 </p><p>cw<br>更改光标所在位置的一个字 </p><p>#cw<br>更改光标所在位置的#个字 </p><p>2、下表列出行命令模式下的一些指令<br>w filename<br>储存正在编辑的文件为filename </p><p>wq filename<br>储存正在编辑的文件为filename，并退出vi </p><p>q!<br>放弃所有修改，退出vi </p><p>set nu<br>显示行号 </p><p>/或?<br>查找，在/后输入要查找的内容 </p><p>n<br>与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。 </p><p>对于第一次用vi，有几点注意要提醒一下：<br>1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。切换方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。<br>2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键。<br>3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的）</p><h2 id="vi使用"><a href="#vi使用" class="headerlink" title="vi使用"></a>vi使用</h2><p>VI是unix上最常用的文本编辑工具，作为unix软件测试人员，有必要熟练掌握它。</p><p>进入vi的命令<br>vi filename :打开或新建文件，并将光标置于第一行首<br>vi +n filename ：打开文件，并将光标置于第n行首<br>vi + filename ：打开文件，并将光标置于最后一行首<br>vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处<br>vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename<br>vi filename….filename ：打开多个文件，依次编辑</p><h2 id="移动光标类命令"><a href="#移动光标类命令" class="headerlink" title="移动光标类命令"></a>移动光标类命令</h2><p>h ：光标左移一个字符<br>l ：光标右移一个字符<br>space：光标右移一个字符<br>Backspace：光标左移一个字符<br>k或Ctrl+p：光标上移一行<br>j或Ctrl+n ：光标下移一行<br>Enter ：光标下移一行<br>w或W ：光标右移一个字至字首<br>b或B ：光标左移一个字至字首<br>e或E ：光标右移一个字j至字尾<br>) ：光标移至句尾<br>( ：光标移至句首<br>}：光标移至段落开头<br>{：光标移至段落结尾<br>nG：光标移至第n行首<br>n+：光标下移n行<br>n-：光标上移n行<br>n$：光标移至第n行尾<br>H ：光标移至屏幕顶行<br>M ：光标移至屏幕中间行<br>L ：光标移至屏幕最后行<br>0：（注意是数字零）光标移至当前行首<br>$：光标移至当前行尾</p><h2 id="屏幕翻滚类命令"><a href="#屏幕翻滚类命令" class="headerlink" title="屏幕翻滚类命令"></a>屏幕翻滚类命令</h2><p>Ctrl+u：向文件首翻半屏<br>Ctrl+d：向文件尾翻半屏<br>Ctrl+f：向文件尾翻一屏<br>Ctrl＋b；向文件首翻一屏<br>nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。</p><h2 id="插入文本类命令"><a href="#插入文本类命令" class="headerlink" title="插入文本类命令"></a>插入文本类命令</h2><p>i ：在光标前<br>I ：在当前行首<br>a：光标后<br>A：在当前行尾<br>o：在当前行之下新开一行<br>O：在当前行之上新开一行<br>r：替换当前字符<br>R：替换当前字符及其后的字符，直至按ESC键<br>s：从当前光标位置处开始，以输入的文本替代指定数目的字符<br>S：删除指定数目的行，并以所输入文本代替之<br>ncw或nCW：修改指定数目的字<br>nCC：修改指定数目的行</p><h2 id="删除命令-1"><a href="#删除命令-1" class="headerlink" title="删除命令"></a>删除命令</h2><p>ndw或ndW：删除光标处开始及其后的n-1个字<br>do：删至行首<br>d$：删至行尾<br>ndd：删除当前行及其后n-1行<br>x或X：删除一个字符，x删除光标后的，而X删除光标前的<br>Ctrl+u：删除输入方式下所输入的文本</p><h2 id="搜索及替换命令"><a href="#搜索及替换命令" class="headerlink" title="搜索及替换命令 :"></a>搜索及替换命令 :</h2><p>/pattern：从光标开始处向文件尾搜索pattern<br>?pattern：从光标开始处向文件首搜索pattern<br>n：在同一方向重复上一次搜索命令<br>N：在反方向上重复上一次搜索命令<br>：s/p1/p2/g：将当前行中所有p1均用p2替代<br>：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代<br>：g/p1/s//p2/g：将文件中所有p1均用p2替换</p><h2 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h2><p>all：列出所有选项设置情况<br>term：设置终端类型<br>ignorance：在搜索中忽略大小写<br>list：显示制表位(Ctrl+I)和行尾标志（$)<br>number：显示行号<br>report：显示由面向行的命令修改过的数目<br>terse：显示简短的警告信息<br>warn：在转到别的文件时若没保存当前文件则显示NO write信息<br>nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符<br>nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始<br>mesg：允许vi显示其他用户用write写到自己终端上的信息</p><h2 id="最后行方式命令"><a href="#最后行方式命令" class="headerlink" title="最后行方式命令"></a>最后行方式命令</h2><p>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下<br>：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下<br>：n1,n2 d ：将n1行到n2行之间的内容删除<br>：w ：保存当前文件<br>：e filename：打开文件filename进行编辑<br>：x：保存当前文件并退出<br>：q：退出vi<br>：q!：不保存文件并退出vi<br>：!command：执行shell命令command<br>：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指<br>定n1，n2，则表示将整个文件内容作为command的输入<br>：r!command：将命令command的输出结果放到当前行 。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2017/10/04/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2017/10/04/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1-1-Linux的概述："><a href="#1-1-Linux的概述：" class="headerlink" title="1.1   Linux的概述："></a>1.1   Linux的概述：</h2><h3 id="1-1-1-什么是Linux："><a href="#1-1-1-什么是Linux：" class="headerlink" title="1.1.1  什么是Linux："></a>1.1.1  什么是Linux：</h3><h4 id="1-1-1-1-学习Linux之前先了解Unix"><a href="#1-1-1-1-学习Linux之前先了解Unix" class="headerlink" title="1.1.1.1 学习Linux之前先了解Unix"></a>1.1.1.1 学习Linux之前先了解Unix</h4><p>Unix是一个强大的多用户、多任务操作系统。</p><p>于1969年在AT&amp;T的贝尔实验室开发。</p><p>UNIX的商标权由国际开放标准组织（The Open Group）所拥有。</p><p>UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。</p><h4 id="1-1-1-2-Linux的概述："><a href="#1-1-1-2-Linux的概述：" class="headerlink" title="1.1.1.2 Linux的概述："></a>1.1.1.2 Linux的概述：</h4><p>Linux是基于Unix的</p><p>Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机</p><p>诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成</p><p>Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统.</p><h4 id="1-1-1-4-Linux系统的应用："><a href="#1-1-1-4-Linux系统的应用：" class="headerlink" title="1.1.1.4 Linux系统的应用："></a>1.1.1.4 Linux系统的应用：</h4><p>服务器系统</p><p>Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； </p><p>嵌入式系统</p><p>路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，</p><p>高性能运算、计算密集型应用</p><p>Linux有强大的运算能力。</p><p>桌面应用系统</p><p>移动手持系统</p><h4 id="1-1-1-5-Linux的版本"><a href="#1-1-1-5-Linux的版本" class="headerlink" title="1.1.1.5 Linux的版本"></a>1.1.1.5 Linux的版本</h4><p><strong>Linux****的版本分为两种：内核版本和发行版本；</strong></p><p>内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；</p><p>发行版本是一些组织和公司根据自己发行版的不同而自定的 ；</p><h2 id="1-2-Linux的安装："><a href="#1-2-Linux的安装：" class="headerlink" title="1.2   Linux的安装："></a>1.2   Linux的安装：</h2><h3 id="1-2-1-虚拟机安装："><a href="#1-2-1-虚拟机安装：" class="headerlink" title="1.2.1  虚拟机安装："></a>1.2.1  虚拟机安装：</h3><h4 id="1-2-1-1-什么是虚拟机"><a href="#1-2-1-1-什么是虚拟机" class="headerlink" title="1.2.1.1 什么是虚拟机"></a>1.2.1.1 什么是虚拟机</h4><p>虚拟机：一台虚拟的电脑.</p><p>虚拟机软件:</p><p>* VmWare    :收费的.</p><p>* VirtualBox  :免费的.</p><h3 id="1-2-3-Linux的目录结构："><a href="#1-2-3-Linux的目录结构：" class="headerlink" title="1.2.3  Linux的目录结构："></a>1.2.3  Linux的目录结构：</h3><p><img src="/img/cphoto/linux01.jpg"></p><p>root管理员的home目录root</p><p>其他用户的home目录home目录中</p><h2 id="1-3-Linux的常用命令"><a href="#1-3-Linux的常用命令" class="headerlink" title="1.3   Linux的常用命令"></a>1.3   Linux的常用命令</h2><h3 id="1-3-1-切换目录命令cd："><a href="#1-3-1-切换目录命令cd：" class="headerlink" title="1.3.1  切换目录命令cd："></a>1.3.1  切换目录命令cd：</h3><p>使用</p><p>cd app 切换到app目录</p><p>cd ..  切换到上一层目录</p><p>cd /   切换到系统根目录</p><p>cd ~   切换到用户主目录</p><p>cd -   切换到上一个所在目录</p><h3 id="1-3-2-列出文件列表：ls-ll-dir"><a href="#1-3-2-列出文件列表：ls-ll-dir" class="headerlink" title="1.3.2  列出文件列表：ls ll dir(*****)"></a>1.3.2  列出文件列表：ls ll dir(*****)</h3><p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。</p><p>  格式：ls[参数] [路径或文件名]</p><p>常用：</p><p>在linux中以 . 开头的文件都是隐藏的文件</p><p>* ls</p><p>* ls -a 显示所有文件或目录（包含隐藏的文件）</p><p>* ls -l 缩写成ll</p><h3 id="1-3-3-创建目录和移除目录：mkdir-rmdir"><a href="#1-3-3-创建目录和移除目录：mkdir-rmdir" class="headerlink" title="1.3.3  创建目录和移除目录：mkdir rmdir"></a>1.3.3  创建目录和移除目录：mkdir rmdir</h3><p>mkdir(make directory)命令可用来创建子目录。</p><p>mkdir app  在当前目录下创建app目录</p><p>mkdir –p app2/test  级联创建aap2以及test目</p><p>rmdir(remove directory)命令可用来删除“空”的子目录：</p><p>rmdir app  删除app目录</p><h3 id="1-3-4-浏览文件"><a href="#1-3-4-浏览文件" class="headerlink" title="1.3.4  浏览文件"></a>1.3.4  浏览文件</h3><p>【cat、more、less】</p><p>cat</p><p>用于显示文件的内容。</p><p>格式：cat[参数]&lt;文件名&gt;</p><p>  * cat yum.conf</p><p>more</p><p>一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。</p><p>回车显示下一行内容。</p><p>按 q 键退出查看。</p><p>* more yum.conf</p><p>  * 空格显示下一页数据 回车显示下一行的数据</p><p>less</p><p>用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。</p><p>  * less yum.conf</p><p>​    * PgUp 和 PgDn 进行上下翻页.</p><p>【tail】</p><p>tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。</p><p>用法:</p><p>tail -10 /etc/passwd  查看后10行数据</p><p>tail -f catalina.log  动态查看日志(*****)</p><p>ctrl+c 结束查看</p><h3 id="1-3-5-文件操作："><a href="#1-3-5-文件操作：" class="headerlink" title="1.3.5  文件操作："></a>1.3.5  文件操作：</h3><p>【rm】</p><p>rm 删除文件</p><p>用法：rm [选项]… 文件…</p><p>rm a.txt  删除a.txt文件</p><p>删除需要用户确认，y/n</p><p>rm 删除不询问</p><p>rm -f a.txt  不询问，直接删除</p><p>rm 删除目录</p><p>rm -r a  递归删除</p><p>不询问递归删除（慎用）</p><p>rm -rf a  不询问递归删除</p><p>rm -rf *    删除所有文件</p><p>rm -rf /*    自杀</p><p>【cp、mv】</p><p>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p><p>cp a.txt b.txt  将a.txt复制为b.txt文件</p><p>cp a.txt ../  将a.txt文件复制到上一层目录中</p><p>mv 移动或者重命名</p><p>mv a.txt ../  将a.txt文件移动到上一层目录中</p><p>mv a.txt b.txt  将a.txt文件重命名为b.txt</p><p>【tar】命令:(***** 打包或解压)</p><p>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。</p><p>常用参数：</p><p>-c：创建一个新tar文件</p><p>-v：显示运行过程的信息</p><p>-f：指定文件名</p><p>-z：调用gzip压缩命令进行压缩</p><p>-t：查看压缩文件的内容</p><p>-x：解开tar文件</p><p>打包：</p><p>tar –cvf xxx.tar ./*</p><p>打包并且压缩：</p><p>tar –zcvf xxx.tar.gz ./* </p><p>解压 </p><p>   tar –xvf xxx.tar</p><p>tar -xvf xxx.tar.gz -C /usr/aaa</p><p>【grep】命令</p><p>查找符合条件的字符串。</p><p>用法: grep [选项]… PATTERN [FILE]…</p><p>示例：</p><p>grep lang anaconda-ks.cfg 在文件中查找lang</p><p>grep lang anaconda-ks.cfg –color 高亮显示</p><p> <img src="/img/cphoto/linux02.jpg"></p><h3 id="1-3-6-其他常用命令"><a href="#1-3-6-其他常用命令" class="headerlink" title="1.3.6  其他常用命令"></a>1.3.6  其他常用命令</h3><p>【pwd】</p><p>显示当前所在目录</p><p>【touch】</p><p>创建一个空文件</p><p>* touch a.txt</p><p>【ll -h】</p><p>友好显示文件大小</p><p>【wget】</p><p>下载资料</p><p>* wget <a href="http://nginx.org/download/nginx-1.9.12.tar.gz">http://nginx.org/download/nginx-1.9.12.tar.gz</a></p><h2 id="1-4-Vi和Vim编辑器"><a href="#1-4-Vi和Vim编辑器" class="headerlink" title="1.4   Vi和Vim编辑器"></a>1.4   Vi和Vim编辑器</h2><h3 id="1-4-1-Vim编辑器："><a href="#1-4-1-Vim编辑器：" class="headerlink" title="1.4.1  Vim编辑器："></a>1.4.1  Vim编辑器：</h3><p>在Linux下一般使用vi编辑器来编辑文件。</p><p>vi既可以查看文件也可以编辑文件。</p><p>三种模式：命令行、插入、底行模式。</p><p>切换到命令行模式：按Esc键；</p><p>切换到插入模式：按 i 、o、a键；</p><p>  i 在当前位置生前插入</p><p>  I 在当前行首插入</p><p>  a 在当前位置后插入</p><p>  A 在当前行尾插入</p><p>  o 在当前行之后插入一行</p><p>  O 在当前行之前插入一行</p><p>切换到底行模式：按 :（冒号）；</p><p>更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》</p><p>打开文件：vim file</p><p>退出：esc à :q</p><p>修改文件：输入i进入插入模式</p><p>保存并退出：escà:wq</p><p>不保存退出：escà:q!</p><p>3中进入插入模式：</p><p>i:在当前的光标所在处插入</p><p>o:在当前光标所在的行的下一行插入</p><p>a:在光标所在的下一个字符插入</p><p>快捷键：</p><p>dd – 快速删除一行</p><p>R – 替换</p><h3 id="1-4-2-重定向输出-gt-和-gt-gt"><a href="#1-4-2-重定向输出-gt-和-gt-gt" class="headerlink" title="1.4.2  重定向输出&gt;和&gt;&gt;"></a>1.4.2  重定向输出&gt;和&gt;&gt;</h3><p>&gt; 重定向输出，覆盖原有内容；</p><p>&gt;&gt; 重定向输出，又追加功能；</p><p>示例：</p><p>cat /etc/passwd &gt; a.txt 将输出定向到a.txt中</p><p>cat /etc/passwd &gt;&gt; a.txt 输出并且追加</p><p>ifconfig &gt; ifconfig.txt</p><h3 id="1-4-3-管道"><a href="#1-4-3-管道" class="headerlink" title="1.4.3  管道 |"></a>1.4.3  管道 |</h3><p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。</p><p>示例</p><p>ls –help | more 分页查询帮助信息</p><p>ps –ef | grep java 查询名称中包含java的进程</p><p>ifconfig | more</p><p>cat index.html | more</p><p>ps –ef | grep aio</p><h3 id="1-4-4-amp-amp-命令执行控制："><a href="#1-4-4-amp-amp-命令执行控制：" class="headerlink" title="1.4.4  &amp;&amp;命令执行控制："></a>1.4.4  &amp;&amp;命令执行控制：</h3><p>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 </p><p>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 </p><p>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p><p>mkdir test &amp;&amp; cd test</p><h3 id="1-4-5-网络通讯命令"><a href="#1-4-5-网络通讯命令" class="headerlink" title="1.4.5  网络通讯命令"></a>1.4.5  网络通讯命令</h3><p>ifconfig 显示或设置网络设备。</p><p>ifconfig 显示网络设备</p><p>ifconfig eth0 up 启用eth0网卡</p><p>ifconfig eth0 down 停用eth0网卡</p><p>ping  探测网络是否通畅。</p><p>ping 192.168.0.1</p><p>netstat 查看网络端口。</p><p>netstat -an | grep 3306 查询3306端口占用情况</p><h3 id="1-4-6-系统管理命令"><a href="#1-4-6-系统管理命令" class="headerlink" title="1.4.6  系统管理命令"></a>1.4.6  系统管理命令</h3><p>date 显示或设置系统时间</p><p>date 显示当前系统时间</p><p>date -s “2014-01-01 10:10:10“ 设置系统时间</p><p>df 显示磁盘信息</p><p>df –h 友好显示大小</p><p>free 显示内存状态</p><p>free –m 以mb单位显示内存组昂头</p><p>top 显示，管理执行中的程序</p><p>clear 清屏幕</p><p>ps 正在运行的某个进程的状态</p><p>ps –ef 查看所有进程</p><p>ps –ef | grep ssh 查找某一进程</p><p>kill 杀掉某一进程</p><p>kill 2868 杀掉2868编号的进程</p><p>kill -9 2868 强制杀死进程</p><p>du 显示目录或文件的大小。</p><p>du –h 显示当前目录的大小</p><p>who 显示目前登入系统的用户信息。</p><p>hostname 查看当前主机名</p><p>修改：vi /etc/sysconfig/network</p><p>uname 显示系统信息。</p><p>uname -a 显示本机详细信息。</p><p>依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p><h2 id="1-5-Linux的用户和组"><a href="#1-5-Linux的用户和组" class="headerlink" title="1.5   Linux的用户和组"></a>1.5   Linux的用户和组</h2><h3 id="1-5-1-用户的管理"><a href="#1-5-1-用户的管理" class="headerlink" title="1.5.1  用户的管理"></a>1.5.1  用户的管理</h3><p>useradd 添加一个用户</p><p>useradd test 添加test用户</p><p>useradd test -d /home/t1 指定用户home目录</p><p>passwd 设置、修改密码</p><p>passwd test 为test用户设置密码</p><p>切换登录：</p><p>ssh -l test -p 22 192.168.19.128</p><p>su – 用户名</p><p>userdel 删除一个用户</p><p>userdel test 删除test用户(不会删除home目录)</p><p>userdel –r test 删除用户以及home目录</p><h3 id="1-5-2-组管理："><a href="#1-5-2-组管理：" class="headerlink" title="1.5.2  组管理："></a>1.5.2  组管理：</h3><p>当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组</p><p>创建用户时也可以指定所在组</p><p>groupadd 创建组</p><p>groupadd public 创建一个名为public的组</p><p>useradd u1 –g public 创建用户指定组</p><p>groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。</p><p>groupdel public</p><h3 id="1-5-3-id，su命令"><a href="#1-5-3-id，su命令" class="headerlink" title="1.5.3  id，su命令"></a>1.5.3  id，su命令</h3><p>【id命令】</p><p>功能：查看一个用户的UID和GID</p><p>用法：id [选项]… [用户名]</p><p>直接使用id</p><p>直接使用id 用户名</p><p>【su命令】</p><p>功能：切换用户。</p><p>用法：su [选项]… [-] [用户 [参数]… ]</p><p>示例：</p><p>su u1 切换到u1用户</p><p>su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用）</p><p>【账户文件】</p><p>/etc/passwd 用户文件</p><p>/etc/shadow 密码文件</p><p>/etc/group 组信息文件</p><p>【用户文件】</p><p>root​ x:0:0:root:/root:/bin/bash</p><p>账号名称：    在系统中是唯一的</p><p>用户密码：    此字段存放加密口令</p><p>用户标识码(User ID)： 系统内部用它来标示用户</p><p>组标识码(Group ID)：  系统内部用它来标识用户属性</p><p>用户相关信息：    例如用户全名等</p><p>用户目录：    用户登录系统后所进入的目录</p><p>用户环境:    用户工作的环境</p><p>【密码文件】</p><p>shadow文件中每条记录用冒号间隔的9个字段组成.</p><p>用户名：用户登录到系统时使用的名字，而且是惟一的</p><p>口令： 存放加密的口令</p><p>最后一次修改时间: 标识从某一时刻起到用户最后一次修改时间</p><p>最大时间间隔: 口令保持有效的最大天数，即多少天后必须修改口令</p><p>最小时间间隔：  再次修改口令之间的最小天数</p><p>警告时间：从系统开始警告到口令正式失效的天数</p><p>不活动时间： 口令过期少天后，该账号被禁用</p><p>失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算)</p><p>标志：未使用</p><p>【组文件】</p><p>root​ x:0:</p><p>组名：用户所属组</p><p>组口令：一般不用</p><p>GID：组ID</p><p>用户列表：属于该组的所有用户</p><h2 id="1-6-Linux的权限命令"><a href="#1-6-Linux的权限命令" class="headerlink" title="1.6   Linux的权限命令"></a>1.6   Linux的权限命令</h2><h3 id="1-6-1-文件权限"><a href="#1-6-1-文件权限" class="headerlink" title="1.6.1  文件权限"></a>1.6.1  文件权限</h3><p><img src="/img/cphoto/linux03.jpg"></p><table><thead><tr><th><strong>属主（<strong><strong>user</strong></strong>）</strong></th><th><strong>属组（<strong><strong>group</strong></strong>）</strong></th><th><strong>其他用户</strong></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>r</td><td>w</td><td>x</td><td>r</td><td>w</td><td>x</td><td>r</td><td>w</td><td>x</td></tr><tr><td>4</td><td>2</td><td>1</td><td>4</td><td>2</td><td>1</td><td>4</td><td>2</td><td>1</td></tr></tbody></table><h3 id="1-6-2-Linux三种文件类型："><a href="#1-6-2-Linux三种文件类型：" class="headerlink" title="1.6.2  Linux三种文件类型："></a>1.6.2  Linux三种文件类型：</h3><p>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </p><p>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 </p><p>设备文件： Linux系统把每一个设备都看成是一个文件</p><h3 id="1-6-3-文件类型标识"><a href="#1-6-3-文件类型标识" class="headerlink" title="1.6.3  文件类型标识"></a>1.6.3  文件类型标识</h3><p>普通文件（-）</p><p>目录（d）</p><p>符号链接（l）</p><p>* 进入etc可以查看，相当于快捷方式</p><p>字符设备文件（c）</p><p>块设备文件（s）</p><p>套接字（s）</p><p>命名管道（p）</p><h3 id="1-6-4-文件权限管理："><a href="#1-6-4-文件权限管理：" class="headerlink" title="1.6.4  文件权限管理："></a>1.6.4  文件权限管理：</h3><p>chmod 变更文件或目录的权限。</p><p>chmod 755 a.txt </p><p>chmod u=rwx,g=rx,o=rx a.txt</p><p>chmod 000 a.txt / chmod 777 a.txt</p><p>chown 变更文件或目录改文件所属用户和组</p><p>chown u1:public a.txt ：变更当前的目录或文件的所属用户和组</p><p>chown -R u1:public dir ：变更目录中的所有的子目录及文件的所属用户和组</p><h1 id="Linux下安装lrzsz"><a href="#Linux下安装lrzsz" class="headerlink" title="Linux下安装lrzsz"></a>Linux下安装lrzsz</h1><h2 id="1-手动编译安装"><a href="#1-手动编译安装" class="headerlink" title="1. 手动编译安装"></a>1. 手动编译安装</h2><p>1、下载安装包，wget <a href="https://ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz">https://ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</a> 或者是 上传已经下载好的安装包</p><p>2、cd /usr/local/src/</p><p>3、mkdir lrzsz</p><p>4、cd lrzsz/</p><p>5、解压：tar -xvf lrzsz-0.12.20.tar.gz</p><p>6、cd lrzsz-0.12.20</p><p>7、执行配置：./configure </p><p>a)    会提示 configure: error: no acceptable cc found in $PATH，意思是缺少gcc命令，需要安装gcc</p><p>b)   手动安装gcc比较麻烦，所有选择使用yum安装</p><p>c)    yum install gcc</p><p>8、编译：make</p><p>9、安装：make install</p><p>10、     cd /usr/bin</p><p>11、     ln -s /usr/local/bin/lrz rz</p><p>12、     ln -s /usr/local/bin/lsz sz</p><p>13、     输入命令：rz</p><p>   安装成功！</p><h2 id="2-使用yum安装"><a href="#2-使用yum安装" class="headerlink" title="2. 使用yum安装"></a>2. 使用yum安装</h2><p>yum -y install lrzsz</p><h1 id="Linux安装jdk"><a href="#Linux安装jdk" class="headerlink" title="Linux安装jdk"></a>Linux安装jdk</h1><p>先卸载open-jdk</p><p>java –version</p><p>rpm -qa | grep java</p><p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64</p><p>rpm -e –nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64</p><p>开始安装：</p><p>mkdir /usr/local/src/java</p><p>rz 上传jdk tar包</p><p>tar -xvf jdk-7u71-linux-i586.tar.gz</p><p>yum install glibc.i686</p><p>配置环境变量：</p><p>① vi /etc/profile</p><p>② 在末尾行添加</p><p>​    #set java environment</p><p>​    JAVA_HOME=/usr/local/src/java/jdk1.7.0_71</p><p>​    CLASSPATH=.:$JAVA_HOME/lib.tools.jar</p><p>​    PATH=$JAVA_HOME/bin:$PATH</p><p>​    export JAVA_HOME CLASSPATH PATH</p><p>保存退出</p><p>③source /etc/profile 使更改的配置立即生效</p><p>④java -version 查看JDK版本信息，如果显示出1.7.0证明成功</p><h1 id="Linux下安装Mysql"><a href="#Linux下安装Mysql" class="headerlink" title="Linux下安装Mysql"></a>Linux下安装Mysql</h1><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><p><a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a></p><p>或者使用wget下载：</p><p>wget <a href="http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar">http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar</a></p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><h3 id="2-1-检测是否已经安装了mysql"><a href="#2-1-检测是否已经安装了mysql" class="headerlink" title="2.1. 检测是否已经安装了mysql"></a>2.1. 检测是否已经安装了mysql</h3><p>rpm -qa | grep mysql  </p><p>如果已经安装了，将其卸载，如：</p><p>rpm -e –nodeps mysql-libs-5.1.71-1.el6.x86_64</p><h3 id="2-2-安装mysql"><a href="#2-2-安装mysql" class="headerlink" title="2.2. 安装mysql"></a>2.2. 安装mysql</h3><p>1、mkdir /usr/local/src/mysql</p><p>2、cd /usr/local/src/mysql</p><p>3、tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar</p><p>4、安装server<br> rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</p><p>如果安装出错,可能还需要安装依赖</p><p> 安装依赖：yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 </p><p> 需要升级libstdc++-4.4.7-4.el6.x86_64<br> yum update libstdc++-4.4.7-4.el6.x86_64</p><p>6、安装client</p><p>rpm -ivh mysql-client-5.6.22-1.el6.i686.rpm</p><p> 安装依赖：yum -y install libncurses.so.5 libtinfo.so.5</p><p>7、查询mysq服务运行状态</p><p>service mysql status<br> 服务未启动。</p><p>8、启动mysql服务<br> service mysql start</p><p>9、使用root账号登录mysql</p><p> 在安装mysql server时有句提示：<br> 随机生成的root用户密码保存在/root/.mysql_secret</p><p><img src="/img/cphoto/linux04.jpg"></p><p> 注意：这个密码是不安全的，所有需要修改初始密码。</p><p>10、     使用密码登录mysql账号：mysql -uroot -p</p><p>11、     修改root密码：SET PASSWORD = PASSWORD(‘123456’);</p><h3 id="2-3-系统启动时自动启动mysql服务"><a href="#2-3-系统启动时自动启动mysql服务" class="headerlink" title="2.3. 系统启动时自动启动mysql服务"></a>2.3. 系统启动时自动启动mysql服务</h3><p>加入到系统服务：</p><p>chkconfig –add mysql</p><p>自动启动：</p><p>chkconfig mysql on</p><p>查询列表：</p><p>chkconfig</p><p>说明：都没关闭（off）时是没有自动启动。</p><h3 id="2-4-开启远程访问"><a href="#2-4-开启远程访问" class="headerlink" title="2.4. 开启远程访问"></a>2.4. 开启远程访问</h3><p>登录：</p><p>mysql -uroot –p123456</p><p>设置远程访问（使用root密码）：</p><p>grant all privileges on <em>.</em> to ‘root’ @’%’ identified by ‘123456’; </p><p>flush privileges;</p><p>防火墙打开3306端口</p><p>/sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT</p><p>/etc/rc.d/init.d/iptables save</p><p>/etc/init.d/iptables status</p><h1 id="Linux部署web程序"><a href="#Linux部署web程序" class="headerlink" title="Linux部署web程序"></a>Linux部署web程序</h1><h2 id="1-创建ucenter用户"><a href="#1-创建ucenter用户" class="headerlink" title="1. 创建ucenter用户"></a>1. 创建ucenter用户</h2><p>一般情况下，发布应用程序都不是使用root用户的，需要创建一个普通用户来发布程序；</p><p>创建ucenter用户：<br>useradd -d /ucenter ucenter</p><p>设置密码：<br>passwd ucenter （密码 ucenter）<br>切换用户：<br>su - ucenter</p><h2 id="2-安装Tomcat"><a href="#2-安装Tomcat" class="headerlink" title="2. 安装Tomcat"></a>2. 安装Tomcat</h2><p>tomcat只要解压就可以使用。<br>1、创建web目录<br> mkdir /ucenter/web</p><p>2、上传apache-tomcat-7.0.57.tar.gz</p><p>3、解压：tar -xvf apache-tomcat-7.0.57.tar.gz</p><p>4、重命名：mv apache-tomcat-7.0.57 itcast-usermanage</p><p>5、启动tomcat：<br> cd itcast-usermanage/bin/<br> ./startup.sh 或者 sh startup.sh</p><p>6、查看日志：<br> tail -f ../logs/catalina.out</p><p>7、查看效果 <a href="http://192.168.0.160:8080/">http://192.168.0.160:8080/</a><br> 发现无法访问</p><p>8、防火墙打开 8080 端口<br> /sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT</p><p>/etc/rc.d/init.d/iptables save</p><p>9、安装成功</p><h2 id="3-部署用户管理项目"><a href="#3-部署用户管理项目" class="headerlink" title="3. 部署用户管理项目"></a>3. 部署用户管理项目</h2><h2 id="3-1-上传usermanage-sql和ROOT-war到-ucenter-web"><a href="#3-1-上传usermanage-sql和ROOT-war到-ucenter-web" class="headerlink" title="3.1. 上传usermanage.sql和ROOT.war到/ucenter/web"></a>3.1. 上传usermanage.sql和ROOT.war到/ucenter/web</h2><h2 id="3-2-执行数据库脚本"><a href="#3-2-执行数据库脚本" class="headerlink" title="3.2. 执行数据库脚本"></a>3.2. 执行数据库脚本</h2><p>cat usermanage.sql | mysql -uroot -p123456</p><h2 id="3-3-部署web程序"><a href="#3-3-部署web程序" class="headerlink" title="3.3. 部署web程序"></a>3.3. 部署web程序</h2><h3 id="3-3-1-删除webapps下的所有文件"><a href="#3-3-1-删除webapps下的所有文件" class="headerlink" title="3.3.1.  删除webapps下的所有文件"></a>3.3.1.  删除webapps下的所有文件</h3><p>cd /ucenter/web/itcast-usermanage/webapps</p><p>rm -rf *</p><h3 id="3-3-2-拷贝ROOT-war到webapps"><a href="#3-3-2-拷贝ROOT-war到webapps" class="headerlink" title="3.3.2.  拷贝ROOT.war到webapps"></a>3.3.2.  拷贝ROOT.war到webapps</h3><p>cp /ucenter/web/ROOT.war .</p><h3 id="3-3-3-重新启动tomcat"><a href="#3-3-3-重新启动tomcat" class="headerlink" title="3.3.3.  重新启动tomcat"></a>3.3.3.  重新启动tomcat</h3><p>cd ../bin/</p><p>sh startup.sh &amp;&amp; tail -f ../logs/catalina.out</p><h3 id="3-3-4-启动浏览器测试"><a href="#3-3-4-启动浏览器测试" class="headerlink" title="3.3.4.  启动浏览器测试"></a>3.3.4.  启动浏览器测试</h3><p><a href="http://192.168.0.160:8080/user/page/query">http://192.168.0.160:8080/user/page/query</a></p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx (“engine x”) 是一个高性能的 HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。</p><p>正向代理：</p><p><img src="/img/cphoto/nginx01.jpg"></p><p>反向代理:</p><p><img src="/img/cphoto/nginx02.jpg"></p><p> 很多大网站都是使用nginx做反向代理，应用非常广泛。</p><p>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2  应用场景"></a>2  应用场景</h1><p>1、http服务器，可以做静态网页的http服务器。</p><p>2、配置虚拟机。</p><p>一个域名可以被多个ip绑定。可以根据域名的不同吧请求转发给运行在不同端口的服务器。</p><p>3、反向代理，负载均衡。把请求转发给不同的服务器。</p><h1 id="3-安装及配置"><a href="#3-安装及配置" class="headerlink" title="3  安装及配置"></a>3  安装及配置</h1><h2 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1  下载"></a>3.1  下载</h2><p>官方网站：<a href="http://nginx.org/">http://nginx.org/</a></p><p>最后的一个稳定版本：1.8.0版本。有两个版本windows版本和linux版本。生产环境都是使用linux版本。</p><h2 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2  安装"></a>3.2  安装</h2><h3 id="3-2-1-环境要求"><a href="#3-2-1-环境要求" class="headerlink" title="3.2.1 环境要求"></a>3.2.1 环境要求</h3><p>nginx是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。</p><p>n gcc</p><p>​    安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ </p><p>n PCRE</p><p>​    PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p><p><strong>yum install -y pcre pcre-devel</strong></p><p>注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</p><p>n zlib</p><p>​    zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p><p><strong>yum install -y zlib zlib-devel</strong></p><p>n openssl</p><p>​    OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p><p>​    nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</p><p><strong>yum install -y openssl openssl-devel</strong></p><h3 id="3-2-2-编译及安装"><a href="#3-2-2-编译及安装" class="headerlink" title="3.2.2 编译及安装"></a>3.2.2 编译及安装</h3><p>第一步：把nginx的源码包上传至linux服务器</p><p>第二步：解压源码包。 tar -zxf nginx-1.8.0.tar.gz </p><p>第三步：进入nginx-1.8.0文件夹。使用configure命令创建makefile。</p><p>第四步：参数设置如下：</p><p>./configure \</p><p>–prefix=/usr/local/nginx \</p><p>–pid-path=/var/run/nginx/nginx.pid \</p><p>–lock-path=/var/lock/nginx.lock \</p><p>–error-log-path=/var/log/nginx/error.log \</p><p>–http-log-path=/var/log/nginx/access.log \</p><p>–with-http_gzip_static_module \</p><p>–http-client-body-temp-path=/var/temp/nginx/client \</p><p>–http-proxy-temp-path=/var/temp/nginx/proxy \</p><p>–http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</p><p>–http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</p><p>–http-scgi-temp-path=/var/temp/nginx/scgi</p><p><strong>注意：上边将临时文件目录指定为**</strong>/var/temp/nginx<strong><strong>，需要在</strong></strong>/var<strong><strong>下创建</strong></strong>temp<strong><strong>及</strong></strong>nginx**<strong>目录</strong></p><p>第五步：make</p><p>第六步 make install </p><h2 id="3-3-Nginx的启动及关闭"><a href="#3-3-Nginx的启动及关闭" class="headerlink" title="3.3  Nginx的启动及关闭"></a>3.3  Nginx的启动及关闭</h2><h3 id="3-3-1-启动"><a href="#3-3-1-启动" class="headerlink" title="3.3.1 启动"></a>3.3.1 启动</h3><p>在nginx目录下有一个sbin目录，sbin目录下有一个nginx可执行程序。</p><p>./nginx</p><p> <img src="/img/cphoto/nginx03.jpg"></p><h3 id="3-3-2-关闭nginx"><a href="#3-3-2-关闭nginx" class="headerlink" title="3.3.2 关闭nginx"></a>3.3.2 关闭nginx</h3><p>关闭命令：相当于找到nginx进程kill。</p><p>./nginx <strong>-s</strong> stop</p><p>退出命令：</p><p>./nginx -s quit</p><p>等程序执行完毕后关闭，建议使用此命令。</p><h3 id="3-3-3-动态加载配置文件"><a href="#3-3-3-动态加载配置文件" class="headerlink" title="3.3.3 动态加载配置文件"></a>3.3.3 动态加载配置文件</h3><p>./nginx -s reload</p><p>可以不关闭nginx的情况下更新配置文件。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下Top命令</title>
    <link href="/2017/10/03/Linux%E4%B8%8BTop%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/10/03/Linux%E4%B8%8BTop%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Top命令"><a href="#Top命令" class="headerlink" title="Top命令"></a>Top命令</h1><p>TOP命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。</p><p>TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p><p><img src="/img/cphoto/linux06.jpg"></p><h1 id="一-统计信息区"><a href="#一-统计信息区" class="headerlink" title="一. 统计信息区"></a>一. 统计信息区</h1><p>统计信息区前五行是系统整体的统计信息。</p><p><img src="/img/cphoto/linux07.jpg"></p><h2 id="1-第一行是任务队列信息"><a href="#1-第一行是任务队列信息" class="headerlink" title="1. 第一行是任务队列信息"></a>1. 第一行是任务队列信息</h2><p>同 uptime 命令的执行结果:</p><p>[root@localhost ~]# uptime</p><p> 13:22:30 up 8 min, 4 users, load average: 0.14, 0.38, 0.25</p><p>其内容如下：</p><table><thead><tr><th>12:38:33</th><th>当前时间</th></tr></thead><tbody><tr><td>up 50days</td><td>系统运行时间，格式为时:分</td></tr><tr><td>1 user</td><td>当前登录用户数</td></tr><tr><td>load average: 0.06, 0.60, 0.48</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</td></tr></tbody></table><h2 id="2-第二、三行为进程和CPU的信息"><a href="#2-第二、三行为进程和CPU的信息" class="headerlink" title="2. 第二、三行为进程和CPU的信息"></a>2. 第二、三行为进程和CPU的信息</h2><p>当有多个CPU时，这些内容可能会超过两行。内容如下：</p><table><thead><tr><th>Tasks: 29 total</th><th>进程总数</th></tr></thead><tbody><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>28 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>Cpu(s): 0.3% us</td><td>用户空间占用CPU百分比</td></tr><tr><td>1.0% sy</td><td>内核空间占用CPU百分比</td></tr><tr><td>0.0% ni</td><td>用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td>98.7% id</td><td>空闲CPU百分比</td></tr><tr><td>0.0% wa</td><td>等待输入输出的CPU时间百分比</td></tr><tr><td>0.0% hi</td><td></td></tr><tr><td>0.0% si</td><td></td></tr></tbody></table><h2 id="3-第四五行为内存信息。"><a href="#3-第四五行为内存信息。" class="headerlink" title="3. 第四五行为内存信息。"></a>3. 第四五行为内存信息。</h2><p>内容如下：</p><table><thead><tr><th>Mem: 191272k total</th><th>物理内存总量</th></tr></thead><tbody><tr><td>173656k used</td><td>使用的物理内存总量</td></tr><tr><td>17616k free</td><td>空闲内存总量</td></tr><tr><td>22052k buffers</td><td>用作内核缓存的内存量</td></tr><tr><td>Swap: 192772k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>192772k free</td><td>空闲交换区总量</td></tr><tr><td>123988k cached</td><td>缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些<strong>内容已存在于内存中</strong>的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。</td></tr></tbody></table><h1 id="二-进程信息区"><a href="#二-进程信息区" class="headerlink" title="二. 进程信息区"></a>二. 进程信息区</h1><p>统计信息区域的下方显示了各个进程的详细信息。我们来认识一下各列的含义：</p><p><img src="/img/cphoto/linux08.jpg"></p><h2 id="1-列信息"><a href="#1-列信息" class="headerlink" title="1.列信息"></a>1.列信息</h2><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程id</td></tr><tr><td>PPID</td><td>父进程id</td></tr><tr><td>RUSER</td><td>Real user name</td></tr><tr><td>UID</td><td>进程所有者的用户id</td></tr><tr><td>USER</td><td>进程所有者的用户名</td></tr><tr><td>GROUP</td><td>进程所有者的组名</td></tr><tr><td>TTY</td><td>启动进程的终端名。不是从终端启动的进程则显示为 ?</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>P</td><td>最后使用的CPU，仅在多CPU环境下有意义</td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>TIME</td><td>进程使用的CPU时间总计，单位秒</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td>SWAP</td><td>进程使用的虚拟内存中，被换出的大小，单位kb。</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td>CODE</td><td>可执行代码占用的物理内存大小，单位kb</td></tr><tr><td>DATA</td><td>可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td></tr><tr><td>SHR</td><td>共享内存大小，单位kb</td></tr><tr><td>nFLT</td><td>页面错误次数</td></tr><tr><td>nDRT</td><td>最后一次写入到现在，被修改过的页面数。</td></tr><tr><td>S</td><td>进程状态。           D=不可中断的睡眠状态           R=运行           S=睡眠           T=跟踪/停止           Z=僵尸进程</td></tr><tr><td>COMMAND</td><td>命令名/命令行</td></tr><tr><td>WCHAN</td><td>若该进程在睡眠，则显示睡眠中的系统函数名</td></tr><tr><td>Flags</td><td>任务标志，参考 sched.h</td></tr></tbody></table><h2 id="2-用快捷键更改显示内容"><a href="#2-用快捷键更改显示内容" class="headerlink" title="2.用快捷键更改显示内容"></a>2.用快捷键更改显示内容</h2><p>h或者? : 显示帮助画面，给出一些简短的命令总结说明。</p><p>k ：终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。</p><p>i：忽略闲置和僵死进程。这是一个开关式命令。</p><p>q： 退出程序。</p><p>r： 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。</p><p>S：切换到累计模式。</p><p>s : 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。</p><p>f或者F :从当前显示中添加或者删除项目。</p><p>o或者O :改变显示项目的顺序。</p><p>l: 切换显示平均负载和启动时间信息。即显示影藏第一行</p><p>m： 切换显示内存信息。即显示影藏内存行</p><p>t ： 切换显示进程和CPU状态信息。即显示影藏CPU行</p><p>c： 切换显示命令名称和完整命令行。 显示完整的命令。 这个功能很有用。</p><p>M ： 根据驻留内存大小进行排序。</p><p>P：根据CPU使用百分比大小进行排序。</p><p>T： 根据时间/累计时间进行排序。</p><p>W： 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p><p>z：改变显示的颜色</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rpm执行安装包</title>
    <link href="/2017/10/03/rpm%E6%89%A7%E8%A1%8C%E5%AE%89%E8%A3%85%E5%8C%85/"/>
    <url>/2017/10/03/rpm%E6%89%A7%E8%A1%8C%E5%AE%89%E8%A3%85%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rpm 执行安装包<br> 二进制包（Binary）以及源代码包（Source）两种。二进制包可以直接安装在计算机中，而源代码包将会由 RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。</p><p>常用命令组合：</p><p>－ivh：安装显示安装进度–install–verbose–hash<br> －Uvh：升级软件包–Update；<br> －qpl： 列出RPM软件包内的文件信息[Query Package list]；<br> －qpi：列出RPM软件包的描述信息[Query Package install package(s)]；<br> －qf：查找指定文件属于哪个RPM软件包[Query File]；<br> －Va：校验所有的 RPM软件包，查找丢失的文件[View Lost]；<br> －e：删除包</p><p>rpm -q samba //查询程序是否安装</p><p>rpm -ivh /media/cdrom/RedHat/RPMS/samba-3.0.10-1.4E.i386.rpm //按路径安装并显示进度<br> rpm -ivh –relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm  //指定安装目录</p><p>rpm -ivh –test gaim-1.3.0-1.fc4.i386.rpm　　　 //用来检查依赖关系；并不是真正的安装；<br> rpm -Uvh –oldpackage gaim-1.3.0-1.fc4.i386.rpm //新版本降级为旧版本</p><p>rpm -qa | grep httpd　　　　　 ＃[搜索指定rpm包是否安装]–all搜索<em>httpd</em><br> rpm -ql httpd　　　　　　　　　＃[搜索rpm包]–list所有文件安装目录</p><p>rpm -qpi Linux-1.4-6.i368.rpm　＃[查看rpm包]–query–package–install package信息<br> rpm -qpf Linux-1.4-6.i368.rpm　＃[查看rpm包]–file<br> rpm -qpR file.rpm　　　　　　　＃[查看包]依赖关系<br> rpm2cpio file.rpm |cpio -div  ＃[抽出文件]</p><p>rpm -ivh file.rpm 　＃[安装新的rpm]–install–verbose–hash<br> rpm -ivh [<a href="http://my.chinaunix.net/link.php?url=http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm">url]http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm[/url]</a><br> rpm -Uvh file.rpm  ＃[升级一个rpm]–upgrade<br> rpm -e file.rpm   ＃[删除一个rpm包]–erase</p><p>常用参数：</p><p>Install/Upgrade/Erase options:<br> -i, –install           install package(s)<br> -v, –verbose           provide more detailed output<br> -h, –hash            print hash marks as package installs (good with -v)<br> -e, –erase            erase (uninstall) package<br> -U, –upgrade=<packagefile>+   upgrade package(s)<br> －-replacepkge          无论软件包是否已被安装，都强行安装软件包<br> –test              安装测试，并不实际安装<br> –nodeps             忽略软件包的依赖关系强行安装<br> –force              忽略软件包及文件的冲突</packagefile></p><p>Query options (with -q or –query):<br> -a, –all             query/verify all packages<br> -p, –package           query/verify a package file<br> -l, –list            list files in package<br> -d, –docfiles          list all documentation files<br> -f, –file            query/verify package(s) owning file</p><p><strong>RPM****源代码包装安装</strong></p><p>.src.rpm结尾的文件，这些文件是由软件的源代码包装而成的，用户要安装这类RPM软件包，必须使用命令：</p><p>rpm　–recompile　vim-4.6-4.src.rpm  ＃这个命令会把源代码解包并编译、安装它，如果用户使用命令：</p><p>rpm　–rebuild　vim-4.6-4.src.rpm　　＃在安装完成后，还会把编译生成的可执行文件重新包装成i386.rpm 的RPM软件包。</p><p> [root@localhost src]# rpm -ivh awstats-6.8-1.noarch.rpm<br> error: Failed dependencies:<br> perl(LWP::UserAgent) is needed by awstats-6.8-1.noarch<br> [root@localhost src]#</p><p> 使用rpm 属性相依套件的档案</p><p> [root@localhost src]# rpm -qpR awstats-6.8-1.noarch.rpm<br> /bin/sh<br> /usr/bin/perl<br> config(awstats) = 6.8-1<br> perl &gt;= 0:5.005<br> perl(LWP::UserAgent)<br> perl(POSIX)<br> perl(Socket)<br> perl(Time::Local)<br> perl(strict)<br> perl(vars)<br> rpmlib(CompressedFileNames) &lt;= 3.0.4-1<br> rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</p><p>另外：# rpm -ivh –aid samba*.rpm (一定要安装rpmdb后才可以用这种方式安装排除依赖关系)</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux目录介绍</title>
    <link href="/2017/10/03/Linux%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2017/10/03/Linux%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux各目录及每个目录的详细介绍"><a href="#Linux各目录及每个目录的详细介绍" class="headerlink" title="Linux各目录及每个目录的详细介绍"></a>Linux各目录及每个目录的详细介绍</h1><h2 id="常见目录说明"><a href="#常见目录说明" class="headerlink" title="常见目录说明"></a>常见目录说明</h2><p>目录<br>/bin    存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。<br>/etc    存放系统管理和配置文件<br>/home    存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示</p><p>/usr    用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。<br>/usr/x11r6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令<br>/usr/local/lib 本地增加的库<br>/opt    额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。<br>/proc    虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/root    超级用户（系统管理员）的主目录（特权阶级^o^）<br>/sbin    存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。<br>/dev    用于存放设备文件。<br>/mnt    系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。<br>/boot    存放用于系统引导时使用的各种文件<br>/lib    存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。<br>/tmp    用于存放各种临时文件，是公用的临时文件存储点。<br>/var    用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。<br>/lost+found    这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</p><p>Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图：<br> <img src="/img/cphoto/linux05.jpg"></p><p>/bin 二进制可执行命令<br>/dev 设备特殊文件<br>/etc 系统管理和配置文件<br>/etc/rc.d 启动的配置文件和脚本<br>/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示<br>/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>/sbin 超级管理命令，这里存放的是系统管理员使用的管理程序<br>/tmp 公共的临时文件存储点<br>/root 系统管理员的主目录<br>/mnt 系统提供这个目录是让用户临时挂载其他的文件系统<br>/lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里<br>/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/var 某些大文件的溢出区，比方说各种服务的日志文件<br>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：<br>/usr/x11R6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令<br>/usr/local/lib 本地增加的库根文件系统</p><p>通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的不经常改变的文件系统不容易损坏。<br>除了可能的一个叫/ vmlinuz标准的系统引导映像之外，根目录一般不含任何文件。所有其他文件在根文件系统的子目录中。</p><ol><li>/bin目录<br>/ b i n目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命令都是二进制文件的可执行程序( b i n是b i n a r y - -二进制的简称)，多是系统中重要的系统文件。</li><li>/sbin目录<br>/ s b i n目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用。</li><li>/etc目录<br>/ e t c目录存放着各种系统配置文件，其中包括了用户信息文件/ e t c / p a s s w d，系统初始化文件/ e t c / r c等。l i n u x正是*这些文件才得以正常地运行。</li><li>/root目录<br>/root 目录是超级用户的目录。</li><li>/lib目录<br>/ l i b目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。</li><li>/lib/modules 目录<br>/lib/modules 目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引导系统所需的模块(例如网络和文件系统驱动)。</li><li>/dev目录<br>/ d e v目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可以通过访问/ d e v / m o u s e来访问鼠标的输入，就像访问其他文件一样。</li><li>/tmp目录<br>/tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/ v a r / t m p来代替/tmp ，因为前者可能拥有一个更大的磁盘空间。</li><li>/boot目录<br>/ b o o t目录存放引导加载器(bootstrap loader)使用的文件，如l i lo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在i d e硬盘的前1 0 2 4柱面内。</li><li>/mnt目录<br>/ m n t目录是系统管理员临时安装( m o u n t )文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用m s d o s文件系统的软驱，而/mnt/exta 可能是使用e x t 2文件系统的软驱，/mnt/cdrom 光驱等等。</li><li>/proc, /usr,/var,/home目录<br>其他文件系统的安装点。</li></ol><h2 id="详细介绍；"><a href="#详细介绍；" class="headerlink" title="详细介绍；"></a>详细介绍；</h2><p>/etc文件系统<br>/etc 目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的m a n页。许多网络配置文件也在/etc 中。</p><ol><li>/etc/rc或/etc/rc.d或/etc/rc?.d<br>启动、或改变运行级时运行的脚本或脚本的目录。</li><li>/etc/passwd<br>用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其<br>他信息。</li><li>/etc/fdprm<br>软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见s e t f d p r m<br>的帮助页。</li><li>/etc/fstab<br>指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的s w a p区的信息。</li><li>/etc/group<br>类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。</li><li>/etc/inittab<br>init 的配置文件。</li><li>/etc/issue<br>包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。</li><li>/etc/magic<br>“f i l e”的配置文件。包含不同文件格式的说明，“f i l e”基于它猜测文件类型。</li><li>/etc/motd<br>m o t d是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。</li><li>/etc/mtab<br>当前安装的文件系统列表。由脚本( s c r i t p )初始化，并由mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df 命令)。</li><li>/etc/shadow<br>在安装了影子( s h a d o w )口令软件的系统上的影子口令文件。影子口令文件将/ e t c / p a s s wd文件中的加密口令移动到/ e t c / s h a d o w中，而后者只对超级用户( r o o t)可读。这使破译口令更困难，以此增加系统的安全性。</li><li>/etc/login.defs<br>l o g i n命令的配置文件。</li><li>/etc/printcap<br>类似/etc/termcap ，但针对打印机。语法不同。</li><li>/etc/profile 、/ e t c / c s h . l o g i n、/etc/csh.cshrc<br>登录或启动时b o u r n e或c shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。</li><li>/etc/securetty<br>确认安全终端，即哪个终端允许超级用户( r o o t )登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器( m o d e m )或网络闯入系统并得到超级用户特权。</li><li>/etc/shells<br>列出可以使用的s h e l l。chsh 命令允许用户在本文件指定范围内改变登录的s h e l l。提供一台机器f t p服务的服务进程ftpd 检查用户s h e l l是否列在/etc/shells 文件中，如果不是，将不允许该用户登录。</li><li>/etc/termcap<br>终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。<br>这样，多数的程序可以在多数终端上运行。</li></ol><p>/dev文件系统<br>/dev 目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。<br>设备文件在安装时由系统产生，以后可以用/dev/makedev 描述。/ d e v / m a k e d e v.local是<br>系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准<br>makedev 的一部分)。下面简要介绍/ d e v下一些常用文件。</p><ol><li>/dev/console<br>系统控制台，也就是直接和系统连接的监视器。</li><li>/dev/hd<br>i d e硬盘驱动程序接口。如： / d e v / h d a指的是第一个硬盘， h a d 1则是指/ d e v / h da的第一个<br>分区。如系统中有其他的硬盘，则依次为/ d e v / h d b、/ d e v / h d c、. . . . ..；如有多个分区则依次为<br>h d a 1、h d a 2 . . . . . .</li><li>/dev/sd<br>s c s i磁盘驱动程序接口。如有系统有s c s i硬盘，就不会访问/ d e v / h a d，而会访问/ d e v / sd a。</li><li>/dev/fd<br>软驱设备驱动程序。如： / d e v / f d 0指系统的第一个软盘，也就是通常所说的a：盘，<br>/ d e v / f d 1指第二个软盘，. . . . . .而/ d e v / f d 1 h 1 4 40则表示访问驱动器1中的4 . 5高密盘。</li><li>/dev/st<br>s c s i磁带驱动器驱动程序。</li><li>/dev/tty<br>提供虚拟控制台支持。如： / d e v / t t y 1指的是系统的第一个虚拟控制台， / d e v / t t y2则是系统<br>的第二个虚拟控制台。</li><li>/dev/pty<br>提供远程登陆伪终端支持。在进行te l n e t登录时就要用到/ d e v / p t y设备。</li><li>/dev/ttys<br>计算机串行接口，对于d o s来说就是“ c o m 1”口。</li><li>/dev/cua<br>计算机串行接口，与调制解调器一起使用的设备。</li><li>/dev/null<br>“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输入到/ d e v / n u l l中即可。</li></ol><p>/usr文件系统<br>/usr 是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的<br>所有文件一般来自l i n u x发行版( d i s t r i b u t i o n)；本地安装的程序和其他东西在/usr/local 下，因为这样可以在升级新版系统或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/ u s r可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。</p><ol><li>/usr/x11r6<br>包含x wi n d o w系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x wi n d o w系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft wi n d o w s或m a c h i n t o s h比较熟悉的话，就不会对x win d o w系统感到束手无策了。</li><li>/usr/x386<br>类似/ u s r / x 11r6 ，但是是专门给x 11 release 5的。</li><li>/usr/bin<br>集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin 或/usr/local/bin 中。</li><li>/usr/sbin<br>包括了根文件系统不必要的系统管理命令，例如多数服务程序。</li><li>/usr/man、/ u s r / i n f o、/ u s r / d o c<br>这些目录包含所有手册页、g n u信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如： / u s r / m a n / m a n 1中包含联机手册第一节的源码(没有格式化的原始文件)，/ u s r / m a n / c a t 1包含第一节已格式化的内容。l联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、系统管理和核心程序。</li><li>/usr/include<br>包含了c语言的头文件，这些文件多以. h结尾，用来描述c语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib 下，但习惯上一直沿用了这个名字。</li><li>/usr/lib<br>包含了程序或子系统的不变的数据文件，包括一些s i t e - w i d e配置文件。名字l i b来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。</li><li>/usr/local<br>本地安装的软件和其他文件放在这里。这与/ u s r很相似。用户可能会在这发现一些比较大的软件包，如t e x、e m a c s等。</li></ol><p>/var文件系统<br>/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来/ v a r目录中有些内容是在/ u s r中的，但为了保持/ u s r目录的相对稳定，就把那些需要经常改变的目录放到/ v a r中了。每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。</p><ol><li>/var/catman<br>包括了格式化过的帮助( m a n )页。帮助页的源文件一般存在/ u s r / m a n / m a n中；有些m an页可能有预格式化的版本，存在/ u s r / m a n / c a t中。而其他的m a n页在第一次看时都需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman 经常被清除，就像清除临时目录一样。)</li><li>/var/lib<br>存放系统正常运行时要改变的文件。</li><li>/var/local<br>存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。</li><li>/var/lock<br>锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。</li><li>/var/log<br>各种程序的日志( l o g )文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log里的文件经常不确定地增长，应该定期清除。</li><li>/var/run<br>保存在下一次系统引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。</li><li>/var/spool<br>放置“假脱机( s p o o l )”程序的目录，如m a i l、n e w s、打印队列和其他队列工作的目录。每个不同的s p o o l在/var/spool 下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail中。</li><li>/var/tmp<br>比/tmp 允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许/var/tmp 有很旧的文件。</li></ol><p>/proc文件系统<br>/proc 文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一<br>个非常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提<br>供关于系统的信息。下面说明一些最重要的文件和目录(/proc 文件系统在proc man页中有更详<br>细的说明)。</p><ol><li>/proc/x<br>关于进程x的信息目录，这一x是这一进程的标识号。每个进程在/proc 下有一个名为自<br>己进程号的目录。</li><li>/proc/cpuinfo<br>存放处理器( c p u )的信息，如c p u的类型、制造商、型号和性能等。</li><li>/proc/devices<br>当前运行的核心配置的设备驱动的列表。</li><li>/proc/dma<br>显示当前使用的d m a通道。</li><li>/proc/filesystems<br>核心配置的文件系统信息。</li><li>/proc/interrupts<br>显示被占用的中断信息和占用者的信息，以及被占用的数量。</li><li>/proc/ioports<br>当前使用的i / o端口。</li><li>/proc/kcore<br>系统物理内存映像。与物理内存大小完全一样，然而实际上没有占用这么多内存；它仅仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc 下没有任何东西占用任何磁盘空间。)</li><li>/proc/kmsg<br>核心输出的消息。也会被送到s y s l o g。</li><li>/proc/ksyms<br>核心符号表。</li><li>/proc/loadavg<br>系统“平均负载”； 3个没有意义的指示器指出系统当前的工作量。</li><li>/proc/meminfo<br>各种存储器使用信息，包括物理内存和交换分区( s w a p )。</li><li>/proc/modules<br>存放当前加载了哪些核心模块信息。</li><li>/proc/net<br>网络协议状态信息。</li><li>/proc/self<br>存放到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，这将会是不同的连接。这主要便于程序得到它自己的进程目录。</li><li>/proc/stat<br>系统的不同状态，例如，系统启动后页面发生错误的次数。</li><li>/proc/uptime<br>系统启动的时间长度。</li><li>/proc/version<br>核心版本</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2017/10/01/Maven/"/>
    <url>/2017/10/01/Maven/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>一个对Maven比较正式的定义是这么说的：Maven是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p><h2 id="Maven是干什么的？"><a href="#Maven是干什么的？" class="headerlink" title="Maven是干什么的？"></a>Maven是干什么的？</h2><p>即使不使用Maven 我们仍然可以进行B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案。</p><p>其实Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。</p><p>Maven所解决的问题<br>1、我们需要引用各种jar包，尤其是比较大的工程，引用的jar包往往有几十个乃至上百个， 每用到一种jar包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的jar包冲突，版本冲突。</p><p>2、我们辛辛苦苦写好了Java文件，可是只懂0和1的白痴电脑却完全读不懂，需要将它编译成二进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA等都可以将代码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用javac命令一个个地去编译，逗电脑玩。</p><p>3、世界上没有不存在bug的代码，计算机喜欢bug就和人们总是喜欢美女帅哥一样。为了追求美为了减少bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。</p><p>4、再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是web项目，还需要将之发布到服务器，供人蹂躏。</p><p>Maven就可以帮你构建工程，管理jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成Web站点。</p><h2 id="Maven的优势举例"><a href="#Maven的优势举例" class="headerlink" title="Maven的优势举例"></a>Maven的优势举例</h2><p>Web项目，要能够将项目运行起来，就必须将该项目所依赖的一些jar包添加到工程中，否则项目就不能运行。 试想如果具有相同架构的项目有十个，那么我们就需要将这一份jar包复制到十个不同的工程中。我们一起来看一个CRM项目的工程大小。</p><p>使用传统Web项目构建的CRM项目如下：</p><p>原因主要是因为上面的WEB程序要运行，我们必须将项目运行所需的Jar包复制到工程目录中，从而导致了工程很大。<br>同样的项目，如果我们使用Maven工程来构建，会发现总体上工程的大小会少很多。如下图:</p><h2 id="Maven的两个比较重要的作用"><a href="#Maven的两个比较重要的作用" class="headerlink" title="Maven的两个比较重要的作用"></a>Maven的两个比较重要的作用</h2><p>1.Maven的依赖管理<br>Maven的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven展示出了它对处理这种情形的高度控制。</p><p>传统的WEB项目中，我们必须将工程所依赖的jar包复制到工程中，导致了工程的变得很大。</p><p>那么maven工程是如何使得工程变得很少呢？<br><img src="/img/cphoto/maven01.jpg"></p><p>通过分析发现： maven工程中不直接将jar包导入到工程中， 而是通过在pom.xml文件中添加所需jar包的坐标，这样就很好的避免了jar直接引入进来，在需要用到jar包的时候，只要查找pom.xml文件，再通过pom.xml文件中的坐标，到一个专门用于”存放jar包的仓库”(maven仓库) 中根据坐标从而找到这些jar包，再把这些jar包拿去运行。</p><p>问题：通过读取pom.xml 文件中的坐标，再到仓库中找到jar包，会不会很慢？从而导致这种方式不可行！</p><p>答案： 通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包了，为了解决这个过程中速度慢的问题，maven中也有索引的概念，通过建立索引，可以大大提高加载jar包的速度，使得我们认为jar包基本跟放在本地的工程文件中再读取出来的速度是一样的。这个过程就好比我们查阅字典时，为了能够加快查找到内容，书前面的目录就好比是索引，有了这个目录我们就可以方便找到内容了，一样的在maven仓库中有了索引我们就可以认为可以快速找到jar包。</p><p>2.项目的一键构建<br>我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。</p><p>什么是构建？<br>指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven进行管理，这个过程称为构建。</p><p>①清理 ： 删除以前的编译结果，为重新编译做好准备。<br>②编译 ： 将 Java 源程序编译为字节码文件。<br>③测试 ： 针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。<br>④报告 ： 在每一次测试后以标准的格式记录和展示测试结果。<br>⑤打包 ： 将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。 Java 工程对应 jar 包， Web工程对应 war 包。<br>⑥安装 ： 在 Mav en 环境下特指将打包的结果 jar 包或 war 包安装到本地仓库中。<br>⑦部署 ： 将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</p><p>一键构建<br>指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。</p><p>Maven规范化构建流程如下：</p><p><img src="/img/cphoto/maven04.jpg"></p><h2 id="Maven核心概念"><a href="#Maven核心概念" class="headerlink" title="Maven核心概念"></a>Maven核心概念</h2><p>Maven能够 实现自动化构建 是 和它的内部原理 分不开 的， 这里 我们 从 Maven 的九个核心概念入手</p><p>Maven 自动化构建:<br>①POM<br>②约定的目录结构<br>③坐标<br>④依赖管理<br>⑤仓库管理<br>⑥生命周期<br>⑦插件和目标<br>⑧继承<br>⑨聚合</p><h2 id="Maven构建模型"><a href="#Maven构建模型" class="headerlink" title="Maven构建模型"></a>Maven构建模型</h2><p>Maven包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p><p>项目对象模型 (Project Object Model)<br>一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。</p><p>依赖管理系统(Dependency Management System)</p><p>一个项目生命周期(Project Lifecycle)</p><p>使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段：</p><p>maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。</p><p>一组标准集合</p><p>maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。</p><p>插件(plugin)目标(goal)<br>maven 管理项目生命周期过程都是基于插件完成的。</p><h2 id="Maven指令生命周期"><a href="#Maven指令生命周期" class="headerlink" title="Maven指令生命周期"></a>Maven指令生命周期</h2><p>maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”， 这三套生命周期分别是：</p><p>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。<br>Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。<br>Site Lifecycle 生成项目报告，站点，发布站点。</p><p>插件和目标<br>生命周期的各个阶段仅仅定义了要执行的任务是什么<br>各个阶段和插件的目标是对应的<br>相似的目标特定的插件来完成<br>可以将目标看作“调用插件功能的命令”</p><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><p>maven的工作需要从仓库下载一些jar包，如下图所示，本地的项目A、项目B等都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。</p><p><img src="/img/cphoto/maven05.jpg"></p><p>本地仓库 ： 用来存储从远程仓库或中央仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找<br>默认本地仓库位置在 u s e r . d i r / . m 2 / r e p o s i t o r y ， {user.dir}/.m2/repository，user.dir/.m2/repository，{user.dir}表示windows用户目录。</p><p>远程仓库(俗称私服）： 如果本地需要插件或者jar包，本地仓库没有，默认去远程仓库下载。<br>远程仓库可以在互联网内也可以在局域网内。</p><p>中央仓库 ： 在maven软件中内置一个远程仓库地址<a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。</p><p>仓库中保存的内容： Maven工程</p><p>1.maven自身所需要的插件</p><p>2.第三方的框架或工具的jar包</p><p>3.我们自己开发的maven工程</p><p>常见问题：</p><p>运行Maven工程时如果本地仓库配置错误会报下边的错误：</p><p>分析：<br>maven工程运行先从本地仓库找jar包，本地仓库没有再从中央仓库找，上边提示downloading…<br>表示 从中央仓库下载jar，由于本地没有联网，报错。<br>解决：<br>在maven安装目录的conf/setting.xml文件中配置本地仓库地址</p><p>Maven安装与配置<br>百度官网打开下载：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a><br>下载完后将Maven解压到自己规定的文件夹（不要用中文名）</p><p>Maven目录结构</p><p>bin:存放了maven的命令，比如我们前面用到的mvn tomcat:run<br>boot:存放了一些maven本身的引导程序，如类加载器等<br>conf:存放了maven的一些配置文件，如setting.xml文件<br>lib:存放了maven本身运行所需的一些jar包<br>至此我们的maven软件就可以使用了，前提是你的电脑上之前已经安装并配置好了JDK,运行Maven需要有JDK的支持</p><p>Maven配置<br>电脑上需安装java环境，安装JDK1.7 + 版本 （将JAVA_HOME/bin 配置环境变量path ），我们使用的是JDK8相关版本</p><p>配置 MAVEN_HOME ，变量值就是你的maven安装 的路径（bin目录之前一级目录）</p><p>再次检查JDK的安装目录，如下图：</p><p>配置好测试<br>cmd输入：mvn -v出现以下内容说明已经成功</p><p>配置本地仓库<br>在MAVE_HOME/conf/settings.xml文件中配置本地仓库位置（maven的安装目录下）</p><p>打开settings.xml文件，配置如下：</p><p> <localRepository>你的本地仓库路径</localRepository><br>这是我的本地仓库路径，以及存放的jar包</p><p>全局setting与用户setting<br>maven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。<br>在maven安装目录下的有 conf/setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。<br>如需要个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在：u s e r . d i r / . m 2 / s e t t i n g s . x m l 目 录 中 , {user.dir} /.m2/settings.xml目录中,user.dir/.m2/settings.xml目录中,{user.dir} 指windows 中的用户目录。<br>maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。</p><h2 id="Maven工程的认识"><a href="#Maven工程的认识" class="headerlink" title="Maven工程的认识"></a>Maven工程的认识</h2><p>Maven工程的目录结构</p><p>我以IDEA普通Maven工程为例：</p><p>IDEA中Web工程为例</p><p>src/main/java—— 存放项目的.java文件<br>src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件<br>src/test/java —— 存放所有单元测试.java文件，如JUnit测试类<br>src/test/resources —— 测试资源文件<br>target —— 项目输出位置，编译后的class文件会输出到此目录<br>pom.xml——maven项目核心配置文件<br>注意：如果是普通的java项目，那么就没有webapp目录。</p><h2 id="Maven的常用命令介绍"><a href="#Maven的常用命令介绍" class="headerlink" title="Maven的常用命令介绍"></a>Maven的常用命令介绍</h2><p>我在cmd中通过一系列的maven命令来对我的maven工程进行编译、测试、运行、打包、安装、部署。</p><p>compile<br>compile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。</p><p>cmd进入命令状态，执行mvn compile，如下图提示成功：</p><p>发现在我的项目目录里多出了这个文件：</p><p>test<br>test是maven工程的测试命令 mvn test，会执行src/test/java下的单元测试类。</p><p>cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行1个测试用例，全部成功：</p><p>clean<br>clean是maven工程的清理命令，执行 clean会删除target目录及内容。</p><p>package<br>package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。</p><p>install<br>install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。</p><h2 id="Maven坐标依赖"><a href="#Maven坐标依赖" class="headerlink" title="Maven坐标依赖"></a>Maven坐标依赖</h2><p>坐标使用如下三个向量在Maven 的仓库中唯一的确定一个 Maven 工程。</p><p>groupid：公司或组织的域名倒序 当前项目名称<br>artifactId：当前项目的模块名称<br>version：当前模块的版本</p><!--项目名称，定义为组织名+项目名，类似包名--><p><groupId>cn.itcast.maven</groupId></p><!-- 模块名称 --><p><artifactId>maven-first</artifactId></p><!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 --><p><version>0.0.1-SNAPSHOT</version><br><packaging>打包类型</packaging><br>jar：执行package会打成jar包<br>war：执行package会打成war包<br>pom ：用于maven工程的继承，通常父工程设置为pom</p><p>依赖小demo：</p><p>比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9</p><p>如下所示是junit4.9的依赖定义：</p><!-- 依赖关系 --><dependencies>        <!-- 此项目运行使用junit，所以此项目依赖junit -->        <dependency>            <!-- junit的项目名称 -->            <groupId>junit</groupId>            <!-- junit的模块名称 -->            <artifactId>junit</artifactId>            <!-- junit版本 -->            <version>4.9</version>            <!-- 依赖范围：单元测试时使用junit -->            <scope>test</scope>        </dependency></dependencies><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>A依赖B，需要在A的pom.xml文件中添加B的坐标，添加坐标时需要指定依赖范围，依赖范围包括：</p><p>compile：编译范围，指A在编译时依赖B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打z包。<br>provided：provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依赖在编译和测试时需要，在运行时不需要，比如：servlet api被tomcat容器提供。<br>runtime：runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以runtime范围的依赖会被打包。<br>test：test范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。<br>system：system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径，需要指定systemPath磁盘路径，system依赖不推荐使用。</p><p>在maven-web工程中测试各各scop。<br>测试总结：</p><p>默认引入 的jar包 ——- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ）<br>servlet-api 、jsp-api ——- provided （编译、测试 有效， 运行时无效 防止和tomcat下jar冲突）<br>jdbc驱动jar包 —- runtime （测试、运行 有效 ）<br>junit —– test （测试有效）<br>依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test<br>pom.xml基本配置<br>pom.xml是Maven项目的核心配置文件，位于每个工程的根目录，基本配置如下：</p><p>文件的根节点<br><project><br>    <artifactId> 模块名称，子项目名或模块名称就是Idea中的Module</artifactId><br>    <!--pom.xml使用的对象模型版本--><br>    <modelVersion>4.0.0</modelVersion><br>     <!--项目依赖构件配置，配置项目依赖构件的坐标--><br>    <dependencies><br>        <dependency><br>            <groupId>项目名称，一般写项目的域名</groupId><br>        <artifactId>模块名称，子项目名或模块名称</artifactId><br>            <version>产品的版本号</version><br>            <scope>依赖范围</scope><br>        </dependency><br>    </dependencies><br>    <build> 项目构建配置，配置编译、运行插件等。</build><br>    <name> 项目的显示名，常用于 Maven 生成的文档。</name><br>    <description>项目描述，常用于 Maven 生成的文档</description><br></project></p><p>依赖的传递性<br>假如：在你的Maven项目里定义了3个Maven工程</p><p>HelloFriend工程与工程2，和工程3</p><p>依赖关系：HelloFriend→工程2→工程3</p><p>我在HelloFriend这个最底层的工程添加了Spring-core依赖，那么在工程2和工程3中都有Spring-core的依赖，这个就是依赖的传递性</p><p>但是： 非compile范围的依赖不能传递，所以在各个工程的模块中，如果由需要，就得重复声明依赖。</p><p>依赖的排除</p><p>排除依赖的方式：</p><exclusions>        <exclusion>            <groupId>commos-logging</groupId>            <artifactId>commons-logging</artifactId>        </exclusion>    </exclusions><p>依赖的原则：</p><p>统一管理依赖的版本</p><p>继承<br>问题出现：</p><p>工程1依赖的Junit：4.0<br>工程2依赖的Junit：4.0<br>工程3依赖的Junit：4.9<br>由于依赖范围中的test不能传递，所以在各个模块的工程中，容易造成版本不一致</p><p>那么如何解决问题：让各个版本统一。</p><p>答案：将junit依赖统一到“父”工程中，在子工程中声明junit依赖时不指定版本</p><p>聚合<br>将多个工程拆分为模块后， 需要 手动逐个 安装 到仓库后 依赖 才能够生效。 修改 源码后 也 需要 逐个 手动进行 clean 操作。 而 使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。</p><p>在总的聚合工程中 使用 modules /module 标签 组合， 指定 模块工程的 相对 路径即 可</p><modules><module>../Hello</module><module>../HelloFriend</module><module>../MakeFriends</module></modules><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><h2 id="第一章：Maven基础回顾"><a href="#第一章：Maven基础回顾" class="headerlink" title="第一章：Maven基础回顾"></a>第一章：Maven基础回顾</h2><h3 id="1-1-Maven介绍"><a href="#1-1-Maven介绍" class="headerlink" title="1.1-Maven介绍"></a>1.1-Maven介绍</h3><ol><li>Maven是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。</li><li>依赖管理：就是对象jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。</li><li>项目构建：通过Maven的一个命令就可完成项目从清理、编译、测试、报告、打包，部署整个过程。</li></ol><h3 id="1-2-Maven仓库类型"><a href="#1-2-Maven仓库类型" class="headerlink" title="1.2-Maven仓库类型"></a>1.2-Maven仓库类型</h3><ol><li>本地仓库</li><li>远程仓库<ul><li>Maven中央仓库（地址：<a href="http://repo2.maven.org/maven2/%EF%BC%89">http://repo2.maven.org/maven2/）</a></li><li>maven私服（公司局域网内的仓库，需要自己搭建）</li><li>其他公共远程仓库（例如apache提供的远程仓库，地址：<a href="http://repo.maven.apache.org/maven2%EF%BC%89">http://repo.maven.apache.org/maven2）</a></li></ul></li></ol><h3 id="1-3-Maven常用命令"><a href="#1-3-Maven常用命令" class="headerlink" title="1.3-Maven常用命令"></a>1.3-Maven常用命令</h3><p><img src="/img/cphoto/maven06.jpg"></p><h3 id="1-4-Maven坐标书写规范"><a href="#1-4-Maven坐标书写规范" class="headerlink" title="1.4-Maven坐标书写规范"></a>1.4-Maven坐标书写规范</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>项目名<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>模块名<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Maven的依赖范围"><a href="#1-5-Maven的依赖范围" class="headerlink" title="1.5-Maven的依赖范围"></a>1.5-Maven的依赖范围</h3><p><img src="/img/cphoto/maven08.jpg"></p><h2 id="第二章：Maven的依赖传递"><a href="#第二章：Maven的依赖传递" class="headerlink" title="第二章：Maven的依赖传递"></a>第二章：Maven的依赖传递</h2><h3 id="2-1-什么是Maven的依赖传递"><a href="#2-1-什么是Maven的依赖传递" class="headerlink" title="2.1-什么是Maven的依赖传递"></a>2.1-什么是Maven的依赖传递</h3><p><img src="/img/cphoto/maven09.jpg"></p><h3 id="2-2-什么是依赖冲突"><a href="#2-2-什么是依赖冲突" class="headerlink" title="2.2-什么是依赖冲突"></a>2.2-什么是依赖冲突</h3><p><img src="/img/cphoto/maven10.jpg"></p><h3 id="2-3-如何解决依赖冲突"><a href="#2-3-如何解决依赖冲突" class="headerlink" title="2.3-如何解决依赖冲突"></a>2.3-如何解决依赖冲突</h3><p>1,使用maven提供的依赖调节原则</p><ul><li>第一声明者优先原则</li><li>路径近者优先原则</li></ul><p>2,排除依赖<br>3,锁定版本</p><h3 id="2-4-依赖调节原则"><a href="#2-4-依赖调节原则" class="headerlink" title="2.4-依赖调节原则"></a>2.4-依赖调节原则</h3><blockquote><p>第一声明优先原则</p></blockquote><p><img src="/img/cphoto/maven11.jpg"></p><blockquote><p>路径近者优先原则</p></blockquote><p><img src="/img/cphoto/maven12.jpg"></p><h3 id="2-5-排除依赖"><a href="#2-5-排除依赖" class="headerlink" title="2.5-排除依赖"></a>2.5-排除依赖</h3><p><img src="/img/cphoto/maven13.jpg"></p><h3 id="2-6-版本锁定"><a href="#2-6-版本锁定" class="headerlink" title="2.6-版本锁定"></a>2.6-版本锁定</h3><p><img src="/img/cphoto/maven14.jpg"></p><p><img src="/img/cphoto/maven15.jpg"></p><h2 id="第三章：分模块构建Maven工程"><a href="#第三章：分模块构建Maven工程" class="headerlink" title="第三章：分模块构建Maven工程"></a>第三章：分模块构建Maven工程</h2><h3 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1-分析"></a>3.1-分析</h3><blockquote><p>开发中</p></blockquote><p><img src="/img/cphoto/maven16.jpg"></p><h3 id="3-2-Maven工程的继承"><a href="#3-2-Maven工程的继承" class="headerlink" title="3.2-Maven工程的继承"></a>3.2-Maven工程的继承</h3><p><img src="/img/cphoto/maven17.jpg"></p><h3 id="3-3-Maven工程的聚合"><a href="#3-3-Maven工程的聚合" class="headerlink" title="3.3-Maven工程的聚合"></a>3.3-Maven工程的聚合</h3><p><img src="/img/cphoto/maven18.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2017/09/30/Redis/"/>
    <url>/2017/09/30/Redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库    1.1.什么是NOSQL        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。        1.1.1.    NOSQL和关系型数据库比较            优点：                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。            缺点：                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。                3）不提供关系型数据库对事务的处理。        1.1.2.    非关系型数据库的优势：            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。        1.1.3.    关系型数据库的优势：            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。        1.1.4.    总结            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，            让NoSQL数据库对关系型数据库的不足进行弥补。            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据    1.2.主流的NOSQL产品        •    键值(Key-Value)存储数据库                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。                 数据模型： 一系列键值对                优势： 快速查询                劣势： 存储的数据缺少结构化        •    列存储数据库                相关产品：Cassandra, HBase, Riak                典型应用：分布式的文件系统                数据模型：以列簇式存储，将同一列数据存在一起                优势：查找速度快，可扩展性强，更容易进行分布式扩展                劣势：功能相对局限        •    文档型数据库                相关产品：CouchDB、MongoDB                典型应用：Web应用（与Key-Value类似，Value是结构化的）                数据模型： 一系列键值对                优势：数据结构要求不严格                劣势： 查询性能不高，而且缺乏统一的查询语法        •    图形(Graph)数据库                相关数据库：Neo4J、InfoGrid、Infinite Graph                典型应用：社交网络                数据模型：图结构                优势：利用图结构相关算法。                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。    1.3 什么是Redis        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：            1) 字符串类型 string            2) 哈希类型 hash            3) 列表类型 list            4) 集合类型 set            5) 有序集合类型 sortedset        1.3.1 redis的应用场景            •    缓存（数据查询、短连接、新闻内容、商品内容等等）            •    聊天室的在线好友列表            •    任务队列。（秒杀、抢购、12306等等）            •    应用排行榜            •    网站访问统计            •    数据过期处理（可以精确到毫秒            •    分布式集群架构中的session分离2. 下载安装    1. 官网：https://redis.io    2. 中文网：http://www.redis.net.cn/    3. 解压直接可以使用：        * redis.windows.conf：配置文件        * redis-cli.exe：redis的客户端        * redis-server.exe：redis服务器端    3. 命令操作    1. redis的数据结构：        * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构            * value的数据结构：                1) 字符串类型 string                2) 哈希类型 hash ： map格式                  3) 列表类型 list ： linkedlist格式。支持重复元素                4) 集合类型 set  ： 不允许重复元素                5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序        2. 字符串类型 string        1. 存储： set key value            127.0.0.1:6379&gt; set username zhangsan            OK        2. 获取： get key            127.0.0.1:6379&gt; get username            &quot;zhangsan&quot;        3. 删除： del key            127.0.0.1:6379&gt; del age            (integer) 1    3. 哈希类型 hash        1. 存储： hset key field value            127.0.0.1:6379&gt; hset myhash username lisi            (integer) 1            127.0.0.1:6379&gt; hset myhash password 123            (integer) 1        2. 获取：             * hget key field: 获取指定的field对应的值                127.0.0.1:6379&gt; hget myhash username                &quot;lisi&quot;            * hgetall key：获取所有的field和value                127.0.0.1:6379&gt; hgetall myhash                1) &quot;username&quot;                2) &quot;lisi&quot;                3) &quot;password&quot;                4) &quot;123&quot;                        3. 删除： hdel key field            127.0.0.1:6379&gt; hdel myhash username            (integer) 1        4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）        1. 添加：            1. lpush key value: 将元素加入列表左表                            2. rpush key value：将元素加入列表右边                                127.0.0.1:6379&gt; lpush myList a                (integer) 1                127.0.0.1:6379&gt; lpush myList b                (integer) 2                127.0.0.1:6379&gt; rpush myList c                (integer) 3        2. 获取：            * lrange key start end ：范围获取                127.0.0.1:6379&gt; lrange myList 0 -1                1) &quot;b&quot;                2) &quot;a&quot;                3) &quot;c&quot;        3. 删除：            * lpop key： 删除列表最左边的元素，并将元素返回            * rpop key： 删除列表最右边的元素，并将元素返回    5. 集合类型 set ： 不允许重复元素        1. 存储：sadd key value            127.0.0.1:6379&gt; sadd myset a            (integer) 1            127.0.0.1:6379&gt; sadd myset a            (integer) 0        2. 获取：smembers key:获取set集合中所有元素            127.0.0.1:6379&gt; smembers myset            1) &quot;a&quot;        3. 删除：srem key value:删除set集合中的某个元素                127.0.0.1:6379&gt; srem myset a            (integer) 1    6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。        1. 存储：zadd key score value            127.0.0.1:6379&gt; zadd mysort 60 zhangsan            (integer) 1            127.0.0.1:6379&gt; zadd mysort 50 lisi            (integer) 1            127.0.0.1:6379&gt; zadd mysort 80 wangwu            (integer) 1        2. 获取：zrange key start end [withscores]            127.0.0.1:6379&gt; zrange mysort 0 -1            1) &quot;lisi&quot;            2) &quot;zhangsan&quot;            3) &quot;wangwu&quot;            127.0.0.1:6379&gt; zrange mysort 0 -1 withscores            1) &quot;zhangsan&quot;            2) &quot;60&quot;            3) &quot;wangwu&quot;            4) &quot;80&quot;            5) &quot;lisi&quot;            6) &quot;500&quot;        3. 删除：zrem key value            127.0.0.1:6379&gt; zrem mysort lisi            (integer) 1    7. 通用命令        1. keys * : 查询所有的键        2. type key ： 获取键对应的value的类型        3. del key：删除指定的key value4. 持久化    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。    2. redis持久化机制：        1. RDB：默认方式，不需要进行配置，默认就使用这种机制            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据            1. 编辑redis.windwos.conf文件                #   after 900 sec (15 min) if at least 1 key changed                save 900 1                #   after 300 sec (5 min) if at least 10 keys changed                save 300 10                #   after 60 sec if at least 10000 keys changed                save 60 10000                            2. 重新启动redis服务器，并指定配置文件名称                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf                        2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据            1. 编辑redis.windwos.conf文件                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）                                # appendfsync always ： 每一次操作都进行持久化                appendfsync everysec ： 每隔一秒进行一次持久化                # appendfsync no     ： 不进行持久化5. Java客户端 Jedis    * Jedis: 一款java操作redis数据库的工具.    * 使用步骤：        1. 下载jedis的jar包        2. 使用            //1. 获取连接            Jedis jedis = new Jedis(&quot;localhost&quot;,6379);               //2. 操作               jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //3. 关闭连接            jedis.close();</code></pre><p>​        </p><pre><code>    * Jedis操作各种redis中的数据结构        1) 字符串类型 string            set            get                         //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            //存储            jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //获取            String username = jedis.get(&quot;username&quot;);            System.out.println(username);                //可以使用setex()方法存储可以指定过期时间的 key value            jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对                //3. 关闭连接            jedis.close();        2) 哈希类型 hash ： map格式              hset            hget            hgetAll            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // 存储hash            jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);            jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);            jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);                // 获取hash            String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);            System.out.println(name);</code></pre><p>​        </p><pre><code>            // 获取hash的所有map中的数据            Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;);                // keyset            Set&lt;String&gt; keySet = user.keySet();            for (String key : keySet) &#123;                //获取value                String value = user.get(key);                System.out.println(key + &quot;:&quot; + value);            &#125;                //3. 关闭连接            jedis.close();        3) 列表类型 list ： linkedlist格式。支持重复元素            lpush / rpush            lpop / rpop            lrange start end : 范围获取                         //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // list 存储            jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存            jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存                // list 范围获取            List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist);                        // list 弹出            String element1 = jedis.lpop(&quot;mylist&quot;);//c            System.out.println(element1);                String element2 = jedis.rpop(&quot;mylist&quot;);//c            System.out.println(element2);                // list 范围获取            List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist2);                //3. 关闭连接            jedis.close();        4) 集合类型 set  ： 不允许重复元素            sadd            smembers:获取所有元素            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作</code></pre><p>​        </p><pre><code>            // set 存储            jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);                // set 获取            Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);            System.out.println(myset);                //3. 关闭连接            jedis.close();        5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序            zadd            zrange            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // sortedset 存储            jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);            jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);            jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);                // sortedset 获取            Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);                System.out.println(mysortedset);</code></pre><p>​        </p><pre><code>            //3. 关闭连接            jedis.close();</code></pre><p>​        </p><pre><code>    * jedis连接池： JedisPool        * 使用：            1. 创建JedisPool连接池对象            2. 调用方法 getResource()方法获取Jedis连接                //0.创建一个配置对象                JedisPoolConfig config = new JedisPoolConfig();                config.setMaxTotal(50);                config.setMaxIdle(10);                        //1.创建Jedis连接池对象                JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379);                        //2.获取连接                Jedis jedis = jedisPool.getResource();                //3. 使用                jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);</code></pre><p>​            </p><pre><code>                //4. 关闭 归还到连接池中                jedis.close();                * 连接池工具类            public class JedisPoolUtils &#123;                private static JedisPool jedisPool;                            static&#123;                    //读取配置文件                    InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);                    //创建Properties对象                    Properties pro = new Properties();                    //关联文件                    try &#123;                        pro.load(is);                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                    //获取数据，设置到JedisPoolConfig中                    JedisPoolConfig config = new JedisPoolConfig();                    config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));                    config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));                                //初始化JedisPool                    jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</code></pre><p>​<br>​                </p><pre><code>                &#125;</code></pre><p>​                </p><pre><code>                /**                 * 获取连接方法                 */                public static Jedis getJedis()&#123;                    return jedisPool.getResource();                &#125;            &#125;</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：    1. 提供index.html页面，页面中有一个省份 下拉列表    2. 当 页面加载完成后 发送ajax请求，加载所有省份* 注意：使用redis缓存一些不经常发生变化的数据。    * 数据库的数据一旦发生改变，则需要更新缓存。        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入        * 在service对应的增删改方法中，将redis数据删除。</code></pre><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery</title>
    <link href="/2017/09/29/JQuery/"/>
    <url>/2017/09/29/JQuery/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JQuery-基础："><a href="#JQuery-基础：" class="headerlink" title="JQuery 基础："></a>JQuery 基础：</h1><pre><code>1. 概念： 一个JavaScript框架。简化JS开发    * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。    * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已2. 快速入门    1. 步骤：        1. 下载JQuery            * 目前jQuery有三个大版本：                1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，                     功能不再新增。因此一般项目来说，使用1.x版本就可以了，                     最终版本：1.12.4 (2016年5月20日)                2.x：不兼容ie678，很少有人使用，官方只做BUG维护，                     功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，                     最终版本：2.2.4 (2016年5月20日)                3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，                     一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。                     目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）            * jquery-xxx.js 与 jquery-xxx.min.js区别：                1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些                2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快        2. 导入JQuery的js文件：导入min.js文件        3. 使用            var div1 = $(&quot;#div1&quot;);               alert(div1.html());3. JQuery对象和JS对象区别与转换    1. JQuery对象在操作时，更加方便。    2. JQuery对象和js对象方法不通用的.    3. 两者相互转换        * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引)        * js -- &gt; jq : $(js对象)4. 选择器：筛选具有相似特征的元素(标签)    1. 基本操作学习：        1. 事件绑定            //1.获取b1按钮            $(&quot;#b1&quot;).click(function()&#123;                alert(&quot;abc&quot;);            &#125;);        2. 入口函数             $(function () &#123;                               &#125;);             window.onload  和 $(function) 区别                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉                 * $(function)可以定义多次的。        3. 样式控制：css方法             // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);              $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);    2. 分类        1. 基本选择器            1. 标签选择器（元素选择器）                * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素            2. id选择器                 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素            3. 类选择器                * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素            4. 并集选择器：                * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素        2. 层级选择器            1. 后代选择器                * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素                    2. 子选择器                * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素        3. 属性选择器            1. 属性名称选择器                 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器            2. 属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器            3. 复合属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器        4. 过滤选择器            1. 首元素选择器                 * 语法： :first 获得选择的元素中的第一个元素            2. 尾元素选择器                 * 语法： :last 获得选择的元素中的最后一个元素            3. 非元素选择器                * 语法： :not(selector) 不包括指定内容的元素            4. 偶数选择器                * 语法： :even 偶数，从 0 开始计数            5. 奇数选择器                * 语法： :odd 奇数，从 0 开始计数            6. 等于索引选择器                * 语法： :eq(index) 指定索引元素            7. 大于索引选择器                 * 语法： :gt(index) 大于指定索引元素            8. 小于索引选择器                 * 语法： :lt(index) 小于指定索引元素            9. 标题选择器                * 语法： :header 获得标题（h1~h6）元素，固定写法        5. 表单过滤选择器            1. 可用元素选择器                 * 语法： :enabled 获得可用元素            2. 不可用元素选择器                 * 语法： :disabled 获得不可用元素            3. 选中选择器                 * 语法： :checked 获得单选/复选框选中的元素            4. 选中选择器                 * 语法： :selected 获得下拉框选中的元素5. DOM操作    1. 内容操作        1. html(): 获取/设置元素的标签体内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;        2. text(): 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容        3. val()： 获取/设置元素的value属性值    2. 属性操作        1. 通用属性操作            1. attr(): 获取/设置元素的属性            2. removeAttr():删除属性            3. prop():获取/设置元素的属性            4. removeProp():删除属性            * attr和prop区别？                1. 如果操作的是元素的固有属性，则建议使用prop                2. 如果操作的是元素自定义的属性，则建议使用attr        2. 对class属性操作            1. addClass():添加class属性值            2. removeClass():删除class属性值            3. toggleClass():切换class属性                * toggleClass(&quot;one&quot;):                     * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。  如果元素对象上不存在class=&quot;one&quot;，则添加            4. css():    3. CRUD操作:        1. append():父元素将子元素追加到末尾            * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾        2. prepend():父元素将子元素追加到开头            * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头        3. appendTo():            * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾        4. prependTo()：            * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头        5. after():添加元素到元素后边            * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系        6. before():添加元素到元素前边            * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        7. insertAfter()            * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系        8. insertBefore()            * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        9. remove():移除元素            * 对象.remove():将对象删除掉        10. empty():清空元素的所有后代元素。            * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点6. 案例</code></pre><h2 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h2><pre><code>1. JQuery 高级    1. 动画    2. 遍历    3. 事件绑定    4. 案例    5. 插件</code></pre><h2 id="JQuery-高级"><a href="#JQuery-高级" class="headerlink" title="JQuery 高级"></a>JQuery 高级</h2><pre><code>1. 动画    1. 三种方式显示和隐藏元素        1. 默认显示和隐藏方式            1. show([speed,[easing],[fn]])                1. 参数：                    1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)                    2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;                        * swing：动画执行时效果是 先慢，中间快，最后又慢                        * linear：动画执行时速度是匀速的                    3. fn：在动画完成时执行的函数，每个元素执行一次。            2. hide([speed,[easing],[fn]])            3. toggle([speed],[easing],[fn])                2. 滑动显示和隐藏方式            1. slideDown([speed],[easing],[fn])            2. slideUp([speed,[easing],[fn]])            3. slideToggle([speed],[easing],[fn])        3. 淡入淡出显示和隐藏方式            1. fadeIn([speed],[easing],[fn])            2. fadeOut([speed],[easing],[fn])            3. fadeToggle([speed,[easing],[fn]])2. 遍历    1. js的遍历方式        * for(初始化值;循环结束条件;步长)    2. jq的遍历方式        1. jq对象.each(callback)            1. 语法：                jquery对象.each(function(index,element)&#123;&#125;);                    * index:就是元素在集合中的索引                    * element：就是集合中的每一个元素对象                    * this：集合中的每一个元素对象            2. 回调函数返回值：                * true:如果当前function返回为false，则结束循环(break)。                * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)        2. $.each(object, [callback])        3. for..of: jquery 3.0 版本之后提供的方式            for(元素对象 of 容器对象)    3. 事件绑定    1. jquery标准的绑定方式        * jq对象.事件方法(回调函数)；        * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。            * 表单对象.submit();//让表单提交    2. on绑定事件/off解除绑定        * jq对象.on(&quot;事件名称&quot;,回调函数)        * jq对象.off(&quot;事件名称&quot;)            * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑    3. 事件切换：toggle        * jq对象.toggle(fn1,fn2...)            * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....                    * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。             &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;4. 案例    1. 广告显示和隐藏        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt;            &lt;style&gt;                #content&#123;width:100%;height:500px;background:#999&#125;            &lt;/style&gt;                    &lt;!--引入jquery--&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script&gt;                /*                    需求：                        1. 当页面加载完，3秒后。自动显示广告                        2. 广告显示5秒后，自动消失。                            分析：                        1. 使用定时器来完成。setTimeout (执行一次定时器)                        2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display                        3. 使用  show/hide方法来完成广告的显示                 */                        //入口函数，在页面加载完成之后，定义定时器，调用这两个方法                $(function () &#123;                   //定义定时器，调用adShow方法 3秒后执行一次                   setTimeout(adShow,3000);                   //定义定时器，调用adHide方法，8秒后执行一次                    setTimeout(adHide,8000);                &#125;);                //显示广告                function adShow() &#123;                    //获取广告div，调用显示方法                    $(&quot;#ad&quot;).show(&quot;slow&quot;);                &#125;                //隐藏广告                function adHide() &#123;                    //获取广告div，调用隐藏方法                    $(&quot;#ad&quot;).hide(&quot;slow&quot;);                &#125;</code></pre><p>​<br>​            </p><pre><code>            &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;!-- 整体的DIV --&gt;        &lt;div&gt;            &lt;!-- 广告DIV --&gt;            &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt;                &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt;            &lt;/div&gt;                    &lt;!-- 下方正文部分 --&gt;            &lt;div id=&quot;content&quot;&gt;                正文部分            &lt;/div&gt;        &lt;/div&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 抽奖        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;jquery案例之抽奖&lt;/title&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;                    &lt;script language=&#39;javascript&#39; type=&#39;text/javascript&#39;&gt;                        /*                    分析：                        1. 给开始按钮绑定单击事件                            1.1 定义循环定时器                            1.2 切换小相框的src属性                                * 定义数组，存放图片资源路径                                * 生成随机数。数组索引</code></pre><p>​            </p><pre><code>                        2. 给结束按钮绑定单击事件                            1.1 停止定时器                            1.2 给大相框设置src属性                         */                var imgs = [&quot;../img/man00.jpg&quot;,                            &quot;../img/man01.jpg&quot;,                            &quot;../img/man02.jpg&quot;,                            &quot;../img/man03.jpg&quot;,                            &quot;../img/man04.jpg&quot;,                            &quot;../img/man05.jpg&quot;,                            &quot;../img/man06.jpg&quot;,                            ];                var startId;//开始定时器的id                var index;//随机角标                $(function () &#123;                    //处理按钮是否可以使用的效果                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</code></pre><p>​            </p><pre><code>                   //1. 给开始按钮绑定单击事件                    $(&quot;#startID&quot;).click(function () &#123;                        // 1.1 定义循环定时器 20毫秒执行一次                        startId = setInterval(function () &#123;                            //处理按钮是否可以使用的效果                            $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true);                            $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false);</code></pre><p>​            </p><pre><code>                            //1.2生成随机角标 0-6                            index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999                            //1.3设置小相框的src属性                            $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);                                &#125;,20);                    &#125;);</code></pre><p>​            </p><pre><code>                    //2. 给结束按钮绑定单击事件                    $(&quot;#stopID&quot;).click(function () &#123;                        //处理按钮是否可以使用的效果                        $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                        $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</code></pre><p>​            </p><pre><code>                       // 1.1 停止定时器                        clearInterval(startId);                       // 1.2 给大相框设置src属性                        $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide();                        //显示1秒之后                        $(&quot;#img2ID&quot;).show(1000);                    &#125;);                &#125;);</code></pre><p>​<br>​<br>​            </p><pre><code>            &lt;/script&gt;                &lt;/head&gt;        &lt;body&gt;                &lt;!-- 小像框 --&gt;        &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;            &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;        &lt;/div&gt;                &lt;!-- 大像框 --&gt;        &lt;div                style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;            &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;        &lt;/div&gt;                &lt;!-- 开始按钮 --&gt;        &lt;input                id=&quot;startID&quot;                type=&quot;button&quot;                value=&quot;点击开始&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;                &lt;!-- 停止按钮 --&gt;        &lt;input                id=&quot;stopID&quot;                type=&quot;button&quot;                value=&quot;点击停止&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;</code></pre><p>​            </p><pre><code>        &lt;/body&gt;        &lt;/html&gt;5. 插件：增强JQuery的功能    1. 实现方式：        1. $.fn.extend(object)             * 增强通过Jquery获取的对象的功能  $(&quot;#id&quot;)        2. $.extend(object)            * 增强JQeury对象自身的功能  $/jQuery</code></pre><p>​            </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat&amp;Servlet</title>
    <link href="/2017/09/26/Tomcat&amp;Servlet/"/>
    <url>/2017/09/26/Tomcat&amp;Servlet/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tomcat-amp-Servlet"><a href="#Tomcat-amp-Servlet" class="headerlink" title="Tomcat&amp;Servlet"></a>Tomcat&amp;Servlet</h1><pre><code>1. web相关概念回顾2. web服务器软件：Tomcat3. Servlet入门学习</code></pre><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人                * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称                * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。* 快速入门：    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;            &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;* 执行原理：    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法* Servlet中的生命周期方法：    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target(&#123;ElementType.TYPE&#125;)            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet &#123;                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                            String[] value() default &#123;&#125;;//代表urlPatterns()属性配置                            String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;                            int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                            WebInitParam[] initParams() default &#123;&#125;;                            boolean asyncSupported() default false;                            String smallIcon() default &quot;&quot;;                            String largeIcon() default &quot;&quot;;                            String description() default &quot;&quot;;                            String displayName() default &quot;&quot;;            &#125;</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre><h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><pre><code>1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0 注解配置6. Servlet的体系结构        Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法7. Servlet相关配置    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre><h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><pre><code>* 概念：Hyper Text Transfer Protocol 超文本传输协议    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式    * 特点：        1. 基于TCP/IP的高级协议        2. 默认端口号:80        3. 基于请求/响应模型的:一次请求对应一次响应        4. 无状态的：每次请求之间相互独立，不能交互数据    * 历史版本：        * 1.0：每一次请求响应都会建立新的连接        * 1.1：复用连接* 请求消息数据格式    1. 请求行        请求方式 请求url 请求协议/版本        GET /login.html    HTTP/1.1        * 请求方式：            * HTTP协议有7中请求方式，常用的有2种                * GET：                    1. 请求参数在请求行中，在url后。                    2. 请求的url长度有限制的                    3. 不太安全                * POST：                    1. 请求参数在请求体中                    2. 请求的url长度没有限制的                    3. 相对安全    2. 请求头：客户端浏览器告诉服务器一些信息        请求头名称: 请求头值        * 常见的请求头：            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题            2. Referer：http://localhost/login.html                * 告诉服务器，我(当前请求)从哪里来？                    * 作用：                        1. 防盗链：                        2. 统计工作：    3. 请求空行        空行，就是用于分割POST请求的请求头，和请求体的。    4. 请求体(正文)：        * 封装POST请求消息的请求参数的    * 字符串格式：        POST /login.html    HTTP/1.1        Host: localhost        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2        Accept-Encoding: gzip, deflate        Referer: http://localhost/login.html        Connection: keep-alive        Upgrade-Insecure-Requests: 1                username=zhangsan    * 响应消息数据格式</code></pre><h2 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h2><pre><code>1. request对象和response对象的原理    1. request和response对象是由服务器创建的。我们来使用它们    2. request对象是来获取请求消息，response对象是来设置响应消息2. request对象继承体系结构：        ServletRequest        --    接口        |    继承    HttpServletRequest    -- 接口        |    实现    org.apache.catalina.connector.RequestFacade 类(tomcat)3. request功能：    1. 获取请求消息数据        1. 获取请求行数据            * GET /day14/demo1?name=zhangsan HTTP/1.1            * 方法：                1. 获取请求方式 ：GET                    * String getMethod()                  2. (*)获取虚拟目录：/day14                    * String getContextPath()                3. 获取Servlet路径: /demo1                    * String getServletPath()                4. 获取get方式请求参数：name=zhangsan                    * String getQueryString()                5. (*)获取请求URI：/day14/demo1                    * String getRequestURI():        /day14/demo1                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国                    * URI：统一资源标识符 : /day14/demo1                    共和国                                6. 获取协议及版本：HTTP/1.1                    * String getProtocol()                7. 获取客户机的IP地址：                    * String getRemoteAddr()                        2. 获取请求头数据            * 方法：                * (*)String getHeader(String name):通过请求头的名称获取请求头的值                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称                    3. 获取请求体数据:            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数            * 步骤：                1. 获取流对象                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据                        * 在文件上传知识点后讲解                2. 再从流对象中拿数据</code></pre><p>​                </p><pre><code>    2. 其他功能：        1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数            1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123            2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game            3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称            4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合            * 中文乱码问题：                * get方式：tomcat 8 已经将get方式乱码问题解决了                * post方式：会乱码                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);</code></pre><p>​                    </p><pre><code>        2. 请求转发：一种在服务器内部的资源跳转方式            1. 步骤：                1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)                2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)             2. 特点：                1. 浏览器地址栏路径不发生变化                2. 只能转发到当前服务器内部资源中。                3. 转发是一次请求        3. 共享数据：            * 域对象：一个有作用范围的对象，可以在范围内共享数据            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据            * 方法：                1. void setAttribute(String name,Object obj):存储数据                2. Object getAttitude(String name):通过键获取值                3. void removeAttribute(String name):通过键移除键值对        4. 获取ServletContext：            * ServletContext getServletContext()</code></pre><h2 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h2><pre><code>* 用户登录案例需求：    1.编写login.html登录页面        username &amp; password 两个输入框    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表    3.使用JdbcTemplate技术封装JDBC    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误* 分析* 开发步骤    1. 创建项目，导入html页面，配置文件，jar包    2. 创建数据库环境        CREATE DATABASE day14;        USE day14;        CREATE TABLE USER(                    id INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(32) UNIQUE NOT NULL,            PASSWORD VARCHAR(32) NOT NULL        );    3. 创建包cn.itcast.domain,创建类User        package cn.itcast.domain;        /**         * 用户的实体类         */        public class User &#123;                    private int id;            private String username;            private String password;</code></pre><p>​            </p><pre><code>            public int getId() &#123;                return id;            &#125;                    public void setId(int id) &#123;                this.id = id;            &#125;                    public String getUsername() &#123;                return username;            &#125;                    public void setUsername(String username) &#123;                this.username = username;            &#125;                    public String getPassword() &#123;                return password;            &#125;                    public void setPassword(String password) &#123;                this.password = password;            &#125;                    @Override            public String toString() &#123;                return &quot;User&#123;&quot; +                        &quot;id=&quot; + id +                        &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                        &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                        &#39;&#125;&#39;;            &#125;        &#125;    4. 创建包cn.itcast.util,编写工具类JDBCUtils        package cn.itcast.util;        import com.alibaba.druid.pool.DruidDataSourceFactory;                import javax.sql.DataSource;        import javax.xml.crypto.Data;        import java.io.IOException;        import java.io.InputStream;        import java.sql.Connection;        import java.sql.SQLException;        import java.util.Properties;                /**         * JDBC工具类 使用Durid连接池         */        public class JDBCUtils &#123;                    private static DataSource ds ;                    static &#123;                        try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    //使用ClassLoader加载配置文件，获取字节输入流                    InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);                    pro.load(is);                            //2.初始化连接池对象                    ds = DruidDataSourceFactory.createDataSource(pro);                        &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;                    /**             * 获取连接池对象             */            public static DataSource getDataSource()&#123;                return ds;            &#125;</code></pre><p>​            </p><pre><code>            /**             * 获取连接Connection对象             */            public static Connection getConnection() throws SQLException &#123;                return  ds.getConnection();            &#125;        &#125;    5. 创建包cn.itcast.dao,创建类UserDao,提供login方法                package cn.itcast.dao;        import cn.itcast.domain.User;        import cn.itcast.util.JDBCUtils;        import org.springframework.dao.DataAccessException;        import org.springframework.jdbc.core.BeanPropertyRowMapper;        import org.springframework.jdbc.core.JdbcTemplate;                /**         * 操作数据库中User表的类         */        public class UserDao &#123;                    //声明JDBCTemplate对象共用            private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                    /**             * 登录方法             * @param loginUser 只有用户名和密码             * @return user包含用户全部数据,没有查询到，返回null             */            public User login(User loginUser)&#123;                try &#123;                    //1.编写sql                    String sql = &quot;select * from user where username = ? and password = ?&quot;;                    //2.调用query方法                    User user = template.queryForObject(sql,                            new BeanPropertyRowMapper&lt;User&gt;(User.class),                            loginUser.getUsername(), loginUser.getPassword());</code></pre><p>​            </p><pre><code>                    return user;                &#125; catch (DataAccessException e) &#123;                    e.printStackTrace();//记录日志                    return null;                &#125;            &#125;        &#125;        6. 编写cn.itcast.web.servlet.LoginServlet类        package cn.itcast.web.servlet;        import cn.itcast.dao.UserDao;        import cn.itcast.domain.User;                import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;</code></pre><p>​            </p><pre><code>        @WebServlet(&quot;/loginServlet&quot;)        public class LoginServlet extends HttpServlet &#123;</code></pre><p>​            </p><pre><code>            @Override            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                //1.设置编码                req.setCharacterEncoding(&quot;utf-8&quot;);                //2.获取请求参数                String username = req.getParameter(&quot;username&quot;);                String password = req.getParameter(&quot;password&quot;);                //3.封装user对象                User loginUser = new User();                loginUser.setUsername(username);                loginUser.setPassword(password);                        //4.调用UserDao的login方法                UserDao dao = new UserDao();                User user = dao.login(loginUser);                        //5.判断user                if(user == null)&#123;                    //登录失败                    req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp);                &#125;else&#123;                    //登录成功                    //存储数据                    req.setAttribute(&quot;user&quot;,user);                    //转发                    req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp);                &#125;                    &#125;                    @Override            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                this.doGet(req,resp);            &#125;        &#125;    7. 编写FailServlet和SuccessServlet类        @WebServlet(&quot;/successServlet&quot;)        public class SuccessServlet extends HttpServlet &#123;            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                //获取request域中共享的user对象                User user = (User) request.getAttribute(&quot;user&quot;);                        if(user != null)&#123;                    //给页面写一句话                            //设置编码                    response.setContentType(&quot;text/html;charset=utf-8&quot;);                    //输出                    response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;);                &#125;</code></pre><p>​            </p><pre><code>            &#125;                @WebServlet(&quot;/failServlet&quot;)        public class FailServlet extends HttpServlet &#123;            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                //给页面写一句话                        //设置编码                response.setContentType(&quot;text/html;charset=utf-8&quot;);                //输出                response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;);                    &#125;                    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                this.doPost(request,response);            &#125;        &#125;    8. login.html中form表单的action路径的写法        * 虚拟目录+Servlet的资源路径    9. BeanUtils工具类，简化数据封装        * 用于封装JavaBean的        1. JavaBean：标准的Java类            1. 要求：                1. 类必须被public修饰                2. 必须提供空参的构造器                3. 成员变量必须使用private修饰                4. 提供公共setter和getter方法            2. 功能：封装数据        2. 概念：            成员变量：            属性：setter和getter方法截取后的产物                例如：getUsername() --&gt; Username--&gt; username        3. 方法：            1. setProperty()            2. getProperty()            3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre><h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><pre><code>1. 请求消息：客户端发送给服务器端的数据    * 数据格式：        1. 请求行        2. 请求头        3. 请求空行        4. 请求体2. 响应消息：服务器端发送给客户端的数据    * 数据格式：        1. 响应行            1. 组成：协议/版本 响应状态码 状态码描述            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。                1. 状态码都是3位数字                 2. 分类：                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码                    2. 2xx：成功。代表：200                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)                    4. 4xx：客户端错误。                        * 代表：                            * 404（请求路径没有对应的资源）                             * 405：请求方式没有对应的doXxx方法                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)</code></pre><p>​                    </p><pre><code>        2. 响应头：            1. 格式：头名称： 值            2. 常见的响应头：                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据                    * 值：                        * in-line:默认值,在当前页面内打开                        * attachment;filename=xxx：以附件形式打开响应体。文件下载        3. 响应空行        4. 响应体:传输的数据    * 响应字符串格式        HTTP/1.1 200 OK        Content-Type: text/html;charset=UTF-8        Content-Length: 101        Date: Wed, 06 Jun 2018 07:08:42 GMT        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;$Title$&lt;/title&gt;          &lt;/head&gt;          &lt;body&gt;          hello , response          &lt;/body&gt;        &lt;/html&gt;</code></pre><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息    1. 设置响应行        1. 格式：HTTP/1.1 200 ok        2. 设置状态码：setStatus(int sc)     2. 设置响应头：setHeader(String name, String value)             3. 设置响应体：        * 使用步骤：            1. 获取输出流                * 字符输出流：PrintWriter getWriter()                * 字节输出流：ServletOutputStream getOutputStream()            2. 使用输出流，将数据输出到客户端浏览器* 案例：    1. 完成重定向        * 重定向：资源跳转的方式        * 代码实现：            //1. 设置状态码为302            response.setStatus(302);            //2.设置响应头location            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);            //简单的重定向方法            response.sendRedirect(&quot;/day15/responseDemo2&quot;);        * 重定向的特点:redirect            1. 地址栏发生变化            2. 重定向可以访问其他站点(服务器)的资源            3. 重定向是两次请求。不能使用request对象来共享数据        * 转发的特点：forward            1. 转发地址栏路径不变            2. 转发只能访问当前服务器下的资源            3. 转发是一次请求，可以使用request对象来共享数据                * forward 和  redirect 区别                    * 路径写法：            1. 路径分类                1. 相对路径：通过相对路径不可以确定唯一资源                    * 如：./index.html                    * 不以/开头，以.开头路径                    * 规则：找到当前资源和目标资源之间的相对位置关系                        * ./：当前目录                        * ../:后退一级目录                2. 绝对路径：通过绝对路径可以确定唯一资源                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2                    * 以/开头的路径                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)                            * 建议虚拟目录动态获取：request.getContextPath()                            * &lt;a&gt; , &lt;form&gt; 重定向...                        * 给服务器使用：不需要加虚拟目录                            * 转发路径</code></pre><p>​<br>​                        </p><pre><code>    2. 服务器输出字符数据到浏览器        * 步骤：            1. 获取字符输出流            2. 输出数据        * 注意：            * 乱码问题：                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1                2. 设置该流的默认编码                3. 告诉浏览器响应体使用的编码                //简单的形式，设置编码，是在获取流之前设置                response.setContentType(&quot;text/html;charset=utf-8&quot;);    3. 服务器输出字节数据到浏览器        * 步骤：            1. 获取字节输出流            2. 输出数据    4. 验证码        1. 本质：图片        2. 目的：防止恶意表单注册</code></pre><h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信2. 获取：    1. 通过request对象获取        request.getServletContext();    2. 通过HttpServlet获取        this.getServletContext();3. 功能：    1. 获取MIME类型：        * MIME类型:在互联网通信过程中定义的一种文件数据类型            * 格式： 大类型/小类型   text/html        image/jpeg        * 获取：String getMimeType(String file)      2. 域对象：共享数据        1. setAttribute(String name,Object value)        2. getAttribute(String name)        3. removeAttribute(String name)        * ServletContext对象范围：所有用户所有请求的数据    3. 获取文件的真实(服务器)路径        1. 方法：String getRealPath(String path)               String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问             System.out.println(b);                String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问            System.out.println(c);                String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问            System.out.println(a);</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：    1. 页面显示超链接    2. 点击超链接后弹出下载提示框    3. 完成图片文件下载* 分析：    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求    2. 任何资源都必须弹出下载提示框    3. 使用响应头设置资源的打开方式：        * content-disposition:attachment;filename=xxx* 步骤：    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename    2. 定义Servlet        1. 获取文件名称        2. 使用字节输入流加载文件进内存        3. 指定response的响应头： content-disposition:attachment;filename=xxx        4. 将数据写出到response输出流* 问题：    * 中文文件问题        * 解决思路：            1. 获取客户端使用的浏览器版本信息            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><pre><code>1. 会话：一次会话中包含多次请求和响应。    * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止2. 功能：在一次会话的范围内的多次请求间，共享数据3. 方式：    1. 客户端会话技术：Cookie    2. 服务器端会话技术：Session</code></pre><h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2><pre><code>1. 概念：客户端会话技术，将数据保存到客户端2. 快速入门：    * 使用步骤：        1. 创建Cookie对象，绑定数据            * new Cookie(String name, String value)         2. 发送Cookie对象            * response.addCookie(Cookie cookie)         3. 获取Cookie，拿到数据            * Cookie[]  request.getCookies()  3. 实现原理    * 基于响应头set-cookie和请求头cookie实现4. cookie的细节    1. 一次可不可以发送多个cookie?        * 可以        * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。    2. cookie在浏览器中保存多长时间？        1. 默认情况下，当浏览器关闭后，Cookie数据被销毁        2. 持久化存储：            * setMaxAge(int seconds)                1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效                2. 负数：默认值                3. 零：删除cookie信息    3. cookie能不能存中文？        * 在tomcat 8 之前 cookie中不能直接存储中文数据。            * 需要将中文数据转码---一般采用URL编码(%E3)        * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析    4. cookie共享问题？        1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？            * 默认情况下cookie不能共享            * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录                * 如果要共享，则可以将path设置为&quot;/&quot;</code></pre><p>​            </p><pre><code>        2. 不同的tomcat服务器间cookie共享问题？            * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享                * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享5. Cookie的特点和作用    1. cookie存储数据在客户端浏览器    2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)    * 作用：        1. cookie一般用于存出少量的不太敏感的数据        2. 在不登录的情况下，完成服务器对客户端的身份识别6. 案例：记住上一次访问时间    1. 需求：        1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。        2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串    2. 分析：        1. 可以采用Cookie来完成        2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie            1. 有：不是第一次访问                1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20                2. 写回Cookie：lastTime=2018年6月10日11:50:01            2. 没有：是第一次访问                1. 响应数据：您好，欢迎您首次访问                2. 写回Cookie：lastTime=2018年6月10日11:50:01    3. 代码实现：        package cn.itcast.cookie;        import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.Cookie;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;        import java.net.URLDecoder;        import java.net.URLEncoder;        import java.text.SimpleDateFormat;        import java.util.Date;    @WebServlet(&quot;/cookieTest&quot;)    public class CookieTest extends HttpServlet &#123;        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            //设置响应的消息体的数据格式以及编码            response.setContentType(&quot;text/html;charset=utf-8&quot;);                //1.获取所有Cookie            Cookie[] cookies = request.getCookies();            boolean flag = false;//没有cookie为lastTime            //2.遍历cookie数组            if(cookies != null &amp;&amp; cookies.length &gt; 0)&#123;                for (Cookie cookie : cookies) &#123;                    //3.获取cookie的名称                    String name = cookie.getName();                    //4.判断名称是否是：lastTime                    if(&quot;lastTime&quot;.equals(name))&#123;                        //有该Cookie，不是第一次访问                            flag = true;//有lastTime的cookie                            //设置Cookie的value                        //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                        Date date  = new Date();                        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                        String str_date = sdf.format(date);                        System.out.println(&quot;编码前：&quot;+str_date);                        //URL编码                        str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                        System.out.println(&quot;编码后：&quot;+str_date);                        cookie.setValue(str_date);                        //设置cookie的存活时间                        cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                        response.addCookie(cookie);</code></pre><p>​        </p><pre><code>                        //响应数据                        //获取Cookie的value，时间                        String value = cookie.getValue();                        System.out.println(&quot;解码前：&quot;+value);                        //URL解码：                        value = URLDecoder.decode(value,&quot;utf-8&quot;);                        System.out.println(&quot;解码后：&quot;+value);                        response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;);                            break;                        &#125;                &#125;            &#125;</code></pre><p>​        </p><pre><code>            if(cookies == null || cookies.length == 0 || flag == false)&#123;                //没有，第一次访问                    //设置Cookie的value                //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                Date date  = new Date();                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                String str_date = sdf.format(date);                System.out.println(&quot;编码前：&quot;+str_date);                //URL编码                str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                System.out.println(&quot;编码后：&quot;+str_date);                    Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);                //设置cookie的存活时间                cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                response.addCookie(cookie);                    response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;);            &#125;</code></pre><p>​        </p><pre><code>        &#125;            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            this.doPost(request, response);        &#125;    &#125;</code></pre><h2 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h2><pre><code>1. 概念：    * Java Server Pages： java服务器端页面        * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码        * 用于简化书写！！！2. 原理    * JSP本质上就是一个Servlet3. JSP的脚本：JSP定义Java代码的方式    1. &lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。    2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。    3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。4. JSP的内置对象：    * 在jsp页面中不需要获取和创建，可以直接使用的对象    * jsp一共有9个内置对象。    * 今天学习3个：        * request        * response        * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似            * response.getWriter()和out.write()的区别：                * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。                * response.getWriter()数据输出永远在out.write()之前            5. 案例:改造Cookie案例</code></pre><h2 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h2><pre><code>1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession2. 快速入门：    1. 获取HttpSession对象：        HttpSession session = request.getSession();    2. 使用HttpSession对象：        Object getAttribute(String name)          void setAttribute(String name, Object value)        void removeAttribute(String name)  3. 原理    * Session的实现是依赖于Cookie的。</code></pre><p>​    </p><pre><code>4. 细节：    1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？        * 默认情况下。不是。        * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。             Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());             c.setMaxAge(60*60);             response.addCookie(c);    2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？        * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作            * session的钝化：                * 在服务器正常关闭之前，将session对象系列化到硬盘上            * session的活化：                * 在服务器启动后，将session文件转化为内存中的session对象即可。                3. session什么时候被销毁？        1. 服务器关闭        2. session对象调用invalidate() 。        3. session默认失效时间 30分钟            选择性配置修改                &lt;session-config&gt;                &lt;session-timeout&gt;30&lt;/session-timeout&gt;            &lt;/session-config&gt; 5. session的特点     1. session用于存储一次会话的多次请求的数据，存在服务器端     2. session可以存储任意类型，任意大小的数据    * session与Cookie的区别：        1. session存储数据在服务器端，Cookie在客户端        2. session没有数据大小限制，Cookie有        3. session数据安全，Cookie相对于不安全</code></pre><h2 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h2><pre><code>1. 案例需求：    1. 访问带有验证码的登录页面login.jsp    2. 用户输入用户名，密码以及验证码。        * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误        * 如果验证码输入有误，跳转登录页面，提示：验证码错误        * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</code></pre><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP:"></a>JSP:</h2><pre><code>1. 指令    * 作用：用于配置JSP页面，导入资源文件    * 格式：        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;    * 分类：        1. page        ： 配置JSP页面的            * contentType：等同于response.setContentType()                1. 设置响应体的mime类型以及字符集                2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）            * import：导包            * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面            * isErrorPage：标识当前也是是否是错误页面。                * true：是，可以使用内置对象exception                * false：否。默认值。不可以使用内置对象exception        2. include    ： 页面包含的。导入页面的资源文件            * &lt;%@include file=&quot;top.jsp&quot;%&gt;        3. taglib    ： 导入资源            * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;                * prefix：前缀，自定义的2. 注释:    1. html注释：        &lt;!-- --&gt;:只能注释html代码片段    2. jsp注释：推荐使用        &lt;%-- --%&gt;：可以注释所有3. 内置对象    * 在jsp页面中不需要创建，直接使用的对象    * 一共有9个：            变量名                    真实类型                        作用        * pageContext                PageContext                    当前页面共享数据，还可以获取其他八个内置对象        * request                    HttpServletRequest            一次请求访问的多个资源(转发)        * session                    HttpSession                    一次会话的多个请求间        * application                ServletContext                所有用户间共享数据        * response                    HttpServletResponse            响应对象        * page                        Object                        当前页面(Servlet)的对象  this        * out                        JspWriter                    输出对象，数据输出到页面上        * config                    ServletConfig                Servlet的配置对象        * exception                    Throwable                    异常对象</code></pre><p>​    </p><h2 id="MVC：开发模式"><a href="#MVC：开发模式" class="headerlink" title="MVC：开发模式"></a>MVC：开发模式</h2><pre><code>1. jsp演变历史    1. 早期只有servlet，只能使用response输出标签数据，非常麻烦    2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作    3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性2. MVC：    1. M：Model，模型。JavaBean        * 完成具体的业务操作，如：查询数据库，封装对象    2. V：View，视图。JSP        * 展示数据    3. C：Controller，控制器。Servlet        * 获取用户的输入        * 调用模型        * 将数据交给视图进行展示    * 优缺点：        1. 优点：            1. 耦合性低，方便维护，可以利于分工协作            2. 重用性高        2. 缺点：            1. 使得项目架构变得复杂，对开发人员要求高</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. 概念：Expression Language 表达式语言2. 作用：替换和简化jsp页面中java代码的编写3. 语法：$&#123;表达式&#125;4. 注意：    * jsp默认支持el表达式的。如果要忽略el表达式        1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式        2. \$&#123;表达式&#125; ：忽略当前这个el表达式5. 使用：    1. 运算：        * 运算符：            1. 算数运算符： + - * /(div) %(mod)            2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=            3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not)            4. 空运算符： empty                * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0                * $&#123;empty list&#125;:判断字符串、集合、数组对象是否为null或者长度为0                * $&#123;not empty str&#125;:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0    2. 获取值        1. el表达式只能从域对象中获取值        2. 语法：            1. $&#123;域名称.键名&#125;：从指定域中获取指定键的值                * 域名称：                    1. pageScope        --&gt; pageContext                    2. requestScope     --&gt; request                    3. sessionScope     --&gt; session                    4. applicationScope --&gt; application（ServletContext）                * 举例：在request域中存储了name=张三                * 获取：$&#123;requestScope.name&#125;            2. $&#123;键名&#125;：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</code></pre><p>​<br>​                </p><pre><code>            3. 获取对象、List集合、Map集合的值                1. 对象：$&#123;域名称.键名.属性名&#125;                    * 本质上会去调用对象的getter方法                2. List集合：$&#123;域名称.键名[索引]&#125;                3. Map集合：                    * $&#123;域名称.键名.key名称&#125;                    * $&#123;域名称.键名[&quot;key名称&quot;]&#125;    3. 隐式对象：        * el表达式中有11个隐式对象        * pageContext：            * 获取jsp其他八个内置对象                * $&#123;pageContext.request.contextPath&#125;：动态获取虚拟目录</code></pre><p>​    </p><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><pre><code>1. 概念：JavaServer Pages Tag Library  JSP标准标签库    * 是由Apache组织提供的开源的免费的jsp标签        &lt;标签&gt;2. 作用：用于简化和替换jsp页面上的java代码        3. 使用步骤：    1. 导入jstl相关jar包    2. 引入标签库：taglib指令：  &lt;%@ taglib %&gt;    3. 使用标签4. 常用的JSTL标签    1. if:相当于java代码的if语句        1. 属性：            * test 必须属性，接受boolean表达式                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容                * 一般情况下，test属性值会结合el表达式一起使用            2. 注意：                * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签    2. choose:相当于java代码的switch语句        1. 使用choose标签声明                     相当于switch声明        2. 使用when标签做判断                     相当于case        3. 使用otherwise标签做其他情况的声明        相当于default    3. foreach:相当于java代码的for语句5. 练习：    * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中</code></pre><h2 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h2><pre><code>1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互2. 业务逻辑层：处理业务逻辑的。3. 数据访问层：操作数据存储文件。</code></pre><h2 id="案例：用户信息列表展示"><a href="#案例：用户信息列表展示" class="headerlink" title="案例：用户信息列表展示"></a>案例：用户信息列表展示</h2><pre><code>1. 需求：用户信息的增删改查操作2. 设计：    1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat    2. 数据库设计：        create database day17; -- 创建数据库        use day17;                -- 使用数据库        create table user(   -- 创建表            id int primary key auto_increment,            name varchar(20) not null,            gender varchar(5),            age int,            address varchar(32),            qq    varchar(20),            email varchar(50)        );3. 开发：    1. 环境搭建        1. 创建数据库环境        2. 创建项目，导入需要的jar包    2. 编码4. 测试5. 部署运维</code></pre><h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1><pre><code>1. 概念：    * 生活中的过滤器：净水器,空气净化器，土匪、    * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。    * 过滤器的作用：        * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...2. 快速入门：    1. 步骤：        1. 定义一个类，实现接口Filter        2. 复写方法        3. 配置拦截路径            1. web.xml            2. 注解    2. 代码：        @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器        public class FilterDemo1 implements Filter &#123;            @Override            public void init(FilterConfig filterConfig) throws ServletException &#123;                    &#125;                    @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                System.out.println(&quot;filterDemo1被执行了....&quot;);</code></pre><p>​            </p><pre><code>                //放行                filterChain.doFilter(servletRequest,servletResponse);                    &#125;                    @Override            public void destroy() &#123;                    &#125;        &#125;3. 过滤器细节：    1. web.xml配置            &lt;filter&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;        &lt;/filter&gt;        &lt;filter-mapping&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;!-- 拦截路径 --&gt;            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;        &lt;/filter-mapping&gt;    2. 过滤器执行流程        1. 执行过滤器        2. 执行放行后的资源        3. 回来执行过滤器放行代码下边的代码    3. 过滤器生命周期方法        1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源        2. doFilter:每一次请求被拦截资源时，会执行。执行多次        3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源    4. 过滤器配置详解        * 拦截路径配置：            1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行            2. 拦截目录： /user/*    访问/user下的所有资源时，过滤器都会被执行            3. 后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行            4. 拦截所有资源：/*        访问所有资源时，过滤器都会被执行        * 拦截方式配置：资源被访问的方式            * 注解配置：                * 设置dispatcherTypes属性                    1. REQUEST：默认值。浏览器直接请求资源                    2. FORWARD：转发访问资源                    3. INCLUDE：包含访问资源                    4. ERROR：错误跳转资源                    5. ASYNC：异步访问资源            * web.xml配置                * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可                5. 过滤器链(配置多个过滤器)        * 执行顺序：如果有两个过滤器：过滤器1和过滤器2            1. 过滤器1            2. 过滤器2            3. 资源执行            4. 过滤器2            5. 过滤器1         * 过滤器先后顺序问题：            1. 注解配置：按照类名的字符串比较规则比较，值小的先执行                * 如： AFilter 和 BFilter，AFilter就先执行了。            2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行4. 案例：    1. 案例1_登录验证        * 需求：            1. 访问day17_case案例的资源。验证其是否登录            2. 如果登录了，则直接放行。            3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。</code></pre><p>​    </p><pre><code>    2. 案例2_敏感词汇过滤        * 需求：            1. 对day17_case案例录入的数据进行敏感词汇过滤            2. 敏感词汇参考《敏感词汇.txt》            3. 如果是敏感词汇，替换为 ***         * 分析：            1. 对request对象进行增强。增强获取参数相关方法            2. 放行。传递代理对象        * 增强对象的功能：            * 设计模式：一些通用的解决固定问题的方式            1. 装饰模式            2. 代理模式                * 概念：                    1. 真实对象：被代理的对象                    2. 代理对象：                    3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的                 * 实现方式：                     1. 静态代理：有一个类文件描述代理模式                     2. 动态代理：在内存中形成代理类                        * 实现步骤：                            1. 代理对象和真实对象实现相同的接口                            2. 代理对象 = Proxy.newProxyInstance();                            3. 使用代理对象调用方法。                            4. 增强方法                        * 增强方式：                            1. 增强参数列表                            2. 增强返回值类型                            3. 增强方法体执行逻辑    </code></pre><h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><pre><code>* 概念：web的三大组件之一。    * 事件监听机制        * 事件    ：一件事情        * 事件源 ：事件发生的地方        * 监听器 ：一个对象        * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码* ServletContextListener:监听ServletContext对象的创建和销毁    * 方法：        * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法        * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法    * 步骤：        1. 定义一个类，实现ServletContextListener接口        2. 复写方法        3. 配置            1. web.xml                    &lt;listener&gt;                      &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;                       &lt;/listener&gt;                    * 指定初始化参数&lt;context-param&gt;            2. 注解：                * @WebListener</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XML&amp;AJAX&amp;JSON</title>
    <link href="/2017/09/25/xml/"/>
    <url>/2017/09/25/xml/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ol><li>概念：Extensible Markup Language 可扩展标记语言<ul><li>可扩展：标签都是自定义的。<br><code>&lt;user&gt;  &lt;student&gt;</code><ul><li>功能<ul><li>存储数据<ol><li>配置文件</li><li>在网络中传输</li></ol></li><li>xml与html的区别<ol><li>xml标签都是自定义的，html标签是预定义。</li><li>xml的语法严格，html语法松散</li><li>xml是存储数据的，html是展示数据</li></ol></li></ul></li><li>w3c:万维网联盟</li></ul></li></ul> 语法：<ol start="2"><li><ul><li>基本语法：<ol><li>xml文档的后缀名 .xml</li><li>xml第一行必须定义为文档声明</li><li>xml文档中有且仅有一个根标签</li><li>属性值必须使用引号(单双都可)引起来</li><li>标签必须正确关闭</li><li>xml标签名称区分大小写</li></ol></li><li>快速入门：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">users</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;1&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>23<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>male<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;2&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>24<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>female<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>组成部分：<ol><li><p>文档声明</p><ol><li>格式：<?xml 属性列表 ?></li><li>属性列表：<ul><li>version：版本号，必须的属性</li><li>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li><li>standalone：是否独立<ul><li>取值：<ul><li>yes：不依赖其他文件</li><li>no：依赖其他文件</li></ul></li></ul></li></ul></li></ol></li><li><p>指令(了解)：结合css的</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>标签：标签名称自定义的</p><ul><li>规则：</li><li>名称可以包含字母、数字以及其他的字符 <ul><li>名称不能以数字或者标点符号开始 </li><li>名称不能以字母 xml（或者 XML、Xml 等等）开始 </li><li>名称不能包含空格 </li></ul></li></ul></li><li><p>属性：<br> id属性值唯一</p></li><li><p>文本：</p><ul><li>CDATA区：在该区域中的数据会被原样展示<ul><li>格式：  <!--[CDATA[ 数据 ]]--></li></ul></li></ul></li></ol></li></ul></li></ol></li></ol><ul><li><p>约束：规定xml文档的书写规则</p><ul><li><p>作为框架的使用者(程序员)：</p><ol><li>能够在xml中引入约束文档</li><li>能够简单的读懂约束文档</li></ol></li><li><p>分类：</p><ol><li>DTD:一种简单的约束技术</li><li>Schema:一种复杂的约束技术</li></ol></li><li><p>DTD：</p><ul><li>引入dtd文档到xml文档中<ul><li>内部dtd：将约束规则定义在xml文档中</li><li>外部dtd：将约束的规则定义在外部的dtd文件中<ul><li>本地：<!DOCTYPE 根标签名 SYSTEM "dtd文件的位置"></li><li>网络：<!DOCTYPE 根标签名 PUBLIC "dtd文件名字" "dtd文件的位置URL"></li></ul></li></ul></li></ul></li><li><p>Schema:</p><ul><li>引入：<br>  1.填写xml文档的根元素<br>  2.引入xsi前缀.  xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>  3.引入xsd文件命名空间.  xsi:schemaLocation=”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a>  student.xsd”<br>  4.为每一个xsd约束声明一个前缀,作为标识  xmlns=”<a href="http://www.itcast.cn/xml&quot;">http://www.itcast.cn/xml&quot;</a> </li></ul></li></ul>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;students   xmlns:<span class="hljs-attribute">xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="hljs-attribute">xmlns</span>=<span class="hljs-string">&quot;http://www.itcast.cn/xml&quot;</span><br>xsi:<span class="hljs-attribute">schemaLocation</span>=<span class="hljs-string">&quot;http://www.itcast.cn/xml  student.xsd&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>解析：操作xml文档，将文档中的数据读取到内存中</p><ul><li><p>操作xml文档</p><ol><li>解析(读取)：将文档中的数据读取到内存中</li><li>写入：将内存中的数据保存到xml文档中。持久化的存储</li></ol></li><li><p>解析xml的方式：</p><ol><li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul><li>优点：操作方便，可以对文档进行CRUD的所有操作</li><li>缺点：占内存</li></ul></li><li>SAX：逐行读取，基于事件驱动的。<ul><li>优点：不占内存。</li><li>缺点：只能读取，不能增删改</li></ul></li></ol></li><li><p>xml常见的解析器：</p><ol><li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li><li>DOM4J：一款非常优秀的解析器</li><li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li></ol></li></ul><ol start="4"><li>PULL：Android操作系统内置的解析器，sax方式的。<h1 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h1></li></ol><ul><li>jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<ul><li>快速入门：<ul><li>步骤：</li></ul><ol><li>导入jar包<ol start="2"><li>获取Document对象</li><li>获取对应的标签Element对象</li></ol></li><li>获取数据</li></ol></li><li>代码：</li></ul>   <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">   //<span class="hljs-number">2.1</span>获取student.xml的<span class="hljs-type">path</span><br>String <span class="hljs-type">path</span> = JsoupDemo1.<span class="hljs-keyword">class</span>.getClassLoader().getResource(&quot;student.xml&quot;).getPath();<br>   <br>   //<span class="hljs-number">2.2</span>解析<span class="hljs-type">xml</span>文档，加载文档进内存，获取dom树<span class="hljs-comment">---&gt;Document</span><br>     Document document = Jsoup.parse(<span class="hljs-built_in">new</span> File(<span class="hljs-type">path</span>), &quot;utf-8&quot;);<br>   <br>   //<span class="hljs-number">3.</span>获取元素对象 Element<br>   //<span class="hljs-number">3.1</span>获取第一个<span class="hljs-type">name</span>的Element对象<br>  Element element = elements.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(elements.size());<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><br>//<span class="hljs-number">3.1</span>获取第一个<span class="hljs-type">name</span>的Element对象<br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>Element element = elements.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br><br>//<span class="hljs-number">3.1</span>获取第一个<span class="hljs-type">name</span>的Element对象<br>Element element = elements.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(elements.size());<br>Elements elements = document.getElementsByTag(&quot;name&quot;);<br><br>//<span class="hljs-number">3.2</span>获取数据<br>String <span class="hljs-type">name</span> = element.text();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br></code></pre></td></tr></table></figure></li><li>对象的使用：<ol><li><p>Jsoup：工具类，可以解析html或xml文档，返回Document</p><ul><li>parse：解析html或xml文档，返回Document<ul><li>parse​(File in, String charsetName)：解析xml或html文件的。</li><li>parse​(String html)：解析xml或html字符串</li><li>parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象</li></ul></li></ul></li><li><p>Document：文档对象。代表内存中的dom树</p><ul><li>获取Element对象<ul><li>getElementById​(String id)：根据id属性值获取唯一的element对象</li><li>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合</li><li>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul></li></ul></li><li><p>Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用</Element></p></li><li><p>Element：元素对象</p><ol><li>获取子元素对象<ul><li>getElementById​(String id)：根据id属性值获取唯一的element对象</li></ul></li></ol><ul><li>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合<ul><li>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul></li></ul><ol start="2"><li>获取属性值<ul><li>String attr(String key)：根据属性名称获取属性值</li></ul></li><li>获取文本内容<ul><li>String text():获取文本内容</li><li>String html():获取标签体的所有内容(包括字标签的字符串内容)</li></ul></li></ol></li><li><p>Node：节点对象</p><ul><li>是Document和Element的父类</li></ul></li></ol></li></ul></li></ol><p>​            </p><ul><li>快捷查询方式：<ol><li>selector:选择器<ul><li>使用的方法：Elements    select​(String cssQuery)<ul><li>语法：参考Selector类中定义的语法</li></ul></li></ul></li><li>XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言<ul><li>使用Jsoup的Xpath需要额外导入jar包。</li><li>查询w3cshool参考手册，使用xpath的语法完成查询</li><li>代码：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1.获取student.xml的path</span><br>    String path = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JsoupDemo6</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.get<span class="hljs-constructor">Resource(<span class="hljs-string">&quot;student.xml&quot;</span>)</span>.get<span class="hljs-constructor">Path()</span>;<br>  <span class="hljs-comment">//2.获取Document对象</span><br> Document document = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Jsoup</span>.</span></span>parse(<span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">path</span>)</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br> <br>  <span class="hljs-comment">//3.根据document对象，创建JXDocument对象</span><br>    JXDocument jxDocument = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JXDocument(<span class="hljs-params">document</span>)</span>;<br> <br>    <span class="hljs-comment">//4.结合xpath语法查询</span><br>    <span class="hljs-comment">//4.1查询所有student标签</span><br> List&lt;JXNode&gt; jxNodes = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes) &#123;<br>   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br>   <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br> <br>    <span class="hljs-comment">//4.2查询所有student标签下的name标签</span><br> List&lt;JXNode&gt; jxNodes2 = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student/name&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes2) &#123;<br>   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br>   <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br> <br>    <span class="hljs-comment">//4.3查询student标签下带有id属性的name标签</span><br>    List&lt;JXNode&gt; jxNodes3 = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student/name[@id]&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes3) &#123;<br>     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>    <span class="hljs-comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span><br> <br>    List&lt;JXNode&gt; jxNodes4 = jxDocument.sel<span class="hljs-constructor">N(<span class="hljs-string">&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;</span>)</span>;<br>    <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes4) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(jxNode);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h1 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h1><pre><code>1. 概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML    1. 异步和同步：客户端和服务器端相互通信的基础上        * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。        * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。        Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1]         通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。        传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。        提升用户的体验2. 实现方式：    1. 原生的JS实现方式（了解）                 //1.创建核心对象                var xmlhttp;                if (window.XMLHttpRequest)                &#123;// code for IE7+, Firefox, Chrome, Opera, Safari                    xmlhttp=new XMLHttpRequest();                &#125;                else                &#123;// code for IE6, IE5                    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);                &#125;                    //2. 建立连接                /*                    参数：                        1. 请求方式：GET、POST                            * get方式，请求参数在URL后边拼接。send方法为空参                            * post方式，请求参数在send方法中定义                        2. 请求的URL：                        3. 同步或异步请求：true（异步）或 false（同步）                     */                xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);                    //3.发送请求                xmlhttp.send();                    //4.接受并处理来自服务器的响应结果                //获取方式 ：xmlhttp.responseText                //什么时候获取？当服务器响应成功后再获取                    //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。                xmlhttp.onreadystatechange=function()                &#123;                    //判断readyState就绪状态是否为4，判断status响应状态码是否为200                    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)                    &#123;                       //获取服务器的响应结果                        var responseText = xmlhttp.responseText;                        alert(responseText);                    &#125;                &#125;    2. JQeury实现方式        1. $.ajax()            * 语法：$.ajax(&#123;键值对&#125;);             //使用$.ajax()发送异步请求                $.ajax(&#123;                    url:&quot;ajaxServlet1111&quot; , // 请求路径                    type:&quot;POST&quot; , //请求方式                    //data: &quot;username=jack&amp;age=23&quot;,//请求参数                    data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;,                    success:function (data) &#123;                        alert(data);                    &#125;,//响应成功后的回调函数                    error:function () &#123;                        alert(&quot;出错啦...&quot;)                    &#125;,//表示如果请求响应出现错误，会执行的回调函数                        dataType:&quot;text&quot;//设置接受到的响应数据的格式                &#125;);        2. $.get()：发送get请求            * 语法：$.get(url, [data], [callback], [type])                * 参数：                    * url：请求路径                    * data：请求参数                    * callback：回调函数                    * type：响应结果的类型        3. $.post()：发送post请求            * 语法：$.post(url, [data], [callback], [type])                * 参数：                    * url：请求路径                    * data：请求参数                    * callback：回调函数                    * type：响应结果的类型</code></pre><h1 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h1><pre><code>1. 概念： JavaScript Object Notation        JavaScript对象表示法    Person p = new Person();    p.setName(&quot;张三&quot;);    p.setAge(23);    p.setGender(&quot;男&quot;);    var p = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;;    * json现在多用于存储和交换文本信息的语法    * 进行数据的传输    * JSON 比 XML 更小、更快，更易解析。2. 语法：    1. 基本规则        * 数据在名称/值对中：json数据是由键值对构成的            * 键用引号(单双都行)引起来，也可以不使用引号            * 值得取值类型：                1. 数字（整数或浮点数）                2. 字符串（在双引号中）                3. 逻辑值（true 或 false）                4. 数组（在方括号中）    &#123;&quot;persons&quot;:[&#123;&#125;,&#123;&#125;]&#125;                5. 对象（在花括号中） &#123;&quot;address&quot;:&#123;&quot;province&quot;：&quot;陕西&quot;....&#125;&#125;                6. null        * 数据由逗号分隔：多个键值对由逗号分隔        * 花括号保存对象：使用&#123;&#125;定义json 格式        * 方括号保存数组：[]    2. 获取数据:        1. json对象.键名        2. json对象[&quot;键名&quot;]        3. 数组对象[索引]        4. 遍历                 //1.定义基本格式                var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &#39;gender&#39;: true&#125;;                        var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;,                    &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;,                    &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];</code></pre><p>​<br>​<br>​            </p><pre><code>                //获取person对象中所有的键和值                //for in 循环               /* for(var key in person)&#123;                    //这样的方式获取不行。因为相当于  person.&quot;name&quot;                    //alert(key + &quot;:&quot; + person.key);                    alert(key+&quot;:&quot;+person[key]);                &#125;*/                       //获取ps中的所有值                for (var i = 0; i &lt; ps.length; i++) &#123;                    var p = ps[i];                    for(var key in p)&#123;                        alert(key+&quot;:&quot;+p[key]);                    &#125;                &#125;3. JSON数据和Java对象的相互转换    * JSON解析器：        * 常见的解析器：Jsonlib，Gson，fastjson，jackson        1. JSON转为Java对象        1. 导入jackson的相关jar包        2. 创建Jackson核心对象 ObjectMapper        3. 调用ObjectMapper的相关方法进行转换            1. readValue(json字符串数据,Class)    2. Java对象转换JSON        1. 使用步骤：            1. 导入jackson的相关jar包            2. 创建Jackson核心对象 ObjectMapper            3. 调用ObjectMapper的相关方法进行转换                1. 转换方法：                    * writeValue(参数1，obj):                        参数1：                            File：将obj对象转换为JSON字符串，并保存到指定的文件中                            Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中                            OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中                    * writeValueAsString(obj):将对象转为json字符串                2. 注解：                    1. @JsonIgnore：排除属性。                    2. @JsonFormat：属性值得格式化                        * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)                3. 复杂java对象转换                    1. List：数组                    2. Map：对象格式一致</code></pre><h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><pre><code>* 校验用户名是否存在    1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：        1. $.get(type):将最后一个参数type指定为&quot;json&quot;        2. 在服务器端设置MIME类型            response.setContentType(&quot;application/json;charset=utf-8&quot;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Xml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bootstrap</title>
    <link href="/2017/09/24/Bootstrap/"/>
    <url>/2017/09/24/Bootstrap/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Bootstrap："><a href="#Bootstrap：" class="headerlink" title="Bootstrap："></a>Bootstrap：</h1><ol><li><p>概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。</p><ul><li>框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</li><li>好处：<ol><li>定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。</li><li>响应式布局。<ul><li>同一套页面可以兼容不同分辨率的设备。</li></ul></li></ol></li></ul></li><li><p>快速入门</p><ol><li>下载Bootstrap</li><li>在项目中将这三个文件夹复制</li><li>创建html页面，引入必要的资源文件</li></ol> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Bootstrap HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-3.2.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好，世界！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul><li><p>同一套页面可以兼容不同分辨率的设备。</p></li><li><p>实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子</p></li><li><p>步骤：</p><ol><li>定义容器。相当于之前的table、<ul><li>容器分类：<ol><li>container：两边留白</li><li>container-fluid：每一种设备都是100%宽度</li></ol></li></ul></li><li>定义行。相当于之前的tr   样式：row</li><li>定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目<ul><li>设备代号：<ol><li>xs：超小屏幕 手机 (&lt;768px)：col-xs-12</li><li>sm：小屏幕 平板 (≥768px)</li><li>md：中等屏幕 桌面显示器 (≥992px)</li><li>lg：大屏幕 大桌面显示器 (≥1200px)</li></ol></li></ul></li></ol><ul><li>注意：<ol><li>一行中如果格子数目超过12，则超出部分自动换行。</li><li>栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</li><li>如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</li></ol></li></ul></li></ul><h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><ol><li>全局CSS样式：<ul><li>按钮：class=”btn btn-default”</li><li>图片：<ul><li>class=”img-responsive”：图片在任意尺寸都占100%</li><li>图片形状<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-rounded&quot;</span>&gt;：方形<br>*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-circle&quot;</span>&gt; ： 圆形<br>*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-thumbnail&quot;</span>&gt; ：相框<br></code></pre></td></tr></table></figure></li></ul></li><li>表格<ul><li>table</li><li>table-bordered</li><li>table-hover</li></ul></li><li>表单<ul><li>给表单项添加：class=”form-control” </li></ul></li></ul></li><li>组件：<ul><li>导航条</li><li>分页条</li></ul></li><li>插件：<ul><li>轮播图</li></ul></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;        .paddtop&#123;            padding-top: 10px;        &#125;        .search-btn&#123;            float: left;            border:1px solid #ffc900;            width: 90px;            height: 35px;            background-color:#ffc900 ;            text-align: center;            line-height: 35px;            margin-top: 15px;        &#125;        .search-input&#123;            float: left;            border:2px solid #ffc900;            width: 400px;            height: 35px;            padding-left: 5px;            margin-top: 15px;        &#125;        .jx&#123;            border-bottom: 2px solid #ffc900;            padding: 5px;        &#125;        .company&#123;            height: 40px;            background-color: #ffc900;            text-align: center;            line-height:40px ;            font-size: 8px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;!-- 1.页眉部分--&gt;   &lt;header class=&quot;container-fluid&quot;&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;img src=&quot;img/top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt;       &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;img src=&quot;img/logo.jpg&quot; class=&quot;img-responsive&quot;&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-5&quot;&gt;               &lt;input class=&quot;search-input&quot; placeholder=&quot;请输入线路名称&quot;&gt;               &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-4&quot;&gt;               &lt;img src=&quot;img/hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt;           &lt;/div&gt;       &lt;/div&gt;              &lt;!--导航栏--&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;nav class=&quot;navbar navbar-default&quot;&gt;               &lt;div class=&quot;container-fluid&quot;&gt;                   &lt;!-- Brand and toggle get grouped for better mobile display --&gt;                   &lt;div class=&quot;navbar-header&quot;&gt;                       &lt;!-- 定义汉堡按钮 --&gt;                       &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;                           &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                       &lt;/button&gt;                       &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;                   &lt;/div&gt;                   &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;                   &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;                       &lt;ul class=&quot;nav navbar-nav&quot;&gt;                           &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                       &lt;/ul&gt;                   &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;               &lt;/div&gt;&lt;!-- /.container-fluid --&gt;           &lt;/nav&gt;       &lt;/div&gt;              &lt;!--轮播图--&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;               &lt;!-- Indicators --&gt;               &lt;ol class=&quot;carousel-indicators&quot;&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;               &lt;/ol&gt;               &lt;!-- Wrapper for slides --&gt;               &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;                   &lt;div class=&quot;item active&quot;&gt;                       &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;               &lt;/div&gt;                              &lt;!-- Controls --&gt;               &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;               &lt;/a&gt;               &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;               &lt;/a&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/header&gt;   &lt;!-- 2.主体部分--&gt;   &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row jx&quot;&gt;            &lt;img src=&quot;img/icon_5.jpg&quot;&gt;            &lt;span&gt;精选&lt;/span&gt;        &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                    &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;       &lt;div class=&quot;row jx&quot;&gt;           &lt;img src=&quot;img/icon_6.jpg&quot;&gt;           &lt;span&gt;国内游&lt;/span&gt;       &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-4&quot;&gt;               &lt;img src=&quot;img/guonei_1.jpg&quot;&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-8&quot;&gt;               &lt;div class=&quot;row&quot;&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;               &lt;/div&gt;               &lt;div class=&quot;row&quot;&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;               &lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;!-- 3.页脚部分--&gt;   &lt;footer class=&quot;container-fluid&quot;&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;img src=&quot;img/footer_service.png&quot; class=&quot;img-responsive&quot;&gt;       &lt;/div&gt;       &lt;div class=&quot;row company&quot;&gt;           ccllyy 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882       &lt;/div&gt;       &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootstrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo部署到github</title>
    <link href="/2017/09/24/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <url>/2017/09/24/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="将hexo项目clone到本地"><a href="#将hexo项目clone到本地" class="headerlink" title="将hexo项目clone到本地"></a>将hexo项目clone到本地</h1><h1 id="使用npm初始化环境"><a href="#使用npm初始化环境" class="headerlink" title="使用npm初始化环境"></a>使用npm初始化环境</h1><p>全局初始化</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>项目文件初始化</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>初始化后进行hexo配置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span> clydeblog<br></code></pre></td></tr></table></figure><h1 id="发布到github-gitee-coding"><a href="#发布到github-gitee-coding" class="headerlink" title="发布到github/gitee/coding"></a>发布到github/gitee/coding</h1><p>修改项目配置文件<code>_config.yml</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/cylinclinv/cylinclinv.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>清除<br>hexo  clean    <br><span class="hljs-regexp">//</span>编译<br>hexo g<br><span class="hljs-regexp">//</span>发布<br>hexo d<br></code></pre></td></tr></table></figure><p>以上发布完成后,在浏览器输入cylinclinv.github.io就打开了自己的博客</p><h1 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h1><p>cmd输入ping cylinclinv.github.io,获得github的公网ip地址</p><p>在你购买域名的地方配置这个公网ip解析,这个ip地址是指向github网站而不是你博客</p><p>想根据这个找到你博客地址,就需要在github pages配置自定义域名(custom domain) </p><p>最后在blog目录/source下创建CNAME文件(没有后缀),内容输入你的域名,这一步很重要,不然每次通过<code> hexo d</code> 部署,都需要重新配置custom domain</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">lyoric.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML&amp;CSS&amp;JS</title>
    <link href="/2017/09/23/HTML&amp;CSS&amp;JS/"/>
    <url>/2017/09/23/HTML&amp;CSS&amp;JS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><pre><code>1. web概念概述2. HTML</code></pre><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。    * 代码：        &lt;html&gt;                    &lt;head&gt;                &lt;title&gt;title&lt;/title&gt;            &lt;/head&gt;                        &lt;body&gt;                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;                                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;                        &lt;/body&gt;            &lt;/html&gt;3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例        * 案例：公司简介            &lt;!DOCTYPE html&gt;            &lt;html lang=&quot;ch&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;黑马程序员简介&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                        &lt;h1&gt;                公司简介            &lt;/h1&gt;            &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;p&gt;            &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。            &lt;/p&gt;                        &lt;p&gt;            目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。            &lt;/p&gt;                        &lt;p&gt;                        黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。            中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。            &lt;/p&gt;                        &lt;p&gt;                        一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。            &lt;/p&gt;                        &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                &lt;center&gt;                    江苏传智播客教育科技股份有限公司&lt;br&gt;                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                &lt;/center&gt;            &lt;/font&gt;</code></pre><p>​<br>​                </p><pre><code>            &lt;/body&gt;            &lt;/html&gt;    3. 图片标签：        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;                    &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;                    &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;                    &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;    4. 列表标签：        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:    5. 链接标签：        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;                    &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;                    &lt;br&gt;                    &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;                    &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;    6. div和span：        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚    8. 表格标签：        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分</code></pre><h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用    &lt;tr&gt;        &lt;td&gt;            &lt;table&gt;&lt;/table&gt;        &lt;/td&gt;    &lt;/tr&gt;4. 代码实现    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;黑马旅游网&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            &lt;!--采用table来完成布局--&gt;        &lt;!--最外层的table，用于整个页面的布局--&gt;        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;           &lt;!-- 第1行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第2行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第3行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;                            &lt;td&gt;                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第4行 轮播图 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第5行 黑马精选--&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;                    黑马精选                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第6行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第7行 国内游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;                    国内游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第8行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第9行 境外游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;                    境外游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第10行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第11行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第12行 --&gt;            &lt;tr&gt;                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                    江苏传智播客教育科技股份有限公司                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                    &lt;/font&gt;                &lt;/td&gt;            &lt;/tr&gt;                    &lt;/table&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性</code></pre><p>​        </p><pre><code>    * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项                    * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率3. CSS的使用：CSS与html结合方式    1. 内联样式         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;    2. 内部样式        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;                    &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;    3. 外部样式        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；5. 选择器：筛选具有相似特征的元素    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;                        3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;注册页面&lt;/title&gt;    &lt;style&gt;        *&#123;            margin: 0px;            padding: 0px;            box-sizing: border-box;        &#125;        body&#123;            background: url(&quot;img/register_bg.png&quot;) no-repeat center;            padding-top: 25px;        &#125;            .rg_layout&#123;            width: 900px;            height: 500px;            border: 8px solid #EEEEEE;            background-color: white;            /*让div水平居中*/            margin: auto;        &#125;            .rg_left&#123;            /*border: 1px solid red;*/            float: left;            margin: 15px;        &#125;        .rg_left &gt; p:first-child&#123;            color:#FFD026;            font-size: 20px;        &#125;            .rg_left &gt; p:last-child&#123;            color:#A6A6A6;            font-size: 20px;            &#125;</code></pre><p>​        </p><pre><code>        .rg_center&#123;            float: left;           /* border: 1px solid red;*/            &#125;            .rg_right&#123;            /*border: 1px solid red;*/            float: right;            margin: 15px;        &#125;            .rg_right &gt; p:first-child&#123;            font-size: 15px;            &#125;        .rg_right p a &#123;            color:pink;        &#125;            .td_left&#123;            width: 100px;            text-align: right;            height: 45px;        &#125;        .td_right&#123;            padding-left: 50px ;        &#125;            #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;            width: 251px;            height: 32px;            border: 1px solid #A6A6A6 ;            /*设置边框圆角*/            border-radius: 5px;            padding-left: 10px;        &#125;        #checkcode&#123;            width: 110px;        &#125;            #img_check&#123;            height: 32px;            vertical-align: middle;        &#125;            #btn_sub&#123;            width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026 ;        &#125;        &lt;/style&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;rg_layout&quot;&gt;        &lt;div class=&quot;rg_left&quot;&gt;            &lt;p&gt;新用户注册&lt;/p&gt;            &lt;p&gt;USER REGISTER&lt;/p&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_center&quot;&gt;            &lt;div class=&quot;rg_form&quot;&gt;                &lt;!--定义表单 form--&gt;                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;</code></pre><p>​        </p><pre><code>                        &lt;tr&gt;                            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/form&gt;</code></pre><p>​        </p><pre><code>            &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_right&quot;&gt;            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><pre><code>1. JavaScript基础</code></pre><h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><pre><code>* 概念：    一门客户端脚本语言    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了* 功能：    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。* JavaScript发展史：    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--    ，后来更名为：ScriptEase    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript    3. 1996年，微软抄袭JavaScript开发出JScript语言    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)* ECMAScript：客户端脚本语言的标准    1. 基本语法：        1. 与html结合方式            1. 内部JS：                * 定义&lt;script&gt;，标签体内容就是js代码            2. 外部JS：                * 定义&lt;script&gt;，通过src属性引入外部的js文件            * 注意：                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。                2. &lt;script&gt;可以定义多个。        2. 注释            1. 单行注释：//注释内容            2. 多行注释：/*注释内容*/        3. 数据类型：            1. 原始数据类型(基本数据类型)：                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &#39;abc&#39;                3. boolean: true和false                4. null：一个对象为空的占位符                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined                            2. 引用数据类型：对象                    4. 变量            * 变量：一小块存储数据的内存空间            * Java语言是强类型语言，而JavaScript是弱类型语言。                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。            * 语法：                * var 变量名 = 初始化值;                        * typeof运算符：获取变量的类型。                * 注：null运算后得到的是object        5. 运算符            1. 一元运算符：只有一个运算数的运算符                ++，-- ， +(正号)                  * ++ --: 自增(自减)                    * ++(--) 在前，先自增(自减)，再运算                    * ++(--) 在后，先运算，再自增(自减)                * +(-)：正负号                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换                    * 其他类型转number：                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）                        * boolean转number：true转为1，false转为0            2. 算数运算符                + - * / % ...            3. 赋值运算符                = += -+....            4. 比较运算符                &gt; &lt; &gt;= &lt;= == ===(全等于)                * 比较方式                  1. 类型相同：直接比较                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。                  2. 类型不同：先进行类型转换，再比较                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false            5. 逻辑运算符                &amp;&amp; || !                * 其他类型转boolean：                   1. number：0或NaN为假，其他为真                   2. string：除了空字符串(&quot;&quot;)，其他都是true                   3. null&amp;undefined:都是false                   4. 对象：所有对象都为true                        6. 三元运算符                ? : 表达式                var a = 3;                var b = 4;                        var c = a &gt; b ? 1:0;                * 语法：                    * 表达式? 值1:值2;                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；                    6. 流程控制语句：            1. if...else...            2. switch:                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)                    * switch(变量):                        case 值:                * 在JS中,switch语句可以接受任意的原始数据类型            3. while            4. do...while            5. for        7. JS特殊语法：            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)            2. 变量的定义使用var关键字，也可以不使用                * 用： 定义的变量是局部变量                * 不用：定义的变量是全局变量(不建议)        8. 练习：99乘法表        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;99乘法表&lt;/title&gt;            &lt;style&gt;                td&#123;                    border: 1px solid;                &#125;                    &lt;/style&gt;                    &lt;script&gt;                        document.write(&quot;&lt;table  align=&#39;center&#39;&gt;&quot;);</code></pre><p>​            </p><pre><code>                //1.完成基本的for循环嵌套，展示乘法表                for (var i = 1; i &lt;= 9 ; i++) &#123;                    document.write(&quot;&lt;tr&gt;&quot;);                    for (var j = 1; j &lt;=i ; j++) &#123;                        document.write(&quot;&lt;td&gt;&quot;);                                //输出  1 * 1 = 1                        document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);                                document.write(&quot;&lt;/td&gt;&quot;);                    &#125;                    /*//输出换行                    document.write(&quot;&lt;br&gt;&quot;);*/                            document.write(&quot;&lt;/tr&gt;&quot;);                &#125;                        //2.完成表格嵌套                document.write(&quot;&lt;/table&gt;&quot;);                    &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;                &lt;/body&gt;        &lt;/html&gt;    2. 基本对象：        1. Function：函数(方法)对象            1. 创建：                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧                2.                     function 方法名称(形式参数列表)&#123;                        方法体                    &#125;                3.                    var 方法名 = function(形式参数列表)&#123;                        方法体                   &#125;            2. 方法：            3. 属性：                length:代表形参的个数            4. 特点：                1. 方法定义是，形参的类型不用写,返回值类型也不写。                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数            5. 调用：                方法名称(实际参数列表);                2. Array:数组对象            1. 创建：                1. var arr = new Array(元素列表);                2. var arr = new Array(默认长度);                3. var arr = [元素列表];            2. 方法                join(参数):将数组中的元素按照指定的分隔符拼接为字符串                push()    向数组的末尾添加一个或更多元素，并返回新的长度。            3. 属性                length:数组的长度            4. 特点：                1. JS中，数组元素的类型可变的。                2. JS中，数组长度可变的。        3. Boolean        4. Date：日期对象            1. 创建：                var date = new Date();            2. 方法：                toLocaleString()：返回当前date对象对应的时间本地字符串格式                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差        5. Math：数学对象            1. 创建：                * 特点：Math对象不用创建，直接使用。  Math.方法名();            2. 方法：                random():返回 0 ~ 1 之间的随机数。 含0不含1                ceil(x)：对数进行上舍入。                floor(x)：对数进行下舍入。                round(x)：把数四舍五入为最接近的整数。            3. 属性：                PI        6. Number        7. String        8. RegExp：正则表达式对象            1. 正则表达式：定义字符串的组成规则。                1. 单个字符:[]                    如： [a] [ab] [a-zA-Z0-9_]                    * 特殊符号代表特殊含义的单个字符:                        \d:单个数字字符 [0-9]                        \w:单个单词字符[a-zA-Z0-9_]                2. 量词符号：                    ?：表示出现0次或1次                    *：表示出现0次或多次                    +：出现1次或多次                    &#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n                        * m如果缺省： &#123;,n&#125;:最多n次                        * n如果缺省：&#123;m,&#125; 最少m次                3. 开始结束符号                    * ^:开始                    * $:结束            2. 正则对象：                1. 创建                    1. var reg = new RegExp(&quot;正则表达式&quot;);                    2. var reg = /正则表达式/;                2. 方法                        1. test(参数):验证指定的字符串是否符合正则定义的规范            9. Global            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();            2. 方法：                encodeURI():url编码                decodeURI():url解码                encodeURIComponent():url编码,编码的字符更多                decodeURIComponent():url解码                parseInt():将字符串转为数字                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number                isNaN():判断一个值是否是NaN                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。            3. URL编码               传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2* BOM* DOM</code></pre><h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><pre><code>1. JavaScript：    1. ECMAScript：    2. BOM：    3. DOM：        1. 事件</code></pre><h2 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h2><pre><code>* 功能：控制html文档的内容* 获取页面标签(元素)对象：Element    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象* 操作Element对象：    1. 修改属性值：        1. 明确获取的对象是哪一个？        2. 查看API文档，找其中有哪些属性可以设置    2. 修改标签体内容：        * 属性：innerHTML        1. 获取元素对象        2. 使用innerHTML属性修改标签体内容</code></pre><h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2><pre><code>* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。    * 造句：  xxx被xxx,我就xxx        * 我方水晶被摧毁后，我就责备对友。        * 敌方水晶被摧毁后，我就夸奖自己。* 如何绑定事件    1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码        1. 事件：onclick--- 单击事件    2. 通过js获取元素对象，指定事件属性，设置一个函数    * 代码：        &lt;body&gt;            &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;  onclick=&quot;fun();&quot;&gt;            &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt;                        &lt;script&gt;                function fun()&#123;                    alert(&#39;我被点了&#39;);                    alert(&#39;我又被点了&#39;);                &#125;                            function fun2()&#123;                    alert(&#39;咋老点我？&#39;);                &#125;                            //1.获取light2对象                var light2 = document.getElementById(&quot;light2&quot;);                //2.绑定事件                light2.onclick = fun2;</code></pre><p>​                </p><pre><code>            &lt;/script&gt;        &lt;/body&gt;* 案例1：电灯开关    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;电灯开关&lt;/title&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt;        &lt;script&gt;        /*            分析：                1.获取图片对象                2.绑定单击事件                3.每次点击切换图片                    * 规则：                        * 如果灯是开的 on,切换图片为 off                        * 如果灯是关的 off,切换图片为 on                    * 使用标记flag来完成             */            //1.获取图片对象        var light = document.getElementById(&quot;light&quot;);            var flag = false;//代表灯是灭的。 off图片            //2.绑定单击事件        light.onclick = function()&#123;            if(flag)&#123;//判断如果灯是开的，则灭掉                light.src = &quot;img/off.gif&quot;;                flag = false;                &#125;else&#123;                //如果灯是灭的，则打开                    light.src = &quot;img/on.gif&quot;;                flag = true;            &#125;</code></pre><p>​        </p><pre><code>        &#125;            &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><pre><code>1. 概念：Browser Object Model 浏览器对象模型    * 将浏览器的各个组成部分封装成对象。2. 组成：    * Window：窗口对象    * Navigator：浏览器对象    * Screen：显示器屏幕对象    * History：历史记录对象    * Location：地址栏对象3. Window：窗口对象    1. 创建    2. 方法         1. 与弹出框有关的方法：            alert()    显示带有一段消息和一个确认按钮的警告框。            confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。                * 如果用户点击确定按钮，则方法返回true                * 如果用户点击取消按钮，则方法返回false            prompt()    显示可提示用户输入的对话框。                * 返回值：获取用户输入的值         2. 与打开关闭有关的方法：            close()    关闭浏览器窗口。                * 谁调用我 ，我关谁            open()    打开一个新的浏览器窗口                * 返回新的Window对象         3. 与定时器有关的方式            setTimeout()    在指定的毫秒数后调用函数或计算表达式。                * 参数：                    1. js代码或者方法对象                    2. 毫秒值                * 返回值：唯一标识，用于取消定时器            clearTimeout()    取消由 setTimeout() 方法设置的 timeout。            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。            clearInterval()    取消由 setInterval() 设置的 timeout。    3. 属性：        1. 获取其他BOM对象：            history            location            Navigator            Screen:        2. 获取DOM对象            document    4. 特点        * Window对象不需要创建可以直接使用 window使用。 window.方法名();        * window引用可以省略。  方法名();4. Location：地址栏对象    1. 创建(获取)：        1. window.location        2. location    2. 方法：        * reload()    重新加载当前文档。刷新    3. 属性        * href    设置或返回完整的 URL。5. History：历史记录对象    1. 创建(获取)：        1. window.history        2. history    2. 方法：        * back()    加载 history 列表中的前一个 URL。        * forward()    加载 history 列表中的下一个 URL。        * go(参数)    加载 history 列表中的某个具体页面。            * 参数：                * 正数：前进几个历史记录                * 负数：后退几个历史记录    3. 属性：        * length    返回当前窗口历史列表中的 URL 数量。</code></pre><h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><pre><code>* 概念： Document Object Model 文档对象模型    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作* W3C DOM 标准被分为 3 个不同的部分：    * 核心 DOM - 针对任何结构化文档的标准模型        * Document：文档对象        * Element：元素对象        * Attribute：属性对象        * Text：文本对象        * Comment:注释对象        * Node：节点对象，其他5个的父对象    * XML DOM - 针对 XML 文档的标准模型    * HTML DOM - 针对 HTML 文档的标准模型* 核心DOM模型：    * Document：文档对象        1. 创建(获取)：在html dom模型中可以使用window对象来获取            1. window.document            2. document        2. 方法：            1. 获取Element对象：                1. getElementById()    ： 根据id属性值获取元素对象。id属性值一般唯一                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组            2. 创建其他DOM对象：                createAttribute(name)                createComment()                createElement()                createTextNode()        3. 属性    * Element：元素对象        1. 获取/创建：通过document来获取和创建        2. 方法：            1. removeAttribute()：删除属性            2. setAttribute()：设置属性    * Node：节点对象，其他5个的父对象        * 特点：所有dom对象都可以被认为是一个节点        * 方法：            * CRUD dom树：                * appendChild()：向节点的子节点列表的结尾添加新的子节点。                * removeChild()    ：删除（并返回）当前节点的指定子节点。                * replaceChild()：用新节点替换一个子节点。        * 属性：            * parentNode 返回节点的父节点。* HTML DOM    1. 标签体的设置和获取：innerHTML    2. 使用html元素对象的属性    3. 控制元素样式        1. 使用元素的style属性来设置            如：                 //修改样式方式1                div1.style.border = &quot;1px solid red&quot;;                div1.style.width = &quot;200px&quot;;                //font-size--&gt; fontSize                div1.style.fontSize = &quot;20px&quot;;        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</code></pre><h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><pre><code>* 概念：某些组件被执行了某些操作后，触发某些代码的执行。        * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了    * 事件源：组件。如： 按钮 文本输入框...    * 监听器：代码。    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。* 常见的事件：    1. 点击事件：        1. onclick：单击事件        2. ondblclick：双击事件    2. 焦点事件        1. onblur：失去焦点        2. onfocus:元素获得焦点。    3. 加载事件：        1. onload：一张页面或一幅图像完成加载。    4. 鼠标事件：        1. onmousedown    鼠标按钮被按下。        2. onmouseup    鼠标按键被松开。        3. onmousemove    鼠标被移动。        4. onmouseover    鼠标移到某元素之上。        5. onmouseout    鼠标从某元素移开。</code></pre><p>​            </p><pre><code>    5. 键盘事件：        1. onkeydown    某个键盘按键被按下。            2. onkeyup        某个键盘按键被松开。        3. onkeypress    某个键盘按键被按下并松开。    6. 选择和改变        1. onchange    域的内容被改变。        2. onselect    文本被选中。    7. 表单事件：        1. onsubmit    确认按钮被点击。        2. onreset    重置按钮被点击。</code></pre><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
      <tag>Css</tag>
      
      <tag>Js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2017/09/21/mysql/"/>
    <url>/2017/09/21/mysql/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h1><ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL</code></pre><p>​    </p><pre><code>4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。    3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。    2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */    3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !                    -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;                        SELECT * FROM student WHERE age &gt;= 20;                        -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;                        -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;                        -- 查询年龄大于等于20 小于等于30                        SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;                        -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);                        -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断                        SELECT * FROM student WHERE english IS NULL;                        -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;            -- 查询姓名第二个字是化的人                        SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;                        -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;</code></pre><p>​                </p><pre><code>            -- 查询姓名中包含德的人            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;</code></pre><h1 id="Mysql约束"><a href="#Mysql约束" class="headerlink" title="Mysql约束"></a>Mysql约束</h1><pre><code>1. DQL:查询语句    1. 排序查询    2. 聚合函数    3. 分组查询    4. 分页查询2. 约束3. 多表之间的关系4. 范式5. 数据库的备份和还原</code></pre><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count：计算个数        1. 一般选择非空的列：主键        2. count(*)    2. max：计算最大值    3. min：计算最小值    4. sum：计算和    5. avg：计算平均值    * 注意：聚合函数的计算，排除null值。        解决方案：            1. 选择不包含非空的列进行计算            2. IFNULL函数3. 分组查询:    1. 语法：group by 分组字段；    2. 注意：        1. 分组之后查询的字段：分组字段、聚合函数        2. where 和 having 的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。        -- 按照性别分组。分别查询男、女同学的平均分        SELECT sex , AVG(math) FROM student GROUP BY sex;                -- 按照性别分组。分别查询男、女同学的平均分,人数                SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;                --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;                --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;                SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</code></pre><p>​            </p><pre><code>4. 分页查询    1. 语法：limit 开始的索引,每页查询的条数;    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数        -- 每页显示3条记录         SELECT * FROM student LIMIT 0,3; -- 第1页                SELECT * FROM student LIMIT 3,3; -- 第2页                SELECT * FROM student LIMIT 6,3; -- 第3页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    * 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null，值不能为null    1. 创建表时添加约束        CREATE TABLE stu(            id INT,            NAME VARCHAR(20) NOT NULL -- name为非空        );    2. 创建表完后，添加非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20);</code></pre><p>​    </p><pre><code>* 唯一约束：unique，值不能重复    1. 创建表时，添加唯一约束        CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束                );        * 注意mysql中，唯一约束限定的列的值可以有多个null</code></pre><p>​        </p><pre><code>    2. 删除唯一约束            ALTER TABLE stu DROP INDEX phone_number;        3. 在创建表后，添加唯一约束        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 在创建表时，添加主键约束        create table stu(            id int primary key,-- 给id添加主键约束            name varchar(20)        );    3. 删除主键        -- 错误 alter table stu modify id int ;        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建完表后，添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长        2. 在创建表时，添加主键约束，并且完成主键自增长        create table stu(            id int primary key auto_increment,-- 给id添加主键约束            name varchar(20)        );</code></pre><p>​            </p><pre><code>        3. 删除自动增长        ALTER TABLE stu MODIFY id INT;        4. 添加自动增长        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。    1. 在创建表时，可以添加外键        * 语法：            create table 表名(                ....                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre><p>​        </p><pre><code>    4. 级联操作        1. 添加级联操作            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                     FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;        2. 分类：            1. 级联更新：ON UPDATE CASCADE             2. 级联删除：ON DELETE CASCADE </code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。    3. 案例        -- 创建旅游线路分类表 tab_category        -- cid 旅游线路分类主键，自动增长        -- cname 旅游线路分类名称非空，唯一，字符串 100        CREATE TABLE tab_category (            cid INT PRIMARY KEY AUTO_INCREMENT,            cname VARCHAR(100) NOT NULL UNIQUE        );                -- 创建旅游线路表 tab_route        /*        rid 旅游线路主键，自动增长        rname 旅游线路名称非空，唯一，字符串 100        price 价格        rdate 上架时间，日期类型        cid 外键，所属分类        */        CREATE TABLE tab_route(            rid INT PRIMARY KEY AUTO_INCREMENT,            rname VARCHAR(100) NOT NULL UNIQUE,            price DOUBLE,            rdate DATE,            cid INT,            FOREIGN KEY (cid) REFERENCES tab_category(cid)        );                /*创建用户表 tab_user        uid 用户主键，自增长        username 用户名长度 100，唯一，非空        password 密码长度 30，非空        name 真实姓名长度 100        birthday 生日        sex 性别，定长字符串 1        telephone 手机号，字符串 11        email 邮箱，字符串长度 100        */        CREATE TABLE tab_user (            uid INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(100) UNIQUE NOT NULL,            PASSWORD VARCHAR(30) NOT NULL,            NAME VARCHAR(100),            birthday DATE,            sex CHAR(1) DEFAULT &#39;男&#39;,            telephone VARCHAR(11),            email VARCHAR(100)        );                /*        创建收藏表 tab_favorite        rid 旅游线路 id，外键        date 收藏时间        uid 用户 id，外键        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次        */        CREATE TABLE tab_favorite (            rid INT, -- 线路id            DATE DATETIME,            uid INT, -- 用户id            -- 创建复合主键            PRIMARY KEY(rid,uid), -- 联合主键            FOREIGN KEY (rid) REFERENCES tab_route(rid),            FOREIGN KEY(uid) REFERENCES tab_user(uid)        );</code></pre><p>​        </p><pre><code>2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性                            3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：    * 语法：        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2. 图形化工具：</code></pre><h1 id="多表-amp-事务"><a href="#多表-amp-事务" class="headerlink" title="多表&amp;事务"></a>多表&amp;事务</h1><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：    select        列名列表    from        表名列表    where....* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)    );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);* 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;                        -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;                        SELECT                 t1.name, -- 员工表的姓名                t1.gender,-- 员工表的性别                t2.name -- 部门表的名称            FROM                emp t1,                dept t2            WHERE                 t1.`dept_id` = t2.`id`;</code></pre><p>​    </p><pre><code>        2. 显式内连接：            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;                    * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;            3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段    2. 外链接查询：        1. 左外连接：            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；            * 查询的是左表所有数据以及其交集部分。            * 例子：                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;        2. 右外连接：            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；            * 查询的是右表所有数据以及其交集部分。            * 例子：                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;    3. 子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 查询工资最高的员工信息            -- 1 查询最高的工资是多少 9000            SELECT MAX(salary) FROM emp;                        -- 2 查询员工信息，并且工资等于9000的            SELECT * FROM emp WHERE emp.`salary` = 9000;                        -- 一条sql就完成这个操作。子查询            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);        * 子查询不同情况            1. 子查询的结果是单行单列的：                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =                *                 -- 查询员工工资小于平均工资的人                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in来判断                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;                -- 子查询                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2                WHERE t1.id = t2.dept_id;                                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;    * 多表查询练习            -- 部门表            CREATE TABLE dept (              id INT PRIMARY KEY PRIMARY KEY, -- 部门id              dname VARCHAR(50), -- 部门名称              loc VARCHAR(50) -- 部门所在地            );                        -- 添加4个部门            INSERT INTO dept(id,dname,loc) VALUES             (10,&#39;教研部&#39;,&#39;北京&#39;),            (20,&#39;学工部&#39;,&#39;上海&#39;),            (30,&#39;销售部&#39;,&#39;广州&#39;),            (40,&#39;财务部&#39;,&#39;深圳&#39;);</code></pre><p>​<br>​                </p><pre><code>            -- 职务表，职务名称，职务描述            CREATE TABLE job (              id INT PRIMARY KEY,              jname VARCHAR(20),              description VARCHAR(50)            );                        -- 添加4个职务            INSERT INTO job (id, jname, description) VALUES            (1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;),            (2, &#39;经理&#39;, &#39;管理部门员工&#39;),            (3, &#39;销售员&#39;, &#39;向客人推销产品&#39;),            (4, &#39;文员&#39;, &#39;使用办公软件&#39;);</code></pre><p>​<br>​                </p><pre><code>            -- 员工表            CREATE TABLE emp (              id INT PRIMARY KEY, -- 员工id              ename VARCHAR(50), -- 员工姓名              job_id INT, -- 职务id              mgr INT , -- 上级领导              joindate DATE, -- 入职日期              salary DECIMAL(7,2), -- 工资              bonus DECIMAL(7,2), -- 奖金              dept_id INT, -- 所在部门编号              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)            );                        -- 添加员工            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES             (1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),            (1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),            (1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),            (1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),            (1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),            (1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),            (1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),            (1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),            (1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),            (1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),            (1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),            (1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),            (1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),            (1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);</code></pre><p>​<br>​                </p><pre><code>            -- 工资等级表            CREATE TABLE salarygrade (              grade INT PRIMARY KEY,   -- 级别              losalary INT,  -- 最低工资              hisalary INT -- 最高工资            );                        -- 添加5个工资等级            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES             (1,7000,12000),            (2,12010,14000),            (3,14010,20000),            (4,20010,30000),            (5,30010,99990);                        -- 需求：                        -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述            /*                分析：                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表                    2.查询条件 emp.job_id = job.id                        */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description` -- 职务描述            FROM                 emp t1, job t2            WHERE                 t1.`job_id` = t2.`id`;</code></pre><p>​<br>​                </p><pre><code>            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置            /*                分析：                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id            */                        SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description`, -- 职务描述                t3.`dname`, -- 部门名称                t3.`loc` -- 部门位置            FROM                 emp t1, job t2,dept t3            WHERE                 t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;                           -- 3.查询员工姓名，工资，工资等级            /*                分析：                    1.员工姓名，工资 emp  工资等级 salarygrade                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.ename ,                t1.`salary`,                t2.*            FROM emp t1, salarygrade t2            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;</code></pre><p>​<br>​                </p><pre><code>            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级            /*                分析：                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary                                    */            SELECT                 t1.`ename`,                t1.`salary`,                t2.`jname`,                t2.`description`,                t3.`dname`,                t3.`loc`,                t4.`grade`            FROM                 emp t1,job t2,dept t3,salarygrade t4            WHERE                 t1.`job_id` = t2.`id`                 AND t1.`dept_id` = t3.`id`                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;</code></pre><p>​<br>​                </p><pre><code>            -- 5.查询出部门编号、部门名称、部门位置、部门人数                        /*                分析：                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)                    3.使用子查询将第2步的查询结果和dept表进行关联查询                                */            SELECT                 t1.`id`,t1.`dname`,t1.`loc` , t2.total            FROM                 dept t1,                (SELECT                    dept_id,COUNT(id) total                FROM                     emp                GROUP BY dept_id) t2            WHERE t1.`id` = t2.dept_id;</code></pre><p>​                </p><pre><code>            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询                        /*                分析：                    1.姓名 emp， 直接上级的姓名 emp                        * emp表的id 和 mgr 是自关联                    2.条件 emp.id = emp.mgr                    3.查询左表的所有数据，和 交集数据                        * 使用左外连接查询                            */            /*            select                t1.ename,                t1.mgr,                t2.`id`,                t2.ename            from emp t1, emp t2            where t1.mgr = t2.`id`;                        */                        SELECT                 t1.ename,                t1.mgr,                t2.`id`,                t2.`ename`            FROM emp t1            LEFT JOIN emp t2            ON t1.`mgr` = t2.`id`;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍    1. 概念：        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。            2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;    3. 例子：        CREATE TABLE account (            id INT PRIMARY KEY AUTO_INCREMENT,            NAME VARCHAR(10),            balance DOUBLE        );        -- 添加数据        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);</code></pre><p>​            </p><pre><code>        SELECT * FROM account;        UPDATE account SET balance = 1000;        -- 张三给李四转账 500 元                -- 0. 开启事务        START TRANSACTION;        -- 1. 张三账户 -500                UPDATE account SET balance = balance - 500 WHERE NAME = &#39;zhangsan&#39;;        -- 2. 李四账户 +500        -- 出错了...        UPDATE account SET balance = balance + 500 WHERE NAME = &#39;lisi&#39;;                -- 发现执行没有问题，提交事务        COMMIT;                -- 发现出问题了，回滚事务        ROLLBACK;    4. MySQL数据库中事务默认自动提交                * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle 数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        2. 删除用户：            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        3. 修改用户密码：                        UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;                        SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;                        * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;            -- 给张三用户授予所有权限，在任意数据库任意表上                        GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;</code></pre><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><pre><code>1. JDBC基本概念2. 对JDBC中各个接口和类详解</code></pre><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static &#123;                        try &#123;                            java.sql.DriverManager.registerDriver(new Driver());                        &#125; catch (SQLException E) &#123;                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                        &#125;                    &#125;                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try &#123;                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0)&#123;                        System.out.println(&quot;添加成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;添加失败！&quot;);                    &#125;                        &#125; catch (ClassNotFoundException e) &#123;                    e.printStackTrace();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null)&#123;                        try &#123;                            stmt.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                            if(conn != null)&#123;                        try &#123;                            conn.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;                4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)                * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next())&#123;                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                        System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                &#125;        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125;                3. 实现方法 select * from emp;                        5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a            2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils &#123;    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static&#123;        //读取资源文件，获取值。        try &#123;            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><p>​    </p><pre><code>    /**     * 获取连接     * @return 连接对象     */    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url, user, password);    &#125;    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(Statement stmt,Connection conn)&#123;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><p>​    </p><pre><code>    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;        if( rs != null)&#123;            try &#123;                rs.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)                        );            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);        2. 代码实现：            public class JDBCDemo9 &#123;                public static void main(String[] args) &#123;                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag)&#123;                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;用户名或密码错误！&quot;);                    &#125;</code></pre><p>​                </p><pre><code>                &#125;</code></pre><p>​<br>​                </p><pre><code>                /**                 * 登录方法                 */                public boolean login(String username ,String password)&#123;                    if(username == null || password == null)&#123;                        return false;                    &#125;                    //连接数据库判断是否登录成功                    Connection conn = null;                    Statement stmt =  null;                    ResultSet rs = null;                    //1.获取连接                    try &#123;                        conn =  JDBCUtils.getConnection();                        //2.定义sql                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;                        //3.获取执行sql的对象                        stmt = conn.createStatement();                        //4.执行查询                        rs = stmt.executeQuery(sql);                        //5.判断                       /* if(rs.next())&#123;//如果有下一行，则返回true                            return true;                        &#125;else&#123;                            return false;                        &#125;*/                       return rs.next();//如果有下一行，则返回true                                &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;finally &#123;                        JDBCUtils.close(rs,stmt,conn);                    &#125;</code></pre><p>​                </p><pre><code>                    return false;                &#125;            &#125;</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()         * 当所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务4. 代码：    public class JDBCDemo10 &#123;        public static void main(String[] args) &#123;            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;                try &#123;                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                    //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                    pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                    pstmt2.executeUpdate();                //提交事务                conn.commit();            &#125; catch (Exception e) &#123;                //事务回滚                try &#123;                    if(conn != null) &#123;                        conn.rollback();                    &#125;                &#125; catch (SQLException e1) &#123;                    e1.printStackTrace();                &#125;                e.printStackTrace();            &#125;finally &#123;                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            &#125;</code></pre><p>​        </p><pre><code>        &#125;        &#125;</code></pre><p>​            </p><h1 id="JDBC连接池"><a href="#JDBC连接池" class="headerlink" title="JDBC连接池"></a>JDBC连接池</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils &#123;            //1.定义成员变量 DataSource            private static DataSource ds ;                    static&#123;                try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;                    /**             * 获取连接             */            public static Connection getConnection() throws SQLException &#123;                return ds.getConnection();            &#125;                    /**             * 释放资源             */            public static void close(Statement stmt,Connection conn)&#123;               /* if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                        if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;*/                       close(null,stmt,conn);            &#125;</code></pre><p>​            </p><pre><code>            public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;</code></pre><p>​            </p><pre><code>                if(rs != null)&#123;                    try &#123;                        rs.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;</code></pre><p>​            </p><pre><code>                if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                        if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;                    /**             * 获取连接池方法             */                    public static DataSource getDataSource()&#123;                return  ds;            &#125;                &#125;</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：                        import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;                        import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;                        public class JdbcTemplateDemo2 &#123;                            //Junit单元测试，可以让方法独立执行</code></pre><p>​                </p><pre><code>                //1. 获取JDBCTemplate对象                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                /**                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1()&#123;                                //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                &#125;                            /**                 * 2. 添加一条记录                 */                @Test                public void test2()&#123;                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                            &#125;                            /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3()&#123;                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                &#125;                            /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4()&#123;                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;                            &#125;                            /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                                for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;                        System.out.println(stringObjectMap);                    &#125;                &#125;                            /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                            @Test                public void test6()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;                                    @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                                        emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                                        return emp;                        &#125;                    &#125;);</code></pre><p>​                </p><pre><code>                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                            /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                            @Test                public void test6_2()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                            /**                 * 7. 查询总记录数                 */                            @Test                public void test7()&#123;                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                &#125;                        &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎08-网络</title>
    <link href="/2017/09/19/java%E5%9F%BA%E7%A4%8E08-%E7%BD%91%E7%BB%9C/"/>
    <url>/2017/09/19/java%E5%9F%BA%E7%A4%8E08-%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件</li></ul><ul><li><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li></ul><ul><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="/img/cphoto/net01.jpg"></p><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示</p></li></ul><p><img src="/img/cphoto/net02.jpg"></p><p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位 </p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p><img src="/img/cphoto/net03.jpg"></p><p> 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ipconfig<br></code></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ping 空格 IP地址<br>ping <span class="hljs-number">220.181</span><span class="hljs-number">.57</span><span class="hljs-number">.216</span><br></code></pre></td></tr></table></figure><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public void close()</code> ：关闭此套接字。</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p><ul><li>任何先前写出的数据将被发送，随后终止输出流。 </li></ul><h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li></ul><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure><h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="/img/cphoto/net04.jpg"></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p>服务端实现：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      <span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>        <span class="hljs-comment">//5.关闭资源.</span><br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br><span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br><span class="hljs-comment">// 2.获取流对象 . 输出流</span><br>OutputStream os = client.getOutputStream();<br><span class="hljs-comment">// 3.写出数据.</span><br>os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br><span class="hljs-comment">// 4. 关闭资源 .</span><br>os.close();<br>client.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      <span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>      <span class="hljs-comment">// =================回写数据=======================</span><br>      <span class="hljs-comment">// 5. 通过 socket 获取输出流</span><br>       OutputStream out = server.getOutputStream();<br>      <span class="hljs-comment">// 6. 回写数据</span><br>       out.write(<span class="hljs-string">&quot;我很好,谢谢你&quot;</span>.getBytes());<br>      <span class="hljs-comment">// 7.关闭资源.</span><br>      out.close();<br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br><span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br><span class="hljs-comment">// 2.通过Scoket,获取输出流对象 </span><br>OutputStream os = client.getOutputStream();<br><span class="hljs-comment">// 3.写出数据.</span><br>os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br>      <span class="hljs-comment">// ==============解析回写=========================</span><br>      <span class="hljs-comment">// 4. 通过Scoket,获取 输入流对象</span><br>      InputStream in = client.getInputStream();<br>      <span class="hljs-comment">// 5. 读取数据数据</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];<br>      <span class="hljs-keyword">int</span> len = in.read(b);<br>      System.out.println(<span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len));<br><span class="hljs-comment">// 6. 关闭资源 .</span><br>      in.close();<br>os.close();<br>client.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol><p><img src="/img/cphoto/net05.jpg">    </p><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>      ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>  <span class="hljs-comment">// 2. 建立连接 </span><br>        Socket accept = serverSocket.accept();<br>      <span class="hljs-comment">// 3. 创建流对象</span><br>      <span class="hljs-comment">// 3.1 获取输入流,读取文件数据</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>        <span class="hljs-comment">// 3.2 创建输出流,保存到本地 .</span><br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.jpg&quot;</span>));<br><span class="hljs-comment">// 4. 读写数据</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        <span class="hljs-comment">//5. 关闭 资源</span><br>        bos.close();<br>        bis.close();<br>        accept.close();<br>        System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUPload_Client</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件  </span><br>        BufferedInputStream bis  = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.jpg&quot;</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端 </span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream   bos   = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据. </span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ; <br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>            bos.flush();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;文件发送完毕&quot;</span>);<br>        <span class="hljs-comment">// 3.释放资源</span><br><br>        bos.close(); <br>        socket.close();<br>        bis.close(); <br>        System.out.println(<span class="hljs-string">&quot;文件上传完毕 &quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="hljs-string">&quot;.jpg&quot;</span>) <span class="hljs-comment">// 文件名称</span><br>BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次接收新的连接,创建一个Socket</span><br><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    <span class="hljs-comment">// accept 交给子线程处理.</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      ......<br>        InputStream bis = accept.getInputStream();<br>      ......<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>      <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          <span class="hljs-comment">/* </span><br><span class="hljs-comment">          3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                      bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    <span class="hljs-comment">//4. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                  e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol><p><img src="/img/cphoto/net06.jpg"></p><h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">          3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br>                ) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                        bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br><br>                    <span class="hljs-comment">// 4.=======信息回写===========================</span><br>                    System.out.println(<span class="hljs-string">&quot;back ........&quot;</span>);<br>                    OutputStream out = accept.getOutputStream();<br>                    out.write(<span class="hljs-string">&quot;上传成功&quot;</span>.getBytes());<br>                    out.close();<br>                    <span class="hljs-comment">//================================</span><br><br>                    <span class="hljs-comment">//5. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.jpg&quot;</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据.</span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ;<br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>      <span class="hljs-comment">// 关闭输出流,通知服务端,写出数据完毕</span><br>        socket.shutdownOutput();<br>        System.out.println(<span class="hljs-string">&quot;文件发送完毕&quot;</span>);<br>        <span class="hljs-comment">// 3. =====解析回写============</span><br>        InputStream in = socket.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] back = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">20</span>];<br>        in.read(back);<br>        System.out.println(<span class="hljs-keyword">new</span> String(back));<br>        in.close();<br>        <span class="hljs-comment">// ============================</span><br><br>        <span class="hljs-comment">// 4.释放资源</span><br>        socket.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li><p>准备页面数据，web文件夹。</p><p>复制到我们Module中，比如复制到day08中</p><p><img src="/img/cphoto/net07.jpg"></p></li><li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8000</span>);<br>    Socket socket = server.accept();<br>    InputStream in = socket.getInputStream();<br>       <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> len = in.read(bytes);<br>    System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,len));<br>    socket.close();<br>    server.close();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p><p><img src="/img/cphoto/net08.jpg"></p></li></ol><p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>BufferedReader readWb = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>String requst = readWb.readLine();<br><span class="hljs-comment">//取出请求资源的路径</span><br>String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-comment">//去掉web前面的/</span><br>String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>System.out.println(path);<br></code></pre></td></tr></table></figure><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端  启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 创建ServerSocket 对象</span><br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        Socket socket = server.accept();<br>        <span class="hljs-comment">// 转换流读取浏览器的请求消息</span><br>        BufferedReader readWb = <span class="hljs-keyword">new</span><br>        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        String requst = readWb.readLine();<br>        <span class="hljs-comment">// 取出请求资源的路径</span><br>        String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-comment">// 去掉web前面的/</span><br>        String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 读取客户端请求的资源文件</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>        <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// 字节输出流,将文件写会客户端</span><br>        OutputStream out = socket.getOutputStream();<br>        <span class="hljs-comment">// 写入HTTP协议响应头,固定写法</span><br>        out.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>        out.write(<span class="hljs-string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());<br>        <span class="hljs-comment">// 必须要写入空行,否则浏览器不解析</span><br>        out.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>        <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>            out.write(bytes,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fis.close();<br>        out.close();<br>        readWb.close();<br>        socket.close();<br>        server.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul><li><strong>火狐</strong></li></ul><p><img src="/img/cphoto/net09.jpg"></p><blockquote><p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p></blockquote><p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            Socket socket = server.accept();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Web(socket)).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Web</span><span class="hljs-params">(Socket socket)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.socket=socket;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>                BufferedReader readWb = <span class="hljs-keyword">new</span><br>                        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>                String requst = readWb.readLine();<br>                <span class="hljs-comment">//取出请求资源的路径</span><br>                String[] strArr = requst.split(<span class="hljs-string">&quot; &quot;</span>);<br>                System.out.println(Arrays.toString(strArr));<br>                String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>                System.out.println(path);<br><br>                FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>                System.out.println(fis);<br>                <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>                <span class="hljs-comment">//向浏览器 回写数据</span><br>                OutputStream out = socket.getOutputStream();<br>                out.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>                out.write(<span class="hljs-string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());<br>                out.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>                <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>                    out.write(bytes,<span class="hljs-number">0</span>,len);<br>                &#125;<br>                fis.close();<br>                out.close();<br>                readWb.close();<br>                socket.close();<br>            &#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>图解：</p><h6 id><a href="#" class="headerlink" title></a><img src="/img/cphoto/net10.jpg"></h6><h1 id="第四章-函数式接口"><a href="#第四章-函数式接口" class="headerlink" title="第四章 函数式接口"></a>第四章 函数式接口</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>函数式接口在Java中是指：有且仅有一个抽象方法的接口。<br>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><blockquote><p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p></blockquote><h2 id="1-2-格式"><a href="#1-2-格式" class="headerlink" title="1.2 格式"></a>1.2 格式</h2><p>只要确保接口中有且仅有一个抽象方法即可：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">abstract</span> 返回值类型 方法名称(<span class="hljs-type">可选参数信息</span>);</span><br><span class="hljs-class">// 其他非抽象方法内容</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-3-FunctionalInterface注解"><a href="#1-3-FunctionalInterface注解" class="headerlink" title="1.3 @FunctionalInterface注解"></a>1.3 @FunctionalInterface注解</h2><p>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注<br>解可用于一个接口的定义上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注<br>意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h2 id="1-4-自定义函数式接口"><a href="#1-4-自定义函数式接口" class="headerlink" title="1.4 自定义函数式接口"></a>1.4 自定义函数式接口</h2><p>对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09FunctionalInterface</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义的函数式接口作为方法参数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doSomething</span>(<span class="hljs-params">MyFunctionalInterface inter</span>)</span> &#123;<br>   inter.myMethod(); <span class="hljs-comment">// 调用自定义的函数式接口方法</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 调用使用函数式接口的方法</span><br>        doSomething(() ‐&gt; System.out.println(<span class="hljs-string">&quot;Lambda执行啦！&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-函数式编程"><a href="#第五章-函数式编程" class="headerlink" title="第五章 函数式编程"></a>第五章 函数式编程</h1><p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。<br>下面我们做一个初探。</p><h2 id="2-1-Lambda的延迟执行"><a href="#2-1-Lambda的延迟执行" class="headerlink" title="2.1 Lambda的延迟执行"></a>2.1 Lambda的延迟执行</h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以<br>作为解决方案，提升性能。<br><em><strong>性能浪费的日志案例</strong></em><br>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。<br>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Logger</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, <span class="hljs-keyword">String</span> msg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(msg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>, msgA + msgB + msgC);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码存在问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方<br>法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p><blockquote><p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p></blockquote><p><strong>体验Lambda的更优写法</strong><br>使用Lambda必然需要一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageBuilder</span> </span>&#123;<br><span class="hljs-function">String <span class="hljs-title">buildMessage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后对 log 方法进行改造：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02LoggerLambda</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">buildMessage</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>, () ‐&gt; msgA + msgB + msgC );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p><p><strong>证明Lambda的延迟</strong><br>下面的代码可以通过结果进行验证：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03LoggerDelay</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">buildMessage</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        <span class="hljs-keyword">String</span> msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>, () ‐&gt; &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Lambda执行！&quot;</span>);<br>            <span class="hljs-keyword">return</span> msgA + msgB + msgC;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。<br>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法<br>来完成。而是否调用其所在方法是在条件判断之后才执行的。</p><h2 id="2-2-使用Lambda作为参数和返回值"><a href="#2-2-使用Lambda作为参数和返回值" class="headerlink" title="2.2 使用Lambda作为参数和返回值"></a>2.2 使用Lambda作为参数和返回值</h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数<br>式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式<br>接口作为方法参数。</p><p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就<br>可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">startThread</span>(<span class="hljs-params">Runnable task</span>)</span> &#123;<br>    <span class="hljs-keyword">new</span> Thread(task).start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    startThread(() ‐&gt; System.out.println(<span class="hljs-string">&quot;线程任务执行！&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一<br>个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import java.util.Arrays;<br>import java.util.Comparator;<br>public <span class="hljs-keyword">class</span> Demo06Comparator &#123;<br>    <span class="hljs-keyword">private</span> static Comparator&lt;String&gt; <span class="hljs-keyword">new</span><span class="hljs-constructor">Comparator()</span> &#123;<br>    return (a, b) ‐&gt; b.length<span class="hljs-literal">()</span> ‐ a.length<span class="hljs-literal">()</span>;<br>    &#125;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        String<span class="hljs-literal">[]</span> <span class="hljs-built_in">array</span> = &#123; <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span> &#125;;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">array</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(<span class="hljs-built_in">array</span>, <span class="hljs-keyword">new</span><span class="hljs-constructor">Comparator()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">array</span>)</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中直接return一个Lambda表达式即可。</p><h1 id="第六章-常用函数式接口"><a href="#第六章-常用函数式接口" class="headerlink" title="第六章 常用函数式接口"></a>第六章 常用函数式接口</h1><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。<br>下面是最简单的几个接口及使用示例。</p><h2 id="3-1-Supplier接口"><a href="#3-1-Supplier接口" class="headerlink" title="3.1 Supplier接口"></a>3.1 Supplier接口</h2><p>java.util.function.Supplier<T> 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对<br>象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象<br>数据。</T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08Supplier</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getString</span>(<span class="hljs-params">Supplier&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">function</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>.get();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-built_in">String</span> msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>        System.out.println(getString(() ‐&gt; msgA + msgB));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-练习：求数组元素最大值"><a href="#3-2-练习：求数组元素最大值" class="headerlink" title="3.2 练习：求数组元素最大值"></a>3.2 练习：求数组元素最大值</h2><p><strong>题目</strong><br>使用 Supplier 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型请使用<br>java.lang.Integer 类。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Test</span> &#123;</span><br>    <span class="hljs-comment">//定一个方法,方法的参数传递Supplier,泛型使用Integer</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> sup.<span class="hljs-built_in">get</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">333</span>,<span class="hljs-number">23</span>&#125;;<br>        <span class="hljs-comment">//调用getMax方法,参数传递Lambda</span><br>        <span class="hljs-keyword">int</span> maxNum = <span class="hljs-built_in">getMax</span>(()‐&gt;&#123;<br>            <span class="hljs-comment">//计算数组的最大值</span><br>            <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;max)&#123;<br>                max = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>        &#125;);<br>        System.out.<span class="hljs-built_in">println</span>(maxNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-Consumer接口"><a href="#3-3-Consumer接口" class="headerlink" title="3.3 Consumer接口"></a>3.3 Consumer接口</h2><p>java.util.function.Consumer<T> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，<br>其数据类型由泛型决定。<br><strong>抽象方法：accept</strong><br>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。基本使用如：</T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Consumer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">consumeString</span>(<span class="hljs-params">Consumer&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">function</span></span>)</span> &#123;<br>    <span class="hljs-keyword">function</span>.accept(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    consumeString(s ‐&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，更好的写法是使用方法引用。<br><strong>默认方法：andThen</strong><br>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，<br>然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。下面是JDK的源代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">default Consumer&lt;T&gt; <span class="hljs-keyword">and</span><span class="hljs-constructor">Then(Consumer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">after</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>require<span class="hljs-constructor">NonNull(<span class="hljs-params">after</span>)</span>;<br>    return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注： java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出<br>NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote><p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组<br>合的情况：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConsumerAndThen</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeString</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">String</span>&gt; one, Consumer&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        one.<span class="hljs-built_in">andThen</span>(two).<span class="hljs-built_in">accept</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">consumeString</span>(<br>            s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s.<span class="hljs-built_in">toUpperCase</span>()),<br>            s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s.<span class="hljs-built_in">toLowerCase</span>()));<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的<br>组合。<br>3.4 练习：格式化打印信息<br>题目<br>下面的字符串数组当中存有多条信息，请按照格式“ 姓名：XX。性别：XX。 ”的格式将信息打印出来。要求将打印姓<br>名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实<br>例，将两个 Consumer 接口按照顺序“拼接”到一起。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">public<span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br>String[]<span class="hljs-built_in"> array </span>= &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>解答</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConsumer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span> &#125;;<br>        <span class="hljs-built_in">printInfo</span>(s ‐&gt; System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;姓名：&quot;</span> + s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>]),<br>        s ‐&gt; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;。性别：&quot;</span> + s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;。&quot;</span>),<br>        array);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">String</span>&gt; one, Consumer&lt;<span class="hljs-keyword">String</span>&gt; two, <span class="hljs-keyword">String</span>[] array)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> info : array) &#123;<br>        one.<span class="hljs-built_in">andThen</span>(two).<span class="hljs-built_in">accept</span>(info); <span class="hljs-comment">// 姓名：迪丽热巴。性别：女。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-Predicate接口"><a href="#3-5-Predicate接口" class="headerlink" title="3.5 Predicate接口"></a>3.5 Predicate接口</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<br>java.util.function.Predicate<T> 接口。<br><strong>抽象方法：test</strong><br>Predicate 接口中包含一个抽象方法： boolean test(T t) 。用于条件判断的场景：```</T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo15PredicateTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Predicate&lt;<span class="hljs-built_in">String</span>&gt; predicate</span>)</span> &#123;<br>        <span class="hljs-built_in">boolean</span> veryLong = predicate.test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    method(s ‐&gt; s.length() &gt; <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。<br><strong>默认方法：and</strong><br>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实<br>现“并且”的效果时，可以使用default方法 and 。其JDK源码为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;<br>    Objects<span class="hljs-selector-class">.requireNonNull</span>(other);<br>    return (t) ‐&gt; test(t) &amp;&amp; other<span class="hljs-selector-class">.test</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;<span class="hljs-keyword">String</span>&gt; one, Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isValid = one.<span class="hljs-built_in"><span class="hljs-keyword">and</span></span>(two).<span class="hljs-built_in">test</span>(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;W&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h2><p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。JDK源码为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">default Predicate&lt;<span class="hljs-built_in">T</span>&gt; <span class="hljs-built_in">or</span>(Predicate&lt;? super <span class="hljs-built_in">T</span>&gt; other) &#123;<br>    Objects.requireNonNull(other);<br>    return (<span class="hljs-built_in">t</span>) ‐&gt; test(<span class="hljs-built_in">t</span>) || other.test(<span class="hljs-built_in">t</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不<br>变：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;<span class="hljs-keyword">String</span>&gt; one, Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isValid = one.<span class="hljs-built_in"><span class="hljs-keyword">or</span></span>(two).<span class="hljs-built_in">test</span>(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;W&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>默认方法：negate</strong><br>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-function"><span class="hljs-title">negate</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> (t) ‐&gt; !test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前<br>调用 negate 方法，正如 and 和 or 方法一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo17PredicateNegate</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Predicate&lt;<span class="hljs-built_in">String</span>&gt; predicate</span>)</span> &#123;<br>        <span class="hljs-built_in">boolean</span> veryLong = predicate.negate().test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    method(s ‐&gt; s.length() &lt; <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-练习：集合信息筛选"><a href="#3-6-练习：集合信息筛选" class="headerlink" title="3.6 练习：集合信息筛选"></a>3.6 练习：集合信息筛选</h2><p><strong>题目</strong><br>数组当中有多条“姓名+性别”的信息如下，请通过 Predicate 接口的拼装将符合要求的字符串筛选到集合<br>ArrayList 中，需要同时满足两个条件：</p><ol><li>必须为女生；</li><li>姓名为4个字。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPredicate</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span>, <span class="hljs-string">&quot;赵丽颖,女&quot;</span> &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解答</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPredicate</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;迪丽热巴,女&quot;</span>, <span class="hljs-string">&quot;古力娜扎,女&quot;</span>, <span class="hljs-string">&quot;马尔扎哈,男&quot;</span>, <span class="hljs-string">&quot;赵丽颖,女&quot;</span> &#125;;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-built_in">filter</span>(array,<br>        s ‐&gt; <span class="hljs-string">&quot;女&quot;</span>.<span class="hljs-built_in">equals</span>(s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]),<br>        s ‐&gt; s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>() == <span class="hljs-number">4</span>);<br>        System.out.<span class="hljs-built_in">println</span>(list);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] array, Predicate&lt;<span class="hljs-keyword">String</span>&gt; one,</span></span><br><span class="hljs-params"><span class="hljs-function">        Predicate&lt;<span class="hljs-keyword">String</span>&gt; two)</span> </span>&#123;<br>            List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> info : array) &#123;<br>                <span class="hljs-keyword">if</span> (one.<span class="hljs-built_in"><span class="hljs-keyword">and</span></span>(two).<span class="hljs-built_in">test</span>(info)) &#123;<br>                    list.<span class="hljs-built_in">add</span>(info);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-7-Function接口"><a href="#3-7-Function接口" class="headerlink" title="3.7 Function接口"></a>3.7 Function接口</h2><p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，<br>后者称为后置条件。<br><strong>抽象方法：apply</strong><br>Function 接口中最主要的抽象方法为： R apply(T t) ，根据类型T的参数获取类型R的结果。<br>使用的场景例如：将 String 类型转换为 Integer 类型。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">function</span>.<span class="hljs-keyword">Function</span>;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo11FunctionApply &#123;<br>    private static <span class="hljs-type">void</span> <span class="hljs-keyword">method</span>(<span class="hljs-keyword">Function</span>&lt;String, <span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">function</span>) &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-keyword">function</span>.apply(&quot;10&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(num + <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-keyword">method</span>(s ‐&gt; <span class="hljs-type">Integer</span>.parseInt(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，最好是通过方法引用的写法。<br><strong>默认方法：andThen</strong><br>Function 接口中有一个默认的 andThen 方法，用来进行组合操作。JDK源代码如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">default &lt;V&gt; <span class="hljs-keyword">Function</span>&lt;T, V&gt; andThen(<span class="hljs-keyword">Function</span>&lt;? super R, ? extends V&gt; <span class="hljs-built_in">after</span>) &#123;<br>    Objects.requireNonNull(<span class="hljs-built_in">after</span>);<br>    <span class="hljs-keyword">return</span> (T t) ‐&gt; <span class="hljs-built_in">after</span>.<span class="hljs-built_in">apply</span>(<span class="hljs-built_in">apply</span>(t));<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">function</span>.<span class="hljs-keyword">Function</span>;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo12FunctionAndThen &#123;<br>    private static <span class="hljs-type">void</span> <span class="hljs-keyword">method</span>(<span class="hljs-keyword">Function</span>&lt;String, <span class="hljs-type">Integer</span>&gt; one, <span class="hljs-keyword">Function</span>&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt; two) &#123;<br>        <span class="hljs-type">int</span> num = one.andThen(two).apply(&quot;10&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(num + <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-keyword">method</span>(str‐&gt;<span class="hljs-type">Integer</span>.parseInt(str)+<span class="hljs-number">10</span>, i ‐&gt; i *= <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一<br>起。<br>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p><h2 id="3-8-练习：自定义函数模型拼接"><a href="#3-8-练习：自定义函数模型拼接" class="headerlink" title="3.8 练习：自定义函数模型拼接"></a>3.8 练习：自定义函数模型拼接</h2><p>题目<br>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：<br>String str = “赵丽颖,20”;</p><ol><li>将字符串截取数字年龄部分，得到字符串；</li><li>将上一步的字符串转换成为int类型的数字；</li><li>将上一步的int数字累加100，得到结果int数字。</li></ol><p>解答</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">public</span> class DemoFunction &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;赵丽颖,20&quot;</span>;<br>        <span class="hljs-built_in">int</span> age = getAgeNum(<span class="hljs-built_in">str</span>, s ‐&gt; s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>],<br>        s ‐&gt;Integer.parseInt(s),<br>        n ‐&gt; n += <span class="hljs-number">100</span>);<br>        System.out.<span class="hljs-built_in">println</span>(age);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> getAgeNum(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>, Function&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; one,<br>        Function&lt;<span class="hljs-keyword">String</span>, Integer&gt; two,<br>        Function&lt;Integer, Integer&gt; three) &#123;<br>        <span class="hljs-keyword">return</span> one.andThen(two).andThen(three).apply(<span class="hljs-built_in">str</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第七章-Stream流"><a href="#第七章-Stream流" class="headerlink" title="第七章 Stream流"></a>第七章 Stream流</h1><p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带<br>来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</p><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p><strong>传统集合的多步遍历代码</strong><br>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元<br>素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo01ForEach &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : list) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。<br><strong>循环遍历的弊端</strong><br>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行<br>了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p><ul><li><p>for循环的语法就是“怎么做”</p></li><li><p>for循环的循环体才是“做什么”</p><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。</p></li></ul><p>试想一下，如果希望对集合中的元素进行筛选过滤：</p><ol><li>将集合A根据条件一过滤为子集B；</li><li>然后再根据条件二过滤为子集C。</li></ol><p>那怎么办？在Java 8之前的做法可能为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo02NormalFilter &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>        list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>        List&lt;String&gt; zhangList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : list) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">name</span>.startsWith(&quot;张&quot;)) &#123;<br>            zhangList.<span class="hljs-keyword">add</span>(<span class="hljs-type">name</span>);<br>            &#125;<br>    &#125;<br>        List&lt;String&gt; shortList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : zhangList) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">name</span>.length() == <span class="hljs-number">3</span>) &#123;<br>                shortList.<span class="hljs-keyword">add</span>(<span class="hljs-type">name</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-type">name</span> : shortList) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中含有三个循环，每一个作用不同：</p><ol><li>首先筛选所有姓张的人；</li><li>然后筛选名字有三个字的人；</li><li>最后进行对结果进行打印输出。<br>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</li></ol><p><strong>Stream的更优写法</strong><br>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Demo03StreamFilter &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            list.<span class="hljs-keyword">add</span>(&quot;张无忌&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;周芷若&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;赵敏&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;张强&quot;);<br>            list.<span class="hljs-keyword">add</span>(&quot;张三丰&quot;);<br>            list.stream()<br>                .<span class="hljs-keyword">filter</span>(s ‐&gt; s.startsWith(&quot;张&quot;))<br>                .<span class="hljs-keyword">filter</span>(s ‐&gt; s.length() == <span class="hljs-number">3</span>)<br>                .<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印。代码<br>中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h2 id="1-2-流式思想概述"><a href="#1-2-流式思想概述" class="headerlink" title="1.2 流式思想概述"></a>1.2 流式思想概述</h2><p>注意：请暂时忘记对传统IO流的固有印象！<br>整体来看，流式思想类似于工厂车间的“生产流水线”</p><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤<br>方案，然后再按照方案去执行它。<br><img src="/img/cphoto/flow01.jpg"></p><p>过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。<br>这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 count执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p><blockquote><p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源 流的来源。 可以是集合，数组 等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><p>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p></li><li><p>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭<br>代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</p></li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结  果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以  像链条一样排列，变成一个管道。</p><h2 id="1-3-获取流"><a href="#1-3-获取流" class="headerlink" title="1.3 获取流"></a>1.3 获取流</h2><p>java.util.stream.Stream<T> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）获取一个流非常简单，有以下几种常用的方式：</T></p><ul><li>所有的 Collection 集合都可以通过 stream 默认方法获取流；</li><li>Stream 接口的静态方法 of 可以获取数组对应的流。</li></ul><p><strong>根据Collection获取流</strong><br>首先， java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream1 = list.<span class="hljs-built_in">stream</span>();<br>        Set&lt;<span class="hljs-keyword">String</span>&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream2 = set.<span class="hljs-built_in">stream</span>();<br>        Vector&lt;<span class="hljs-keyword">String</span>&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream3 = vector.<span class="hljs-built_in">stream</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>根据Map获取流</strong><br>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        Map&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; keyStream = map.<span class="hljs-built_in">keySet</span>().<span class="hljs-built_in">stream</span>();<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; valueStream = map.<span class="hljs-built_in">values</span>().<span class="hljs-built_in">stream</span>();<br>        <span class="hljs-built_in">Stream</span>&lt;Map.Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt;&gt; entryStream = map.<span class="hljs-built_in">entrySet</span>().<span class="hljs-built_in">stream</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>根据数组获取流</strong><br>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法<br>of ，使用很简单：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06GetStream</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span>[] array = &#123; <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张翠山&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;张一元&quot;</span> &#125;;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><ul><li><p>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方<br>法均为延迟方法。）</p></li><li><p>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调<br>用。本小节中，终结方法包括 count 和 forEach 方法。</p></li></ul><blockquote><p>备注：本小节之外的更多方法，请自行参考API文档。</p></blockquote><p><strong>逐一处理：forEach</strong><br>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。<br><strong>复习Consumer接口</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">java.util.function.Consumer&lt;<span class="hljs-built_in">T</span>&gt;接口是一个消费型接口。<br>Consumer接口中包含抽象方法void accept(<span class="hljs-built_in">T</span> <span class="hljs-built_in">t</span>)，意为消费一个指定泛型的数据。<br></code></pre></td></tr></table></figure><p><strong>基本使用：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamForEach</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        stream.forEach(name‐&gt; System.out.<span class="hljs-built_in">println</span>(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>过滤：filter</strong></p><p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Stream</span>&lt;<span class="hljs-type">T</span>&gt; filter(<span class="hljs-type">Predicate</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; predicate);<br></code></pre></td></tr></table></figure><p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><p><strong>复习Predicate接口</strong><br>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure><p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法<br>将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。<br><strong>基本使用</strong><br>Stream流中的 filter 方法基本使用的代码如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07StreamFilter</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。<br><strong>映射：map</strong><br>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-keyword">map</span>(<span class="hljs-built_in">Function</span>&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> R&gt; mapper);<br></code></pre></td></tr></table></figure><p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><p><strong>复习Function接口</strong><br>此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">R apply(<span class="hljs-built_in">T</span> <span class="hljs-built_in">t</span>);<br><br></code></pre></td></tr></table></figure><p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。<br><strong>基本使用</strong><br>Stream流中的 map 方法基本使用的代码如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08StreamMap</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;Integer&gt; result = original.<span class="hljs-built_in">map</span>(str‐&gt;Integer.<span class="hljs-built_in">parseInt</span>(str));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。<br><strong>统计个数：count</strong><br>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09StreamCount</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h2><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br><br></code></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10StreamLimit</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">limit</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>跳过前几个：skip</strong><br>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11StreamSkip</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; original = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = original.<span class="hljs-built_in">skip</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(result.<span class="hljs-built_in">count</span>()); <span class="hljs-comment">// 1</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>组合：concat</strong><br>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="xml">static <span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> Stream<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> concat(Stream</span><span class="php"><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; a, Stream<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; b)</span><br><span class="php"></span><br></code></pre></td></tr></table></figure><blockquote><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p></blockquote><p>该方法的基本使用代码如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamConcat</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamA = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamB = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张翠山&quot;</span>);<br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; result = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(streamA, streamB);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-5-练习：集合元素处理（传统方式）"><a href="#1-5-练习：集合元素处理（传统方式）" class="headerlink" title="1.5 练习：集合元素处理（传统方式）"></a>1.5 练习：集合元素处理（传统方式）</h2><p><strong>题目</strong><br>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以下若干操作步骤：</p><ol><li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li><li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li><li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li><li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li><li>将两个队伍合并为一个队伍；存储到一个新集合中。</li><li>根据姓名创建 Person 对象；存储到一个新集合中。</li><li>打印整个队伍的Person对象信息。</li></ol><p>两个队伍（集合）的代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> class DemoArrayListNames &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">//第一支队伍</span><br>        ArrayList&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;宋远桥&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;苏星河&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;石破天&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;石中玉&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;老子&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;庄子&quot;</span>);<br>        one.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;洪七公&quot;</span>);<br>        <span class="hljs-comment">//第二支队伍</span><br>        ArrayList&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;古力娜扎&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;赵丽颖&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;尼古拉斯赵四&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张天爱&quot;</span>);<br>        two.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张二狗&quot;</span>);<br>        <span class="hljs-comment">// ....</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而 Person 类的代码为：    </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解答<br>既然使用传统的for循环写法，那么：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoArrayListNames</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 第一个队伍只要名字为3个字的成员姓名；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; oneA = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">one</span>) &#123;<br>            <span class="hljs-keyword">if</span> (name.length() == <span class="hljs-number">3</span>) &#123;<br>            oneA.add(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 第一个队伍筛选之后只要前3个人；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; oneB = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        oneB.add(oneA.<span class="hljs-keyword">get</span>(i));<br>        &#125;<br>        <span class="hljs-comment">// 第二个队伍只要姓张的成员姓名；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; twoA = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">two</span>) &#123;<br>            <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)) &#123;<br>            twoA.add(name);<br>        &#125;<br>        &#125;<br>        <span class="hljs-comment">// 第二个队伍筛选之后不要前2个人；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; twoB = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">2</span>; i &lt; twoA.size(); i++) &#123;<br>        twoB.add(twoA.<span class="hljs-keyword">get</span>(i));<br>        &#125;<br>        <span class="hljs-comment">// 将两个队伍合并为一个队伍；</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; totalNames = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        totalNames.addAll(oneB);<br>        totalNames.addAll(twoB);<br>        <span class="hljs-comment">// 根据姓名创建Person对象；</span><br>        List&lt;Person&gt; totalPersonList = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">totalNames</span>) &#123;<br>        totalPersonList.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name));<br>        &#125;<br>        <span class="hljs-comment">// 打印整个队伍的Person对象信息。</span><br>        <span class="hljs-keyword">for</span> (Person person : <span class="hljs-type">totalPersonList</span>) &#123;<br>        System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;石破天&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-6-练习：集合元素处理（Stream方式）"><a href="#1-6-练习：集合元素处理（Stream方式）" class="headerlink" title="1.6 练习：集合元素处理（Stream方式）"></a>1.6 练习：集合元素处理（Stream方式）</h2><p><strong>题目</strong><br>将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变， Person 类的定义也不变</p><p>解答</p><p>等效的Stream流式处理代码为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.<span class="hljs-built_in">Stream</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoStreamNames</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; one = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; two = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 第一个队伍只要名字为3个字的成员姓名；</span><br>        <span class="hljs-comment">// 第一个队伍筛选之后只要前3个人；</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamOne = one.<span class="hljs-built_in">stream</span>().<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">length</span>() == <span class="hljs-number">3</span>).<span class="hljs-built_in">limit</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 第二个队伍只要姓张的成员姓名；</span><br>        <span class="hljs-comment">// 第二个队伍筛选之后不要前2个人；</span><br>        <span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; streamTwo = two.<span class="hljs-built_in">stream</span>().<span class="hljs-built_in">filter</span>(s ‐&gt; s.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;张&quot;</span>)).<span class="hljs-built_in">skip</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 将两个队伍合并为一个队伍；</span><br>        <span class="hljs-comment">// 根据姓名创建Person对象；</span><br>        <span class="hljs-comment">// 打印整个队伍的Person对象信息。</span><br>        <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(streamOne, streamTwo).<span class="hljs-built_in">map</span>(Person::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行效果完全一样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;石破天&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="第八章-方法引用"><a href="#第八章-方法引用" class="headerlink" title="第八章 方法引用"></a>第八章 方法引用</h1><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑<br>一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p><h2 id="2-1-冗余的Lambda场景"><a href="#2-1-冗余的Lambda场景" class="headerlink" title="2.1 冗余的Lambda场景"></a>2.1 冗余的Lambda场景</h2><p>来看一个简单的函数式接口以应用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01PrintSimple</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>    data.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">printString</span>(s ‐&gt; System.out.<span class="hljs-built_in">println</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 Printable 的具体操作方案为：拿到String（类型可推导，所以可省略）数据后，在控制台中输出它。</p><p>2## .2 问题分析<br>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out对象中的 println(String) 方法。既然Lambda希望做的事情就是调用 println(String) 方法，那何必自己手动调用呢？</p><h2 id="2-3-用方法引用改进代码"><a href="#2-3-用方法引用改进代码" class="headerlink" title="2.3 用方法引用改进代码"></a>2.3 用方法引用改进代码</h2><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02PrintRef</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>    data.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">printString</span>(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意其中的双冒号 :: 写法，这被称为“方法引用”，而双冒号是一种新的语法。</p><h2 id="2-4-方法引用符"><a href="#2-4-方法引用符" class="headerlink" title="2.4 方法引用符"></a>2.4 方法引用符</h2><p>双冒号 :: 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方<br>法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>例如上例中， System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于printString 方法的函数式接口参数，对比下面两种写法，完全等效：</p><ul><li>Lambda表达式写法： s -&gt; System.out.println(s);</li><li>方法引用写法： System.out::println</li></ul><p>1, 第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。<br> 2, 第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一  样，而第二种方法引用的写法复用了已有方案，更加简洁。<br>  注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p><p><strong>推导与省略</strong><br>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都<br>将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。<br>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。<br>下面这段代码将会调用 println 方法的不同重载形式，将函数式接口改为int类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PrintableInteger</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03PrintOverload</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInteger</span><span class="hljs-params">(PrintableInteger data)</span> </span>&#123;<br>        data.<span class="hljs-built_in">print</span>(<span class="hljs-number">1024</span>);<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>   <span class="hljs-built_in">printInteger</span>(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次方法引用将会自动匹配到 println(int) 的重载形式。</p><h2 id="2-5-通过对象名引用成员方法"><a href="#2-5-通过对象名引用成员方法" class="headerlink" title="2.5 通过对象名引用成员方法"></a>2.5 通过对象名引用成员方法</h2><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodRefObject</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printUpperCase</span><span class="hljs-params">(<span class="hljs-keyword">String</span> str)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(str.<span class="hljs-built_in">toUpperCase</span>());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>函数式接口仍然定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的Lambda的时候，已经具有了<br>MethodRefObject 类的对象实例，则可以通过对象名引用成员方法，代码为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04MethodRef</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printString</span>(<span class="hljs-params">Printable lambda</span>)</span> &#123;<br>    lambda.print(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        MethodRefObject obj = <span class="hljs-keyword">new</span> MethodRefObject();<br>        printString(obj::printUpperCase);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-通过类名称引用静态方法"><a href="#2-6-通过类名称引用静态方法" class="headerlink" title="2.6 通过类名称引用静态方法"></a>2.6 通过类名称引用静态方法</h2><p>由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calcable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第一种写法是使用Lambda表达式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05Lambda</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>   System.out.<span class="hljs-built_in">println</span>(lambda.<span class="hljs-built_in">calc</span>(num));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(‐<span class="hljs-number">10</span>, n ‐&gt; Math.<span class="hljs-built_in">abs</span>(n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是使用方法引用的更好写法是：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06MethodRef</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(lambda.<span class="hljs-built_in">calc</span>(num));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-built_in">method</span>(‐<span class="hljs-number">10</span>, Math::abs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： n -&gt; Math.abs(n)</li><li>方法引用： Math::abs</li></ul><h2 id="2-7-通过super引用成员方法"><a href="#2-7-通过super引用成员方法" class="headerlink" title="2.7 通过super引用成员方法"></a>2.7 通过super引用成员方法</h2><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Greetable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后是父类 Human 的内容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是子类 Man 的内容，其中使用了Lambda的写法：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Man extends Human <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    @Override</span><br><span class="hljs-comment">    public void sayHello() &#123;</span><br><span class="hljs-comment">    System.out.println(&quot;大家好,我是Man!&quot;);</span><br><span class="hljs-comment">    &#125;</span><br>    <span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(Greetable g)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    g.greet();</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    //调用method方法,使用Lambda表达式</span></span><br><span class="hljs-comment"><span class="hljs-function">    method(()‐&gt;&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">        //创建Human对象,调用sayHello方法</span></span><br><span class="hljs-comment"><span class="hljs-function">        new Human().sayHello();</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span>);</span><br>    <span class="hljs-comment">//简化Lambda</span><br>    <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(()</span>‐&gt;<span class="hljs-title">new</span> <span class="hljs-title">Human</span><span class="hljs-params">()</span>.<span class="hljs-title">sayHello</span><span class="hljs-params">()</span>);</span><br>    <span class="hljs-comment">//使用super关键字代替父类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(()</span>‐&gt;<span class="hljs-title">super</span>.<span class="hljs-title">sayHello</span><span class="hljs-params">()</span>);</span><br>    &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">Greetable g</span>)</span>&#123;<br>    g.greet();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>&#123;<br>    method(<span class="hljs-built_in">super</span>::sayHello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：<br>Lambda表达式： () -&gt; super.sayHello()<br>方法引用： super::sayHello</p><h2 id="2-8-通过this引用成员方法"><a href="#2-8-通过this引用成员方法" class="headerlink" title="2.8 通过this引用成员方法"></a>2.8 通过this引用成员方法</h2><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Richable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个丈夫 Husband 类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    marry(() ‐&gt; System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>开心方法 beHappy 调用了结婚方法 marry ，后者的参数为函数式接口 Richable ，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 Husband 丈夫类进行修改：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">buyHouse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    marry(() ‐&gt; <span class="hljs-built_in">this</span>.buyHouse());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">buyHouse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">marry</span>(<span class="hljs-params">Richable lambda</span>)</span> &#123;<br>    lambda.buy();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">beHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    marry(<span class="hljs-built_in">this</span>::buyHouse);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： () -&gt; this.buyHouse()</li><li>方法引用： this::buyHouse</li></ul><h2 id="2-9-类的构造器引用"><a href="#2-9-类的构造器引用" class="headerlink" title="2.9 类的构造器引用"></a>2.9 类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。首先是一个简单的 Person 类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是用来创建 Person 对象的函数式接口：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>Person buildPerson(<span class="hljs-keyword">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过Lambda表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Lambda</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, PersonBuilder builder</span>)</span> &#123;<br>    System.out.println(builder.buildPerson(name).getName());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="hljs-keyword">new</span> Person(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是通过构造器引用，有更好的写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConstructorRef</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, PersonBuilder builder</span>)</span> &#123;<br>    System.out.println(builder.buildPerson(name).getName());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-attr">Person</span>::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： name -&gt; new Person(name)</li><li>方法引用： Person::new</li></ul><h2 id="2-10-数组的构造器引用"><a href="#2-10-数组的构造器引用" class="headerlink" title="2.10 数组的构造器引用"></a>2.10 数组的构造器引用</h2><p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，<br>需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArrayBuilder</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] buildArray(<span class="hljs-keyword">int</span> length);<br>&#125;<br></code></pre></td></tr></table></figure><p>在应用该接口的时候，可以通过Lambda表达式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11ArrayInitRef</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">initArray</span>(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br>    <span class="hljs-keyword">return</span> builder.<span class="hljs-built_in">buildArray</span>(length);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-built_in">initArray</span>(<span class="hljs-number">10</span>, length ‐&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是更好的写法是使用数组的构造器引用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12ArrayInitRef</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">initArray</span>(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-built_in">buildArray</span>(length);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] array = <span class="hljs-built_in">initArray</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： length -&gt; new int[length]</li><li>方法引用： int[]::new</li></ul><h1 id="第九章-Junit反射注解"><a href="#第九章-Junit反射注解" class="headerlink" title="第九章 Junit反射注解"></a>第九章 Junit反射注解</h1><pre><code>1. Junit单元测试2. 反射3. 注解</code></pre><h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><pre><code>* 测试分类：    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。    2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试    * 步骤：        1. 定义一个测试类(测试用例)            * 建议：                * 测试类名：被测试的类名Test        CalculatorTest                * 包名：xxx.xxx.xx.test        cn.itcast.test        2. 定义测试方法：可以独立运行            * 建议：                * 方法名：test测试的方法名        testAdd()                  * 返回值：void                * 参数列表：空参        3. 给方法加@Test        4. 导入junit依赖环境    * 判定结果：        * 红色：失败        * 绿色：成功        * 一般我们会使用断言操作来处理结果            * Assert.assertEquals(期望的结果,运算的结果);    * 补充：        * @Before:            * 修饰的方法会在测试方法之前被自动执行        * @After:            * 修饰的方法会在测试方法执行之后自动被执行</code></pre><h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class：通过类名的属性class获取        * 多用于参数的传递    3. 对象.getClass()：getClass()方法在Object类中定义着。        * 多用于对象的获取字节码的方式    * 结论：        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFields() ：获取所有public修饰的成员变量            * Field getField(String name)   获取指定名称的 public修饰的成员变量            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符            * Field getDeclaredField(String name)          2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()              * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;?&gt;[] getDeclaredConstructors()          3. 获取成员方法们：            * Method[] getMethods()              * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)              * Method[] getDeclaredMethods()              * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)          4. 获取全类名                * String getName()  * Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)          2. 获取值            * get(Object obj)         3. 忽略访问权限修饰符的安全检查            * setAccessible(true):暴力反射* Constructor:构造方法    * 创建对象：        * T newInstance(Object... initargs)          * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)      * 获取方法名称：        * String getName:获取方法名* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        * 实现：            1. 配置文件            2. 反射        * 步骤：            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中            2. 在程序中加载读取配置文件            3. 使用反射技术来加载类文件进内存            4. 创建对象            5. 执行方法</code></pre><h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><pre><code>* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述：    * JDK1.5之后的新特性    * 说明程序的    * 使用注解：@注解名称</code></pre><p>​    </p><pre><code>* 作用分类：    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】* JDK中预定义的一些注解    * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的    * @Deprecated：该注解标注的内容，表示已过时    * @SuppressWarnings：压制警告        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)* 自定义注解    * 格式：        元注解        public @interface 注解名称&#123;            属性列表;        &#125;    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口        * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125;    * 属性：接口中的抽象方法        * 要求：            1. 属性的返回值类型有下列取值                * 基本数据类型                * String                * 枚举                * 注解                * 以上类型的数组            2. 定义了属性，在使用时需要给属性赋值                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。                3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略        * 元注解：用于描述注解的注解        * @Target：描述注解能够作用的位置            * ElementType取值：                * TYPE：可以作用于类上                * METHOD：可以作用于方法上                * FIELD：可以作用于成员变量上        * @Retention：描述注解被保留的阶段            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到        * @Documented：描述注解是否被抽取到api文档中        * @Inherited：描述注解是否被子类继承* 在程序使用(解析)注解：获取注解中定义的属性值    1. 获取注解定义的位置的对象  （Class，Method,Field）    2. 获取指定的注解        * getAnnotation(Class)        //其实就是在内存中生成了一个该注解接口的子类实现对象                public class ProImpl implements Pro&#123;                    public String className()&#123;                        return &quot;cn.itcast.annotation.Demo1&quot;;                    &#125;                    public String methodName()&#123;                        return &quot;show&quot;;                    &#125;                &#125;    3. 调用注解中的抽象方法获取配置的属性值* 案例：简单的测试框架* 小结：    1. 以后大多数时候，我们会使用注解，而不是自定义注解    2. 注解给谁用？        1. 编译器        2. 给解析程序用    3. 注解不是程序的一部分，可以理解为注解就是一个标签</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎07-文件类</title>
    <link href="/2017/09/18/java%E5%9F%BA%E7%A4%8E07-%E6%96%87%E4%BB%B6%E7%B1%BB/"/>
    <url>/2017/09/18/java%E5%9F%BA%E7%A4%8E07-%E6%96%87%E4%BB%B6%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-File类"><a href="#第一章-File类" class="headerlink" title="第一章 File类"></a>第一章 File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul><li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li></ul><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件路径名</span><br>String pathname = <span class="hljs-string">&quot;D:\\aaa.txt&quot;</span>;<br>File file1 = <span class="hljs-keyword">new</span> File(pathname); <br><br><span class="hljs-comment">// 文件路径名</span><br>String pathname2 = <span class="hljs-string">&quot;D:\\aaa\\bbb.txt&quot;</span>;<br>File file2 = <span class="hljs-keyword">new</span> File(pathname2); <br><br><span class="hljs-comment">// 通过父路径和子路径字符串</span><br> String parent = <span class="hljs-string">&quot;d:\\aaa&quot;</span>;<br> String child = <span class="hljs-string">&quot;bbb.txt&quot;</span>;<br> File file3 = <span class="hljs-keyword">new</span> File(parent, child);<br><br><span class="hljs-comment">// 通过父级File对象和子路径字符串</span><br>File parentDir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\aaa&quot;</span>);<br>String child = <span class="hljs-string">&quot;bbb.txt&quot;</span>;<br>File file4 = <span class="hljs-keyword">new</span> File(parentDir, child);<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileGet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/aaa/bbb.java&quot;</span>);     <br>        System.out.println(<span class="hljs-string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;文件构造路径:&quot;</span>+f.getPath());<br>        System.out.println(<span class="hljs-string">&quot;文件名称:&quot;</span>+f.getName());<br>        System.out.println(<span class="hljs-string">&quot;文件长度:&quot;</span>+f.length()+<span class="hljs-string">&quot;字节&quot;</span>);<br><br>        File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/aaa&quot;</span>);     <br>        System.out.println(<span class="hljs-string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;目录构造路径:&quot;</span>+f2.getPath());<br>        System.out.println(<span class="hljs-string">&quot;目录名称:&quot;</span>+f2.getName());<br>        System.out.println(<span class="hljs-string">&quot;目录长度:&quot;</span>+f2.length());<br>    &#125;<br>&#125;<br>输出结果：<br>文件绝对路径:d:\aaa\bbb.java<br>文件构造路径:d:\aaa\bbb.java<br>文件名称:bbb.java<br>文件长度:<span class="hljs-number">636</span>字节<br><br>目录绝对路径:d:\aaa<br>目录构造路径:d:\aaa<br>目录名称:aaa<br>目录长度:<span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilePath</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// D盘下的bbb.java文件</span><br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\bbb.java&quot;</span>);<br>        System.out.println(f.getAbsolutePath());<br>      <br><span class="hljs-comment">// 项目下的bbb.java文件</span><br>        File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;bbb.java&quot;</span>);<br>        System.out.println(f2.getAbsolutePath());<br>    &#125;<br>&#125;<br>输出结果：<br>D:\bbb.java<br>D:\idea_project_test4\bbb.java<br></code></pre></td></tr></table></figure><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileIs</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\aaa\\bbb.java&quot;</span>);<br>        File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 判断是否存在</span><br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());<br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());<br>      <span class="hljs-comment">// 判断是文件还是目录</span><br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());<br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());<br>    &#125;<br>&#125;<br>输出结果：<br>d:\aaa\bbb.java 是否存在:<span class="hljs-keyword">true</span><br>d:\aaa 是否存在:<span class="hljs-keyword">true</span><br>d:\aaa 文件?:<span class="hljs-keyword">false</span><br>d:\aaa 目录?:<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileCreateDelete</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 文件的创建</span><br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;aaa.txt&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f.exists()); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f.exists()); <span class="hljs-comment">// true</span><br><br>     <span class="hljs-comment">// 目录的创建</span><br>      File f2= <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDir&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f2.exists());<span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;是否创建:&quot;</span>+f2.mkdir());<span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f2.exists());<span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 创建多级目录</span><br>      File f3= <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDira\\newDirb&quot;</span>);<br>        System.out.println(f3.mkdir());<span class="hljs-comment">// false</span><br>        File f4= <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDira\\newDirb&quot;</span>);<br>        System.out.println(f4.mkdirs());<span class="hljs-comment">// true</span><br>      <br>      <span class="hljs-comment">// 文件的删除</span><br>       System.out.println(f.delete());<span class="hljs-comment">// true</span><br>      <br>      <span class="hljs-comment">// 目录的删除</span><br>        System.out.println(f2.delete());<span class="hljs-comment">// true</span><br>        System.out.println(f4.delete());<span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li></ul><ul><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\java_code&quot;</span>);<br>      <br>      <span class="hljs-comment">//获取当前目录下的文件以及文件夹的名称。</span><br>String[] names = dir.list();<br><span class="hljs-keyword">for</span>(String name : names)&#123;<br>System.out.println(name);<br>&#125;<br>        <span class="hljs-comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span><br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            System.out.println(file);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h1 id="第二章-递归"><a href="#第二章-递归" class="headerlink" title="第二章 递归"></a>第二章 递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法,禁止递归</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01DiGui</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// a();</span><br>b(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 3.构造方法,禁止递归</span><br><span class="hljs-comment"> * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo01DiGui</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//Demo01DiGui();</span><br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span><br><span class="hljs-comment"> * 4993</span><br><span class="hljs-comment"> * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>System.out.println(i);<br><span class="hljs-comment">//添加一个递归结束的条件,i==5000的时候结束</span><br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">5000</span>)&#123;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//结束方法</span><br>&#125;<br>b(++i);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span><br><span class="hljs-comment"> * java.lang.StackOverflowError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;a方法&quot;</span>);<br>a();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p><p><strong>实现代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//计算1~num的和，使用递归完成</span><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;<br>      <span class="hljs-comment">// 调用求和的方法</span><br><span class="hljs-keyword">int</span> sum = getSum(num);<br>      <span class="hljs-comment">// 输出结果</span><br>System.out.println(sum);<br><br>&#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    通过递归算法实现.</span><br><span class="hljs-comment">    参数列表:int </span><br><span class="hljs-comment">    返回值类型: int </span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>      <span class="hljs-comment">/* </span><br><span class="hljs-comment">         num为1时,方法返回1,</span><br><span class="hljs-comment">         相当于是方法的出口,num总有是1的情况</span><br><span class="hljs-comment">      */</span><br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">          num不为1时,方法返回 num +(num-1)的累和</span><br><span class="hljs-comment">          递归调用getSum方法</span><br><span class="hljs-comment">        */</span><br><span class="hljs-keyword">return</span> num + getSum(num-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="/img/cphoto/file02.jpg"></p><blockquote><p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p></blockquote><h2 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h2><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">n的阶乘：n! = n * (n-<span class="hljs-number">1</span>) *...* <span class="hljs-number">3</span> * <span class="hljs-number">2</span> * <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">推理得出：<span class="hljs-built_in">n</span>! = <span class="hljs-built_in">n</span> * (<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)!<br></code></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo</span> </span>&#123;<br>  <span class="hljs-comment">//计算n的阶乘，使用递归完成</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;<br>      <span class="hljs-comment">// 调用求阶乘的方法</span><br>        <span class="hljs-keyword">int</span> value = getValue(n);<br>      <span class="hljs-comment">// 输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;阶乘为:&quot;</span>+ value);<br>    &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    通过递归算法实现.</span><br><span class="hljs-comment">    参数列表:int </span><br><span class="hljs-comment">    返回值类型: int </span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-comment">// 1的阶乘为1</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        n不为1时,方法返回 n! = n*(n-1)!</span><br><span class="hljs-comment">          递归调用getValue方法</span><br><span class="hljs-comment">      */</span><br>        <span class="hljs-keyword">return</span> n * getValue(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 创建File对象</span><br>        File dir  = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 调用打印目录方法</span><br>        printDir(dir);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">printDir</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>      <span class="hljs-comment">// 获取子文件和目录</span><br>        File[] files = dir.listFiles();<br>      <span class="hljs-comment">// 循环打印</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        判断:</span><br><span class="hljs-comment">        当是文件时,打印绝对路径.</span><br><span class="hljs-comment">        当是目录时,继续调用打印目录的方法,形成递归调用.</span><br><span class="hljs-comment">      */</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>    <span class="hljs-comment">// 判断</span><br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>              <span class="hljs-comment">// 是文件,输出文件绝对路径</span><br>                System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 是目录,输出目录绝对路径</span><br>                System.out.println(<span class="hljs-string">&quot;目录:&quot;</span>+file.getAbsolutePath());<br>              <span class="hljs-comment">// 继续遍历,调用printDir,形成递归</span><br>                printDir(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h2><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p><p><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建File对象</span><br>        File dir  = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 调用打印目录方法</span><br>        printDir(dir);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>      <span class="hljs-comment">// 获取子文件和目录</span><br>        File[] files = dir.listFiles();<br>      <br>      <span class="hljs-comment">// 循环打印</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>              <span class="hljs-comment">// 是文件，判断文件名并输出文件绝对路径</span><br>                <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 是目录，继续遍历,形成递归</span><br>                printDir(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-文件过滤器优化"><a href="#3-2-文件过滤器优化" class="headerlink" title="3.2 文件过滤器优化"></a>3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p><p><code>boolean accept(File pathname)  </code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiGuiDemo4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>        printDir2(dir);<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir2</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>      <span class="hljs-comment">// 匿名内部类方式,创建过滤器子类对象</span><br>        File[] files = dir.listFiles(<span class="hljs-keyword">new</span> FileFilter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File pathname)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> pathname.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)||pathname.isDirectory();<br>            &#125;<br>        &#125;);<br>      <span class="hljs-comment">// 循环打印</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                printDir2(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;      <br></code></pre></td></tr></table></figure><h2 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p><p>lambda格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">()-&gt;&#123; &#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir3</span><span class="hljs-params">(File dir)</span> </span>&#123;<br>  <span class="hljs-comment">// lambda的改写</span><br>    File[] files = dir.listFiles(f -&gt;&#123; <br>      <span class="hljs-keyword">return</span> f.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>) || f.isDirectory(); <br>    &#125;);<br>  <br><span class="hljs-comment">// 循环打印</span><br>    <span class="hljs-keyword">for</span> (File file : files) &#123;<br>        <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        printDir3(file);<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章-IO概述"><a href="#第四章-IO概述" class="headerlink" title="第四章 IO概述"></a>第四章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p><h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="1-3-顶级父类们"><a href="#1-3-顶级父类们" class="headerlink" title="1.3 顶级父类们"></a>1.3 顶级父类们</h2><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br><strong>InputStream</strong></td><td align="center">字节输出流<br><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br><strong>Reader</strong></td><td align="center">字符输出流<br><strong>Writer</strong></td></tr></tbody></table><h1 id="第五章-字节流"><a href="#第五章-字节流" class="headerlink" title="第五章 字节流"></a>第五章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p><p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileOutputStreamConstructor</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 写出数据</span><br>      fos.write(<span class="hljs-number">97</span>); <span class="hljs-comment">// 写出第1个字节</span><br>      fos.write(<span class="hljs-number">98</span>); <span class="hljs-comment">// 写出第2个字节</span><br>      fos.write(<span class="hljs-number">99</span>); <span class="hljs-comment">// 写出第3个字节</span><br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>abc<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;黑马程序员&quot;</span>.getBytes();<br>      <span class="hljs-comment">// 写出字节数组数据</span><br>      fos.write(b);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑马程序员<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br>        fos.write(b,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>cd<br></code></pre></td></tr></table></figure><h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>，<span class="hljs-keyword">true</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br>        fos.write(b);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>文件操作前：cd<br>文件操作后：cdabcde<br></code></pre></td></tr></table></figure><h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p><p>以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FOSWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fos.txt&quot;</span>);  <br>      <span class="hljs-comment">// 定义字节数组</span><br>      <span class="hljs-keyword">byte</span>[] words = &#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>&#125;;<br>      <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>          <span class="hljs-comment">// 写出一个字节</span><br>            fos.write(words[i]);<br>          <span class="hljs-comment">// 写出一个换行, 换行符号转成数组写出</span><br>            fos.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>        &#125;<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>a<br>b<br>c<br>d<br>e<br></code></pre></td></tr></table></figure><blockquote><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileInputStreamConstructor</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileInputStream fos = <span class="hljs-keyword">new</span> FileInputStream(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileInputStream fos = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 读取数据，返回一个字节</span><br>        <span class="hljs-keyword">int</span> read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-keyword">char</span>) read);<br>      <span class="hljs-comment">// 读取到末尾,返回-1</span><br>       read = fis.read();<br>        System.out.println( read);<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>循环改进读取方式，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存数据</span><br>        <span class="hljs-keyword">int</span> b ；<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((b = fis.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println((<span class="hljs-keyword">char</span>)b);<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然读取了一个字节，但是会自动提升为int类型。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象.</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>); <span class="hljs-comment">// 文件中为abcde</span><br>      <span class="hljs-comment">// 定义变量，作为有效个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字节数组，作为装字节数据的容器   </span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> (( len= fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-comment">// 每次读取后,把数组变成字符串打印</span><br>            System.out.println(<span class="hljs-keyword">new</span> String(b));<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>ab<br>cd<br>ed<br></code></pre></td></tr></table></figure><p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象.</span><br>       FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>); <span class="hljs-comment">// 文件中为abcde</span><br>      <span class="hljs-comment">// 定义变量，作为有效个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字节数组，作为装字节数据的容器   </span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> (( len= fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span><br>            System.out.println(<span class="hljs-keyword">new</span> String(b，<span class="hljs-number">0</span>，len));<span class="hljs-comment">//  len 每次读取的有效字节个数</span><br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>ab<br>cd<br>e<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote><h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="/img/cphoto/file01.jpg"></p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Copy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 指定数据源</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\test.jpg&quot;</span>);<br>        <span class="hljs-comment">// 1.2 指定目的地</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test_copy.jpg&quot;</span>);<br><br>        <span class="hljs-comment">// 2.读写数据</span><br>        <span class="hljs-comment">// 2.1 定义数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">// 2.2 定义长度</span><br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-comment">// 2.3 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 2.4 写出数据</span><br>            fos.write(b, <span class="hljs-number">0</span> , len);<br>        &#125;<br><br>        <span class="hljs-comment">// 3.关闭资源</span><br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>流的关闭原则：先开后关，后开先关。</p></blockquote><h1 id="第六章-字符流"><a href="#第六章-字符流" class="headerlink" title="第六章 字符流"></a>第六章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>小贴士：</p><ol><li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p><p>idea中UTF-8</p></li><li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p></li></ol></blockquote><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileReaderConstructor</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存数据</span><br>        <span class="hljs-keyword">int</span> b ；<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((b = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println((<span class="hljs-keyword">char</span>)b);<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑<br>马<br>程<br>序<br>员<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p></blockquote><ol start="2"><li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存有效字符个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字符数组，作为装字符数据的容器</span><br>         <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(cbuf));<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑马<br>程序<br>员序<br></code></pre></td></tr></table></figure><p>获取有效的字符改进，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FISRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存有效字符个数</span><br>        <span class="hljs-keyword">int</span> len ；<br>        <span class="hljs-comment">// 定义字符数组，作为装字符数据的容器</span><br>        <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(cbuf,<span class="hljs-number">0</span>,len));<br>        &#125;<br>    <span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>黑马<br>程序<br>员<br></code></pre></td></tr></table></figure><h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf) </code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str) </code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush() </code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。 </li></ul><h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileWriterConstructor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 写出数据</span><br>      fw.write(<span class="hljs-number">97</span>); <span class="hljs-comment">// 写出第1个字符</span><br>      fw.write(<span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">// 写出第2个字符</span><br>      fw.write(<span class="hljs-string">&#x27;C&#x27;</span>); <span class="hljs-comment">// 写出第3个字符</span><br>      fw.write(<span class="hljs-number">30000</span>); <span class="hljs-comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span><br>      <br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        【注意】关闭资源时,与FileOutputStream不同。</span><br><span class="hljs-comment">       如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// fw.close();</span><br>    &#125;<br>&#125;<br>输出结果：<br>abC田<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li></ol></blockquote><h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);<br>        <span class="hljs-comment">// 写出数据，通过flush</span><br>        fw.write(<span class="hljs-string">&#x27;刷&#x27;</span>); <span class="hljs-comment">// 写出第1个字符</span><br>        fw.flush();<br>        fw.write(<span class="hljs-string">&#x27;新&#x27;</span>); <span class="hljs-comment">// 继续写出第2个字符，写出成功</span><br>        fw.flush();<br>      <br>      <span class="hljs-comment">// 写出数据，通过close</span><br>        fw.write(<span class="hljs-string">&#x27;关&#x27;</span>); <span class="hljs-comment">// 写出第1个字符</span><br>        fw.close();<br>        fw.write(<span class="hljs-string">&#x27;闭&#x27;</span>); <span class="hljs-comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol><li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-keyword">char</span>[] chars = <span class="hljs-string">&quot;黑马程序员&quot;</span>.toCharArray();<br>      <br>      <span class="hljs-comment">// 写出字符数组</span><br>      fw.write(chars); <span class="hljs-comment">// 黑马程序员</span><br>        <br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span><br>        fw.write(b,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 程序</span><br>      <br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串</span><br>      String msg = <span class="hljs-string">&quot;黑马程序员&quot;</span>;<br>      <br>      <span class="hljs-comment">// 写出字符数组</span><br>      fw.write(msg); <span class="hljs-comment">//黑马程序员</span><br>      <br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span><br>        fw.write(msg,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// 程序</span><br>      <br>        <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FWWrite</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象，可以续写数据</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>，<span class="hljs-keyword">true</span>);     <br>      <span class="hljs-comment">// 写出字符串</span><br>        fw.write(<span class="hljs-string">&quot;黑马&quot;</span>);<br>      <span class="hljs-comment">// 写出换行</span><br>      fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>      <span class="hljs-comment">// 写出字符串</span><br>  fw.write(<span class="hljs-string">&quot;程序员&quot;</span>);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fw.close();<br>    &#125;<br>&#125;<br>输出结果:<br>黑马<br>程序员<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p><p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p></blockquote><h1 id="第七章-IO异常的处理"><a href="#第七章-IO异常的处理" class="headerlink" title="第七章 IO异常的处理"></a>第七章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleException1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 声明变量</span><br>        FileWriter fw = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建流对象</span><br>            fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>);<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(<span class="hljs-string">&quot;黑马程序员&quot;</span>); <span class="hljs-comment">//黑马程序员</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fw != <span class="hljs-keyword">null</span>) &#123;<br>                    fw.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (创建流对象语句，如果多个,使用<span class="hljs-string">&#x27;;&#x27;</span>隔开) &#123;<br><span class="hljs-comment">// 读写数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleException2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> ( FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;fw.txt&quot;</span>); ) &#123;<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(<span class="hljs-string">&quot;黑马程序员&quot;</span>); <span class="hljs-comment">//黑马程序员</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p><p>改进前格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被final修饰的对象</span><br><span class="hljs-keyword">final</span> Resource resource1 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// 普通对象</span><br>Resource resource2 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource2&quot;</span>);<br><span class="hljs-comment">// 引入方式：创建新的变量保存</span><br><span class="hljs-keyword">try</span> (Resource r1 = resource1;<br>     Resource r2 = resource2) &#123;<br>     <span class="hljs-comment">// 使用对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>改进后格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被final修饰的对象</span><br><span class="hljs-keyword">final</span> Resource resource1 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// 普通对象</span><br>Resource resource2 = <span class="hljs-keyword">new</span> Resource(<span class="hljs-string">&quot;resource2&quot;</span>);<br><br><span class="hljs-comment">// 引入方式：直接引入</span><br><span class="hljs-keyword">try</span> (resource1; resource2) &#123;<br>     <span class="hljs-comment">// 使用对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>改进后，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">final</span>  FileReader fr  = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;in.txt&quot;</span>);<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;out.txt&quot;</span>);<br>       <span class="hljs-comment">// 引入到try中</span><br>        <span class="hljs-keyword">try</span> (fr; fw) &#123;<br>          <span class="hljs-comment">// 定义变量</span><br>            <span class="hljs-keyword">int</span> b;<br>          <span class="hljs-comment">// 读取数据</span><br>          <span class="hljs-keyword">while</span> ((b = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(b);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第八章-属性集"><a href="#第八章-属性集" class="headerlink" title="第八章 属性集"></a>第八章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public Properties()</code> :创建一个空的属性列表。</li></ul><h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 创建属性集对象</span><br>        Properties properties = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">// 添加键值对元素</span><br>        properties.setProperty(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-string">&quot;a.txt&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;length&quot;</span>, <span class="hljs-string">&quot;209385038&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;location&quot;</span>, <span class="hljs-string">&quot;D:\\a.txt&quot;</span>);<br>        <span class="hljs-comment">// 打印属性集对象</span><br>        System.out.println(properties);<br>        <span class="hljs-comment">// 通过键,获取属性值</span><br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;filename&quot;</span>));<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;length&quot;</span>));<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;location&quot;</span>));<br><br>        <span class="hljs-comment">// 遍历属性集,获取所有键的集合</span><br>        Set&lt;String&gt; strings = properties.stringPropertyNames();<br>        <span class="hljs-comment">// 打印键值对</span><br>        <span class="hljs-keyword">for</span> (String key : strings ) &#123;<br>          System.out.println(key+<span class="hljs-string">&quot; -- &quot;</span>+properties.getProperty(key));<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>&#123;filename=a.txt, length=<span class="hljs-number">209385038</span>, location=D:\a.txt&#125;<br>a.txt<br><span class="hljs-number">209385038</span><br>D:\a.txt<br>filename -- a.txt<br>length -- <span class="hljs-number">209385038</span><br>location -- D:\a.txt<br></code></pre></td></tr></table></figure><h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul><li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li></ul><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">filename</span>=a.txt<br><span class="hljs-attr">length</span>=<span class="hljs-number">209385038</span><br><span class="hljs-attr">location</span>=D:\a.txt<br></code></pre></td></tr></table></figure><p>加载代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 创建属性集对象</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">// 加载文本中信息到属性集</span><br>        pro.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>));<br>        <span class="hljs-comment">// 遍历集合并打印</span><br>        Set&lt;String&gt; strings = pro.stringPropertyNames();<br>        <span class="hljs-keyword">for</span> (String key : strings ) &#123;<br>          System.out.println(key+<span class="hljs-string">&quot; -- &quot;</span>+pro.getProperty(key));<br>        &#125;<br>     &#125;<br>&#125;<br>输出结果：<br>filename -- a.txt<br>length -- <span class="hljs-number">209385038</span><br>location -- D:\a.txt<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote><h1 id="第九章-缓冲流"><a href="#第九章-缓冲流" class="headerlink" title="第九章 缓冲流"></a>第九章 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p><h2 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节缓冲输入流</span><br>BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;bis.txt&quot;</span>));<br><span class="hljs-comment">// 创建字节缓冲输出流</span><br>BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;bos.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p><ol><li>基本流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 记录开始时间</span><br>      <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jdk9.exe&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.exe&quot;</span>)<br>        )&#123;<br>        <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-keyword">int</span> b;<br>            <span class="hljs-keyword">while</span> ((b = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br>十几分钟过去了...<br></code></pre></td></tr></table></figure><ol start="2"><li>缓冲流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 记录开始时间</span><br>      <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jdk9.exe&quot;</span>));<br>     BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.exe&quot;</span>));<br>        )&#123;<br>        <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-keyword">int</span> b;<br>            <span class="hljs-keyword">while</span> ((b = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br>缓冲流复制时间:<span class="hljs-number">8016</span> 毫秒<br></code></pre></td></tr></table></figure><p>如何更快呢？</p><p>使用数组的方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>      <span class="hljs-comment">// 记录开始时间</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jdk9.exe&quot;</span>));<br> BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.exe&quot;</span>));<br>        )&#123;<br>          <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-keyword">int</span> len;<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8</span>*<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span> ((len = bis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(bytes, <span class="hljs-number">0</span> , len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br>缓冲流使用数组复制时间:<span class="hljs-number">666</span> 毫秒<br></code></pre></td></tr></table></figure><h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字符缓冲输入流</span><br>BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;br.txt&quot;</span>));<br><span class="hljs-comment">// 创建字符缓冲输出流</span><br>BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;bw.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><p><code>readLine</code>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">// 创建流对象</span><br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;in.txt&quot;</span>));<br><span class="hljs-comment">// 定义字符串,保存读取的一行文字</span><br>        String line  = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-comment">// 循环读取,读取到最后返回null</span><br>        <span class="hljs-keyword">while</span> ((line = br.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(line);<br>            System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        &#125;<br><span class="hljs-comment">// 释放资源</span><br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>newLine</code>方法演示，代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedWriterDemo</span> <span class="hljs-title">throws</span> <span class="hljs-title">IOException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException  </span>&#123;<br>      <span class="hljs-comment">// 创建流对象</span><br>BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;out.txt&quot;</span>));<br>      <span class="hljs-comment">// 写出数据</span><br>        bw.write(<span class="hljs-string">&quot;黑马&quot;</span>);<br>      <span class="hljs-comment">// 写出换行</span><br>        bw.newLine();<br>        bw.write(<span class="hljs-string">&quot;程序&quot;</span>);<br>        bw.newLine();<br>        bw.write(<span class="hljs-string">&quot;员&quot;</span>);<br>        bw.newLine();<br><span class="hljs-comment">// 释放资源</span><br>        bw.close();<br>    &#125;<br>&#125;<br>输出效果:<br>黑马<br>程序<br>员<br></code></pre></td></tr></table></figure><h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。<br>8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。<br>4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。<br>2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。<br>1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>9.今当远离，临表涕零，不知所言。<br>6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。<br>7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。<br>5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。<br></code></pre></td></tr></table></figure><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>逐行读取文本信息。</li><li>解析文本信息到集合中。</li><li>遍历集合，按顺序，写出文本信息。</li></ol><h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 创建map集合,保存文本数据,键为序号,值为文字</span><br>        HashMap&lt;String, String&gt; lineMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 创建流对象</span><br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;in.txt&quot;</span>));<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;out.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 读取数据</span><br>        String line  = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 解析文本</span><br>            String[] split = line.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>            <span class="hljs-comment">// 保存到集合</span><br>            lineMap.put(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 释放资源</span><br>        br.close();<br><br>        <span class="hljs-comment">// 遍历map集合</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= lineMap.size(); i++) &#123;<br>            String key = String.valueOf(i);<br>            <span class="hljs-comment">// 获取map中文本</span><br>            String value = lineMap.get(key);<br>          <span class="hljs-comment">// 写出拼接文本</span><br>            bw.write(key+<span class="hljs-string">&quot;.&quot;</span>+value);<br>          <span class="hljs-comment">// 写出换行</span><br>            bw.newLine();<br>        &#125;<br><span class="hljs-comment">// 释放资源</span><br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十章-转换流"><a href="#第十章-转换流" class="headerlink" title="第十章 转换流"></a>第十章 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</p><p><img src="/img/cphoto/file03.jpg"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;E:\\File_GBK.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> read;<br>        <span class="hljs-keyword">while</span> ((read = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read);<br>        &#125;<br>        fileReader.close();<br>    &#125;<br>&#125;<br>输出结果：<br>���<br></code></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ </p><h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;in.txt&quot;</span>));<br>InputStreamReader isr2 = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;in.txt&quot;</span>) , <span class="hljs-string">&quot;GBK&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 定义文件路径,文件为gbk编码</span><br>        String FileName = <span class="hljs-string">&quot;E:\\file_gbk.txt&quot;</span>;<br>      <span class="hljs-comment">// 创建流对象,默认UTF8编码</span><br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(FileName));<br>      <span class="hljs-comment">// 创建流对象,指定GBK编码</span><br>        InputStreamReader isr2 = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(FileName) , <span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-comment">// 定义变量,保存字符</span><br>        <span class="hljs-keyword">int</span> read;<br>      <span class="hljs-comment">// 使用默认编码字符流读取,乱码</span><br>        <span class="hljs-keyword">while</span> ((read = isr.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read); <span class="hljs-comment">// ��Һ�</span><br>        &#125;<br>        isr.close();<br>      <br>      <span class="hljs-comment">// 使用指定编码字符流读取,正常解析</span><br>        <span class="hljs-keyword">while</span> ((read = isr2.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read);<span class="hljs-comment">// 大家好</span><br>        &#125;<br>        isr2.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">OutputStreamWriter isr = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;out.txt&quot;</span>));<br>OutputStreamWriter isr2 = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;out.txt&quot;</span>) , <span class="hljs-string">&quot;GBK&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 定义文件路径</span><br>        String FileName = <span class="hljs-string">&quot;E:\\out.txt&quot;</span>;<br>      <span class="hljs-comment">// 创建流对象,默认UTF8编码</span><br>        OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName));<br>        <span class="hljs-comment">// 写出数据</span><br>      osw.write(<span class="hljs-string">&quot;你好&quot;</span>); <span class="hljs-comment">// 保存为6个字节</span><br>        osw.close();<br>      <br><span class="hljs-comment">// 定义文件路径</span><br>String FileName2 = <span class="hljs-string">&quot;E:\\out2.txt&quot;</span>;<br>     <span class="hljs-comment">// 创建流对象,指定GBK编码</span><br>        OutputStreamWriter osw2 = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName2),<span class="hljs-string">&quot;GBK&quot;</span>);<br>        <span class="hljs-comment">// 写出数据</span><br>      osw2.write(<span class="hljs-string">&quot;你好&quot;</span>);<span class="hljs-comment">// 保存为4个字节</span><br>        osw2.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong></p><p><img src="/img/cphoto/file04.jpg"></p><h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>指定GBK编码的转换流，读取文本文件。</li><li>使用UTF-8编码的转换流，写出文本文件。</li></ol><h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <br>    <span class="hljs-comment">// 1.定义文件路径</span><br>     String srcFile = <span class="hljs-string">&quot;file_gbk.txt&quot;</span>;<br>        String destFile = <span class="hljs-string">&quot;file_utf8.txt&quot;</span>;<br><span class="hljs-comment">// 2.创建流对象</span><br>    <span class="hljs-comment">// 2.1 转换输入流,指定GBK编码</span><br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(srcFile) , <span class="hljs-string">&quot;GBK&quot;</span>);<br>    <span class="hljs-comment">// 2.2 转换输出流,默认utf8编码</span><br>        OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(destFile));<br><span class="hljs-comment">// 3.读写数据</span><br>    <span class="hljs-comment">// 3.1 定义数组</span><br>        <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">// 3.2 定义长度</span><br>        <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-comment">// 3.3 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = isr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 循环写出</span><br>          osw.write(cbuf,<span class="hljs-number">0</span>,len);<br>        &#125;<br>    <span class="hljs-comment">// 4.释放资源</span><br>        osw.close();<br>        isr.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十一章-序列化"><a href="#第十一章-序列化" class="headerlink" title="第十一章 序列化"></a>第十一章 序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： </p><p><img src="/img/cphoto/file05.jpg"></p><h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fileOut = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;employee.txt&quot;</span>);<br>ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(fileOut);<br></code></pre></td></tr></table></figure><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><ul><li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String address;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// transient瞬态修饰成员,不会被序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addressCheck</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Address  check : &quot;</span> + name + <span class="hljs-string">&quot; -- &quot;</span> + address);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializeDemo</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span>   </span>&#123;<br>    Employee e = <span class="hljs-keyword">new</span> Employee();<br>    e.name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    e.address = <span class="hljs-string">&quot;beiqinglu&quot;</span>;<br>    e.age = <span class="hljs-number">20</span>; <br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 创建序列化流对象</span><br>          ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;employee.txt&quot;</span>));<br>        <span class="hljs-comment">// 写出对象</span><br>        out.writeObject(e);<br>        <span class="hljs-comment">// 释放资源</span><br>        out.close();<br>        fileOut.close();<br>        System.out.println(<span class="hljs-string">&quot;Serialized data is saved&quot;</span>); <span class="hljs-comment">// 姓名，地址被序列化，年龄没有被序列化。</span><br>        &#125; <span class="hljs-keyword">catch</span>(IOException i)   &#123;<br>            i.printStackTrace();<br>        &#125;<br>   &#125;<br>&#125;<br>输出结果：<br>Serialized data is saved<br></code></pre></td></tr></table></figure><h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h3 id="构造方法-10"><a href="#构造方法-10" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li></ul><h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeserializeDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span>   </span>&#123;<br>        Employee e = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">// 创建反序列化流</span><br>             FileInputStream fileIn = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;employee.txt&quot;</span>);<br>             ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(fileIn);<br>             <span class="hljs-comment">// 读取一个对象</span><br>             e = (Employee) in.readObject();<br>             <span class="hljs-comment">// 释放资源</span><br>             in.close();<br>             fileIn.close();<br>        &#125;<span class="hljs-keyword">catch</span>(IOException i) &#123;<br>             <span class="hljs-comment">// 捕获其他异常</span><br>             i.printStackTrace();<br>             <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException c)  &#123;<br>        <span class="hljs-comment">// 捕获类找不到异常</span><br>             System.out.println(<span class="hljs-string">&quot;Employee class not found&quot;</span>);<br>             c.printStackTrace();<br>             <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 无异常,直接打印输出</span><br>        System.out.println(<span class="hljs-string">&quot;Name: &quot;</span> + e.name);<span class="hljs-comment">// zhangsan</span><br>        System.out.println(<span class="hljs-string">&quot;Address: &quot;</span> + e.address); <span class="hljs-comment">// beiqinglu</span><br>        System.out.println(<span class="hljs-string">&quot;age: &quot;</span> + e.age); <span class="hljs-comment">// 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>     <span class="hljs-comment">// 加入序列版本号</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>     <span class="hljs-keyword">public</span> String name;<br>     <span class="hljs-keyword">public</span> String address;<br>     <span class="hljs-comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> eid; <br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addressCheck</span><span class="hljs-params">()</span> </span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;Address  check : &quot;</span> + name + <span class="hljs-string">&quot; -- &quot;</span> + address);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h3 id="案例实现-3"><a href="#案例实现-3" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 创建 学生对象</span><br>Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;老王&quot;</span>, <span class="hljs-string">&quot;laow&quot;</span>);<br>Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;老张&quot;</span>, <span class="hljs-string">&quot;laoz&quot;</span>);<br>Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;老李&quot;</span>, <span class="hljs-string">&quot;laol&quot;</span>);<br><br>ArrayList&lt;Student&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>arrayList.add(student);<br>arrayList.add(student2);<br>arrayList.add(student3);<br><span class="hljs-comment">// 序列化操作</span><br><span class="hljs-comment">// serializ(arrayList);</span><br><br><span class="hljs-comment">// 反序列化  </span><br>ObjectInputStream ois  = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br><span class="hljs-comment">// 读取对象,强转为ArrayList类型</span><br>ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++ )&#123;<br>          Student s = list.get(i);<br>        System.out.println(s.getName()+<span class="hljs-string">&quot;--&quot;</span>+ s.getPwd());<br>      &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serializ</span><span class="hljs-params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// 创建 序列化流 </span><br>ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br><span class="hljs-comment">// 写出对象</span><br>oos.writeObject(arrayList);<br><span class="hljs-comment">// 释放资源</span><br>oos.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十二章-打印流"><a href="#第十二章-打印流" class="headerlink" title="第十二章 打印流"></a>第十二章 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-11"><a href="#构造方法-11" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">&quot;ps.txt&quot;</span>)；<br></code></pre></td></tr></table></figure><h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">// 调用系统的打印流,控制台直接输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>      <br><span class="hljs-comment">// 创建打印流,指定文件的名称</span><br>        PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">&quot;ps.txt&quot;</span>);<br>      <br>      <span class="hljs-comment">// 设置系统的打印流流向,输出到ps.txt</span><br>        System.setOut(ps);<br>      <span class="hljs-comment">// 调用系统的打印流,ps.txt中输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎06-线程</title>
    <link href="/2017/09/17/java%E5%9F%BA%E7%A4%8E06-%E7%BA%BF%E7%A8%8B/"/>
    <url>/2017/09/17/java%E5%9F%BA%E7%A4%8E06-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-线程"><a href="#第一章-线程" class="headerlink" title="第一章 线程"></a>第一章 线程</h1><h2 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1.1 多线程原理"></a>1.1 多线程原理</h2><p>多线程程序的执行流程。<br>代码如下：<br>自定义线程类：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyThread extends Thread&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 利用继承中的特点</span><br><span class="hljs-comment">    * 将线程名称传递 进行设置</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">public</span> MyThread(String <span class="hljs-type">name</span>)&#123;<br>        super(<span class="hljs-type">name</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 重写run方法</span><br><span class="hljs-comment">    * 定义线程要执行的代码</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> run()&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            //getName()方法 来自父亲<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getName()+i);<br>        &#125;<br>    &#125;<br>&#125;<br>=======================================<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;这里是main线程&quot;);<br>MyThread mt = <span class="hljs-built_in">new</span> MyThread(&quot;小强&quot;);<br>mt.<span class="hljs-keyword">start</span>();//开启了一个新的线程<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;旺财:&quot;+i);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/threads01.jpg"></p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。<br>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。<br>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：<br>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p><p><img src="/img/cphoto/threads02.jpg"></p><p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p><h2 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1.2 Thread类"></a>1.2 Thread类</h2><p>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了 java.lang.Thread 类，<br>API中该类中定义了有关线程的一些方法，具体如下：<br>构造方法：</p><ul><li><p>public Thread() :分配一个新的线程对象。</p></li><li><p>public Thread(String name) :分配一个指定名字的新的线程对象。</p></li><li><p>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。</p></li><li><p>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</p></li></ul><p>常用方法：</p><ul><li><p>public String getName() :获取当前线程名称。</p></li><li><p>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</p></li><li><p>  public void run() :此线程要执行的任务在此处定义代码。</p></li><li><p>  public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</p></li><li><p>  public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</p></li></ul><p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。</p><h2 id="1-3-创建线程方式二"><a href="#1-3-创建线程方式二" class="headerlink" title="1.3 创建线程方式二"></a>1.3 创建线程方式二</h2><p>采用 java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。<br>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li><li>调用线程对象的start()方法来启动线程。<br>代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)&#123;<br> System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建自定义类对象 线程任务对象</span><br>        MyRunnable mr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyRunnable</span>();<br>        <span class="hljs-comment">//创建线程对象</span><br>        Thread t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(mr, <span class="hljs-string">&quot;小强&quot;</span>);<br>        t.<span class="hljs-built_in">start</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;旺财 &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。<br>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread<br>对象的start()方法来运行多线程代码。<br>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程<br>编程的基础。<br>tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p><h2 id="1-4-Thread和Runnable的区别"><a href="#1-4-Thread和Runnable的区别" class="headerlink" title="1.4 Thread和Runnable的区别"></a>1.4 Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>适合多个相同的程序代码的线程去共享同一个资源。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li></ol><p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p><h2 id="1-5-匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"><a href="#1-5-匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。" class="headerlink" title="1.5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"></a>1.5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</h2><p>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoNameInnerClassThread</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// new Runnable()&#123;</span><br>        <span class="hljs-comment">// public void run()&#123;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; 20; i++) &#123;</span><br>        <span class="hljs-comment">// System.out.println(&quot;张宇:&quot;+i);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// &#125;; //‐‐‐这个整体 相当于new MyRunnable()</span><br>        Runnable r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>()&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;张宇:&quot;</span>+i);<br>       &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(r).<span class="hljs-built_in">start</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;费玉清:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="第二章-线程安全"><a href="#第二章-线程安全" class="headerlink" title="第二章 线程安全"></a>第二章 线程安全</h1><h2 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2.1 线程安全"></a>2.1 线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>我们通过一个案例，演示线程的安全问题：电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个<br>(本场电影只能卖100张票)。<br>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p><p>模拟票：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Ticket implements Runnable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> ticket = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有票 可以卖</span><br>        <span class="hljs-comment">//出票操作</span><br>        <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>    &#125;<br>        <span class="hljs-comment">//获取当前线程对象的名字</span><br>        String name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(name + <span class="hljs-string">&quot;正在卖:&quot;</span> + ticket‐‐);<br>        &#125;<br>    &#125;<br>    &#125;<br>&#125;<br><br>public <span class="hljs-keyword">class</span> Demo &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">//创建线程任务对象</span><br>        Ticket ticket = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Ticket()</span>;<br>        <span class="hljs-comment">//创建三个窗口对象</span><br>        Thread t1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">ticket</span>, <span class="hljs-string">&quot;窗口1&quot;</span>)</span>;<br>        Thread t2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">ticket</span>, <span class="hljs-string">&quot;窗口2&quot;</span>)</span>;<br>        Thread t3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">ticket</span>, <span class="hljs-string">&quot;窗口3&quot;</span>)</span>;<br>        <span class="hljs-comment">//同时卖票</span><br>        t1.start<span class="hljs-literal">()</span>;<br>        t2.start<span class="hljs-literal">()</span>;<br>        t3.start<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果中有一部分这样现象：</p><p><img src="/img/cphoto/threads03.jpg"></p><p>发现程序出现了两个问题：</p><ol><li><p>相同的票数,比如5这张票被卖了两回。</p></li><li><p>不存在的票，比如0票与-1票，是不存在的。</p></li></ol><p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></blockquote><p>2.2 线程同步<br>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。<br>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。</p><p>根据案例简述</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">窗口<span class="hljs-number">1</span>线程进入操作的时候，窗口<span class="hljs-number">2</span>和窗口<span class="hljs-number">3</span>线程只能在外等着，窗口<span class="hljs-number">1</span>操作结束，窗口<span class="hljs-number">1</span>和窗口<span class="hljs-number">2</span>和窗口<span class="hljs-number">3</span>才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺<span class="hljs-meta">CPU</span>资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。<br><br></code></pre></td></tr></table></figure><p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。<br>那么怎么去使用呢？有三种方式完成同步操作：</p><ol><li>同步代码块。</li><li>同步方法。</li><li>锁机制。</li></ol><h2 id="2-3-同步代码块"><a href="#2-3-同步代码块" class="headerlink" title="2.3 同步代码块"></a>2.3 同步代码块</h2><ul><li>同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(同步锁)</span></span>&#123;<br><span class="hljs-comment">//需要同步操作的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>同步锁</strong>:<br>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p><ol><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。</li></ol><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Ticket implements Runnable&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> ticket = <span class="hljs-number">100</span>;<br>    Object lock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            synchronized (lock) &#123;<br>            <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>                <span class="hljs-comment">//出票操作</span><br>                <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>            <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">50</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取当前线程对象的名字</span><br>            String name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>            &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-同步方法"><a href="#2-4-同步方法" class="headerlink" title="2.4 同步方法"></a>2.4 同步方法</h2><ul><li>同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> synchronized void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">可能会产生线程安全问题的代码</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>       sellTicket();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 锁对象 是 谁调用这个方法 就是谁</span><br><span class="hljs-comment">    * 隐含 锁对象 就是 this</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sellTicket</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>        <span class="hljs-comment">//出票操作</span><br>        <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>       e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//获取当前线程对象的名字</span><br>        String name = Thread.currentThread().getName();<br>        System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-Lock锁"><a href="#2-5-Lock锁" class="headerlink" title="2.5 Lock锁"></a>2.5 Lock锁</h2><p>java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,<br>同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。<br>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li>public void lock() :加同步锁。</li><li>public void unlock() :释放同步锁。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Ticket implements Runnable&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> ticket = <span class="hljs-number">100</span>;<br>    Lock lock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantLock()</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            lock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>            <span class="hljs-comment">//出票操作</span><br>            <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">50</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取当前线程对象的名字</span><br>            String name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>        &#125;<br>    lock.unlock<span class="hljs-literal">()</span>;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="第三章-线程状态"><a href="#第三章-线程状态" class="headerlink" title="第三章 线程状态"></a>第三章 线程状态</h1><p>3.1 线程状态概述<br>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：<br>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。还没调用start方法。</td></tr><tr><td>Runnable(可运行)</td><td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td></tr><tr><td>TimedWaiting(计时等待</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr><tr><td></td><td></td></tr></tbody></table><p>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。</p><h2 id="3-2-Timed-Waiting（计时等待）"><a href="#3-2-Timed-Waiting（计时等待）" class="headerlink" title="3.2 Timed Waiting（计时等待）"></a>3.2 Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？<br>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。<br>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。<br>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i) % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;‐‐‐‐‐‐‐&quot;</span> + i);<br>        &#125;<br>        System.out.<span class="hljs-built_in">print</span>(i);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>            System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; 线程睡眠1秒！\n&quot;</span>);<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>        e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyThread</span>().<span class="hljs-built_in">start</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</li></ol><blockquote><p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p></blockquote><p>Timed Waiting 线程状态图：</p><p><img src="/img/cphoto/threads04.jpg"></p><h2 id="3-3-BLOCKED（锁阻塞）"><a href="#3-3-BLOCKED（锁阻塞）" class="headerlink" title="3.3 BLOCKED（锁阻塞）"></a>3.3 BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。<br>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。<br>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。</p><p><img src="/img/cphoto/threads05.jpg"></p><h2 id="3-4-Waiting（无限等待）"><a href="#3-4-Waiting（无限等待）" class="headerlink" title="3.4 Waiting（无限等待）"></a>3.4 Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来学习一下：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> WaitingTest &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><span class="hljs-comment">// 演示waiting</span><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-keyword">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (obj)&#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;=== 获取到锁对</span><br><span class="hljs-string">象，调用wait方法，进入waiting状态，释放锁对象&quot;</span>);<br>obj.wait(); <span class="hljs-comment">//无限等待</span><br><span class="hljs-comment">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() + <span class="hljs-string">&quot;=== 从waiting状</span><br><span class="hljs-string">态醒来，获取到锁对象，继续执行了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;,<span class="hljs-string">&quot;等待线程&quot;</span>).start();<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-keyword">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>        <span class="hljs-comment">// while (true)&#123; //每隔3秒 唤醒一次</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;‐‐‐‐‐ 等待3秒钟&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>        System.<span class="hljs-keyword">out</span>.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;‐‐‐‐‐ 获取到锁对</span><br><span class="hljs-string">        象,调用notify方法，释放锁对象&quot;</span>);<br>        obj.notify();<br>        &#125;<br>        &#125;<br>        <span class="hljs-comment">// &#125;</span><br>        &#125;,<span class="hljs-string">&quot;唤醒线程&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。<br>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。<br>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了<br>notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。<br>Waiting 线程状态图</p><p><img src="/img/cphoto/threads06.jpg"></p><h2 id="3-5-补充知识点"><a href="#3-5-补充知识点" class="headerlink" title="3.5 补充知识点"></a>3.5 补充知识点</h2><p>到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图：</p><p><img src="/img/cphoto/threads07.jpg"></p><blockquote><p>一条有意思的tips:<br>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p></blockquote><h1 id="第四章-等待唤醒机制"><a href="#第四章-等待唤醒机制" class="headerlink" title="第四章 等待唤醒机制"></a>第四章 等待唤醒机制</h1><h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p><p><img src="/img/cphoto/threada01.jpg"></p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p><p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="hljs-keyword">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="hljs-keyword">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="hljs-keyword">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。<br></code></pre></td></tr></table></figure><p><strong>代码演示：</strong></p><p>包子资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>     String  pier ;<br>     String  xianer ;<br>     <span class="hljs-keyword">boolean</span>  flag = <span class="hljs-keyword">false</span> ;<span class="hljs-comment">//包子资源 是否存在  包子资源状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>吃货线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChiHuo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> BaoZi bz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChiHuo</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (bz)&#123;<br>                <span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">false</span>)&#123;<span class="hljs-comment">//没包子</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        bz.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="hljs-string">&quot;包子&quot;</span>);<br>                bz.flag = <span class="hljs-keyword">false</span>;<br>                bz.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>包子铺线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BaoZi bz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//造包子</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-comment">//同步</span><br>            <span class="hljs-keyword">synchronized</span> (bz)&#123;<br>                <span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">true</span>)&#123;<span class="hljs-comment">//包子资源  存在</span><br>                    <span class="hljs-keyword">try</span> &#123;<br><br>                        bz.wait();<br><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 没有包子  造包子</span><br>                System.out.println(<span class="hljs-string">&quot;包子铺开始做包子&quot;</span>);<br>                <span class="hljs-keyword">if</span>(count%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 冰皮  五仁</span><br>                    bz.pier = <span class="hljs-string">&quot;冰皮&quot;</span>;<br>                    bz.xianer = <span class="hljs-string">&quot;五仁&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 薄皮  牛肉大葱</span><br>                    bz.pier = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>                    bz.xianer = <span class="hljs-string">&quot;牛肉大葱&quot;</span>;<br>                &#125;<br>                count++;<br><br>                bz.flag=<span class="hljs-keyword">true</span>;<br>                System.out.println(<span class="hljs-string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);<br>                System.out.println(<span class="hljs-string">&quot;吃货来吃吧&quot;</span>);<br>                <span class="hljs-comment">//唤醒等待线程 （吃货）</span><br>                bz.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//等待唤醒案例</span><br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>        ChiHuo ch = <span class="hljs-keyword">new</span> ChiHuo(<span class="hljs-string">&quot;吃货&quot;</span>,bz);<br>        BaoZiPu bzp = <span class="hljs-keyword">new</span> BaoZiPu(<span class="hljs-string">&quot;包子铺&quot;</span>,bz);<br><br>        ch.start();<br>        bzp.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">包子铺开始做包子<br>包子造好了：冰皮五仁<br>吃货来吃吧<br>吃货正在吃冰皮五仁包子<br>包子铺开始做包子<br>包子造好了：薄皮牛肉大葱<br>吃货来吃吧<br>吃货正在吃薄皮牛肉大葱包子<br>包子铺开始做包子<br>包子造好了：冰皮五仁<br>吃货来吃吧<br>吃货正在吃冰皮五仁包子<br></code></pre></td></tr></table></figure><h1 id="第五章-线程池"><a href="#第五章-线程池" class="headerlink" title="第五章 线程池"></a>第五章 线程池</h1><h2 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p><h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul><li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p><p><img src="/img/cphoto/threada02.jpg"></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我要一个教练&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程池测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建线程池对象</span><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<span class="hljs-comment">//包含2个线程对象</span><br>        <span class="hljs-comment">// 创建Runnable实例对象</span><br>        MyRunnable r = <span class="hljs-keyword">new</span> MyRunnable();<br><br>        <span class="hljs-comment">//自己创建线程对象的方式</span><br>        <span class="hljs-comment">// Thread t = new Thread(r);</span><br>        <span class="hljs-comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span><br><br>        <span class="hljs-comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span><br>        service.submit(r);<br>        <span class="hljs-comment">// 再获取个线程对象，调用MyRunnable中的run()</span><br>        service.submit(r);<br>        service.submit(r);<br>        <span class="hljs-comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span><br>        <span class="hljs-comment">// 将使用完的线程又归还到了线程池中</span><br>        <span class="hljs-comment">// 关闭线程池</span><br>        <span class="hljs-comment">//service.shutdown();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-Lambda表达式"><a href="#第六章-Lambda表达式" class="headerlink" title="第六章 Lambda表达式"></a>第六章 Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Runnable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 匿名内部类</span><br>Runnable task = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 覆盖重写抽象方法</span><br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;;<br><span class="hljs-keyword">new</span> Thread(task).start(); <span class="hljs-comment">// 启动线程</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02LambdaRunnable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="hljs-comment">// 启动线程</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)<br></code></pre></td></tr></table></figure><p>为了理解Lambda的语义，我们需要从传统的代码起步。</p><h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code></li></ul><p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03ThreadInitParam</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Runnable task = <span class="hljs-keyword">new</span> RunnableImpl();<br><span class="hljs-keyword">new</span> Thread(task).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04ThreadNameless</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p><ul><li><code>public abstract void run();</code></li></ul><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul><h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(参数类型 参数名称)</span> -&gt;</span> &#123; 代码语句 &#125;<br></code></pre></td></tr></table></figure><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cook</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeFood</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05InvokeCook</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeCook</span><span class="hljs-params">(Cook cook)</span> </span>&#123;<br>        cook.makeFood();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    invokeCook(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;吃饭啦！&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p></blockquote><h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">需求:<br>    使用数组存储多个<span class="hljs-keyword">Person</span>对象<br>    对数组中的<span class="hljs-keyword">Person</span>对象使用Arrays的sort方法通过年龄进行升序排序<br></code></pre></td></tr></table></figure><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-comment">// 省略构造器、toString方法与Getter Setter </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06Comparator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 本来年龄乱序的对象数组</span><br>        Person[] array = &#123;<br>        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-number">19</span>),<br>        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">18</span>),<br>       <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;马尔扎哈&quot;</span>, <span class="hljs-number">20</span>) &#125;;<br><br>      <span class="hljs-comment">// 匿名内部类</span><br>        Comparator&lt;Person&gt; comp = <span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>            &#125;<br>        &#125;;<br>        Arrays.sort(array, comp); <span class="hljs-comment">// 第二个参数为排序规则，即Comparator接口实例</span><br><br>        <span class="hljs-keyword">for</span> (Person person : array) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p><ul><li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li><li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li><li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>实际上，<strong>只有参数和方法体才是关键</strong>。</li></ul><h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07ComparatorLambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] array = &#123;<br>          <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-number">19</span>),<br>          <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">18</span>),<br>          <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;马尔扎哈&quot;</span>, <span class="hljs-number">20</span>) &#125;;<br><br>        Arrays.sort(array, (Person a, Person b) -&gt; &#123;<br>          <span class="hljs-keyword">return</span> a.getAge() - b.getAge();<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Person person : array) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08InvokeCalc</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeCalc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, Calculator calculator)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculator.calc(a, b);<br>        System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    invokeCalc(<span class="hljs-number">120</span>, <span class="hljs-number">130</span>, (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; &#123;<br>      <span class="hljs-keyword">return</span> a + b;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p></blockquote><h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  invokeCalc(<span class="hljs-number">120</span>, <span class="hljs-number">130</span>, (a, b) -&gt; a + b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><blockquote><p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p></blockquote><h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09InvokeCook</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeCook</span><span class="hljs-params">(Cook cook)</span> </span>&#123;<br>        cook.makeFood();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  invokeCook(() -&gt; System.out.println(<span class="hljs-string">&quot;吃饭啦！&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎05-数据结构</title>
    <link href="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><img src="/img/cphoto/stack01.jpg" alt="栈图"></p></li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。<ul><li><img src="/img/cphoto/queue01.jpg" alt="队列图"></li></ul></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p> 查找元素快：通过索引，可以快速访问指定位置的元素</p></li><li><p> 增删元素慢</p></li><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。<br><img src="/img/cphoto/arrays01.jpg" alt="队列图"></p></li><li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p></li></ul><p><img src="/img/cphoto/arrays02.jpg" alt="队列图"></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了<br><img src="/img/cphoto/linklist01.jpg" alt="队列图"></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li> 增加元素：只需要修改连接下个元素的地址即可。<br><img src="/img/cphoto/linklist02.jpg" alt="队列图"></li><li>删除元素：只需要修改连接下个元素的地址即可。</li></ul></li><li><p> <img src="/img/cphoto/linklist03.jpg" alt="队列图"></p></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><ul><li> <img src="/img/cphoto/tree01.jpg" alt="队列图"></li></ul><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li>节点可以是红色的或者黑色的</li></ol><ol start="2"><li>根节点是黑色的</li></ol><ol start="3"><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><p>红黑树的特点:</p><p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p><p> <a href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树详细</a></p><h1 id="第七章-List集合"><a href="#第七章-List集合" class="headerlink" title="第七章 List集合"></a>第七章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><blockquote><p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p></blockquote><h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建List集合对象</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <br>    <span class="hljs-comment">// 往 尾部添加 指定元素</span><br>    list.add(<span class="hljs-string">&quot;图图&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;小美&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;不高兴&quot;</span>);<br>    <br>    System.out.println(list);<br>    <span class="hljs-comment">// add(int index,String s) 往指定位置添加</span><br>    list.add(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;没头脑&quot;</span>);<br>    <br>    System.out.println(list);<br>    <span class="hljs-comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span><br>    <span class="hljs-comment">// 删除索引位置为2的元素 </span><br>    System.out.println(<span class="hljs-string">&quot;删除索引位置为2的元素&quot;</span>);<br>    System.out.println(list.remove(<span class="hljs-number">2</span>));<br>    <br>    System.out.println(list);<br>    <br>    <span class="hljs-comment">// String set(int index,String s)</span><br>    <span class="hljs-comment">// 在指定位置 进行 元素替代（改） </span><br>    <span class="hljs-comment">// 修改指定位置元素</span><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;三毛&quot;</span>);<br>    System.out.println(list);<br>    <br>    <span class="hljs-comment">// String get(int index)  获取指定位置元素</span><br>    <br>    <span class="hljs-comment">// 跟size() 方法一起用  来 遍历的 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>    System.out.println(list.get(i));<br>    &#125;<br>    <span class="hljs-comment">//还可以使用增强for</span><br>    <span class="hljs-keyword">for</span> (String string : list) &#123;<br>System.out.println(string);<br>&#125;  <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第八章-List的子类"><a href="#第八章-List的子类" class="headerlink" title="第八章 List的子类"></a>第八章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="/img/cphoto/linkedlist01.jpg"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LinkedList&lt;String&gt; link = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>        <span class="hljs-comment">//添加元素</span><br>        link.addFirst(<span class="hljs-string">&quot;abc1&quot;</span>);<br>        link.addFirst(<span class="hljs-string">&quot;abc2&quot;</span>);<br>        link.addFirst(<span class="hljs-string">&quot;abc3&quot;</span>);<br>        System.out.println(link);<br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(link.getFirst());<br>        System.out.println(link.getLast());<br>        <span class="hljs-comment">// 删除元素</span><br>        System.out.println(link.removeFirst());<br>        System.out.println(link.removeLast());<br><br>        <span class="hljs-keyword">while</span> (!link.isEmpty()) &#123; <span class="hljs-comment">//判断集合是否为空</span><br>            System.out.println(link.pop()); <span class="hljs-comment">//弹出集合中的栈顶元素</span><br>        &#125;<br><br>        System.out.println(link);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSetDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建 Set集合</span><br>        HashSet&lt;String&gt;  set = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br><br>        <span class="hljs-comment">//添加元素</span><br>        set.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;cba&quot;</span>));<br>        set.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;bac&quot;</span>); <br>        set.add(<span class="hljs-string">&quot;cba&quot;</span>);  <br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (String name : set) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下，说明集合中不能存储重复元素：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cba</span><br><span class="hljs-attribute">abc</span><br><span class="hljs-attribute">bac</span><br></code></pre></td></tr></table></figure><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<br><img src="/img/cphoto/hashset01.jpg"></p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="/img/cphoto/linkedlist02.jpg"></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><p>创建自定义Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Student student = (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp;<br>               Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSetDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建集合对象   该集合中存储 Student类型对象</span><br>        HashSet&lt;Student&gt; stuSet = <span class="hljs-keyword">new</span> HashSet&lt;Student&gt;();<br>        <span class="hljs-comment">//存储 </span><br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;于谦&quot;</span>, <span class="hljs-number">43</span>);<br>        stuSet.add(stu);<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-number">44</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;于谦&quot;</span>, <span class="hljs-number">43</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;郭麒麟&quot;</span>, <span class="hljs-number">23</span>));<br>        stuSet.add(stu);<br><br>        <span class="hljs-keyword">for</span> (Student stu2 : stuSet) &#123;<br>            System.out.println(stu2);<br>        &#125;<br>    &#125;<br>&#125;<br>执行结果：<br>Student [name=郭德纲, age=<span class="hljs-number">44</span>]<br>Student [name=于谦, age=<span class="hljs-number">43</span>]<br>Student [name=郭麒麟, age=<span class="hljs-number">23</span>]<br></code></pre></td></tr></table></figure><h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashSetDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;();<br>set.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>set.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>set.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>set.add(<span class="hljs-string">&quot;bbc&quot;</span>);<br>        Iterator&lt;String&gt; it = set.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>System.out.println(it.next());<br>&#125;<br>&#125;<br>&#125;<br>结果：<br>  bbb<br>  aaa<br>  abc<br>  bbc<br></code></pre></td></tr></table></figure><h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">修饰符 返回值类型 方法名(参数类型... 形参名)</span><span class="hljs-template-variable">&#123;  &#125;</span><br></code></pre></td></tr></table></figure><p>其实这个书写完全等价与</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">修饰符 返回值类型 方法名(参数类型<span class="hljs-selector-attr">[]</span> 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeArgs</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">62</span>, <span class="hljs-number">431</span>, <span class="hljs-number">2</span> &#125;;<br>        <span class="hljs-keyword">int</span> sum = getSum(arr);<br>        System.out.println(sum);<br>        <span class="hljs-comment">//  6  7  2 12 2121</span><br>        <span class="hljs-comment">// 求 这几个元素和 6  7  2 12 2121</span><br>        <span class="hljs-keyword">int</span> sum2 = getSum(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2121</span>);<br>        System.out.println(sum2);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 完成数组  所有元素的求和 原始写法</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">      public static int getSum(int[] arr)&#123;</span><br><span class="hljs-comment">        int sum = 0;</span><br><span class="hljs-comment">        for(int a : arr)&#123;</span><br><span class="hljs-comment">            sum += a;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        return sum;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//可变参数写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a : arr) &#123;<br>            sum += a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-comment">//原来写法</span><br>        <span class="hljs-comment">//list.add(12);</span><br>        <span class="hljs-comment">//list.add(14);</span><br>        <span class="hljs-comment">//list.add(15);</span><br>        <span class="hljs-comment">//list.add(1000);</span><br>        <span class="hljs-comment">//采用工具类 完成 往集合中添加元素  </span><br>        Collections.addAll(list, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>，<span class="hljs-number">2</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">//排序方法 </span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br>结果：<br>[<span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>]<br></code></pre></td></tr></table></figure><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt;  list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;cba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;aba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;sba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;nba&quot;</span>);<br>        <span class="hljs-comment">//排序方法</span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[aba, cba, nba, sba]<br></code></pre></td></tr></table></figure><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p>public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; )`方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</T></T></p><ul><li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;cba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;aba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;sba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;nba&quot;</span>);<br>        <span class="hljs-comment">//排序方法  按照第一个单词的降序</span><br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o2.charAt(<span class="hljs-number">0</span>) - o1.charAt(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[sba, nba, cba, aba]<br></code></pre></td></tr></table></figure><h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>               <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>               <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>               <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建四个学生对象 存储到集合中</span><br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br><br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;ace&quot;</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mark&quot;</span>,<span class="hljs-number">16</span>));<br><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          让学生 按照年龄排序 升序</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span><br><br><br>        <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>            System.out.println(student);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br>    ....<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age-o.age;<span class="hljs-comment">//升序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次测试，代码就OK 了效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Student&#123;name=<span class="hljs-string">&#x27;jack&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;abc&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;mark&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;ace&#x27;</span>, age=<span class="hljs-number">17</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;rose&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o2.getAge()-o1.getAge();<span class="hljs-comment">//以学生的年龄降序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ace&#x27;</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mark&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></td></tr></table></figure><p>如果想要规则更多一些，可以参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>                <span class="hljs-comment">// 年龄降序</span><br>                <span class="hljs-keyword">int</span> result = o2.getAge()-o1.getAge();<span class="hljs-comment">//年龄降序</span><br><br>                <span class="hljs-keyword">if</span>(result==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span><br>                    result = o1.getName().charAt(<span class="hljs-number">0</span>)-o2.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ace&#x27;</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mark&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-Map集合"><a href="#第六章-Map集合" class="headerlink" title="第六章 Map集合"></a>第六章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="/img/cphoto/map01.jpg"></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建 map对象</span><br>        HashMap&lt;String, String&gt;  map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br><br>        <span class="hljs-comment">//添加元素到集合</span><br>        map.put(<span class="hljs-string">&quot;黄晓明&quot;</span>, <span class="hljs-string">&quot;杨颖&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;文章&quot;</span>, <span class="hljs-string">&quot;马伊琍&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<br>        System.out.println(map);<br><br>        <span class="hljs-comment">//String remove(String key)</span><br>        System.out.println(map.remove(<span class="hljs-string">&quot;邓超&quot;</span>));<br>        System.out.println(map);<br><br>        <span class="hljs-comment">// 想要查看 黄晓明的媳妇 是谁</span><br>        System.out.println(map.get(<span class="hljs-string">&quot;黄晓明&quot;</span>));<br>        System.out.println(map.get(<span class="hljs-string">&quot;邓超&quot;</span>));    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapDemo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建Map集合对象 </span><br>        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>        <span class="hljs-comment">//添加元素到集合 </span><br>        map.put(<span class="hljs-string">&quot;胡歌&quot;</span>, <span class="hljs-string">&quot;霍建华&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-string">&quot;于谦&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;薛之谦&quot;</span>, <span class="hljs-string">&quot;大张伟&quot;</span>);<br><br>        <span class="hljs-comment">//获取所有的键  获取键集</span><br>        Set&lt;String&gt; keys = map.keySet();<br>        <span class="hljs-comment">// 遍历键集 得到 每一个键</span><br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>          <span class="hljs-comment">//key  就是键</span><br>            <span class="hljs-comment">//获取对应值</span><br>            String value = map.get(key);<br>            System.out.println(key+<span class="hljs-string">&quot;的CP是：&quot;</span>+value);<br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历图解：</p><p><img src="/img/cphoto/map02.jpg"></p><h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p> 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p> 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p> 通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapDemo02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建Map集合对象 </span><br>        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>        <span class="hljs-comment">// 添加元素到集合 </span><br>        map.put(<span class="hljs-string">&quot;胡歌&quot;</span>, <span class="hljs-string">&quot;霍建华&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-string">&quot;于谦&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;薛之谦&quot;</span>, <span class="hljs-string">&quot;大张伟&quot;</span>);<br><br>        <span class="hljs-comment">// 获取 所有的 entry对象  entrySet</span><br>        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();<br><br>        <span class="hljs-comment">// 遍历得到每一个entry对象</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;<br>           <span class="hljs-comment">// 解析 </span><br>            String key = entry.getKey();<br>            String value = entry.getValue();  <br>            System.out.println(key+<span class="hljs-string">&quot;的CP是:&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历图解：</p><p><img src="/img/cphoto/map03.jpg"></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Student student = (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMapTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1,创建Hashmap集合对象。</span><br>        Map&lt;Student,String&gt;map = <span class="hljs-keyword">new</span> HashMap&lt;Student,String&gt;();<br>        <span class="hljs-comment">//2,添加元素。</span><br>        map.put(newStudent(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">28</span>), <span class="hljs-string">&quot;上海&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">22</span>), <span class="hljs-string">&quot;北京&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;zhaoliu&quot;</span>,<span class="hljs-number">24</span>), <span class="hljs-string">&quot;成都&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;zhouqi&quot;</span>,<span class="hljs-number">25</span>), <span class="hljs-string">&quot;广州&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">22</span>), <span class="hljs-string">&quot;南京&quot;</span>);<br>        <br>        <span class="hljs-comment">//3,取出元素。键找值方式</span><br>        Set&lt;Student&gt;keySet = map.keySet();<br>        <span class="hljs-keyword">for</span>(Student key: keySet)&#123;<br>            Stringvalue = map.get(key);<br>            System.out.println(key.toString()+<span class="hljs-string">&quot;.....&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMapDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LinkedHashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;李晨&quot;</span>, <span class="hljs-string">&quot;范冰冰&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-string">&quot;朱丽倩&quot;</span>);<br>        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;  &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">邓超  孙俪<br>李晨  范冰冰<br>刘德华  朱丽倩<br></code></pre></td></tr></table></figure><h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li> 获取一个字符串对象</li><li> 创建一个Map集合，键代表字符，值代表次数。</li><li> 遍历字符串得到每个字符。</li><li> 判断Map中是否有该键。</li><li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li> 打印最终结果</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//友情提示</span><br>        System.out.println(<span class="hljs-string">&quot;请录入一个字符串:&quot;</span>);<br>        String line = <span class="hljs-keyword">new</span> Scanner(System.in).nextLine();<br>        <span class="hljs-comment">// 定义 每个字符出现次数的方法</span><br>        findChar(line);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findChar</span><span class="hljs-params">(String line)</span> </span>&#123;<br>        <span class="hljs-comment">//1:创建一个集合 存储  字符 以及其出现的次数</span><br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        <span class="hljs-comment">//2:遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; line.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = line.charAt(i);<br>            <span class="hljs-comment">//判断 该字符 是否在键集中</span><br>            <span class="hljs-keyword">if</span> (!map.containsKey(c)) &#123;<span class="hljs-comment">//说明这个字符没有出现过</span><br>                <span class="hljs-comment">//那就是第一次</span><br>                map.put(c, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//先获取之前的次数</span><br>                Integer count = map.get(c);<br>                <span class="hljs-comment">//count++;</span><br>                <span class="hljs-comment">//再次存入  更新</span><br>                map.put(c, ++count);<br>            &#125;<br>        &#125;<br>        System.out.println(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第七章-补充知识点"><a href="#第七章-补充知识点" class="headerlink" title="第七章 补充知识点"></a>第七章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;def&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;ghi&quot;</span>);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloJDK9</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        Set&lt;String&gt; str1=Set.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);  <br>        <span class="hljs-comment">//str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span><br>        System.out.println(str1);  <br>        Map&lt;String,Integer&gt; str2=Map.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);  <br>        System.out.println(str2);  <br>        List&lt;String&gt; str3=List.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);  <br>        System.out.println(str3);  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><p>需要注意以下两点：</p><blockquote><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p><p>2:返回的集合是不可变的；</p></blockquote><h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p><ol><li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序     </p><p><img src="/img/cphoto/debug01.jpg"></p></li><li><p>点击Debug运行模式       </p><p><img src="/img/cphoto/debug02.jpg"></p><p>​                                                                                                                                                                      </p></li><li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p><p><img src="/img/cphoto/debug03.jpg"></p></li><li><p>Debug调试窗口介绍</p><p><img src="/img/cphoto/debug04.jpg"></p></li><li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p><p><img src="/img/cphoto/debug05.jpg"></p></li><li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p><p><img src="/img/cphoto/debug04.jpg"></p></li><li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p><p><img src="/img/cphoto/debug07.jpg"></p><p>回车之后效果：</p><p><img src="/img/cphoto/debug08.jpg"></p><p> 调试界面效果：</p><p><img src="/img/cphoto/debug09.jpg"></p></li><li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p><p><img src="/img/cphoto/debug10.jpg"></p></li><li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p><p><img src="/img/cphoto/debug11.jpg"></p></li><li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p><p><img src="/img/cphoto/debug12.jpg"></p></li><li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p><p><img src="/img/cphoto/debug13.jpg"></p></li><li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p><p><img src="/img/cphoto/debug14.jpg"></p></li><li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p><p><img src="/img/cphoto/debug15.jpg"></p></li><li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p><p><img src="/img/cphoto/debug16.jpg"></p></li></ol><h1 id="第八章-模拟斗地主洗牌发牌"><a href="#第八章-模拟斗地主洗牌发牌" class="headerlink" title="第八章  模拟斗地主洗牌发牌"></a>第八章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%96%97%E5%9C%B0%E4%B8%BB.png"></p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol><li> 准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li> 洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li> 发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li> 看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png"></p><h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 1组装54张扑克牌</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 1.1 创建Map集合存储</span><br>        HashMap&lt;Integer, String&gt; pokerMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();<br>        <span class="hljs-comment">// 1.2 创建 花色集合 与 数字集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 1.3 存储 花色 与数字</span><br>        Collections.addAll(colors, <span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        Collections.addAll(numbers, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">// 设置 存储编号变量</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        pokerMap.put(count++, <span class="hljs-string">&quot;大王&quot;</span>);<br>        pokerMap.put(count++, <span class="hljs-string">&quot;小王&quot;</span>);<br>        <span class="hljs-comment">// 1.4 创建牌 存储到map集合中</span><br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                String card = color + number;<br>                pokerMap.put(count++, card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 2 将54张牌顺序打乱</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 取出编号 集合</span><br>        Set&lt;Integer&gt; numberSet = pokerMap.keySet();<br>        <span class="hljs-comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span><br>        ArrayList&lt;Integer&gt; numberList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        numberList.addAll(numberSet);<br><br>        <span class="hljs-comment">// 打乱顺序</span><br>        Collections.shuffle(numberList);<br><br>        <span class="hljs-comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span><br>        <span class="hljs-comment">// 3.1 发牌的编号</span><br>        <span class="hljs-comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span><br>        ArrayList&lt;Integer&gt; noP1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP3 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; dipaiNo = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 3.2发牌的编号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numberList.size(); i++) &#123;<br>            <span class="hljs-comment">// 获取该编号</span><br>            Integer no = numberList.get(i);<br>            <span class="hljs-comment">// 发牌</span><br>            <span class="hljs-comment">// 留出底牌</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">51</span>) &#123;<br>                dipaiNo.add(no);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                    noP1.add(no);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>                    noP2.add(no);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    noP3.add(no);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span><br>        <span class="hljs-comment">// 4.1 对手中编号进行排序</span><br>        Collections.sort(noP1);<br>        Collections.sort(noP2);<br>        Collections.sort(noP3);<br>        Collections.sort(dipaiNo);<br><br>        <span class="hljs-comment">// 4.2 进行牌面的转换</span><br>        <span class="hljs-comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 4.3转换</span><br>        <span class="hljs-keyword">for</span> (Integer i : noP1) &#123;<br>            <span class="hljs-comment">// 4.4 根据编号找到 牌面 pokerMap</span><br>            String card = pokerMap.get(i);<br>            <span class="hljs-comment">// 添加到对应的 牌面集合中</span><br>            player1.add(card);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Integer i : noP2) &#123;<br>            String card = pokerMap.get(i);<br>            player2.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : noP3) &#123;<br>            String card = pokerMap.get(i);<br>            player3.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : dipaiNo) &#123;<br>            String card = pokerMap.get(i);<br>            dipai.add(card);<br>        &#125;<br><br>        <span class="hljs-comment">//4.5 查看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;石破天：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;鸠摩智：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-1-案例介绍-1"><a href="#3-1-案例介绍-1" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/img/cphoto/doudizhu01.jpg"></p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="3-2-案例需求分析-1"><a href="#3-2-案例需求分析-1" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol><li> 准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li> 洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li> 发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li> 看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="/img/cphoto/doudizhu02.jpg"></p><h2 id="3-3-实现代码步骤-1"><a href="#3-3-实现代码步骤-1" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 1组装54张扑克牌</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 1.1 创建Map集合存储</span><br>        HashMap&lt;Integer, String&gt; pokerMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();<br>        <span class="hljs-comment">// 1.2 创建 花色集合 与 数字集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 1.3 存储 花色 与数字</span><br>        Collections.addAll(colors, <span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        Collections.addAll(numbers, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">// 设置 存储编号变量</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        pokerMap.put(count++, <span class="hljs-string">&quot;大王&quot;</span>);<br>        pokerMap.put(count++, <span class="hljs-string">&quot;小王&quot;</span>);<br>        <span class="hljs-comment">// 1.4 创建牌 存储到map集合中</span><br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                String card = color + number;<br>                pokerMap.put(count++, card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 2 将54张牌顺序打乱</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 取出编号 集合</span><br>        Set&lt;Integer&gt; numberSet = pokerMap.keySet();<br>        <span class="hljs-comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span><br>        ArrayList&lt;Integer&gt; numberList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        numberList.addAll(numberSet);<br><br>        <span class="hljs-comment">// 打乱顺序</span><br>        Collections.shuffle(numberList);<br><br>        <span class="hljs-comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span><br>        <span class="hljs-comment">// 3.1 发牌的编号</span><br>        <span class="hljs-comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span><br>        ArrayList&lt;Integer&gt; noP1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP3 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; dipaiNo = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 3.2发牌的编号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numberList.size(); i++) &#123;<br>            <span class="hljs-comment">// 获取该编号</span><br>            Integer no = numberList.get(i);<br>            <span class="hljs-comment">// 发牌</span><br>            <span class="hljs-comment">// 留出底牌</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">51</span>) &#123;<br>                dipaiNo.add(no);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                    noP1.add(no);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>                    noP2.add(no);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    noP3.add(no);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span><br>        <span class="hljs-comment">// 4.1 对手中编号进行排序</span><br>        Collections.sort(noP1);<br>        Collections.sort(noP2);<br>        Collections.sort(noP3);<br>        Collections.sort(dipaiNo);<br><br>        <span class="hljs-comment">// 4.2 进行牌面的转换</span><br>        <span class="hljs-comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 4.3转换</span><br>        <span class="hljs-keyword">for</span> (Integer i : noP1) &#123;<br>            <span class="hljs-comment">// 4.4 根据编号找到 牌面 pokerMap</span><br>            String card = pokerMap.get(i);<br>            <span class="hljs-comment">// 添加到对应的 牌面集合中</span><br>            player1.add(card);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Integer i : noP2) &#123;<br>            String card = pokerMap.get(i);<br>            player2.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : noP3) &#123;<br>            String card = pokerMap.get(i);<br>            player3.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : dipaiNo) &#123;<br>            String card = pokerMap.get(i);<br>            dipai.add(card);<br>        &#125;<br><br>        <span class="hljs-comment">//4.5 查看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;石破天：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;鸠摩智：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章    异常"></a>第九章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="/img/cphoto/throw01.jpg"></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p><p><img src="/img/cphoto/throw02.jpg"></p><h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p> <img src="/img/cphoto/throw03.jpg"></p><h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p> 工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayTools</span> </span>&#123;<br>    <span class="hljs-comment">// 对给定的数组通过给定的角标获取元素。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> element = arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span> &#125;;<br>        intnum = ArrayTools.getElement(arr, <span class="hljs-number">4</span>)<br>        System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序执行过程图解：</p><p> <img src="/2017/09/12/java%E5%9F%BA%E7%A4%8E05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png"></p><h1 id="第十章-异常的处理"><a href="#第十章-异常的处理" class="headerlink" title="第十章 异常的处理"></a>第十章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1     抛出异常throw"></a>2.1     抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type"></span>异常类名(参数);<br></code></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;要访问的arr数组不存在&quot;</span>);<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);<br></code></pre></td></tr></table></figure><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个数组 </span><br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-comment">//根据索引找对应的元素 </span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">int</span> element = getElement(arr, index);<br><br>        System.out.println(element);<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 根据 索引找到数组中对应的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> index)</span></span>&#123; <br>       <span class="hljs-comment">//判断  索引是否越界</span><br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length-<span class="hljs-number">1</span>)&#123;<br>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span><br><span class="hljs-comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;哥们，角标越界了~~~&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> element = arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p></blockquote><h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p><ul><li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li></ul><p>查看源码发现这里对为null的进行了抛出异常操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">requireNonNull</span><span class="hljs-params">(T obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">修饰符 返回值类型 方法名(参数) <span class="hljs-keyword">throws</span> 异常类名<span class="hljs-number">1</span>,异常类名<span class="hljs-number">2</span>…&#123;   &#125;<br></code></pre></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span><span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;b.txt&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型  e)&#123;<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意:try和catch都不能单独使用,必须连用。</p></blockquote><p>演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span><br>            read(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<span class="hljs-comment">// 括号中需要定义什么呢？</span><br>          <span class="hljs-comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span><br>            System.out.println(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何获取异常信息：</p><p>Throwable类中定义了一些查看方法:</p><ul><li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li></ul><ul><li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li><li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li></ul><p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p><h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>什么时候的代码必须最终执行？</p><p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意:finally不能单独使用。</p></blockquote><p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p><p>finally代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            <span class="hljs-comment">//抓取到的是编译期异常  抛出去的是运行期 </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p></blockquote><h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul><li><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型A  e)&#123;  当<span class="hljs-keyword">try</span>中出现A类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型B  e)&#123;  当<span class="hljs-keyword">try</span>中出现B类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote></li><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul><h1 id="第十一章-自定义异常"><a href="#第十一章-自定义异常" class="headerlink" title="第十一章 自定义异常"></a>第十一章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p><p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p><p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义异常类.</p><p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li></ol><h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>首先定义一个登陆异常类RegisterException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 业务逻辑异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空参构造</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 表示异常提示</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-comment">// 模拟数据库中已存在账号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] names = &#123;<span class="hljs-string">&quot;bill&quot;</span>,<span class="hljs-string">&quot;hill&quot;</span>,<span class="hljs-string">&quot;jill&quot;</span>&#125;;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     <br>        <span class="hljs-comment">//调用方法</span><br>        <span class="hljs-keyword">try</span>&#123;<br>              <span class="hljs-comment">// 可能出现异常的代码</span><br>            checkUsername(<span class="hljs-string">&quot;nill&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;注册成功&quot;</span>);<span class="hljs-comment">//如果没有异常就是注册成功</span><br>        &#125;<span class="hljs-keyword">catch</span>(RegisterException e)&#123;<br>            <span class="hljs-comment">//处理异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断当前注册账号是否存在</span><br>    <span class="hljs-comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkUsername</span><span class="hljs-params">(String uname)</span> <span class="hljs-keyword">throws</span> LoginException</span>&#123;<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-keyword">if</span>(name.equals(uname))&#123;<span class="hljs-comment">//如果名字在这里面 就抛出登陆异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RegisterException(<span class="hljs-string">&quot;亲&quot;</span>+name+<span class="hljs-string">&quot;已经被注册了！&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十二章-多线程"><a href="#第十二章-多线程" class="headerlink" title="第十二章 多线程"></a>第十二章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p><p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p><h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src="/img/cphoto/thread01.jpg"></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p></li></ul><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src="/img/cphoto/thread02.jpg"></p><p><strong>线程</strong></p><p><img src="/img/cphoto/thread03.jpg"></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p><img src="/img/cphoto/thread04.jpg"></p><ul><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p><p><img src="/img/cphoto/thread05.jpg"></p></li></ul></li></ul><h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建自定义线程对象</span><br>MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;新的线程！&quot;</span>);<br><span class="hljs-comment">//开启新线程</span><br>mt.start();<br><span class="hljs-comment">//在主方法中执行for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;main线程！&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-comment">//定义指定线程名称的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-comment">//调用父类的String参数的构造方法，指定线程的名称</span><br><span class="hljs-keyword">super</span>(name);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重写run方法，完成该线程执行的逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>System.out.println(getName()+<span class="hljs-string">&quot;：正在执行！&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础04-Collection泛型</title>
    <link href="/2017/09/11/java%E5%9F%BA%E7%A1%8004-Collection%E6%B3%9B%E5%9E%8B/"/>
    <url>/2017/09/11/java%E5%9F%BA%E7%A1%8004-Collection%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-泛型"><a href="#第一章-泛型" class="headerlink" title="第一章 泛型"></a>第一章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>Iterator it = coll.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br><span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>String str = (String) it.next();<br>System.out.println(str.length());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        <span class="hljs-comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span><br>        <span class="hljs-comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String str = it.next();<br>            <span class="hljs-comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span><br>            System.out.println(str.length());<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></code></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123; &#125;<br>   ....<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">MVP</span>&gt; </span>&#123;<br><span class="hljs-comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br><span class="hljs-keyword">private</span> MVP mvp;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMVP</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mvp = mvp;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MVP <span class="hljs-title">getMVP</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericClassDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>         <span class="hljs-comment">// 创建一个泛型为String的类</span><br>         MyGenericClass&lt;String&gt; my = <span class="hljs-keyword">new</span> MyGenericClass&lt;String&gt;();    <br>         <span class="hljs-comment">// 调用setMVP</span><br>         my.setMVP(<span class="hljs-string">&quot;大胡子登登&quot;</span>);<br>         <span class="hljs-comment">// 调用getMVP</span><br>         String mvp = my.getMVP();<br>         System.out.println(mvp);<br>         <span class="hljs-comment">//创建一个泛型为Integer的类</span><br>         MyGenericClass&lt;Integer&gt; my2 = <span class="hljs-keyword">new</span> MyGenericClass&lt;Integer&gt;(); <br>         my2.setMVP(<span class="hljs-number">123</span>);     <br>         Integer mvp2 = my2.getMVP();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">修饰符 <span class="hljs-attribute">&lt;代表泛型的变量&gt;</span> 返回值类型 方法名(参数)&#123;  &#125;<br></code></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethod</span> </span>&#123;  <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>    System.out.println(mvp.getClass());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function">MVP <span class="hljs-title">show2</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        MyGenericMethod mm = <span class="hljs-keyword">new</span> MyGenericMethod();<br>        <span class="hljs-comment">// 演示看方法提示</span><br>        mm.show(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        mm.show(<span class="hljs-number">123</span>);<br>        mm.show(<span class="hljs-number">12.45</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;<br></code></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span></span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;<br>        <span class="hljs-comment">// 省略...</span><br>    &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp2</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-comment">// 省略...</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyImp2&lt;String&gt;  my = <span class="hljs-keyword">new</span> MyImp2&lt;String&gt;();  <br>        my.add(<span class="hljs-string">&quot;aa&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Intger&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list1);<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    getElement(list2);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">//？代表可以接收任意类型</span><br></code></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</String></Object></p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-Collection集合"><a href="#第二章-Collection集合" class="headerlink" title="第二章 Collection集合"></a>第二章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</E></p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1Collection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建集合对象 </span><br>    <span class="hljs-comment">// 使用多态形式</span><br>    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-comment">// 使用方法</span><br>    <span class="hljs-comment">// 添加功能  boolean  add(String s)</span><br>    coll.add(<span class="hljs-string">&quot;小李广&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;扫地僧&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;石破天&quot;</span>);<br>    System.out.println(coll);<br><br>    <span class="hljs-comment">// boolean contains(E e) 判断o是否在集合中存在</span><br>    System.out.println(<span class="hljs-string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="hljs-string">&quot;扫地僧&quot;</span>));<br><br>    <span class="hljs-comment">//boolean remove(E e) 删除在集合中的o元素</span><br>    System.out.println(<span class="hljs-string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="hljs-string">&quot;石破天&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作之后集合中元素:&quot;</span>+coll);<br>    <br>    <span class="hljs-comment">// size() 集合中有几个元素</span><br>System.out.println(<span class="hljs-string">&quot;集合中有&quot;</span>+coll.size()+<span class="hljs-string">&quot;个元素&quot;</span>);<br><br><span class="hljs-comment">// Object[] toArray()转换成一个Object数组</span><br>    Object[] objects = coll.toArray();<br>    <span class="hljs-comment">// 遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;<br>System.out.println(objects[i]);<br>&#125;<br><br><span class="hljs-comment">// void  clear() 清空集合</span><br>coll.clear();<br>System.out.println(<span class="hljs-string">&quot;集合中内容为：&quot;</span>+coll);<br><span class="hljs-comment">// boolean  isEmpty()  判断是否为空</span><br>System.out.println(coll.isEmpty());  <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h1 id="第三章-Iterator迭代器"><a href="#第三章-Iterator迭代器" class="headerlink" title="第三章 Iterator迭代器"></a>第三章 Iterator迭代器</h1><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用多态方式 创建对象</span><br>        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 添加元素到集合</span><br>        coll.add(<span class="hljs-string">&quot;串串星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;吐槽星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;汪星人&quot;</span>);<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span><br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-comment">//  泛型指的是 迭代出 元素的数据类型</span><br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123; <span class="hljs-comment">//判断是否有迭代元素</span><br>            String s = it.next();<span class="hljs-comment">//获取迭代出的元素</span><br>            System.out.println(s);<br>        &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; <br>  <span class="hljs-comment">//写操作代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBForDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">87</span>&#125;;<br>       <span class="hljs-comment">//使用增强for遍历数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr)&#123;<span class="hljs-comment">//a代表数组中的每个元素</span><br>System.out.println(a);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBFor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <br>    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    coll.add(<span class="hljs-string">&quot;小河神&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;老河神&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;神婆&quot;</span>);<br>    <span class="hljs-comment">//使用增强for遍历</span><br>    <span class="hljs-keyword">for</span>(String s :coll)&#123;<span class="hljs-comment">//接收变量s代表 代表被遍历到的集合元素</span><br>    System.out.println(s);<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</String></p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p></li></ul><ul><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 1: 准备牌操作</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//1.1 创建牌盒 将来存储牌面的 </span><br>        ArrayList&lt;String&gt; pokerBox = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        <span class="hljs-comment">//1.2 创建花色集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.3 创建数字集合</span><br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.4 分别给花色 以及 数字集合添加元素</span><br>        colors.add(<span class="hljs-string">&quot;♥&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♦&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♠&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♣&quot;</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>            numbers.add(i+<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        numbers.add(<span class="hljs-string">&quot;J&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;Q&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;K&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-comment">//1.5 创造牌  拼接牌操作</span><br>        <span class="hljs-comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span><br>        <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>            <span class="hljs-comment">//color每一个花色 </span><br>            <span class="hljs-comment">//遍历数字集合</span><br>            <span class="hljs-keyword">for</span>(String number : numbers)&#123;<br>                <span class="hljs-comment">//结合</span><br>                String card = color+number;<br>                <span class="hljs-comment">//存储到牌盒中</span><br>                pokerBox.add(card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//1.6大王小王</span><br>        pokerBox.add(<span class="hljs-string">&quot;小☺&quot;</span>);<br>        pokerBox.add(<span class="hljs-string">&quot;大☠&quot;</span>);  <br>        <span class="hljs-comment">// System.out.println(pokerBox);</span><br>        <span class="hljs-comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span><br>        <span class="hljs-comment">// Collections类  工具类  都是 静态方法</span><br>        <span class="hljs-comment">// shuffer方法   </span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * static void shuffle(List&lt;?&gt; list) </span><br><span class="hljs-comment">         *     使用默认随机源对指定列表进行置换。 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//2:洗牌</span><br>        Collections.shuffle(pokerBox);<br>        <span class="hljs-comment">//3 发牌</span><br>        <span class="hljs-comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br><br>        <span class="hljs-comment">//遍历 牌盒  必须知道索引   </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;pokerBox.size();i++)&#123;<br>            <span class="hljs-comment">//获取 牌面</span><br>            String card = pokerBox.get(i);<br>            <span class="hljs-comment">//留出三张底牌 存到 底牌集合中</span><br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">51</span>)&#123;<span class="hljs-comment">//存到底牌集合中</span><br>                dipai.add(card);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//玩家1   %3  ==0</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                  player1.add(card);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//玩家2</span><br>                  player2.add(card);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//玩家3</span><br>                  player3.add(card);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//看看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;田伯光：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;绿竹翁：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);  <br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础03-Object类</title>
    <link href="/2017/09/07/java%E5%9F%BA%E7%A4%8E03/"/>
    <url>/2017/09/07/java%E5%9F%BA%E7%A4%8E03/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> /*<span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span>*/ </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> + <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 省略构造器与Getter Setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。</p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果对象地址一样，则认为相同</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 如果参数为空，或者类型信息不一样，则认为不同</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 转换为当前类型</span><br>        Person person = (Person) o;<br>        <span class="hljs-comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成</p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Date</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建日期对象，把当前的时间</span><br>        System.out.println(<span class="hljs-keyword">new</span> Date()); <span class="hljs-comment">// Tue Jan 16 14:37:35 CST 2018</span><br>        <span class="hljs-comment">// 创建日期对象，把当前的毫秒值转成日期对象</span><br>        System.out.println(<span class="hljs-keyword">new</span> Date(<span class="hljs-number">0L</span>)); <span class="hljs-comment">// Thu Jan 01 08:00:00 CST 1970</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02SimpleDateFormat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 对应的日期格式如：2018-01-16 15:06:38</span><br>        DateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把Date对象转换成String</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03DateFormatMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        <span class="hljs-comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span><br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        String str = df.format(date);<br>        System.out.println(str); <span class="hljs-comment">// 2008年1月23日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把String转换成Date对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04DateFormatMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        String str = <span class="hljs-string">&quot;2018年12月11日&quot;</span>;<br>        Date date = df.parse(str);<br>        System.out.println(date); <span class="hljs-comment">// Tue Dec 11 00:00:00 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06CalendarInit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalendarUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建Calendar对象</span><br>        Calendar cal = Calendar.getInstance();<br>        <span class="hljs-comment">// 设置年 </span><br>        <span class="hljs-keyword">int</span> year = cal.get(Calendar.YEAR);<br>        <span class="hljs-comment">// 设置月</span><br>        <span class="hljs-keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 设置日</span><br>        <span class="hljs-keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        cal.set(Calendar.YEAR, <span class="hljs-number">2020</span>);<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2020年1月17日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2018年1月17日</span><br>        <span class="hljs-comment">// 使用add方法</span><br>        cal.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">2</span>); <span class="hljs-comment">// 加2天</span><br>        cal.add(Calendar.YEAR, -<span class="hljs-number">3</span>); <span class="hljs-comment">// 减3年</span><br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2015年1月18日; </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        Date date = cal.getTime();<br>        System.out.println(date); <span class="hljs-comment">// Tue Jan 16 16:03:09 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">//获取当前时间毫秒值</span><br>        System.out.println(System.currentTimeMillis()); <span class="hljs-comment">// 1516090531144</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTest1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;共耗时毫秒：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11SystemArrayCopy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] src = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>        System.arraycopy( src, <span class="hljs-number">0</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">/*代码运行后：两个数组中的元素发生了变化</span><br><span class="hljs-comment">         src数组元素[1,2,3,4,5]</span><br><span class="hljs-comment">         dest数组元素[1,2,3,9,10]</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        s += <span class="hljs-string">&quot;World&quot;</span>;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。(默认16字符空间，超过自动扩充)</p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuilder sb1 = <span class="hljs-keyword">new</span> StringBuilder();<br>        System.out.println(sb1); <span class="hljs-comment">// (空白)</span><br>        <span class="hljs-comment">// 使用带参构造</span><br>        StringBuilder sb2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        System.out.println(sb2); <span class="hljs-comment">// itcast</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02StringBuilder</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建对象</span><br>StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-comment">//public StringBuilder append(任意类型)</span><br>StringBuilder builder2 = builder.append(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">//对比一下</span><br>System.out.println(<span class="hljs-string">&quot;builder:&quot;</span>+builder);<br>System.out.println(<span class="hljs-string">&quot;builder2:&quot;</span>+builder2);<br>System.out.println(builder == builder2); <span class="hljs-comment">//true</span><br>    <span class="hljs-comment">// 可以添加 任何类型</span><br>builder.append(<span class="hljs-string">&quot;hello&quot;</span>);<br>builder.append(<span class="hljs-string">&quot;world&quot;</span>);<br>builder.append(<span class="hljs-keyword">true</span>);<br>builder.append(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span><br>        <span class="hljs-comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span><br><span class="hljs-comment">//链式编程</span><br>builder.append(<span class="hljs-string">&quot;hello&quot;</span>).append(<span class="hljs-string">&quot;world&quot;</span>).append(<span class="hljs-keyword">true</span>).append(<span class="hljs-number">100</span>);<br>System.out.println(<span class="hljs-string">&quot;builder:&quot;</span>+builder);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16StringBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 链式创建</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>).append(<span class="hljs-string">&quot;World&quot;</span>).append(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-comment">// 调用方法</span><br>        String str = sb.toString();<br>        System.out.println(str); <span class="hljs-comment">// HelloWorldJava</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure><h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure><h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">基本类型直接与””相连接即可；如：<span class="hljs-number">34</span>+<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>String转换成对应的基本类型 </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo18WrapperParse</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num = Integer.parseInt(<span class="hljs-string">&quot;100&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎02-面向对象</title>
    <link href="/2017/09/03/java%E5%9F%BA%E7%A4%8E02/"/>
    <url>/2017/09/03/java%E5%9F%BA%E7%A4%8E02/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述类事物。<br>属性：就是该事物的状态信息。<br>行为：就是该事物能够做什么。<br>对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为</p><h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><p>类是对一类事物的描述，是抽象的。<br>对象是一类事物的实例，是具体的。<br>类是对象的模板，对象是类的实体。</p><h2 id="对象的使用格式"><a href="#对象的使用格式" class="headerlink" title="对象的使用格式"></a>对象的使用格式</h2><p>创建对象：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">类名 对象名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>类名();<br></code></pre></td></tr></table></figure><p>使用对象访问类中的成员:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">对象名.成员变量；<br>对象名.成员方法<span class="hljs-comment">()</span>；<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/object01.jpg" alt="对象内存图"></p><h2 id="两个对象，调用同一方法内存图"><a href="#两个对象，调用同一方法内存图" class="headerlink" title="两个对象，调用同一方法内存图"></a>两个对象，调用同一方法内存图</h2><p><img src="/img/cphoto/obj02.jpg" alt="对象内存图"></p><h2 id="一个引用，作为参数传递到方法中内存图"><a href="#一个引用，作为参数传递到方法中内存图" class="headerlink" title="一个引用，作为参数传递到方法中内存图"></a>一个引用，作为参数传递到方法中内存图</h2><p><img src="/img/cphoto/obj03.jpg" alt="对象内存图"></p><h2 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h2><p>在类中的位置不同 重点</p><ul><li>成员变量：类中，方法外<br>局部变量：方法中或者方法声明上(形式参数)</li></ul><p>作用范围不一样 重点</p><ul><li>成员变量：类中<br>局部变量：方法中</li></ul><p>初始化值的不同 重点</p><ul><li>成员变量：有默认值<br>局部变量：没有默认值。必须先定义，赋值，最后使用</li></ul><p>在内存中的位置不同 了解</p><ul><li>成员变量：堆内存<br>局部变量：栈内存</li></ul><p>生命周期不同 了解</p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li></ul><h2 id="封装概述"><a href="#封装概述" class="headerlink" title="封装概述"></a>封装概述</h2><p>将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</p><h2 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a>封装步骤</h2><p>使用 private 关键字来修饰成员变量。</p><p>对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。</p><h2 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h2><ol><li>private是一个权限修饰符，代表最小权限。</li><li>可以修饰成员变量和成员方法。</li><li>被private修饰后的成员变量和成员方法，只在本类中才能访问。</li></ol><p>private的使用格式</p><p>private 数据类型 变量名 ；</p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>his代表所在类的当前对象的引用（地址值），即对象自己的引用。<br>记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">修饰符 构造方法名(参数列表)&#123;<br><span class="hljs-regexp">//</span> 方法体<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> &#123;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-comment">// 无参数构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-comment">// 有参数构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name,<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">public class ClassName&#123;<br><span class="hljs-regexp">//</span>成员变量<br><span class="hljs-regexp">//</span>构造方法<br><span class="hljs-regexp">//</span>无参构造方法【必须】<br><span class="hljs-regexp">//</span>有参构造方法【建议】<br><span class="hljs-regexp">//</span>成员方法<br><span class="hljs-regexp">//g</span>etXxx()<br><span class="hljs-regexp">//</span>setXxx()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Scanner sc = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br><span class="hljs-built_in">int</span> i = sc.next<span class="hljs-constructor">Int()</span>;<br></code></pre></td></tr></table></figure><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。<br>匿名对象 ：没有变量名的对象</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type"></span>类名(参数列表)；<br></code></pre></td></tr></table></figure><p>一个匿名对象，只能使用一次</p><p>一旦调用两次方法，就是创建了两个对象，造成浪费，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br><span class="hljs-comment">// 普通方式</span><br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>input(sc);<br><span class="hljs-comment">//匿名对象作为方法接收的参数</span><br>input(<span class="hljs-keyword">new</span> Scanner(System.in));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">input</span>(<span class="hljs-params">Scanner sc</span>)</span>&#123;<br>System.out.println(sc);<br>&#125;<br></code></pre></td></tr></table></figure><p>作为返回值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">ass Test2 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br><span class="hljs-comment">// 普通方式</span><br>Scanner sc = getScanner();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Scanner <span class="hljs-function"><span class="hljs-title">getScanner</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//普通方式</span><br><span class="hljs-comment">//Scanner sc = new Scanner(System.in);</span><br><span class="hljs-comment">//return sc;</span><br><span class="hljs-comment">//匿名对象作为方法返回值</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Scanner(System.in);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>用于生成伪随机数</p><p>创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Random r = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;<br><span class="hljs-built_in">int</span> i = r.next<span class="hljs-constructor">Int()</span>;<br></code></pre></td></tr></table></figure><p>获取1-n之间的随机数，包含n</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> n = <span class="hljs-number">50</span>;<br><span class="hljs-comment">// 创建对象</span><br>Random r = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;<br><span class="hljs-comment">// 获取随机数</span><br><span class="hljs-built_in">int</span> number = r.next<span class="hljs-constructor">Int(<span class="hljs-params">n</span>)</span> + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 输出随机数</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;number:&quot;</span> + number);<br><br></code></pre></td></tr></table></figure><h2 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h2><p>存储对象数据,如果是对象数组,而数组的长度是固定的，无法适应数据变化的需<br>求,为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据</p><p>java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。</p><p>java.util.ArrayList <E> ：该类需要 import导入使后使用。<br><E> ，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。如ArrayList<String>，ArrayList<Student></Student></String></E></E></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ArrayList&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br><span class="hljs-comment">//在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写</span><br>ArrayList&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>对于元素的操作,基本体现在——增、删、查。常用的方法有：<br>public boolean add(E e) ：将指定的元素添加到此集合的尾部。<br>public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。<br>public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。<br>public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</p><h2 id="ArrayList对象只能存储基本数据类型的包装类"><a href="#ArrayList对象只能存储基本数据类型的包装类" class="headerlink" title="ArrayList对象只能存储基本数据类型的包装类"></a>ArrayList对象只能存储基本数据类型的包装类</h2><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 <int> 不能写，但是存储基本数据类型对应的<br>包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写</int></p><table><thead><tr><th>基本类型</th><th>基本类型包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>只有 Integer 和 Character 需要特殊记忆，其他基本类型只是首字母大写即可。</p><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>字符串不变：字符串的值在创建后不能被更改。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>s1 += <span class="hljs-string">&quot;d&quot;</span>;<br>System.out.println(s1); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-regexp">//</span> 内存中有<span class="hljs-string">&quot;abc&quot;</span>，<span class="hljs-string">&quot;abcd&quot;</span>两个对象，s1从指向<span class="hljs-string">&quot;abc&quot;</span>，改变指向，指向了<span class="hljs-string">&quot;abcd&quot;</span>。<br></code></pre></td></tr></table></figure><p>因为String对象是不可变的，所以它们可以被共享。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String s1 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>String s2 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>// 内存中只有一个<span class="hljs-string">&quot;abc&quot;</span>对象被创建，同时被s1和s2共享。<br></code></pre></td></tr></table></figure><p>“abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing">例如：<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br>相当于：<br><span class="hljs-built_in">char</span> data[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(data);<br><span class="hljs-comment">// String底层是靠字符数组实现的。</span><br><br></code></pre></td></tr></table></figure><h2 id="String构造方法"><a href="#String构造方法" class="headerlink" title="String构造方法"></a>String构造方法</h2><ul><li>public String() ：初始化新创建的 String对象，以使其表示空字符序列。</li><li>public String(char[] value) ：通过当前参数中的字符数组来构造新的String。</li><li>public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 无参构造</span><br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>（）；<br><span class="hljs-comment">// 通过字符数组构造</span><br><span class="hljs-built_in">char</span> chars[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(chars);<br><span class="hljs-comment">// 通过字节数组构造</span><br><span class="hljs-built_in">byte</span> bytes[] = &#123; <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span> &#125;;<br><span class="hljs-keyword">String</span> str3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(bytes);<br></code></pre></td></tr></table></figure><h2 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h2><ul><li>public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。</li><li>public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 创建字符串对象</span><br>String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;hello&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;HELLO&quot;</span>;<br><span class="hljs-comment">// boolean equals(Object obj):比较字符串的内容是否相同</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals(s3)); <span class="hljs-comment">// false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-params">s2</span>)</span>); <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1.equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-params">s3</span>)</span>); <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="String功能的方法"><a href="#String功能的方法" class="headerlink" title="String功能的方法"></a>String功能的方法</h2><ul><li><p>public int length () ：返回此字符串的长度。</p></li><li><p>public String concat (String str) ：将指定的字符串连接到该字符串的末尾。</p></li><li><p>public char charAt (int index) ：返回指定索引处的 char值。</p></li><li><p>public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。</p></li><li><p>public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</p></li><li><p>public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</p></li></ul>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//创建字符串对象<br>String s = &quot;helloworld&quot;;<br>// <span class="hljs-type">int</span> length():获取字符串的长度，其实也就是字符个数<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.length());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// String concat (String str):将将指定的字符串连接到该字符串的末尾.<br>String s = &quot;helloworld&quot;;<br>String s2 = s.concat(&quot;**hello clyde&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s2);// helloworld**hello clyde<br><br>// <span class="hljs-type">char</span> charAt(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>):获取指定索引处的字符<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.charAt(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.charAt(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// <span class="hljs-type">int</span> indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐<span class="hljs-number">1</span><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.indexOf(&quot;l&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.indexOf(&quot;owo&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.indexOf(&quot;ld&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// String substring(<span class="hljs-type">int</span> <span class="hljs-keyword">start</span>):从<span class="hljs-keyword">start</span>开始截取字符串到字符串结尾<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">5</span>));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;‐‐‐‐‐‐‐‐&quot;);<br><br>// String substring(<span class="hljs-type">int</span> <span class="hljs-keyword">start</span>,<span class="hljs-type">int</span> <span class="hljs-keyword">end</span>):从<span class="hljs-keyword">start</span>到<span class="hljs-keyword">end</span>截取字符串。含<span class="hljs-keyword">start</span>，不含<span class="hljs-keyword">end</span>。<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">0</span>, s.length()));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s.substring(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>));<br></code></pre></td></tr></table></figure><h2 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h2><ul><li>public char[] toCharArray () ：将此字符串转换为新的字符数组。</li><li>public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li><li>public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//创建字符串对象</span><br>String s = <span class="hljs-string">&quot;abcde&quot;</span>;<br><span class="hljs-comment">// char[] toCharArray():把字符串转换为字符数组</span><br><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> chs = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; chs.length; x++) &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(chs<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>);<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// byte[] getBytes ():把字符串转换为字节数组</span><br>byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = s.get<span class="hljs-constructor">Bytes()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-built_in">bytes</span>.length; x++) &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-built_in">bytes</span><span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>);<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// 替换字母hel为大写HEL</span><br>String str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>String replace = str.replace(<span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;HEL&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(replace); <span class="hljs-comment">// HELlo world</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="分割功能的方法"><a href="#分割功能的方法" class="headerlink" title="分割功能的方法"></a>分割功能的方法</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas">//创建字符串对象<br>String s = <span class="hljs-string">&quot;aa|bb|cc&quot;</span>;<br>String[] strArray = s.split(<span class="hljs-string">&quot;|&quot;</span>); // [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;cc&quot;</span>]<br>for(int <span class="hljs-meta">x</span> = 0; <span class="hljs-meta">x</span> &lt; strArray.<span class="hljs-meta">length</span>; <span class="hljs-meta">x</span>++) &#123;<br>System.<span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span>strArray[<span class="hljs-meta">x</span>]); // aa bb cc<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>定义一个方法，把数组{1,2,3}按照指定个格式拼接成一个字符串。格式参照如下：[word1#word2#word3]</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个int类型的数组</span><br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-comment">//调用方法</span><br>    <span class="hljs-keyword">String</span> s = <span class="hljs-built_in">arrayToString</span>(arr);<br>    <span class="hljs-comment">//输出结果</span><br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;s:&quot;</span> + s);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 写方法实现把数组中的元素按照指定的格式拼接成一个字符串</span><br><span class="hljs-comment">* 两个明确：</span><br><span class="hljs-comment">* 返回值类型：String</span><br><span class="hljs-comment">* 参数列表：int[] arr</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">arrayToString</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建字符串s</span><br>    <span class="hljs-keyword">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;[&quot;</span>);<br>    <span class="hljs-comment">// 遍历数组，并拼接字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; arr.length; x++) &#123;<br>        <span class="hljs-keyword">if</span> (x == arr.length ‐ <span class="hljs-number">1</span>) &#123;<br>             s = s.<span class="hljs-built_in">concat</span>(arr[x] + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>             s = s.<span class="hljs-built_in">concat</span>(arr[x] + <span class="hljs-string">&quot;#&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="统计字符个数"><a href="#统计字符个数" class="headerlink" title="统计字符个数"></a>统计字符个数</h2><p>键盘录入一个字符，统计字符串中大小写字母及数字字符个数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//键盘录入一个字符串数据</span><br>Scanner sc = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;请输入一个字符串数据：&quot;</span>);<br>String s = sc.next<span class="hljs-constructor">Line()</span>;<br><span class="hljs-comment">//定义三个统计变量，初始化值都是0</span><br><span class="hljs-built_in">int</span> bigCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> smallCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> numberCount = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//遍历字符串，得到每一个字符</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>; x&lt;s.length<span class="hljs-literal">()</span>; x++) &#123;<br>    <span class="hljs-built_in">char</span> ch = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">x</span>)</span>;<br>    <span class="hljs-comment">//拿字符进行判断</span><br>    <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-character">&#x27;A&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-character">&#x27;Z&#x27;</span>) &#123;<br>        bigCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-character">&#x27;a&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-character">&#x27;z&#x27;</span>) &#123;<br>        smallCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-character">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-character">&#x27;9&#x27;</span>) &#123;<br>        numberCount++;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;该字符&quot;</span>+ch+<span class="hljs-string">&quot;非法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;大写字符：&quot;</span>+bigCount+<span class="hljs-string">&quot;个&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;小写字符：&quot;</span>+smallCount+<span class="hljs-string">&quot;个&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;数字字符：&quot;</span>+numberCount+<span class="hljs-string">&quot;个&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了</p><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。<br>类变量：使用 static关键字修饰的成员变量。<br>格式:</p><figure class="highlight plaintext"><figcaption><span>int numberID；</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs static">static 数据类型 变量名；<br>static int numberID；<br></code></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要<br>创建类的对象。调用方式非常简单。<br>类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">修饰符 static 返回值类型 方法名 (参数列表)&#123;<br><span class="hljs-comment">// 执行语句</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">=================================</span><br>public static void showNum() &#123;<br><span class="hljs-code">System.out.println(&quot;num:&quot; + numberOfStudent);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h3><p>被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 访问类变量</span><br>类名.类变量名；<br><span class="hljs-comment">// 调用静态方法</span><br>类名.静态方法名(参数)；<br>===================================<br><span class="hljs-comment">// 访问类变量</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Student</span>.</span></span>numberOfStudent);<br><span class="hljs-comment">// 调用静态方法</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Student</span>.</span></span>show<span class="hljs-constructor">Num()</span>;<br></code></pre></td></tr></table></figure><h2 id="静态原理图解"><a href="#静态原理图解" class="headerlink" title="静态原理图解"></a>静态原理图解</h2><p>static 修饰的内容：</p><ul><li>是随着类的加载而加载的，且只加载一次。</li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</li><li>它优先于对象存在，所以，可以被所有对象共享。</li></ul><p><img src="/img/cphoto/static01.jpg" alt="对象内存图"></p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>静态代码块：定义在成员位置，使用static修饰的代码块{ }。</p><ul><li>位置：类中方法外。</li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">static &#123;<br><span class="hljs-comment">// 执行语句</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">========================================</span><br>static &#123;<br><span class="hljs-comment">// 给类变量赋值</span><br>number = 2;<br>list = new ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 添加元素到集合中</span><br>list.add(&quot;张三&quot;);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。</p></blockquote><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法</p><h3 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h3><ul><li>public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 定义int 数组</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">4</span>,<span class="hljs-number">657</span>,<span class="hljs-number">8</span>,<span class="hljs-number">69</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// 打印数组,输出地址值</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arr); <span class="hljs-comment">// [I@2ac1fdc4</span><br><span class="hljs-comment">// 数组内容转为字符串</span><br>String s = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>;<br><span class="hljs-comment">// 打印字符串,输出内容</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s); <span class="hljs-comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span><br><br></code></pre></td></tr></table></figure><ul><li>public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 定义int 数组</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">24</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">48</span>, <span class="hljs-number">4</span>, <span class="hljs-number">46</span>, <span class="hljs-number">35</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;排序前:&quot;</span>+ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>); <span class="hljs-comment">// 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6,2]</span><br><span class="hljs-comment">// 升序排序</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(arr);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;排序后:&quot;</span>+ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>);<span class="hljs-comment">// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]</span><br></code></pre></td></tr></table></figure><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p><h3 id="基本运算的方法"><a href="#基本运算的方法" class="headerlink" title="基本运算的方法"></a>基本运算的方法</h3><p>public static double abs(double a) ：返回 double 值的绝对值</p><p>public static double ceil(double a) ：返回大于等于参数的最小的整数。</p><p>public static double floor(double a) ：返回小于等于参数最大的整数。</p><p>public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">double</span> d<span class="hljs-number">1</span> = Math.abs(‐<span class="hljs-number">5</span>); //d<span class="hljs-number">1</span>的值为<span class="hljs-number">5</span><br><span class="hljs-attribute">double</span> d<span class="hljs-number">3</span> = Math.ceil(<span class="hljs-number">5</span>.<span class="hljs-number">1</span>); //d<span class="hljs-number">3</span>的值为 <span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">double</span> d<span class="hljs-number">1</span> = Math.floor(<span class="hljs-number">3</span>.<span class="hljs-number">3</span>); //d<span class="hljs-number">1</span>的值为<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">long</span> d<span class="hljs-number">1</span> = Math.round(<span class="hljs-number">5</span>.<span class="hljs-number">5</span>); //d<span class="hljs-number">1</span>的值为<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</p><ul><li>提高代码的复用性。</li><li>类与类之间产生了关系，是多态的前提</li></ul><h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><p>通过 extends 关键字，可以声明一个子类继承另外一个父类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">父类</span> </span>&#123;<br>...<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="父子类成员变量重名–-super关键字"><a href="#父子类成员变量重名–-super关键字" class="headerlink" title="父子类成员变量重名–(super关键字)"></a>父子类成员变量重名–(super关键字)</h2><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-comment">// Zi中的成员变量</span><br>    int num = <span class="hljs-number">6</span>;<br>    public void show() &#123;<br>        <span class="hljs-comment">//访问父类中的num</span><br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + <span class="hljs-keyword">super</span>.num);<br>        <span class="hljs-comment">//访问子类中的num</span><br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + <span class="hljs-keyword">this</span>.num);<br>    &#125;<br>&#125;<br>演示结果：<br><span class="hljs-type">Fu</span> num = <span class="hljs-number">5</span><br><span class="hljs-type">Zi</span> num = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><blockquote><p>Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。</p></blockquote><h2 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h2><p>方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fu show&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-comment">//子类重写了父类的show方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Zi show&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo05</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Zi z = <span class="hljs-keyword">new</span> Zi();<br>        <span class="hljs-comment">// 子类中有show方法，只执行重写后的show方法</span><br>        z.show(); <span class="hljs-comment">// Zi show</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。</p><p>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</p><p>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</p></blockquote><h2 id="继承后的特点——构造方法"><a href="#继承后的特点——构造方法" class="headerlink" title="继承后的特点——构造方法"></a>继承后的特点——构造方法</h2><p>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</p><ul><li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> int n;<br>    <span class="hljs-type">Fu</span>()&#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Fu()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>    <span class="hljs-type">Zi</span>()&#123;<br>    <span class="hljs-comment">// super（），调用父类构造方法</span><br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Zi（）&quot;</span>);<br>    &#125;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo07</span></span>&#123;<br>    public static void main (<span class="hljs-type">String</span> args[])&#123;<br>    <span class="hljs-type">Zi</span> zi = <span class="hljs-keyword">new</span> <span class="hljs-type">Zi</span>();<br>&#125;<br>&#125;<br>输出结果：<br><span class="hljs-type">Fu</span>（）<br><span class="hljs-type">Zi</span>（）<br></code></pre></td></tr></table></figure><h2 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h2><h3 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h3><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法</p><p><img src="/img/cphoto/super01.jpg"></p><p>super和this的含义</p><ul><li>super ：代表父类的存储空间标识(可以理解为父亲的引用)。</li><li>this ：代表当前对象的引用(谁调用就代表谁)。</li></ul><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>​     Java只支持单继承，不支持多继承。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//一个类只能有一个父类，不可以有多个父类。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125; <span class="hljs-comment">//ok</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A，B</span>... <span class="hljs-comment">//error</span></span><br></code></pre></td></tr></table></figure><p>Java支持多层继承(继承体系)。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>顶层父类是Object类。所有的类默认继承Object，作为父类</p></blockquote><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">修饰符 abstract 返回值类型 方法名 (参数列表)；</span><br><span class="hljs-section">========================================</span><br>public abstract void run()；<br></code></pre></td></tr></table></figure><p>抽象类<br>如果一个类包含抽象方法，那么该类必须是抽象类。</p><ul><li>抽象方法 ： 没有方法体的方法。</li><li>抽象类：包含抽象方法的类</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">abstract class 类名字 &#123;<br><span class="hljs-section">&#125;</span><br><span class="hljs-section">=========================================</span><br>public abstract class Animal &#123;<br><span class="hljs-code">public abstract void run()；</span><br>&#125;<br></code></pre></td></tr></table></figure><p>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ul><li><p>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<br>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<br>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></li><li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。<br>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。<br>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><blockquote><p>引用数据类型：数组，类，接口。<br>接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">public interface 接口名称 &#123;<br><span class="hljs-regexp">//</span> 抽象方法<br><span class="hljs-regexp">//</span> 默认方法<br><span class="hljs-regexp">//</span> 静态方法<br><span class="hljs-regexp">//</span> 私有方法<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口含有抽象方法"><a href="#接口含有抽象方法" class="headerlink" title="接口含有抽象方法"></a>接口含有抽象方法</h2><p>抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口含有默认方法和静态方法"><a href="#接口含有默认方法和静态方法" class="headerlink" title="接口含有默认方法和静态方法"></a>接口含有默认方法和静态方法</h2><p>默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。<br>静态方法：使用 static 修饰，供接口直接调用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> InterFaceName &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method2</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口含有私有方法和私有静态方法"><a href="#接口含有私有方法和私有静态方法" class="headerlink" title="接口含有私有方法和私有静态方法"></a>接口含有私有方法和私有静态方法</h2><p>私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口基本的实现"><a href="#接口基本的实现" class="headerlink" title="接口基本的实现"></a>接口基本的实现</h2><p>类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类<br>似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。<br>非抽象子类实现接口：</p><ol><li>必须重写接口中所有抽象方法。</li><li>继承了接口的默认方法，即可以直接调用，也可以重写。</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口名 </span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【可选】</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>    <span class="hljs-comment">// 定义抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃东西&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;晚上睡&quot;</span>);<br>    &#125;<br>&#125;<br>=====================================<br><span class="hljs-comment">// 创建子类对象</span><br>Animal a = <span class="hljs-keyword">new</span> Animal();<br><span class="hljs-comment">// 调用实现后的方法</span><br>a.eat();<br>a.sleep();<br></code></pre></td></tr></table></figure><h2 id="接口默认方法的使用"><a href="#接口默认方法的使用" class="headerlink" title="接口默认方法的使用"></a>接口默认方法的使用</h2><p>可以继承，可以重写，二选一，但是只能通过实现类的对象来调用</p><p>定义接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span>&#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">LiveAble</span></span> </span>&#123;<br><span class="hljs-comment">// 继承，什么都不用写，直接调用</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">LiveAble</span></span> </span>&#123;<br><span class="hljs-comment">//重写</span><br>    @Override<br>    <span class="hljs-keyword">public</span> void fly() &#123;<br>    System.out.println(<span class="hljs-string">&quot;自由自在的飞&quot;</span>);<br>    &#125;<br>&#125;<br>=========================================<br><span class="hljs-comment">// 创建子类对象</span><br>Animal a = <span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>();<br><span class="hljs-comment">// 调用默认方法</span><br>a.fly();<br></code></pre></td></tr></table></figure><h2 id="静态方法的使用"><a href="#静态方法的使用" class="headerlink" title="静态方法的使用"></a>静态方法的使用</h2><p>静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用</p><p>定义接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">public class Animal implements LiveAble &#123;<br><span class="hljs-comment">// 无法重写静态方法</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">=========================================</span><br><span class="hljs-comment">// Animal.run(); // 【错误】无法继承方法,也无法调用</span><br>LiveAble.run(); <br><br></code></pre></td></tr></table></figure><h2 id="私有方法的使用"><a href="#私有方法的使用" class="headerlink" title="私有方法的使用"></a>私有方法的使用</h2><p>私有方法：只有默认方法可以调用。<br>私有静态方法：默认方法和静态方法可以调用</p><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。同学们在已学技术的基础上，可以自行测试。</p><h2 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h2><p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 [<span class="hljs-keyword"><span class="hljs-keyword">extends</span> </span>父类名] <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口名1,接口名2,接口名3...</span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【不重名时可选】</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象方法-1"><a href="#抽象方法-1" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showB</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br>=========================================<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showA</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;showA&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showB</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;showB&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;show&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">methodA</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">methodB</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">A,<span class="hljs-symbol">B</span></span>&#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> method() &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><p>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法</p><h2 id="优先级的问题"><a href="#优先级的问题" class="headerlink" title="优先级的问题"></a>优先级的问题</h2><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p><p>定义接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AAAAAAAAAAAA&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义父类</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;DDDDDDDDDDDD&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义子类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span> <span class="hljs-title">implements</span> <span class="hljs-title">A</span> </span>&#123;<br><span class="hljs-comment">// 未重写methodA方法</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        c.methodA();<br>    &#125;<br>&#125;<br>输出结果:<br>DDDDDDDDDDDD?<br></code></pre></td></tr></table></figure><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;AAAAAAAAAAAAAAAAAAA&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;BBBBBBBBBBBBBBBBBBB&quot;</span>);<br>    &#125;<br>&#125;<br>=====================<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;DDDDDDDDDDDDDD&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>子接口-&gt;重写默认方法时，default关键字可以保留。<br>子类    -&gt; 重写默认方法时，default关键字不可以保留。</p></blockquote><h2 id="接口其它"><a href="#接口其它" class="headerlink" title="接口其它"></a>接口其它</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。</li><li>接口中，没有构造方法，不能创建对象。</li><li>接口中，没有静态代码块。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是继封装、继承之后，面向对象的第三大特性</p><p>指同一行为，具有多个不同表现形式</p><h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">父类类型 变量名 = new 子类对象；<br><span class="hljs-section">变量名.方法名();</span><br><span class="hljs-section">======================================</span><br>Fu f = new Zi();<br>f.method();<br></code></pre></td></tr></table></figure><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p><p>定义父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义子类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    public void eat() &#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    public void eat() &#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);<br>    &#125;<br>&#125;<br>=======================================<br><span class="hljs-comment">// 多态形式，创建对象</span><br><span class="hljs-type">Animal</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<br><span class="hljs-comment">// 调用的是 Cat 的 eat</span><br>a1.eat();<br><span class="hljs-comment">// 多态形式，创建对象</span><br><span class="hljs-type">Animal</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>();<br><span class="hljs-comment">// 调用的是 Dog 的 eat</span><br>a2.eat();<br></code></pre></td></tr></table></figure><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 多态形式，创建对象</span><br>Cat c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>();<br>Dog d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br><span class="hljs-comment">// 调用showCatEat</span><br><span class="hljs-built_in">showCatEat</span>(c);<br><span class="hljs-built_in">showDogEat</span>(d);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代</span><br><span class="hljs-comment">而执行效果一致</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">showAnimalEat</span>(c);<br><span class="hljs-built_in">showAnimalEat</span>(d);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showCatEat</span> <span class="hljs-params">(Cat c)</span></span>&#123;<br>c.<span class="hljs-built_in">eat</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDogEat</span> <span class="hljs-params">(Dog d)</span></span>&#123;<br>d.<span class="hljs-built_in">eat</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showAnimalEat</span> <span class="hljs-params">(Animal a)</span></span>&#123;<br>a.<span class="hljs-built_in">eat</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</li><li>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</li><li>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</li></ul><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的</p><p>当父类引用指向一个子类对象时，便是向上转型。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">父类类型 变量名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>子类类型();<br>如：Animal a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<br></code></pre></td></tr></table></figure><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>主要是向上转型会导致创建对象无法使用子类特有方法,需要向下转型进行调用</p><p>向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的</p><p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">子类类型 变量名 = <span class="hljs-comment">(子类类型)</span> 父类变量名;<br>如:Cat c =<span class="hljs-comment">(Cat)</span> a;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">catchMouse</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);<br>    &#125;<br>&#125;<br>=======================================<br><span class="hljs-comment">// 向上转型</span><br>Animal a = <span class="hljs-keyword">new</span> Cat();<br>a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><span class="hljs-comment">// 向下转型</span><br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<span class="hljs-comment">//防止向下转型失败,进行对象判断</span><br>    Cat c = (Cat)a;<br>    c.catchMouse(); <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final： 不可改变。可以用于修饰类、方法和变量。<br>类：被修饰的类，不能被继承。<br>方法：被修饰的方法，不能被重写。<br>变量：被修饰的变量，不能被重新赋值。</p><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>重写被 final 修饰的方法，编译时就会报错</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br><span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><p>局部变量——基本类型</p><p>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 声明变量，使用final修饰<br>final int a;<br><span class="hljs-regexp">//</span> 第一次赋值<br>a = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 第二次赋值<br>a = <span class="hljs-number">20</span>; <span class="hljs-regexp">//</span> 报错,不可重新赋值<br></code></pre></td></tr></table></figure><p>下面代码能通过编译,因为每次循环都会新建一个新的final局部变量</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> c = i;<br>    System.<span class="hljs-keyword">out</span>.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>被final修饰的常量名称，一般都有书写规范，所有字母都大写</p><p>成员变量涉及到初始化的问题，初始化方式有两种</p><p>显示初始化</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> USERNAME = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br></code></pre></td></tr></table></figure><p>构造方法初始化</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> USERNAME ;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">String</span> username, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.USERNAME = username;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，<br>public：公共的。<br>protected：受保护的<br>default：默认的<br>private：私有的</p><table><thead><tr><th align="left"></th><th align="center">public</th><th align="center">protected</th><th align="center">default（空的）</th><th>private</th></tr></thead><tbody><tr><td align="left">同一类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td>√</td></tr><tr><td align="left">同一包中(子类与无关类)</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td></td></tr><tr><td align="left">不同包的子类</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td></td></tr><tr><td align="left">不同包中的无关类</td><td align="center">√</td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><p>public具有最大权限。private则是最小权限。</p><p>不加权限修饰符，其访问能力与default修饰符相同</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用 private ，隐藏细节。</li><li>构造方法使用 public ，方便创建对象。</li><li>成员方法使用 public ，方便调用方法</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 外部类 </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内部类可以直接访问外部类的成员，包括私有成员。</li><li>外部类要访问内部类的成员，必须要建立内部类的对象。</li><li>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">外部类名.内部类名 对象名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>外部类型().<span class="hljs-keyword">new</span> <span class="hljs-type"></span>内部类型()；<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> live = <span class="hljs-literal">true</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heart</span> &#123;</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jump</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 直接访问外部类成员</span><br>            <span class="hljs-keyword">if</span> (live) &#123;<br>                  System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;心脏在跳动&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                  System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;心脏不跳了&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLive</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> live;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLive</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> live)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.live = live;<br>    &#125;<br>&#125;<br>==========================================<br><span class="hljs-comment">// 创建外部类对象</span><br>Person p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br><span class="hljs-comment">// 创建内部类对象</span><br>Heart heart = p.<span class="hljs-keyword">new</span> <span class="hljs-built_in">Heart</span>();<br><span class="hljs-comment">// 调用内部类方法</span><br>heart.<span class="hljs-built_in">jump</span>();<br><span class="hljs-comment">// 调用外部类方法</span><br>p.<span class="hljs-built_in">setLive</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 调用内部类方法</span><br>heart.<span class="hljs-built_in">jump</span>();<br></code></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，使用一个接口时得做如下几步:</p><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><p>匿名内部类是为了调用快速方法，把以上四步简化成一步</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyAble</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">void</span> fly();<br>&#125;<br>=========================================<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.等号右边:定义并创建该接口的子类对象</span><br><span class="hljs-comment">    2.等号左边:是多态,接口类型引用指向子类对象</span><br><span class="hljs-comment">    */</span><br>    FlyAble f = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FlyAble</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>        &#125;<br>    &#125;;<br>        <span class="hljs-comment">// 将f传递给showFly方法中</span><br>        showFly(f);<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">showFly</span>(<span class="hljs-params">FlyAble f</span>)</span> &#123;<br>    f.fly();<br>    &#125;<br>=========================================<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建匿名内部类,直接传递给showFly(FlyAble f)</span><br><span class="hljs-comment">    */</span><br>    showFly( <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FlyAble</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>    &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">showFly</span>(<span class="hljs-params">FlyAble f</span>)</span> &#123;<br>f.fly();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="interface作为成员变量"><a href="#interface作为成员变量" class="headerlink" title="interface作为成员变量"></a>interface作为成员变量</h2><p>接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role 中，可以增加接口作为成员变量，来设置不同的技能。</p><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 法术攻击</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FaShuSkill</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">faShuAttack</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义角色类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;<br>    FaShuSkill fs;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setFaShuSkill</span>(<span class="hljs-params">FaShuSkill fs</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.fs = fs;<br>    &#125;<br>    <span class="hljs-comment">// 法术攻击</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">faShuSkillAttack</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;发动法术攻击:&quot;</span>);<br>        fs.faShuAttack();<br>        System.out.println(<span class="hljs-string">&quot;攻击完毕&quot;</span>);<br>    &#125;<br>&#125;<br>======================================<br><span class="hljs-comment">// 创建游戏角色</span><br>Role role = <span class="hljs-keyword">new</span> Role();<br><span class="hljs-comment">// 设置角色法术技能</span><br>role.setFaShuSkill(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FaShuSkill</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">faShuAttack</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;纵横天下&quot;</span>);<br>&#125;<br>&#125;);<br><span class="hljs-comment">// 发动法术攻击</span><br>role.faShuSkillAttack();<br><span class="hljs-comment">// 更换技能</span><br>role.setFaShuSkill(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FaShuSkill</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">faShuAttack</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;逆转乾坤&quot;</span>);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 发动法术攻击</span><br>role.faShuSkillAttack();<br>&#125;<br>&#125;<br>输出结果:<br>发动法术攻击:纵横天下<br>攻击完毕<br>发动法术攻击:逆转乾坤<br>攻击完毕<br></code></pre></td></tr></table></figure><p>我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基礎01-基本入门</title>
    <link href="/2017/09/01/java%E5%9F%BA%E7%A1%8001/"/>
    <url>/2017/09/01/java%E5%9F%BA%E7%A1%8001/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>生活采用十进制数，而计算机中全部采用二进制数表示，它只包含 0、1两个数，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特） </p><h3 id="十进制数据转成二进制数据"><a href="#十进制数据转成二进制数据" class="headerlink" title="十进制数据转成二进制数据:"></a>十进制数据转成二进制数据:</h3><p>使用除以2获取余数的方式  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">6/<span class="hljs-attribute">2</span>=3---&gt;0<br>3/<span class="hljs-attribute">2</span>=1---&gt;1<br>1/<span class="hljs-attribute">2</span>=0---&gt;1<br>由此获得110<br></code></pre></td></tr></table></figure><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">二进制1001011转换十进制数<br>1 <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span> 1<br>64<span class="hljs-number"> 32 </span>16<span class="hljs-number"> 8 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 2 </span> 1<br>将有1的所有十进制数加起来<br>64+8+2+1=75<br></code></pre></td></tr></table></figure><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性， 我们可以查看文件的字节大小。 8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。</p><p> 8 bit = 1 B </p><p>1024 B =1 KB </p><p>1024 KB =1 MB </p><p>1024 MB =1 GB </p><p>1024 GB = 1 TB</p><h2 id="cmd命令"><a href="#cmd命令" class="headerlink" title="cmd命令"></a>cmd命令</h2><table><thead><tr><th>盘符切换命令</th><th>盘符名:  //例如d:</th></tr></thead><tbody><tr><td>查看当前文件夹</td><td>dir</td></tr><tr><td>进入文件夹命令</td><td>cd 文件夹名</td></tr><tr><td>退出文件夹命令</td><td>cd..</td></tr><tr><td>退出到磁盘根目录</td><td>cd\</td></tr><tr><td>清屏</td><td>cls</td></tr><tr><td>查看IP地址</td><td>ipconfig</td></tr><tr><td>ping网络</td><td>ping IP地址</td></tr><tr><td>telnet测试连通性</td><td>telnet  IP地址</td></tr></tbody></table><p>其它</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>记事本</td><td>notepad</td></tr><tr><td>计算器</td><td>calc</td></tr><tr><td>打开typora</td><td>安装typora后,typora</td></tr><tr><td>打开vscode</td><td>code</td></tr><tr><td>打开服务</td><td>services.msc</td></tr><tr><td>打开控制面板</td><td>control</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="jdk环境变量配置"><a href="#jdk环境变量配置" class="headerlink" title="jdk环境变量配置"></a>jdk环境变量配置</h2><p>安装jdk,jdk安装路径建议不要默认,修改在c盘默认路径java文件夹,默认路径带空格,会导致一些框架引用jdk配置出现问题</p><p>打开环境变量</p><blockquote><p>计算机(右键-属性)-&gt;高级系统设置-&gt;环境变量</p></blockquote><p>新建配置</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">JAV<span class="hljs-built_in">A_HOME</span><br>jdk安装路径<br></code></pre></td></tr></table></figure><p>在path路径添加配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">JAVA_HOME</span></span>%\bin; <br></code></pre></td></tr></table></figure><p>cmd命令行输入测试是否成功</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br>javac<br></code></pre></td></tr></table></figure><h2 id="java运行流程"><a href="#java运行流程" class="headerlink" title="java运行流程"></a>java运行流程</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">javac hello.java <span class="hljs-regexp">//</span>编译器将Java文件编译字节码文件,生成hello.class<br><br>Java hello <span class="hljs-regexp">//</span>运行生成的hello.class<br><br></code></pre></td></tr></table></figure><h2 id="单行注释和多行注释"><a href="#单行注释和多行注释" class="headerlink" title="单行注释和多行注释"></a>单行注释和多行注释</h2><p>单行注释以 //开头 换行结束 多行注释以 /<em>开头 以</em>/结束</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>命名规则： 硬性要求 </p><ul><li>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 </li><li>标识符不能以数字开头。 </li><li>标识符不能是关键字。 </li></ul><p>命名规范： 软性建议 </p><ul><li><p>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</p></li><li><p>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</p></li><li><p>变量名规范：全部小写。</p></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>字节型  byte 1个字节 -128<del>127<br>短整型  short 2个字节 -32768</del>32767<br>整型  int（默认） 4个字节 -231次方<del>2的31次方-1<br>长整型  long 8个字节 -2的63次方</del>2的63次方-1<br>单精度浮点数  float 4个字节 1.4013E-45<del>3.4028E+38<br>双精度浮点数  double（默认） 8个字节 4.9E-324</del>1.7977E+308<br>字符型  char 2个字节 0-65535<br>布尔类型  boolean 1个字节 true，false</p><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型 。</p><p>byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。<br>当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-built_in">byte</span> b = <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>// <span class="hljs-built_in">byte</span> x = b + i<span class="hljs-comment">; // 报错</span><br>//<span class="hljs-keyword">int</span>类型和<span class="hljs-built_in">byte</span>类型运算，结果是<span class="hljs-keyword">int</span>类型<br><span class="hljs-keyword">int</span> j = b + i<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。可以理解为 double 是8升的水壶， int 是4升的水壶，不能把大水壶中的水直接放进小水壶去。想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。<br>强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。<br>比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。</p><p>数据类型 变量名 = （数据类型）被转数据值；</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// <span class="hljs-keyword">double</span>类型数据强制转成<span class="hljs-built_in">int</span>类型，直接去掉小数点。<br><span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)<span class="hljs-number">1.5</span>;<br><br></code></pre></td></tr></table></figure><p>浮点转成整数，直接取消小数点，可能造成数据损失精度。<br>int 强制转成 short 砍掉2个字节，可能造成数据丢失。</p><h2 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h2><p>在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。<br>编码表 ：就是将人类的文字和一个十进制数进行对应起来组成一张表格。</p><h3 id="ASCII可显示字符"><a href="#ASCII可显示字符" class="headerlink" title="ASCII可显示字符"></a>ASCII可显示字符</h3><p>字符 数值<br>0 48<br>9 57<br>A 65<br>Z 90<br>a 97<br>z 122</p><h2 id="算数运算符包括："><a href="#算数运算符包括：" class="headerlink" title="算数运算符包括："></a>算数运算符包括：</h2><ul><li>加法运算，字符串连接运算</li></ul><ul><li>减法运算</li></ul><ul><li>乘法运算<br>/ 除法运算<br>% 取模运算，两个数字相除取余数</li></ul><p>++ 、 – 自增自减运算</p><h2 id="赋值运算符包括："><a href="#赋值运算符包括：" class="headerlink" title="赋值运算符包括："></a>赋值运算符包括：</h2><p>= 等于号<br>+= 加等于<br>-= 减等于<br>*= 乘等于<br>/= 除等于<br>%= 取模等</p><h2 id="比较运算符包括："><a href="#比较运算符包括：" class="headerlink" title="比较运算符包括："></a>比较运算符包括：</h2><p>== 比较符号两边数据是否相等，相等结果是true。<br>&lt; 比较符号左边的数据是否小于右边的数据，如果小于结果是true。</p><blockquote><p>比较符号左边的数据是否大于右边的数据，如果大于结果是true。<br>&lt;= 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。<br>= 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。<br>！= 不等于符号 ，如果符号两边的数据不相等，结果是true。</p></blockquote><h2 id="逻辑运算符包括："><a href="#逻辑运算符包括：" class="headerlink" title="逻辑运算符包括："></a>逻辑运算符包括：</h2><p>&amp;&amp; 短路与</p><ol><li>两边都是true，结果是true</li><li>一边是false，结果是false<br>短路特点：符号左边是false，右边不再运算<br>|| 短路或</li><li>两边都是false，结果是false</li><li>一边是true，结果是true<br>短路特点： 符号左边是true，右边不再运算<br>！ 取反</li><li>! true 结果是false</li><li>! false结果是true</li></ol><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>数据类型 变量名 = 布尔类型表达式？结果1：结果2</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">修饰符 返回值类型 方法名 （参数列表）｛<br>代码...<br><span class="hljs-keyword">return</span> ;<br>｝<br></code></pre></td></tr></table></figure><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">//调用定义的方法method</span><br><span class="hljs-comment">method();</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">//定义方法，被main方法调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">System.out.println(&quot;自己定义的方法，需要被main调用运行&quot;);</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><h2 id="方法定义注意事项："><a href="#方法定义注意事项：" class="headerlink" title="方法定义注意事项："></a>方法定义注意事项：</h2><ul><li>方法必须定义在一类中方法外</li><li>方法不能定义在另一个方法的里面</li></ul><h2 id="JShell脚本工具"><a href="#JShell脚本工具" class="headerlink" title="JShell脚本工具"></a>JShell脚本工具</h2><p>JShell是JDK9的新特性<br>当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这个时候可以使用JShell工具。<br>启动JShell工具，在DOS命令行直接输入JShell命令。<br>JShell工具，只适合片段代码的测试，开发更多内容，建议编写在方法中。</p><h2 id="if语句第一种格式：-if"><a href="#if语句第一种格式：-if" class="headerlink" title="if语句第一种格式： if"></a>if语句第一种格式： if</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(关系表达式)｛<br>语句体<span class="hljs-comment">;</span><br>｝<br></code></pre></td></tr></table></figure><h2 id="if语句第二种格式：-if…else"><a href="#if语句第二种格式：-if…else" class="headerlink" title="if语句第二种格式： if…else"></a>if语句第二种格式： if…else</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(关系表达式) &#123;<br>语句体<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;else &#123;<br>语句体<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if语句第三种格式：-if…else-if-…else"><a href="#if语句第三种格式：-if…else-if-…else" class="headerlink" title="if语句第三种格式： if…else if …else"></a>if语句第三种格式： if…else if …else</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">1</span>) &#123;<br>执行语句<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(判断条件<span class="hljs-number">2</span>)</span> </span>&#123;<br>执行语句<span class="hljs-number">2</span>;<br>&#125;<br>...<br>&#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(判断条件n)</span> </span>&#123;<br>执行语句n;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>执行语句n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch语句格式："><a href="#switch语句格式：" class="headerlink" title="switch语句格式："></a>switch语句格式：</h2><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(表达式) &#123;<br><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:<br>语句体<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:<br>语句体<span class="hljs-number">2</span>;<br><span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">default</span>:<br>语句体n+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for循环语句格式："><a href="#for循环语句格式：" class="headerlink" title="for循环语句格式："></a>for循环语句格式：</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(初始化表达式①; 布尔表达式②; 步进表达式④)</span></span>&#123;<br>循环体③<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="while循环语句格式："><a href="#while循环语句格式：" class="headerlink" title="while循环语句格式："></a>while循环语句格式：</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">初始化表达式①<br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(布尔表达式②)</span></span>&#123;<br>循环体③<br>步进表达式④<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="do…while循环格式"><a href="#do…while循环格式" class="headerlink" title="do…while循环格式"></a>do…while循环格式</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">初始化表达式①<br><span class="hljs-keyword">do</span>&#123;<br>循环体③<br>步进表达式④<br>&#125;<span class="hljs-keyword">while</span><span class="hljs-comment">(布尔表达式②)</span>;<br><br></code></pre></td></tr></table></figure><h2 id="for-和-while-的小区别："><a href="#for-和-while-的小区别：" class="headerlink" title="for 和 while 的小区别："></a>for 和 while 的小区别：</h2><ul><li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消<br>失，能够提高内存的使用效率。</li><li>在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</li></ul><h2 id="idea快捷键-功能"><a href="#idea快捷键-功能" class="headerlink" title="idea快捷键 功能"></a>idea快捷键 功能</h2><p>Alt+Enter 导入包，自动修正代码<br>Ctrl+Y 删除光标所在行<br>Ctrl+D 复制光标所在行的内容，插入光标位置下面<br>Ctrl+Alt+L 格式化代码<br>Ctrl+/ 单行注释<br>Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释<br>Alt+Ins 自动生成代码，toString，get，set等方法<br>Alt+Shift+上下箭头 移动当前代码行</p><h2 id="容器概念"><a href="#容器概念" class="headerlink" title="容器概念"></a>容器概念</h2><p>容器：是将多个数据存储到一起，每个数据称为该容器的元素。</p><h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">数组存储的数据类型[] 数组名字 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>数组存储的数据类型[长度];<br></code></pre></td></tr></table></figure><ul><li>数组定义格式详解：</li><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</li><li>[] : 表示数组。</li><li>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</li><li>new：关键字，创建数组使用的关键字。</li><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</li><li>[长度]：数组的长度，表示数组容器中可以存储多少个元素。</li><li>注意：数组有定长特性，长度一旦指定，不可更改。和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span>[] arr = new int[<span class="hljs-number">3</span>];<br><span class="hljs-attribute">int</span>[] arr = new int[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">数据类型[] 数组名 = </span><span class="hljs-template-variable">&#123;元素1,元素2,元素3...&#125;</span><span class="xml">;</span><br><span class="xml">int[] arr = </span><span class="hljs-template-variable">&#123;1,2,3,4,5&#125;</span><span class="xml">;</span><br></code></pre></td></tr></table></figure><p>数组的长度属性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//打印数组的属性，输出结果是5</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arr.length);<br></code></pre></td></tr></table></figure><p>索引访问数组中的元素：</p><ul><li>数组名[索引]=数值，为数组中的元素赋值</li><li>变量=数组名[索引]，获取出数组中的元素<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//定义存储int类型数组，赋值元素1，2，3，4，5</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//为0索引元素赋值为6</span><br>arr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">6</span>;<br><span class="hljs-comment">//获取数组0索引上的元素</span><br><span class="hljs-built_in">int</span> i = arr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i);<br><span class="hljs-comment">//直接输出数组0索引元素</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);<br></code></pre></td></tr></table></figure><h2 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h2>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。<br>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。<h2 id="JVM的内存划分："><a href="#JVM的内存划分：" class="headerlink" title="JVM的内存划分："></a>JVM的内存划分：</h2>寄存器         //给CPU使用，和我们开发无关。<br>本地方法栈 //JVM在使用操作系统功能的时候使用，和我们开发无关。<br>方法区         //存储可以运行的class文件。<br>堆内存         //存储对象或者数组，new来创建的，都存储在堆内存。<br>方法栈         //方法运行时使用的内存，比如main方法运行，进入方法栈中执行。<h3 id="一个内存"><a href="#一个内存" class="headerlink" title="一个内存"></a>一个内存</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>System.out.<span class="hljs-built_in">println</span>(arr);<span class="hljs-comment">//[I@5f150435</span><br>&#125;<br></code></pre></td></tr></table></figure>以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。<br>输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素<br><img src="/img/cphoto/array01.jpg" alt="array内存图"><h3 id="两个内存"><a href="#两个内存" class="headerlink" title="两个内存"></a>两个内存</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>System.out.<span class="hljs-built_in">println</span>(arr);<br>System.out.<span class="hljs-built_in">println</span>(arr2);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/cphoto/array02.jpg" alt="array内存图"></li></ul><h3 id="两个变量指向一个数组"><a href="#两个变量指向一个数组" class="headerlink" title="两个变量指向一个数组"></a>两个变量指向一个数组</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-comment">// 定义数组，存储3个元素</span><br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-comment">//数组索引进行赋值</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br><span class="hljs-comment">//输出3个索引上的元素值</span><br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">0</span>]);<br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">1</span>]);<br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">//定义数组变量arr2，将arr的地址赋值给arr2</span><br><span class="hljs-keyword">int</span>[] arr2 = arr;<br>arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;<br>System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/array03.jpg" alt="array内存图"></p><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><p>创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 rrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p><h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><p>arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p><p><img src="/img/cphoto/array04.jpg" alt="array内存图"></p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>System.<span class="hljs-keyword">out</span>.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">循环中定义变量min=0最小索引</span><br><span class="hljs-comment">max=arr.length‐1最大索引</span><br><span class="hljs-comment">min++,max‐‐</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">max</span> = arr.<span class="hljs-built_in">length</span> ‐ <span class="hljs-number">1</span>; <span class="hljs-built_in">min</span> &lt;= <span class="hljs-built_in">max</span>; <span class="hljs-built_in">min</span>++, <span class="hljs-built_in">max</span>‐‐) &#123;<br>    <span class="hljs-comment">//利用第三方变量完成数组中的元素交换</span><br>    <span class="hljs-type">int</span> temp = arr[<span class="hljs-built_in">min</span>];<br>    arr[<span class="hljs-built_in">min</span>] = arr[<span class="hljs-built_in">max</span>];<br>    arr[<span class="hljs-built_in">max</span>] = temp;<br>&#125;<br><span class="hljs-comment">// 反转后，遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>System.<span class="hljs-keyword">out</span>.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组作为方法参数"><a href="#数组作为方法参数" class="headerlink" title="数组作为方法参数"></a>数组作为方法参数</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span> &#125;;<br>        <span class="hljs-comment">//调用方法，传递数组</span><br>        <span class="hljs-built_in">printArray</span>(arr);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">创建方法，方法接收数组类型的参数</span><br><span class="hljs-comment">进行数组的遍历</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>System.out.<span class="hljs-built_in">println</span>(arr[i]);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/cphoto/array05.jpg" alt="array内存图"></p><h3 id="方法的参数类型区别"><a href="#方法的参数类型区别" class="headerlink" title="方法的参数类型区别"></a>方法的参数类型区别</h3><p> 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo插入图片的配置</title>
    <link href="/2017/06/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2017/06/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="在blog的目录下安装插件"><a href="#在blog的目录下安装插件" class="headerlink" title="在blog的目录下安装插件"></a>在blog的目录下安装插件</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><h2 id="在配置文件-config-yml-找到-post-asset-folder-设置true"><a href="#在配置文件-config-yml-找到-post-asset-folder-设置true" class="headerlink" title="在配置文件_config.yml,找到 post_asset_folder,设置true"></a>在配置文件_config.yml,找到 post_asset_folder,设置true</h2><h2 id="将该目录下替换为后面的代码"><a href="#将该目录下替换为后面的代码" class="headerlink" title="将该目录下替换为后面的代码"></a>将该目录下替换为后面的代码</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/node_modules/</span>hexo-asset-image/index.js<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.config;<br>  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;<br>        <span class="hljs-keyword">var</span> link = data.permalink;<br>    <span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>       <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>       <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br>    <span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.substring(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;<br>        <span class="hljs-attr">ignoreWhitespace</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">xmlMode</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">lowerCaseTags</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br>            <span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br>            <span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;<br>               !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;<br>              <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>              <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>              <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)<br>                srcArray.shift();<br>              src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);<br>              $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);<br>              <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br>            <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));<br>        &#125;<br>      &#125;);<br>      data[key] = $.html();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>第四步：现在就可以插入图片了，比如hexo new post photo之后<br> 就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br> 在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[这是代替图片的文字，随便写]</span>(head.jpeg)<br></code></pre></td></tr></table></figure><h2 id="Fluid主题下直接使用静态图片"><a href="#Fluid主题下直接使用静态图片" class="headerlink" title="Fluid主题下直接使用静态图片"></a>Fluid主题下直接使用静态图片</h2><p>将图片放置在</p><blockquote><p>blog/themes/Fluid/source/img/</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![图片](<span class="hljs-regexp">/img/</span>pp.jpg)<br></code></pre></td></tr></table></figure><p><img src="/img/pp.jpg" alt="图片"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASCII编码</title>
    <link href="/2017/06/05/ASCII%E7%BC%96%E7%A0%81%E8%A1%A8/"/>
    <url>/2017/06/05/ASCII%E7%BC%96%E7%A0%81%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>图形</th></tr></thead><tbody><tr><td>0010 0000</td><td>32</td><td>20</td><td>（空格）(␠)</td></tr><tr><td>0010 0001</td><td>33</td><td>21</td><td>!</td></tr><tr><td>0010 0010</td><td>34</td><td>22</td><td>“</td></tr><tr><td>0010 0011</td><td>35</td><td>23</td><td>#</td></tr><tr><td>0010 0100</td><td>36</td><td>24</td><td>$</td></tr><tr><td>0010 0101</td><td>37</td><td>25</td><td>%</td></tr><tr><td>0010 0110</td><td>38</td><td>26</td><td>&amp;</td></tr><tr><td>0010 0111</td><td>39</td><td>27</td><td>‘</td></tr><tr><td>0010 1000</td><td>40</td><td>28</td><td>(</td></tr><tr><td>0010 1001</td><td>41</td><td>29</td><td>)</td></tr><tr><td>0010 1010</td><td>42</td><td>2A</td><td>*</td></tr><tr><td>0010 1011</td><td>43</td><td>2B</td><td>+</td></tr><tr><td>0010 1100</td><td>44</td><td>2C</td><td>,</td></tr><tr><td>0010 1101</td><td>45</td><td>2D</td><td>-</td></tr><tr><td>0010 1110</td><td>46</td><td>2E</td><td>.</td></tr><tr><td>0010 1111</td><td>47</td><td>2F</td><td>/</td></tr><tr><td>0011 0000</td><td>48</td><td>30</td><td>0</td></tr><tr><td>0011 0001</td><td>49</td><td>31</td><td>1</td></tr><tr><td>0011 0010</td><td>50</td><td>32</td><td>2</td></tr><tr><td>0011 0011</td><td>51</td><td>33</td><td>3</td></tr><tr><td>0011 0100</td><td>52</td><td>34</td><td>4</td></tr><tr><td>0011 0101</td><td>53</td><td>35</td><td>5</td></tr><tr><td>0011 0110</td><td>54</td><td>36</td><td>6</td></tr><tr><td>0011 0111</td><td>55</td><td>37</td><td>7</td></tr><tr><td>0011 1000</td><td>56</td><td>38</td><td>8</td></tr><tr><td>0011 1001</td><td>57</td><td>39</td><td>9</td></tr><tr><td>0011 1010</td><td>58</td><td>3A</td><td>:</td></tr><tr><td>0011 1011</td><td>59</td><td>3B</td><td>;</td></tr><tr><td>0011 1100</td><td>60</td><td>3C</td><td>&lt;</td></tr><tr><td>0011 1101</td><td>61</td><td>3D</td><td>=</td></tr><tr><td>0011 1110</td><td>62</td><td>3E</td><td>&gt;</td></tr><tr><td>0011 1111</td><td>63</td><td>3F</td><td>?</td></tr></tbody></table><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>图形</th></tr></thead><tbody><tr><td>0100 0000</td><td>64</td><td>40</td><td>@</td></tr><tr><td>0100 0001</td><td>65</td><td>41</td><td>A</td></tr><tr><td>0100 0010</td><td>66</td><td>42</td><td>B</td></tr><tr><td>0100 0011</td><td>67</td><td>43</td><td>C</td></tr><tr><td>0100 0100</td><td>68</td><td>44</td><td>D</td></tr><tr><td>0100 0101</td><td>69</td><td>45</td><td>E</td></tr><tr><td>0100 0110</td><td>70</td><td>46</td><td>F</td></tr><tr><td>0100 0111</td><td>71</td><td>47</td><td>G</td></tr><tr><td>0100 1000</td><td>72</td><td>48</td><td>H</td></tr><tr><td>0100 1001</td><td>73</td><td>49</td><td>I</td></tr><tr><td>0100 1010</td><td>74</td><td>4A</td><td>J</td></tr><tr><td>0100 1011</td><td>75</td><td>4B</td><td>K</td></tr><tr><td>0100 1100</td><td>76</td><td>4C</td><td>L</td></tr><tr><td>0100 1101</td><td>77</td><td>4D</td><td>M</td></tr><tr><td>0100 1110</td><td>78</td><td>4E</td><td>N</td></tr><tr><td>0100 1111</td><td>79</td><td>4F</td><td>O</td></tr><tr><td>0101 0000</td><td>80</td><td>50</td><td>P</td></tr><tr><td>0101 0001</td><td>81</td><td>51</td><td>Q</td></tr><tr><td>0101 0010</td><td>82</td><td>52</td><td>R</td></tr><tr><td>0101 0011</td><td>83</td><td>53</td><td>S</td></tr><tr><td>0101 0100</td><td>84</td><td>54</td><td>T</td></tr><tr><td>0101 0101</td><td>85</td><td>55</td><td>U</td></tr><tr><td>0101 0110</td><td>86</td><td>56</td><td>V</td></tr><tr><td>0101 0111</td><td>87</td><td>57</td><td>W</td></tr><tr><td>0101 1000</td><td>88</td><td>58</td><td>X</td></tr><tr><td>0101 1001</td><td>89</td><td>59</td><td>Y</td></tr><tr><td>0101 1010</td><td>90</td><td>5A</td><td>Z</td></tr><tr><td>0101 1011</td><td>91</td><td>5B</td><td>[</td></tr><tr><td>0101 1100</td><td>92</td><td>5C</td><td>\</td></tr><tr><td>0101 1101</td><td>93</td><td>5D</td><td>]</td></tr><tr><td>0101 1110</td><td>94</td><td>5E</td><td>^</td></tr><tr><td>0101 1111</td><td>95</td><td>5F</td><td>_</td></tr></tbody></table><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>图形</th></tr></thead><tbody><tr><td>0110 0000</td><td>96</td><td>60</td><td>`</td></tr><tr><td>0110 0001</td><td>97</td><td>61</td><td>a</td></tr><tr><td>0110 0010</td><td>98</td><td>62</td><td>b</td></tr><tr><td>0110 0011</td><td>99</td><td>63</td><td>c</td></tr><tr><td>0110 0100</td><td>100</td><td>64</td><td>d</td></tr><tr><td>0110 0101</td><td>101</td><td>65</td><td>e</td></tr><tr><td>0110 0110</td><td>102</td><td>66</td><td>f</td></tr><tr><td>0110 0111</td><td>103</td><td>67</td><td>g</td></tr><tr><td>0110 1000</td><td>104</td><td>68</td><td>h</td></tr><tr><td>0110 1001</td><td>105</td><td>69</td><td>i</td></tr><tr><td>0110 1010</td><td>106</td><td>6A</td><td>j</td></tr><tr><td>0110 1011</td><td>107</td><td>6B</td><td>k</td></tr><tr><td>0110 1100</td><td>108</td><td>6C</td><td>l</td></tr><tr><td>0110 1101</td><td>109</td><td>6D</td><td>m</td></tr><tr><td>0110 1110</td><td>110</td><td>6E</td><td>n</td></tr><tr><td>0110 1111</td><td>111</td><td>6F</td><td>o</td></tr><tr><td>0111 0000</td><td>112</td><td>70</td><td>p</td></tr><tr><td>0111 0001</td><td>113</td><td>71</td><td>q</td></tr><tr><td>0111 0010</td><td>114</td><td>72</td><td>r</td></tr><tr><td>0111 0011</td><td>115</td><td>73</td><td>s</td></tr><tr><td>0111 0100</td><td>116</td><td>74</td><td>t</td></tr><tr><td>0111 0101</td><td>117</td><td>75</td><td>u</td></tr><tr><td>0111 0110</td><td>118</td><td>76</td><td>v</td></tr><tr><td>0111 0111</td><td>119</td><td>77</td><td>w</td></tr><tr><td>0111 1000</td><td>120</td><td>78</td><td>x</td></tr><tr><td>0111 1001</td><td>121</td><td>79</td><td>y</td></tr><tr><td>0111 1010</td><td>122</td><td>7A</td><td>z</td></tr><tr><td>0111 1011</td><td>123</td><td>7B</td><td>{</td></tr><tr><td>0111 1100</td><td>124</td><td>7C</td><td>|</td></tr><tr><td>0111 1101</td><td>125</td><td>7D</td><td>}</td></tr><tr><td>0111 1110</td><td>126</td><td>7E</td><td>~</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ASCII编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>halo博客源码配置</title>
    <link href="/2017/06/05/halo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E9%85%8D%E7%BD%AE/"/>
    <url>/2017/06/05/halo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="halo的github仓库地址"><a href="#halo的github仓库地址" class="headerlink" title="halo的github仓库地址"></a>halo的github仓库地址</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/halo-dev/</span>halo<br></code></pre></td></tr></table></figure><p>一开始我是直接下载zip部署的,但在最后会提示没有主题文件,官网文档和论坛说这样会缺文件,所以后面成功的步骤是先在github下fork了halo项目,然后clone自己仓库的这份,查看clone过程,从源地址clone下来的有2000多个文件,而通过这种方式clone下来的有3000多文件,但这样编译运行还会提示主题缺失,所以需要去这个地址将主题下载下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/halo-dev/</span>halo-theme-anatole.git<br></code></pre></td></tr></table></figure><p>将clone下文件根目录下所有文件复制到halo项目<code> ..\src\main\resources\templates\themes\anatole</code>下面</p><h2 id="其它一些坑"><a href="#其它一些坑" class="headerlink" title="其它一些坑"></a>其它一些坑</h2><ul><li><p>该项目使用的jdk版本需要11以上</p><blockquote><p>我个人尝试使用11版本的有问题,最后编译通过使用的是16版本</p></blockquote></li><li><p>使用的是gradle进行依赖管理</p><blockquote><p>使用gradle一直提示连接网络超时,后面用了梯子,配置了阿里镜像代理,出现了没有找到依赖项问题</p><p>最后解决是通过安装最新版本的idea(2021.1.2)+jdk16才解决的</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Halo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章头示意</title>
    <link href="/2017/06/02/hexo%E6%96%87%E7%AB%A0%E5%A4%B4%E7%A4%BA%E6%84%8F/"/>
    <url>/2017/06/02/hexo%E6%96%87%E7%AB%A0%E5%A4%B4%E7%A4%BA%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本文章头写法"><a href="#基本文章头写法" class="headerlink" title="基本文章头写法"></a>基本文章头写法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">title: hexo文章和mrkdown使用笔记   <span class="hljs-regexp">//</span>标题<br>date: <span class="hljs-number">2018</span>-<span class="hljs-number">06</span>-<span class="hljs-number">01</span> <span class="hljs-number">11</span>:<span class="hljs-number">53</span>:<span class="hljs-number">40</span>    <span class="hljs-regexp">//</span>时间<br>tags: hexo      <span class="hljs-regexp">//</span>标签<br>author: clyde   <span class="hljs-regexp">//</span>作者<br>index_img: <span class="hljs-regexp">/img/</span>pp.jpg   <span class="hljs-regexp">//</span>封面图片<br>banner_img: <span class="hljs-regexp">/img/</span>pp.jpg  <span class="hljs-regexp">//</span>文章头部图片<br>categories: web<span class="hljs-regexp">//</span>分类<br></code></pre></td></tr></table></figure><h2 id="排序-置顶"><a href="#排序-置顶" class="headerlink" title="排序,置顶"></a>排序,置顶</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sticky: <span class="hljs-number">4</span>   <span class="hljs-regexp">//</span>排序,将这个设置很大可以做出置顶效果<br></code></pre></td></tr></table></figure><h2 id="多标签用法"><a href="#多标签用法" class="headerlink" title="多标签用法"></a>多标签用法</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span> [tag1, tag2, tag3, ...]<br>//下面这种方式对hexo版本有限制<br><span class="hljs-keyword">tags:</span><br>- tags1<br>- tags2<br>- ...<br></code></pre></td></tr></table></figure><h1 id="这是一个好用的尺子工具-绿色-无需安装"><a href="#这是一个好用的尺子工具-绿色-无需安装" class="headerlink" title="这是一个好用的尺子工具,绿色,无需安装"></a>这是一个好用的尺子工具,绿色,无需安装</h1><p><a href="/add/capture.zip">尺子工具</a></p><h1 id="音乐链接"><a href="#音乐链接" class="headerlink" title="音乐链接"></a>音乐链接</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="825" height="86" src="//music.163.com/outchain/player?type=2&id=29808783&auto=1&height=66"></iframe>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章和mrkdown使用笔记</title>
    <link href="/2017/06/01/hexo%E6%B5%8B%E8%AF%95%E5%92%8Cmarkdown%E6%96%87%E7%AB%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2017/06/01/hexo%E6%B5%8B%E8%AF%95%E5%92%8Cmarkdown%E6%96%87%E7%AB%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h3><hr><h3 id="2-标题"><a href="#2-标题" class="headerlink" title="2#标题"></a>2#标题</h3><h3 id="3-标题"><a href="#3-标题" class="headerlink" title="3#标题"></a>3#标题</h3><blockquote><p>左竖线<br>  jkjkj<br>dfd<br>  <groupId>com.clyde</groupId><br>   <artifactId>documentproject01</artifactId><br>  <version>1.0-SNAPSHOT</version></p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/F502513A43624EA2B0CABECB87458E06?method=download&shareKey=b71b33f21f65f970e83136b29cac5ac5" alt="外链图片"></p><p>这是测试文章</p><blockquote><p>github创建仓库,在issue中拖入图片,下方文档中就有md格式图片链接<br><img src="https://user-images.githubusercontent.com/32689857/120270452-34d68600-c2dc-11eb-84f0-134ab94b9b39.png" alt="github图床图片"></p></blockquote><h3 id="分割线"><a href="#分割线" class="headerlink" title="*分割线"></a>*分割线</h3><hr><hr><hr><hr><h3 id="斜体粗体"><a href="#斜体粗体" class="headerlink" title="*斜体粗体"></a>*斜体粗体</h3><p><em>jhhh</em>  </p><p><em>zhegeshi</em></p><h3 id="后面空两行或者隔一行来换行"><a href="#后面空两行或者隔一行来换行" class="headerlink" title="*后面空两行或者隔一行来换行"></a>*后面空两行或者隔一行来换行</h3><p><strong>及健康健康</strong><br><strong>即将开机</strong></p><h3 id="删除线-下划线"><a href="#删除线-下划线" class="headerlink" title="*删除线,下划线"></a>*删除线,下划线</h3><p><del>寄几个</del></p><p><u>即将开机公开</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="*脚注"></a>*脚注</h3><p>这个是脚注[^rrr]</p><h3 id="列表"><a href="#列表" class="headerlink" title="*列表"></a>*列表</h3><p>列表1:<br>    - aaaa<br>    - bbb<br>    - cccc</p><h3 id="区块"><a href="#区块" class="headerlink" title="*区块"></a>*区块</h3><blockquote><p>aaa<br>jkjk<br>jkjk<br>kjkj<br>jkjijkj</p></blockquote><h3 id="表格"><a href="#表格" class="headerlink" title="*表格"></a>*表格</h3><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><pre><code class=" mermaid">graph TD开始 --&gt; 结束</code></pre><pre><code class=" mermaid">sequenceDiagram    Alice-&gt;&gt;John: Hello John, how are you?    John--&gt;&gt;Alice: Great!</code></pre><pre><code class=" mermaid">flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">代码分割块<br>代码分割块<br>代码分割块代码分割块<br>代码分割块代码分割块<br>代码分割块代码分割块代码分割块<br>代码分割块代码分割块代码分割块<br>代码分割块代码分割块代码分割块代码分割块<br>代码分割块代码分割块代码分割块代码分割块<br><br></code></pre></td></tr></table></figure><p><img src="/img/pp.jpg" alt="jijkl"></p><h2 id="网易云音乐配置"><a href="#网易云音乐配置" class="headerlink" title="网易云音乐配置"></a>网易云音乐配置</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="825" height="86" src="//music.163.com/outchain/player?type=2&id=29808783&auto=1&height=66"></iframe><h2 id="b站视频配置"><a href="#b站视频配置" class="headerlink" title="b站视频配置"></a>b站视频配置</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=46303362&cid=81124889&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><br>视频分割<hr><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=838863398&bvid=BV1F54y1S7WT&cid=209620845&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea快捷键</title>
    <link href="/2017/01/01/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2017/01/01/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>idea标签页切换:alt+左右键</p><p>idea多项目多窗口切换</p><p>windows下:<br>    * ctrl+alt+[<br>    * ctrl+alt+]</p><p>mac下:<br>    * cmd+`</p><ol><li><p>删除光标所在行代码</p><p>idea快捷键： Ctrl+X</p><p>eclipse快捷键： Ctrl+D</p></li><li><p>复制光标所在行代码，或者鼠标选中的代码<br> idea快捷键： Ctrl+D<br> eclipse快捷键： Ctrl+Alt+上下键</p></li><li><p>切换代码大小写<br> idea： Ctrl+Shift+U<br> eclipse： Ctrl+Shift+X（大写） Ctrl+Shift+Y（小写）</p></li><li><p>关闭当前代码窗<br> idea： Ctrl+F4<br> eclipse： Ctrl+W</p></li><li><p>快速定位到上一次编辑的位置<br> idea： Ctrl+Alt+左右键<br> eclipse：Ctrl+Q</p></li><li><p>快速搜索类和接口<br> idea：Ctrl+Shift+R<br> eclipse：Ctrl+Shift+R</p></li><li><p>切换上一次的浏览栏<br> idea：Alt+左右键<br> eclipse：Alt+左右键</p></li><li><p>生成get，set方法<br> idea快捷键： Alt+insert<br> eclipse快捷键： Shift+Alt+S</p></li><li><p>格式化代码<br> idea：先Ctrl+A选择全部代码 然后 Ctrl+Alt+L<br> eclipse：先Ctrl+A选择全部代码 然后 Ctrl+I格式化代码</p></li><li><p>下上移动正行代码<br>idea：Shift+Ctrl+上下键<br>eclipse：Ctrl+Alt+上下键</p></li><li><p>接口快速进入实现方法<br>idea：鼠标放在接口方法上，然后快捷键 Ctrl+Alt+B 进入实现方法<br>eclipse：鼠标放在接口方法上，然后快捷Ctrl+鼠标右键，显示出来实现方法，点击进入</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Idea快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
