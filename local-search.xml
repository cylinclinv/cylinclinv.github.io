<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo插入图片的配置</title>
    <link href="/2021/06/01/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/06/01/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="第一步：安装插件，在hexo根目录打开Git-Bash-执行"><a href="#第一步：安装插件，在hexo根目录打开Git-Bash-执行" class="headerlink" title="第一步：安装插件，在hexo根目录打开Git Bash,执行"></a>第一步：安装插件，在hexo根目录打开Git Bash,执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">npm install hexo-asset-image --save<br></code></pre></td></tr></table></figure><h2 id="第二步：打开hexo的配置文件-config-yml"><a href="#第二步：打开hexo的配置文件-config-yml" class="headerlink" title="第二步：打开hexo的配置文件_config.yml"></a>第二步：打开hexo的配置文件_config.yml</h2><h2 id="找到-post-asset-folder，把这个选项从false改成true"><a href="#找到-post-asset-folder，把这个选项从false改成true" class="headerlink" title="找到 post_asset_folder，把这个选项从false改成true"></a>找到 post_asset_folder，把这个选项从false改成true</h2><h2 id="第三步：打开"><a href="#第三步：打开" class="headerlink" title="第三步：打开"></a>第三步：打开</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">/node_modules/hexo-asset-image/index.js<br></code></pre></td></tr></table></figure><p>将内容更换为下面的代码<br> （在此感谢Ericam_ 大神：<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xjm850552586">https://blog.csdn.net/xjm850552586</a>）</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&#x27;use strict&#x27;</span>;<br>var cheerio = require(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><br>// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string<br><span class="hljs-keyword">function</span> getPosition(str, m, i) &#123;<br>  <span class="hljs-built_in">return</span> str.split(m, i).join(m).length;<br>&#125;<br><br>var version = String(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-keyword">function</span>(data)&#123;<br>  var config = hexo.config;<br>  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;<br>        var link = data.permalink;<br>    <span class="hljs-keyword">if</span>(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)<br>       var beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, 1) + 1;<br>    <span class="hljs-keyword">else</span><br>       var beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, 3) + 1;<br>    // In hexo 3.1.1, the permalink of <span class="hljs-string">&quot;about&quot;</span> page is like <span class="hljs-string">&quot;.../about/index.html&quot;</span>.<br>    var endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + 1;<br>    link = link.substring(beginPos, endPos);<br><br>    var toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(var i = 0; i &lt; toprocess.length; i++)&#123;<br>      var key = toprocess[i];<br> <br>      var $ = cheerio.load(data[key], &#123;<br>        ignoreWhitespace: <span class="hljs-literal">false</span>,<br>        xmlMode: <span class="hljs-literal">false</span>,<br>        lowerCaseTags: <span class="hljs-literal">false</span>,<br>        decodeEntities: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        <span class="hljs-keyword">if</span> ($(this).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br>            // For windows style path, we replace <span class="hljs-string">&#x27;\&#x27;</span> to <span class="hljs-string">&#x27;/&#x27;</span>.<br>            var src = $(this).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(!/http[s]*.*|\/\/.*/.<span class="hljs-built_in">test</span>(src) &amp;&amp;<br>               !/^\s*\//.<span class="hljs-built_in">test</span>(src)) &#123;<br>              // For <span class="hljs-string">&quot;about&quot;</span> page, the first part of <span class="hljs-string">&quot;src&quot;</span> can<span class="hljs-string">&#x27;t be removed.</span><br><span class="hljs-string">              // In addition, to support multi-level local directory.</span><br><span class="hljs-string">              var linkArray = link.split(&#x27;</span>/<span class="hljs-string">&#x27;).filter(function(elem)&#123;</span><br><span class="hljs-string">                return elem != &#x27;</span><span class="hljs-string">&#x27;;</span><br><span class="hljs-string">              &#125;);</span><br><span class="hljs-string">              var srcArray = src.split(&#x27;</span>/<span class="hljs-string">&#x27;).filter(function(elem)&#123;</span><br><span class="hljs-string">                return elem != &#x27;</span><span class="hljs-string">&#x27; &amp;&amp; elem != &#x27;</span>.<span class="hljs-string">&#x27;;</span><br><span class="hljs-string">              &#125;);</span><br><span class="hljs-string">              if(srcArray.length &gt; 1)</span><br><span class="hljs-string">                srcArray.shift();</span><br><span class="hljs-string">              src = srcArray.join(&#x27;</span>/<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">              $(this).attr(&#x27;</span>src<span class="hljs-string">&#x27;, config.root + link + src);</span><br><span class="hljs-string">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;else&#123;</span><br><span class="hljs-string">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="hljs-string">            console.info&amp;&amp;console.info($(this));</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">      &#125;);</span><br><span class="hljs-string">      data[key] = $.html();</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;);</span><br></code></pre></td></tr></table></figure><p>第四步：现在就可以插入图片了，比如hexo new post photo之后<br> 就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br> 在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">![这是代替图片的文字，随便写](head.jpeg)<br></code></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/32689857/120274711-d06af500-c2e2-11eb-9140-8f30cfc1b4ac.jpg" alt="1e80e79253a027ab37dd3a60e02e624f3d6a9f2d"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ceshitup</title>
    <link href="/2021/06/01/ceshitup/"/>
    <url>/2021/06/01/ceshitup/</url>
    
    <content type="html"><![CDATA[<h1 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h1><hr><p><img src="https://user-images.githubusercontent.com/32689857/120270452-34d68600-c2dc-11eb-84f0-134ab94b9b39.png" alt="aaaa"></p><p>hellloool</p>]]></content>
    
    
    
    <tags>
      
      <tag>photo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/01/JAVA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2021/06/01/JAVA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA动态代理"><a href="#JAVA动态代理" class="headerlink" title="JAVA动态代理"></a>JAVA动态代理</h1><p><a href="https://www.jianshu.com/u/589a52fcab37"><img src="https://upload.jianshu.io/users/upload_avatars/2109481/3d7dbed1-d42a-4812-9cd5-bd083dd1ba1c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/1/w/96/h/96/format/webp" alt="img"></a></p><p><a href="https://www.jianshu.com/u/589a52fcab37">只是肿态度</a>关注</p><p>62019.05.12 23:25:39字数 964阅读 137,431</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。</p><p>其实就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。代理类和被代理类通常会存在关联关系(即上面提到的持有的被带离对象的引用)，代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p><p>接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">HelloInterface</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloInterface</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello zhanghao!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloInterface</span></span>&#123;<br>    <span class="hljs-keyword">private</span> HelloInterface helloInterface = <span class="hljs-keyword">new</span> Hello();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Before invoke sayHello&quot;</span> );<br>        helloInterface.sayHello();<br>        System.out.println(<span class="hljs-string">&quot;After invoke sayHello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类调用：<br>被代理类被传递给了代理类HelloProxy，代理类在执行具体方法时通过所持用的被代理类完成调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloProxy helloProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HelloProxy</span>();<br>        helloProxy.<span class="hljs-built_in">sayHello</span>();<br>    &#125;<br>    <br>输出：<br>Before invoke sayHello<br>Hello zhanghao!<br>After invoke sayHello<br></code></pre></td></tr></table></figure><p>使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>利用反射机制在运行时创建代理类。<br>接口、被代理类不变，我们构建一个handler类来实现InvocationHandler接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyHandler</span> <span class="hljs-title">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Object <span class="hljs-keyword">object</span>;<br>    <span class="hljs-keyword">public</span> ProxyHandler(Object <span class="hljs-keyword">object</span>)&#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">object</span> = <span class="hljs-keyword">object</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Before invoke &quot;</span>  + method.getName());<br>        method.invoke(<span class="hljs-keyword">object</span>, args);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;After invoke &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行动态代理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.<span class="hljs-built_in">getProperties</span>().<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br><br>    HelloInterface hello = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Hello</span>();<br>    <br>    InvocationHandler handler = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProxyHandler</span>(hello);<br><br>    HelloInterface proxyHello = (HelloInterface) Proxy.<span class="hljs-built_in">newProxyInstance</span>(hello.<span class="hljs-built_in">getClass</span>().<span class="hljs-built_in">getClassLoader</span>(), hello.<span class="hljs-built_in">getClass</span>().<span class="hljs-built_in">getInterfaces</span>(), handler);<br><br>    proxyHello.<span class="hljs-built_in">sayHello</span>();<br>&#125;<br>输出：<br>Before invoke sayHello<br>Hello zhanghao!<br>After invoke sayHello<br></code></pre></td></tr></table></figure><p>通过Proxy类的静态方法newProxyInstance返回一个接口的代理实例。针对不同的代理类，传入相应的代理程序控制器InvocationHandler。<br>如果新来一个被代理类Bye，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ByeInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayBye</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bye</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ByeInterface</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayBye</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Bye zhanghao!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么执行过程：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    System.getProperties().setProperty(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br><br>    HelloInterface hello = <span class="hljs-keyword">new</span> Hello();<br>    ByeInterface bye = <span class="hljs-keyword">new</span> Bye();<br><br>    InvocationHandler handler = <span class="hljs-keyword">new</span> ProxyHandler(hello);<br>    InvocationHandler handler1 = <span class="hljs-keyword">new</span> ProxyHandler(bye);<br><br>    HelloInterface proxyHello = (HelloInterface) <span class="hljs-built_in">Proxy</span>.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);<br><br>    ByeInterface proxyBye = (ByeInterface) <span class="hljs-built_in">Proxy</span>.newProxyInstance(bye.getClass().getClassLoader(), bye.getClass().getInterfaces(), handler1);<br>    proxyHello.sayHello();<br>    proxyBye.sayBye();<br>&#125;<br>输出：<br>Before invoke sayHello<br>Hello zhanghao!<br>After invoke sayHello<br>Before invoke sayBye<br>Bye zhanghao!<br>After invoke sayBye<br></code></pre></td></tr></table></figure><h2 id="动态代理底层实现"><a href="#动态代理底层实现" class="headerlink" title="动态代理底层实现"></a>动态代理底层实现</h2><p>动态代理具体步骤：</p><ol><li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li><li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li></ol><p>既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      InvocationHandler h)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalArgumentException</span><br><span class="hljs-function"></span>&#123;<br>    Objects.requireNonNull(h);<br><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();<br>    <span class="hljs-keyword">final</span> SecurityManager sm = System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);<br>    &#125;<br>     <span class="hljs-comment">//生成代理类对象</span><br>    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br><br>    <span class="hljs-comment">//使用指定的调用处理程序获取代理类的构造函数对象</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>            checkNewProxyPermission(Reflection.getCallerClass(), cl);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>        <span class="hljs-keyword">final</span> InvocationHandler ih = h;<br>        <span class="hljs-comment">//如果Class作用域为私有，通过 setAccessible 支持访问</span><br>        <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;<br>            AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    cons.setAccessible(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//获取Proxy Class构造函数，创建Proxy代理实例。</span><br>        <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;h&#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>        Throwable t = e.getCause();<br>        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>            <span class="hljs-keyword">throw</span> (RuntimeException) t;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(t.toString(), t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用getProxyClass0(loader, intfs)生成代理类Proxy的Class对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,<br>                                       Class&lt;?&gt;... interfaces) &#123;<br>    <span class="hljs-comment">//如果接口数量大于65535，抛出非法参数错误</span><br>    <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">65535</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;interface limit exceeded&quot;</span>);<br>    &#125;<br><br>   <br>    <span class="hljs-comment">//如果指定接口的代理类已经存在与缓存中，则不用新创建，直接从缓存中取即可；</span><br>    <span class="hljs-comment">//如果缓存中没有指定代理对象，则通过ProxyClassFactory来创建一个代理对象。</span><br>    <span class="hljs-keyword">return</span> proxyClassCache.<span class="hljs-keyword">get</span>(loader, interfaces);<br>&#125;<br></code></pre></td></tr></table></figure><p>ProxyClassFactory内部类创建、定义代理类，返回给定ClassLoader 和interfaces的代理类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs dart">    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyClassFactory</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BiFunction</span>&lt;<span class="hljs-title">ClassLoader</span>, <span class="hljs-title">Class</span>&lt;?&gt;[], <span class="hljs-title">Class</span>&lt;?&gt;&gt;</span>&#123;<br>    <span class="hljs-comment">// 代理类的名字的前缀统一为“$Proxy”</span><br>    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> proxyClassNamePrefix = <span class="hljs-string">&quot;<span class="hljs-subst">$Proxy</span>&quot;</span>;<br><br>    <span class="hljs-comment">// 每个代理类前缀后面都会跟着一个唯一的编号，如$Proxy0、$Proxy1、$Proxy2</span><br>    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicLong nextUniqueNumber = <span class="hljs-keyword">new</span> AtomicLong();<br><br>    <span class="hljs-meta">@Override</span><br>    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;<br><br>        <span class="hljs-built_in">Map</span>&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="hljs-keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;<br>            <span class="hljs-comment">//验证类加载器加载接口得到对象是否与由apply函数参数传入的对象相同</span><br>            Class&lt;?&gt; interfaceClass = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                interfaceClass = Class.forName(intf.getName(), <span class="hljs-keyword">false</span>, loader);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (interfaceClass != intf) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    intf + <span class="hljs-string">&quot; is not visible from class loader&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//验证这个Class对象是不是接口</span><br>            <span class="hljs-keyword">if</span> (!interfaceClass.isInterface()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    interfaceClass.getName() + <span class="hljs-string">&quot; is not an interface&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    <span class="hljs-string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">String</span> proxyPkg = <span class="hljs-keyword">null</span>;     <span class="hljs-comment">// package to define proxy class in</span><br>        <span class="hljs-built_in">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Record the package of a non-public proxy interface so that the</span><br><span class="hljs-comment">         * proxy class will be defined in the same package.  Verify that</span><br><span class="hljs-comment">         * all non-public proxy interfaces are in the same package.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;<br>            <span class="hljs-built_in">int</span> flags = intf.getModifiers();<br>            <span class="hljs-keyword">if</span> (!Modifier.isPublic(flags)) &#123;<br>                accessFlags = Modifier.FINAL;<br>                <span class="hljs-built_in">String</span> name = intf.getName();<br>                <span class="hljs-built_in">int</span> n = name.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                <span class="hljs-built_in">String</span> pkg = ((n == <span class="hljs-number">-1</span>) ? <span class="hljs-string">&quot;&quot;</span> : name.substring(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-keyword">null</span>) &#123;<br>                    proxyPkg = pkg;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pkg.equals(proxyPkg)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                        <span class="hljs-string">&quot;non-public interfaces from different packages&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// if no non-public proxy interfaces, use com.sun.proxy package</span><br>            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="hljs-string">&quot;.&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Choose a name for the proxy class to generate.</span><br><span class="hljs-comment">         */</span><br>        long <span class="hljs-built_in">num</span> = nextUniqueNumber.getAndIncrement();<br>        <span class="hljs-built_in">String</span> proxyName = proxyPkg + proxyClassNamePrefix + <span class="hljs-built_in">num</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * 生成指定代理类的字节码文件</span><br><span class="hljs-comment">         */</span><br>        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(<br>            proxyName, interfaces, accessFlags);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> defineClass0(loader, proxyName,<br>                                proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassFormatError e) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * A ClassFormatError here means that (barring bugs in the</span><br><span class="hljs-comment">             * proxy class generation code) there was some other</span><br><span class="hljs-comment">             * invalid aspect of the arguments supplied to the proxy</span><br><span class="hljs-comment">             * class creation (such as virtual machine limitations</span><br><span class="hljs-comment">             * exceeded).</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(e.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一系列检查后，调用ProxyGenerator.generateProxyClass来生成字节码文件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">generateProxyClass</span>(<span class="hljs-params">final String var0, Class&lt;?&gt;[] var1, <span class="hljs-built_in">int</span> var2</span>)</span> &#123;<br>      ProxyGenerator var3 = <span class="hljs-keyword">new</span> ProxyGenerator(var0, var1, var2);<br>      <span class="hljs-comment">// 真正用来生成代理类字节码文件的方法在这里</span><br>      final <span class="hljs-built_in">byte</span>[] var4 = var3.generateClassFile();<br>      <span class="hljs-comment">// 保存代理类的字节码文件</span><br>      <span class="hljs-keyword">if</span>(saveGeneratedFiles) &#123;<br>          AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>              <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-built_in">int</span> var1 = var0.lastIndexOf(<span class="hljs-number">46</span>);<br>                      Path var2;<br>                      <span class="hljs-keyword">if</span>(var1 &gt; <span class="hljs-number">0</span>) &#123;<br>                          Path var3 = Paths.<span class="hljs-keyword">get</span>(var0.substring(<span class="hljs-number">0</span>, var1).replace(<span class="hljs-string">&#x27;.&#x27;</span>, File.separatorChar), <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<br>                          Files.createDirectories(var3, <span class="hljs-keyword">new</span> FileAttribute[<span class="hljs-number">0</span>]);<br>                          var2 = var3.resolve(var0.substring(var1 + <span class="hljs-number">1</span>, var0.length()) + <span class="hljs-string">&quot;.class&quot;</span>);<br>                      &#125; <span class="hljs-keyword">else</span> &#123;<br>                          var2 = Paths.<span class="hljs-keyword">get</span>(var0 + <span class="hljs-string">&quot;.class&quot;</span>, <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<br>                      &#125;<br><br>                      Files.write(var2, var4, <span class="hljs-keyword">new</span> OpenOption[<span class="hljs-number">0</span>]);<br>                      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                  &#125; catch (IOException var4x) &#123;<br>                      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;I/O exception saving generated file: &quot;</span> + var4x);<br>                  &#125;<br>              &#125;<br>          &#125;);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> var4;<br>  &#125;<br></code></pre></td></tr></table></figure><p>生成代理类字节码文件的generateClassFile方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> byte[] generateClassFile() &#123;<br>    <span class="hljs-comment">//下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中(proxyMethod)</span><br>    <span class="hljs-keyword">this</span>.addProxyMethod(hashCodeMethod, Object.<span class="hljs-keyword">class</span>);<br>    <span class="hljs-keyword">this</span>.addProxyMethod(equalsMethod, Object.<span class="hljs-keyword">class</span>);<br>    <span class="hljs-keyword">this</span>.addProxyMethod(toStringMethod, Object.<span class="hljs-keyword">class</span>);<br>    Class[] var1 = <span class="hljs-keyword">this</span>.interfaces;<br>    int var2 = var1.length;<br><br>    int var3;<br>    Class var4;<br>    <span class="hljs-comment">//获得接口中所有方法并添加到代理方法中</span><br>    <span class="hljs-keyword">for</span>(var3 = <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>        var4 = var1[var3];<br>        Method[] var5 = var4.getMethods();<br>        int var6 = var5.length;<br><br>        <span class="hljs-keyword">for</span>(int var7 = <span class="hljs-number">0</span>; var7 &lt; var6; ++var7) &#123;<br>            Method var8 = var5[var7];<br>            <span class="hljs-keyword">this</span>.addProxyMethod(var8, var4);<br>        &#125;<br>    &#125;<br><br>    Iterator var11 = <span class="hljs-keyword">this</span>.proxyMethods.values().iterator();<br><br>    List var12;<br>    <span class="hljs-keyword">while</span>(var11.hasNext()) &#123;<br>        var12 = (List)var11.next();<br>        checkReturnTypes(var12);<br>    &#125;<br><br>    Iterator var15;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//生成代理类的构造函数</span><br>        <span class="hljs-keyword">this</span>.methods.add(<span class="hljs-keyword">this</span>.generateConstructor());<br>        var11 = <span class="hljs-keyword">this</span>.proxyMethods.values().iterator();<br><br>        <span class="hljs-keyword">while</span>(var11.hasNext()) &#123;<br>            var12 = (List)var11.next();<br>            var15 = var12.iterator();<br>                <br>            <span class="hljs-keyword">while</span>(var15.hasNext()) &#123;<br>                ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();<br>                <span class="hljs-keyword">this</span>.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="hljs-string">&quot;Ljava/lang/reflect/Method;&quot;</span>, <span class="hljs-number">10</span>));<br>                <span class="hljs-keyword">this</span>.methods.add(var16.generateMethod());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.methods.add(<span class="hljs-keyword">this</span>.generateStaticInitializer());<br>    &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>        <span class="hljs-keyword">throw</span> new InternalError(<span class="hljs-string">&quot;unexpected I/O Exception&quot;</span>, var10);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.methods.size() &gt; <span class="hljs-string">&#x27;\uffff&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> new IllegalArgumentException(<span class="hljs-string">&quot;method limit exceeded&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.fields.size() &gt; <span class="hljs-string">&#x27;\uffff&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> new IllegalArgumentException(<span class="hljs-string">&quot;field limit exceeded&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.cp.getClass(dotToSlash(<span class="hljs-keyword">this</span>.className));<br>        <span class="hljs-keyword">this</span>.cp.getClass(<span class="hljs-string">&quot;java/lang/reflect/Proxy&quot;</span>);<br>        var1 = <span class="hljs-keyword">this</span>.interfaces;<br>        var2 = var1.length;<br><br>        <span class="hljs-keyword">for</span>(var3 = <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>            var4 = var1[var3];<br>            <span class="hljs-keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.cp.setReadOnly();<br>        ByteArrayOutputStream var13 = new ByteArrayOutputStream();<br>        DataOutputStream var14 = new DataOutputStream(var13);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            var14.writeInt(-<span class="hljs-number">889275714</span>);<br>            var14.writeShort(<span class="hljs-number">0</span>);<br>            var14.writeShort(<span class="hljs-number">49</span>);<br>            <span class="hljs-keyword">this</span>.cp.write(var14);<br>            var14.writeShort(<span class="hljs-keyword">this</span>.accessFlags);<br>            var14.writeShort(<span class="hljs-keyword">this</span>.cp.getClass(dotToSlash(<span class="hljs-keyword">this</span>.className)));<br>            var14.writeShort(<span class="hljs-keyword">this</span>.cp.getClass(<span class="hljs-string">&quot;java/lang/reflect/Proxy&quot;</span>));<br>            var14.writeShort(<span class="hljs-keyword">this</span>.interfaces.length);<br>            Class[] var17 = <span class="hljs-keyword">this</span>.interfaces;<br>            int var18 = var17.length;<br><br>            <span class="hljs-keyword">for</span>(int var19 = <span class="hljs-number">0</span>; var19 &lt; var18; ++var19) &#123;<br>                Class var22 = var17[var19];<br>                var14.writeShort(<span class="hljs-keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));<br>            &#125;<br><br>            var14.writeShort(<span class="hljs-keyword">this</span>.fields.size());<br>            var15 = <span class="hljs-keyword">this</span>.fields.iterator();<br><br>            <span class="hljs-keyword">while</span>(var15.hasNext()) &#123;<br>                ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();<br>                var20.write(var14);<br>            &#125;<br><br>            var14.writeShort(<span class="hljs-keyword">this</span>.methods.size());<br>            var15 = <span class="hljs-keyword">this</span>.methods.iterator();<br><br>            <span class="hljs-keyword">while</span>(var15.hasNext()) &#123;<br>                ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();<br>                var21.write(var14);<br>            &#125;<br><br>            var14.writeShort(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> var13.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>            <span class="hljs-keyword">throw</span> new InternalError(<span class="hljs-string">&quot;unexpected I/O Exception&quot;</span>, var9);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码生成后，调用defineClass0来解析字节码，生成了Proxy的Class对象。在了解完代理类动态生成过程后，生产的代理类是怎样的，谁来执行这个代理类。</p><p>其中，在ProxyGenerator.generateProxyClass函数中 saveGeneratedFiles定义如下，其指代是否保存生成的代理类class文件，默认false不保存。</p><p>在前面的示例中，我们修改了此系统变量：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">System<span class="hljs-selector-class">.getProperties</span>()<span class="hljs-selector-class">.setProperty</span>(&quot;sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.ProxyGenerator</span><span class="hljs-selector-class">.saveGeneratedFiles</span>&quot;, &quot;true&quot;);<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2109481-c68c854238142932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>如图，生成了两个名为 <img src="https://math.jianshu.com/math?formula=Proxy0.class%E3%80%81" alt="Proxy0.class、">Proxy1.class的class文件。</p><p>动态代理流程图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2109481-5bc36d36f5997da1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/01/Java%20%E6%B3%A8%E8%A7%A3%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/06/01/Java%20%E6%B3%A8%E8%A7%A3%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-注解完全解析"><a href="#Java-注解完全解析" class="headerlink" title="Java 注解完全解析"></a>Java 注解完全解析</h1><p><a href="https://www.jianshu.com/u/cbd79b1d9ab1"><img src="https://upload.jianshu.io/users/upload_avatars/11474088/abd60fa2-5ec7-4796-916e-7ce6175b45b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/1/w/96/h/96/format/webp" alt="img"></a></p><p><a href="https://www.jianshu.com/u/cbd79b1d9ab1">若丨寒</a>关注</p><p>32019.04.30 21:40:06字数 2,314阅读 41,624</p><blockquote><p>关于注解首先引入官方文档的一句话：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。看完这句话也许你还是一脸懵逼，接下我将从注解的定义、元注解、注解属性、自定义注解、注解解析JDK 提供的注解这几个方面再次了解注解（Annotation）</p></blockquote><h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><ul><li>日常开发中新建Java类，我们使用class、interface比较多，而注解和它们一样，也是一种类的类型，他是用的修饰符为 @interface</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/11474088-eba117b59f30b90c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/373/format/webp" alt="img"></p><h3 id="注解类的写法"><a href="#注解类的写法" class="headerlink" title="注解类的写法"></a>注解类的写法</h3><ul><li>我们新建一个注解MyTestAnnotation</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> @interface MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接着我们就可以在类或者方法上作用我们刚刚新建的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyTestAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>   <span class="hljs-meta">@MyTestAnnotation</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以上我们只是了解了注解的写法，但是我们定义的注解中还没写任何代码，现在这个注解毫无意义，要如何使注解工作呢？接下来我们接着了解元注解。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ul><li>元注解顾名思义我们可以理解为注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能。元注解分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。</li></ul><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><ul><li>Retention英文意思有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）。在@Retention注解中使用枚举RetentionPolicy来表示注解保留时期</li><li>@Retention(RetentionPolicy.SOURCE)，注解仅存在于源码中，在class字节码文件中不包含</li><li>@Retention(RetentionPolicy.CLASS)， 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得</li><li>@Retention(RetentionPolicy.RUNTIME)， 注解会在class字节码文件中存在，在运行时可以通过反射获取到</li><li>如果我们是自定义注解，则通过前面分析，我们自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 <strong>@Retention(RetentionPolicy.RUNTIME)</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@Retention</span>(RetentionPolicy.RUNTIME)<br>public @interface MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><ul><li>Target的英文意思是目标，这也很容易理解，使用@Target元注解表示我们的注解作用的范围就比较具体了，可以是类，方法，方法参数变量等，同样也是通过枚举类ElementType表达作用类型</li><li>@Target(ElementType.TYPE) 作用接口、类、枚举、注解</li><li>@Target(ElementType.FIELD) 作用属性字段、枚举的常量</li><li>@Target(ElementType.METHOD) 作用方法</li><li>@Target(ElementType.PARAMETER) 作用方法参数</li><li>@Target(ElementType.CONSTRUCTOR) 作用构造函数</li><li>@Target(ElementType.LOCAL_VARIABLE)作用局部变量</li><li>@Target(ElementType.ANNOTATION_TYPE)作用于注解（@Retention注解中就使用该属性）</li><li>@Target(ElementType.PACKAGE) 作用于包</li><li>@Target(ElementType.TYPE_PARAMETER) 作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8加入）</li><li>@Target(ElementType.TYPE_USE) 类型使用.可以用于标注任意类型除了 class （jdk1.8加入）</li><li>一般比较常用的是ElementType.TYPE类型</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><ul><li>Document的英文意思是文档。它的作用是能够将注解中的元素包含到 Javadoc 中去。</li></ul><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><ul><li>Inherited的英文意思是继承，但是这个继承和我们平时理解的继承大同小异，一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</li><li>下面我们来看个@Inherited注解例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**自定义注解*/</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br>&#125;<br><span class="hljs-comment">/**父类标注自定义注解*/</span><br><span class="hljs-meta">@MyTestAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">/**子类*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">/**测试子类获取父类自定义注解*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><br>      <span class="hljs-comment">//获取Son的class对象</span><br>       Class&lt;Son&gt; sonClass = Son.class;<br>      <span class="hljs-comment">// 获取Son类上的注解MyTestAnnotation可以执行成功</span><br>      MyTestAnnotation annotation = sonClass.getAnnotation(MyTestAnnotation.class);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><ul><li>Repeatable的英文意思是可重复的。顾名思义说明被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</li><li>下面我们看一个人玩游戏的例子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，则我们需要定义一个人的注解，他属性代表喜欢玩游戏集合，一个游戏注解，游戏属性代表游戏名称*/</span><br><span class="hljs-comment">/**玩家注解*/</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> People &#123;<br>    Game[] value() ;<br>&#125;<br><span class="hljs-comment">/**游戏注解*/</span><br><span class="hljs-meta">@Repeatable(People.class)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Game &#123;<br>    String value() default <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-comment">/**玩游戏类*/</span><br><span class="hljs-meta">@Game(value = <span class="hljs-meta-string">&quot;LOL&quot;</span>)</span><br><span class="hljs-meta">@Game(value = <span class="hljs-meta-string">&quot;PUBG&quot;</span>)</span><br><span class="hljs-meta">@Game(value = <span class="hljs-meta-string">&quot;NFS&quot;</span>)</span><br><span class="hljs-meta">@Game(value = <span class="hljs-meta-string">&quot;Dirt4&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayGame</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过上面的例子，你可能会有一个疑问，游戏注解中括号的变量是啥，其实这和游戏注解中定义的属性对应。接下来我们继续学习注解的属性。</li></ul><h2 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h2><ul><li>通过上一小节@Repeatable注解的例子，我们说到注解的属性。注解的属性其实和类中定义的变量有异曲同工之处，只是注解中的变量都是成员变量（属性），并且注解中是没有方法的，只有成员变量，变量名就是使用注解括号中对应的参数名，变量返回值注解括号中对应参数类型。相信这会你应该会对上面的例子有一个更深的认识。而@Repeatable注解中的变量则类型则是对应Annotation（接口）的泛型Class。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**注解Repeatable源码<span class="hljs-emphasis">*/</span></span></span></span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-meta">@Target</span>(ElementType.ANNOTATION_TYPE)<br>public <span class="hljs-meta">@interface</span> Repeatable &#123;<br>    <span class="hljs-comment"><span class="markdown"><span class="hljs-strong"><span class="hljs-emphasis">/<span class="hljs-strong">**</span></span></span></span></span><br><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* Indicates </span></span></span></span></span>the<span class="markdown"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span></span>containing annotation type<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span> for </span></span></span></span></span>the<span class="markdown"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"></span></span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">     *</span> repeatable annotation type.</span></span></span></span></span><br><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* @return </span></span></span></span></span>the<span class="markdown"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"> containing annotation type</span></span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">     *</span>/</span></span></span></span></span><br>    Class&lt;? <span class="hljs-keyword">extends</span> Annotation&gt; value();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h3><ul><li>注解的本质就是一个Annotation接口</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**Annotation接口源码*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Annotation</span> &#123;<br><br>    <span class="hljs-function">boolean <span class="hljs-title">equals</span>(<span class="hljs-params">Object obj</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span>;<br><br>    Class&lt;? extends Annotation&gt; annotationType();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过以上源码，我们知道注解本身就是Annotation接口的子接口，<strong>也就是说注解中其实是可以有属性和方法，但是接口中的属性都是static final的，对于注解来说没什么意义，而我们定义接口的方法就相当于注解的属性，也就对应了前面说的为什么注解只有属性成员变量，其实他就是接口的方法，这就是为什么成员变量会有括号</strong>，不同于接口我们可以在注解的括号中给成员变量赋值。</li></ul><h3 id="注解属性类型"><a href="#注解属性类型" class="headerlink" title="注解属性类型"></a>注解属性类型</h3><ul><li>注解属性类型可以有以下列出的类型</li><li>1.基本数据类型</li><li>2.String</li><li>3.枚举类型</li><li>4.注解类型</li><li>5.Class类型</li><li>6.以上类型的一维数组类型</li></ul><h3 id="注解成员变量赋值"><a href="#注解成员变量赋值" class="headerlink" title="注解成员变量赋值"></a>注解成员变量赋值</h3><ul><li>如果注解又多个属性，则可以在注解括号中用“，”号隔开分别给对应的属性赋值，如下例子，注解在父类中赋值属性</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br>    String name() default <span class="hljs-string">&quot;mao&quot;</span>;<br>    int age() default <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-meta">@MyTestAnnotation(name = <span class="hljs-meta-string">&quot;father&quot;</span>,age = 50)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取注解属性"><a href="#获取注解属性" class="headerlink" title="获取注解属性"></a>获取注解属性</h3><ul><li>前面我们说了很多注解如何定义，放在哪，现在我们可以开始学习注解属性的提取了，这才是使用注解的关键，获取属性的值才是使用注解的目的。</li><li>如果获取注解属性，当然是反射啦，主要有三个基本的方法</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**是否存在对应 Annotation 对象*/</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isAnnotationPresent(<span class="hljs-class"><span class="hljs-keyword">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Annotation</span>&gt; <span class="hljs-title">annotationClass</span>) </span>&#123;<br>       <span class="hljs-keyword">return</span> GenericDeclaration.super.isAnnotationPresent(annotationClass);<br>   &#125;<br><br><span class="hljs-comment">/**获取 Annotation 对象*/</span><br>   <span class="hljs-keyword">public</span> &lt;A <span class="hljs-keyword">extends</span> Annotation&gt; A getAnnotation(<span class="hljs-class"><span class="hljs-keyword">Class</span>&lt;<span class="hljs-title">A</span>&gt; <span class="hljs-title">annotationClass</span>) </span>&#123;<br>       Objects.requireNonNull(annotationClass);<br><br>       <span class="hljs-keyword">return</span> (A) annotationData().annotations.get(annotationClass);<br>   &#125;<br><span class="hljs-comment">/**获取所有 Annotation 对象数组*/</span>   <br><span class="hljs-keyword">public</span> Annotation[] getAnnotations() &#123;<br>       <span class="hljs-keyword">return</span> AnnotationParser.toArray(annotationData().annotations);<br>   &#125;    <br></code></pre></td></tr></table></figure><ul><li>下面结合前面的例子，我们来获取一下注解属性，在获取之前我们自定义的注解必须使用元注解@Retention(RetentionPolicy.RUNTIME)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> static void main(String[] args) throws NoSuchMethodException &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取类注解属性</span><br><span class="hljs-comment">         */</span><br>        Class&lt;Father&gt; fatherClass = Father.<span class="hljs-keyword">class</span>;<br>        boolean annotationPresent = fatherClass.isAnnotationPresent(MyTestAnnotation.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>            MyTestAnnotation <span class="hljs-keyword">annotation</span> = fatherClass.getAnnotation(MyTestAnnotation.<span class="hljs-keyword">class</span>);<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.name());<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.age());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取方法注解属性</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Field age = fatherClass.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>            boolean annotationPresent1 = age.isAnnotationPresent(Age.<span class="hljs-keyword">class</span>);<br>            <span class="hljs-keyword">if</span>(annotationPresent1)&#123;<br>                Age <span class="hljs-keyword">annotation</span> = age.getAnnotation(Age.<span class="hljs-keyword">class</span>);<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.value());<br>            &#125;<br><br>            Method play = PlayGame.<span class="hljs-keyword">class</span>.getDeclaredMethod(<span class="hljs-string">&quot;play&quot;</span>);<br>            <span class="hljs-keyword">if</span> (play!=<span class="hljs-literal">null</span>)&#123;<br>                People annotation2 = play.getAnnotation(People.<span class="hljs-keyword">class</span>);<br>                Game[] value = annotation2.value();<br>                <span class="hljs-keyword">for</span> (Game game : value) &#123;<br>                    System.<span class="hljs-keyword">out</span>.println(game.value());<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/11474088-ecf7f4d4f110b8b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/779/format/webp" alt="img"></p><h2 id="JDK-提供的注解"><a href="#JDK-提供的注解" class="headerlink" title="JDK 提供的注解"></a>JDK 提供的注解</h2><table><thead><tr><th>注解</th><th>作用</th><th>注意事项</th></tr></thead><tbody><tr><td>@Override</td><td>它是用来描述当前方法是一个重写的方法，在编译阶段对方法进行检查</td><td>jdk1.5中它只能描述继承中的重写，jdk1.6中它可以描述接口实现的重写,也能描述类的继承的重写</td></tr><tr><td>@Deprecated</td><td>它是用于描述当前方法是一个过时的方法</td><td>无</td></tr><tr><td>@SuppressWarnings</td><td>对程序中的警告去除。</td><td>无</td></tr></tbody></table><h2 id="注解作用与应用"><a href="#注解作用与应用" class="headerlink" title="注解作用与应用"></a>注解作用与应用</h2><ul><li>现在我们再次回头看看开头官方文档的那句描述</li></ul><blockquote><p>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。</p></blockquote><ul><li>经过我们前面的了解，注解其实是个很方便的东西，它存活的时间，作用的区域都可以由你方便设置，只是你用注解来干嘛的问题</li></ul><h3 id="使用注解进行参数配置"><a href="#使用注解进行参数配置" class="headerlink" title="使用注解进行参数配置"></a>使用注解进行参数配置</h3><ul><li>下面我们看一个银行转账的例子，假设银行有个转账业务，转账的限额可能会根据汇率的变化而变化，我们可以利用注解灵活配置转账的限额，而不用每次都去修改我们的业务代码。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**定义限额注解*/</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BankTransferMoney &#123;<br>    double maxMoney() default <span class="hljs-number">10000</span>;<br>&#125;<br><span class="hljs-comment">/**转账处理业务类*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money 转账金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@BankTransferMoney(maxMoney = 15000)</span><br>    <span class="hljs-keyword">public</span> static void TransferMoney(double money)&#123;<br>        System.<span class="hljs-keyword">out</span>.println(processAnnotationMoney(money));<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> static String processAnnotationMoney(double money) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Method transferMoney = BankService.<span class="hljs-keyword">class</span>.getDeclaredMethod(<span class="hljs-string">&quot;TransferMoney&quot;</span>,double.<span class="hljs-keyword">class</span>);<br>            boolean annotationPresent = transferMoney.isAnnotationPresent(BankTransferMoney.<span class="hljs-keyword">class</span>);<br>            <span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>                BankTransferMoney <span class="hljs-keyword">annotation</span> = transferMoney.getAnnotation(BankTransferMoney.<span class="hljs-keyword">class</span>);<br>                double l = <span class="hljs-keyword">annotation</span>.maxMoney();<br>                <span class="hljs-keyword">if</span>(money&gt;l)&#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转账金额大于限额，转账失败&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;转账金额为:&quot;</span>+money+<span class="hljs-string">&quot;，转账成功&quot;</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> ( NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转账处理失败&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> static void main(String[] args)&#123;<br>        TransferMoney(<span class="hljs-number">10000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/11474088-5254707ba9b59ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp" alt="img"></p><ul><li>通过上面的例子，只要汇率变化，我们就改变注解的配置值就可以直接改变当前最大限额。</li></ul><h3 id="第三方框架的应用"><a href="#第三方框架的应用" class="headerlink" title="第三方框架的应用"></a>第三方框架的应用</h3><ul><li>作为一个Android 开发者，平常我们所使用的第三方框架ButterKnife，Retrofit2，Dagger2等都有注解的应用，如果我们要了解这些框架的原理，则注解的基础知识则是必不可少的。</li></ul><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><ul><li>提供信息给编译器： 编译器可以利用注解来检测出错误或者警告信息，打印出日志。</li><li>编译阶段时的处理： 软件工具可以用来利用注解信息来自动生成代码、文档或者做其它相应的自动处理。</li><li>运行时处理： 某些注解可以在程序运行的时候接受代码的提取，自动做相应的操作。</li><li>正如官方文档的那句话所说，注解能够提供元数据，转账例子中处理获取注解值的过程是我们开发者直接写的注解提取逻辑，**处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)**。上面转账例子中的processAnnotationMoney方法就可以理解为APT工具类。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/01/idea%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/06/01/idea%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>idea安装配置</p><p>1,安装lombok插件,安装这个插件在使用lombok框架注解时才不会导致一大批getter,setter方法爆红</p><p>2,设置jdk,编码格式</p><p>3,配置maven</p><p>D:/maven/apache-maven-3.5.2</p><p>D:\maven\apache-maven-3.5.2\conf\settings.xml</p><p>D:\maven\repository_boot</p><p>4,设置java compiler</p><p>5,设置file encoding</p><h5 id="七、常用插件"><a href="#七、常用插件" class="headerlink" title="七、常用插件"></a>七、常用插件</h5><p>1、Easy Code  代码生成工具<br> 2、lombok 代码注解插件 添加注解 @Data，即可省去手写getter, setter, toString的麻烦<br> 3、 Codota  辅助开发神器<br> 4、 Translation  翻译插件<br> 5、 Grep Console   日志工具 控制台console输出日志时区分颜色<br> 6、 SGsonFormat  — GsonFormat  JSON转领域对象工具<br> 7、 POJO to JSON  领域对象转JSON工具<br> 8、String Manipulation  字符串工具<br> 9、Rainbow Brackets  括号相同颜色 彩色括号<br> 10、MyBatis Log Plugin 将Mybatis执行的sql脚本显示出来，无需处理，可以直接复制出来执行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/01/gitlab%E6%8A%A5%E9%94%99502/"/>
    <url>/2021/06/01/gitlab%E6%8A%A5%E9%94%99502/</url>
    
    <content type="html"><![CDATA[<p>gitlab报错502</p><p>解决方案:检查端口正常,发现内存不足</p><p>端口更改<br>gitlab.rb修改<br>配置文件在/opt/gitlab/etc/gitlab.rb。这个文件用于gitlab如何调用80和8080的服务等。</p><p>##Advanced settings<br>unicorn[‘listen’] = ‘127.0.0.1’<br>unicorn[‘port’] = 8082</p><p>nginx[‘listen_addresses’] = [‘*’]<br>nginx[‘listen_port’] = 82 # override only if you use a reverse proxy: <a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#setting-the-nginx-listen-port">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#setting-the-nginx-listen-port</a><br>1<br>2<br>3<br>4<br>5<br>6<br>gitlab-rails修改<br>配置文件/var/opt/gitlab/gitlab-rails/etc/unicorn.rb</p><p>##What ports/sockets to listen on, and what options for them.<br>#listen “127.0.0.1:8080”, :tcp_nopush =&gt; true<br>listen “127.0.0.1:8082”, :tcp_nopush =&gt; true<br>listen “/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket”, :backlog =&gt; 1024<br>1<br>2<br>3<br>4<br>gitlab nginx 修改<br>配置文件 /var/opt/gitlab/nginx/conf/gitlab-http.conf。这个文件是gitlab内置的nginx的配置文件，里面可以影响到nginx真实监听端口号。</p><p>server {<br>  listen *:82;</p><p>  server_name gitlab.123.123.cn;<br>  server_tokens off; ## Don’t show the nginx version number, a security best practice<br>1<br>2<br>3<br>4<br>5<br>重启gitlab</p><p>#gitlab-ctl reconfigure<br>#gitlab-ctl restart<br>1<br>2<br>访问登录<br>ip:82(ip+:端口号)</p><p>常见错误以及解决办法<br>在访问gitlab的时候我们会发现会有502的错误，到底是什么原因</p><p>解决办法：</p><p>1、权限问题</p><p>Gitlab文件需要给予读写的权限</p><p>解决办法</p><p>#chmod -R 755 /var/log/gitlab</p><p>2、端口问题</p><p>Gitlab的默认启动端口是80,8080，所以有肯能会与其他的端口产生冲突，所以需要修改文件。</p><p>#vim /etc/gitlab/gitlab.rb</p><p>更改参数</p><p>external_url ‘<a href="http://localhost:8888’">http://localhost:8888’</a> #指定访问端口，默认是80</p><p>unicorn[‘listen’] = ‘127.0.0.1’</p><p>unicorn[‘port’] = 8001 # 为unicorn worker的工作端口，默认为8080，如果你的8080端口被占用的，这一项需要更改。</p><p>重启gitlab</p><p>#gitlab-ctl reconfigure<br>#gitlab-ctl restart</p><p>3、内存不足的问题</p><p>安装gitlab的时候，已经说明你的空余内存需要有4G左右的内存，所以在安装gitlab的时候，请给足内存，再安装。<br>————————————————<br>版权声明：本文为CSDN博主「liang_long」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_46291185/article/details/106037160">https://blog.csdn.net/qq_46291185/article/details/106037160</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/01/nginx%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/01/nginx%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="nginx配置静态资源不起作用-一直404的原因"><a href="#nginx配置静态资源不起作用-一直404的原因" class="headerlink" title="nginx配置静态资源不起作用,一直404的原因"></a>nginx配置静态资源不起作用,一直404的原因</h2><p>使用nginx要有看Log的习惯</p><blockquote><p>#重启nginx使用以下语句,不要点击Nginx.exe</p><p>./nginx -s reload</p></blockquote><p>有多个nginx启动导致冲突,一般情况下会有log,如果没有log提示,</p><p>就需要查看是否是这个问题</p><p>批量关闭nginx进程</p><h3 id="1先查看有多少nginx进程"><a href="#1先查看有多少nginx进程" class="headerlink" title="1先查看有多少nginx进程"></a>1先查看有多少nginx进程</h3><blockquote><p> tasklist /fi “imagename eq nginx.exe”</p></blockquote><h3 id="2该命令作用是结束这些进程"><a href="#2该命令作用是结束这些进程" class="headerlink" title="2该命令作用是结束这些进程"></a>2该命令作用是结束这些进程</h3><blockquote><p> taskkill /fi “imagename eq nginx.exe” /f</p></blockquote><h2 id="nginx下location的使用"><a href="#nginx下location的使用" class="headerlink" title="nginx下location的使用"></a>nginx下location的使用</h2><p>重点是理解alias与root的区别，root与alias主要区别在于nginx如何解释location后面的uri，这使两者分别以不同的方式将请求映射到服务器文件上。</p><p>alias（别名）是一个目录别名</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">location <span class="hljs-regexp">/abc/</span> &#123;<br>　　alias <span class="hljs-regexp">/clyde/</span>;<br>&#125;<br>当请求http:<span class="hljs-regexp">//</span>clyde.com<span class="hljs-regexp">/abc/</span>logo.png时，<br>会返回 <span class="hljs-regexp">/clyde/</span>logo.png文件，<br>即用<span class="hljs-regexp">/clyde替换/</span>abc。<br>alias配置后面是要加/<br></code></pre></td></tr></table></figure><p>root（根目录）是最上层目录的定义。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">location <span class="hljs-regexp">/abc/</span> &#123;<br>root /clyde;<br>&#125;<br>当请求http:<span class="hljs-regexp">//</span>clyde.com<span class="hljs-regexp">/abc/</span>logo.png时，<br>会返回 <span class="hljs-regexp">/clyde/</span>abc/logo.png文件，<br>即用<span class="hljs-regexp">/clyde 加上 /</span>abc。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/01/hello-world/"/>
    <url>/2021/06/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇文章</title>
    <link href="/2018/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2018/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h1><hr><p>cehijjkljl</p><p>这是测试文章</p><p><img src="https://user-images.githubusercontent.com/32689857/120270452-34d68600-c2dc-11eb-84f0-134ab94b9b39.png" alt="logo"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">hello<br>hkjkljjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj<br><span class="hljs-keyword">jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj</span><br><span class="hljs-keyword"></span>dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd<br>sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss<br><span class="hljs-keyword">jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj</span><br><span class="hljs-keyword"></span>kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk<br><span class="hljs-keyword">lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
