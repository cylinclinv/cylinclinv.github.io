

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/logo.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="clyde">
  <meta name="keywords" content="">
  
  <title>Jvm学习04 - Clyde</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Clyde</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/cover/103.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Jvm学习04">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-01-09 22:13" pubdate>
        2018年1月9日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      162
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Jvm学习04</h1>
            
            <div class="markdown-body">
              <p>四、共享模型之内存<br>1、Java 内存模型（JMM）<br>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。<br>JMM 体现在以下几个方面</p>
<p>原子性 - 保证指令不会受到线程上下文切换的影响<br>可见性 - 保证指令不会受 cpu 缓存的影响<br>有序性 - 保证指令不会受 cpu 指令并行优化的影响<br>2、可见性<br>1）退不出的循环<br>首先看一段代码：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> boolean run = <span class="hljs-literal">true</span>;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br><br>​    Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">​        <span class="hljs-keyword">while</span>(run) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">​        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">​    &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">​    <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">​    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">​        <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">​    &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">​        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">​    &#125;</span><br><span class="hljs-function">​    <span class="hljs-title">log</span>.<span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">&quot;t1 Stop&quot;</span>)</span>;</span><br><span class="hljs-function">​    <span class="hljs-title">run</span> = <span class="hljs-title">false</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>首先 t1 线程运行，然后过一秒，主线程设置 run 的值为 false，想让 t1 线程停止下来，但是 t1 线程并没有停，分析如下图：</p>
<p>解决方法</p>
<p>使用 volatile （易变关键字）<br>它可以用来修饰成员变量和静态成员变量（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 保证内存的可见性</span><br></code></pre></td></tr></table></figure>

<p>2）可见性与原子性<br>上面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况。</p>
<p>注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低。<br>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？<br>因为 printIn() 方法使用了 synchronized 同步代码块，可以保证原子性与可见性，它是 PrintStream 类的方法。<br>3）模式之两阶段终止<br>使用 volatile 关键字来实现两阶段终止模式。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_02_Test</span> &#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>		Monitor monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Monitor</span>();<br>		monitor.<span class="hljs-built_in">start</span>();<br>		Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>		monitor.<span class="hljs-built_in">stop</span>();<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br><br>Thread monitor;<br><span class="hljs-comment">// 设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">// 设置线控器线程，用于监控线程状态</span><br>   monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>() &#123;<br>   	@Override<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>   		<span class="hljs-comment">// 开始不停的监控</span><br>   		<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>   			<span class="hljs-keyword">if</span>(stop) &#123;<br>   				System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>   				<span class="hljs-keyword">break</span>;<br>   			&#125;<br>   			System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>   			<span class="hljs-keyword">try</span> &#123;<br>   				<span class="hljs-comment">// 线程休眠</span><br>   				Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>   			&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>   				System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>   			&#125;<br>   		&#125;<br>   	&#125;<br>   &#125;;<br>   monitor.<span class="hljs-built_in">start</span>();<br>   &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * 	用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 修改标记</span><br>    stop = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 打断线程</span><br>    monitor.<span class="hljs-built_in">interrupt</span>();        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>4）模式之 Balking<br>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回，有点类似单例。</p>
<p>用一个标记来判断该任务是否已经被执行过了<br>需要避免线程安全问题<br>加锁的代码块要尽量的小，以保证性能</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_03_Test</span> &#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>		Monitor monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Monitor</span>();<br>		monitor.<span class="hljs-built_in">start</span>();<br>		monitor.<span class="hljs-built_in">start</span>();<br>		Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>		monitor.<span class="hljs-built_in">stop</span>();<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br><br>Thread monitor;<br><span class="hljs-comment">// 设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 设置标记，用于判断是否已经启动过了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">// 上锁，避免多线程运行时出现线程安全问题</span><br>   <span class="hljs-built_in">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>   	<span class="hljs-keyword">if</span> (starting) &#123;<br>   		<span class="hljs-comment">// 已被启动，直接返回</span><br>   		<span class="hljs-keyword">return</span>;<br>   	&#125;<br>   	<span class="hljs-comment">// 启动监视器，改变标记</span><br>   	starting = <span class="hljs-literal">true</span>;<br>   &#125;<br>   <span class="hljs-comment">// 设置线控器线程，用于监控线程状态</span><br>   monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>() &#123;<br>   	@Override<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>   		<span class="hljs-comment">// 开始不停的监控</span><br>   		<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>   			<span class="hljs-keyword">if</span>(stop) &#123;<br>   				System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>   				<span class="hljs-keyword">break</span>;<br>   			&#125;<br>   			System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>   			<span class="hljs-keyword">try</span> &#123;<br>   				<span class="hljs-comment">// 线程休眠</span><br>   				Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>   			&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>   				System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>   			&#125;<br>   		&#125;<br>   	&#125;<br>   &#125;;<br>   monitor.<span class="hljs-built_in">start</span>();<br>   &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * 	用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 打断线程</span><br>    monitor.<span class="hljs-built_in">interrupt</span>();<br>    stop = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、有序性<br>1）指令重排<br>首先看一个例子：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 可以重排的例子 </span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>; <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println( a + b );<br><br><span class="hljs-comment">// 不能重排的例子 </span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> b = a - <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>指令重排简单来说可以，在程序结果不受影响的前提下，可以调整指令语句执行顺序。多线程下指令重排会影响正确性。</p>
<p>2）多线程下指令重排问题<br>首先看一段代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span><br><span class="hljs-keyword">boolean</span> ready = <span class="hljs-literal">false</span>; <br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-keyword">if</span>(ready) &#123;<br> 	r.r1 = num + num;<br> &#125; <br> <span class="hljs-keyword">else</span> &#123;<br> 	r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在多线程环境下，以上的代码 r1 的值有三种情况：<br>第一种：线程 2 先执行，然后线程 1 后执行，r1 的结果为 4<br>第二种：线程 1 先执行，然后线程 2 后执行，r1 的结果为 1<br>第三种：线程 2 先执行，但是发送了指令重排，num = 2 与 ready = true 这两行代码语序发生装换，</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ready</span> = <span class="hljs-literal">true</span><span class="hljs-comment">; // 前</span><br><span class="hljs-attr">num</span> = <span class="hljs-number">2</span><span class="hljs-comment">; // 后</span><br></code></pre></td></tr></table></figure>

<p>然后执行 ready = true 后，线程 1 运行了，那么 r1 的结果是为 0。</p>
<p>3）解决方法<br>volatile 修饰的变量，可以禁用指令重排，禁止的是加 volatile 关键字变量之前的代码重排序</p>
<p>4、volatile 原理<br>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）<br>对 volatile 变量的写指令后会加入写屏障<br>对 volatile 变量的读指令前会加入读屏障</p>
<p>1）如何保证可见性<br>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>     num = <span class="hljs-number">2</span>;<br>     ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是被 volatile 修饰的，赋值带写屏障</span><br>     <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">// ready是被 volatile 修饰的，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<br> 	r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> 	r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析如图：</p>
<p>2）如何保证有序性<br>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是被 volatile 修饰的，赋值带写屏障</span><br> <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">// ready 是被 volatile 修饰的，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<br> 	r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> 	r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：volatile 不能解决指令交错<br>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读跑到它前面去。<br>而有序性的保证也只是保证了本线程内相关代码不被重排序</p>
<p>3）double-checked locking 问题<br>看如下代码：</p>
<pre><code>// 最开始的单例模式是这样的
public final class Singleton &#123;
    private Singleton() &#123; &#125;
    private static Singleton INSTANCE = null;
    public static Singleton getInstance() &#123;
    // 首次访问会同步，而之后的使用不用进入synchronized
    synchronized(Singleton.class) &#123;
        if (INSTANCE == null) &#123; // t1
            INSTANCE = new Singleton();
        &#125;
    &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<p>// 但是上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响性能！因此就有了模式如下double-checked lockin：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-literal">null</span>;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>         <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2</span><br>             <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>             <span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params">Singleton.<span class="hljs-keyword">class</span></span>)</span> &#123;<br>                 <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                     INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                 &#125;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> INSTANCE;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性，可见性。所以</p>
<p>以上的实现特点是：</p>
<p>懒惰实例化<br>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁<br>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外<br>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">getstatic</span> <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">ifnonnull</span> <span class="hljs-number">37</span><br><span class="hljs-string">//</span> <span class="hljs-string">ldc是获得类对象</span><br><span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span> <span class="hljs-comment">#3 // class cn/itcast/n5/Singleton</span><br><span class="hljs-string">//</span> <span class="hljs-string">复制操作数栈栈顶的值放入栈顶,</span> <span class="hljs-string">将类对象的引用地址复制了一份</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">dup</span><br><span class="hljs-string">//</span> <span class="hljs-string">操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span><br><span class="hljs-string">//</span> <span class="hljs-string">将类对象的引用地址存储了一份，是为了将来解锁用</span><br><span class="hljs-attr">9:</span> <span class="hljs-string">astore_0</span><br><span class="hljs-attr">10:</span> <span class="hljs-string">monitorenter</span><br><span class="hljs-attr">11:</span> <span class="hljs-string">getstatic</span> <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">14:</span> <span class="hljs-string">ifnonnull</span> <span class="hljs-number">27</span><br><span class="hljs-string">//</span> <span class="hljs-string">新建一个实例</span><br><span class="hljs-attr">17:</span> <span class="hljs-string">new</span> <span class="hljs-comment">#3 // class cn/itcast/n5/Singleton</span><br><span class="hljs-string">//</span> <span class="hljs-string">复制了一个实例的引用</span><br><span class="hljs-attr">20:</span> <span class="hljs-string">dup</span><br><span class="hljs-string">//</span> <span class="hljs-string">通过这个复制的引用调用它的构造方法</span><br><span class="hljs-attr">21:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-string">//</span> <span class="hljs-string">最开始的这个引用用来进行赋值操作</span><br><span class="hljs-attr">24:</span> <span class="hljs-string">putstatic</span> <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">27:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">28:</span> <span class="hljs-string">monitorexit</span><br><span class="hljs-attr">29:</span> <span class="hljs-string">goto</span> <span class="hljs-number">37</span><br><span class="hljs-attr">32:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">33:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">34:</span> <span class="hljs-string">monitorexit</span><br><span class="hljs-attr">35:</span> <span class="hljs-string">aload_1</span><br><span class="hljs-attr">36:</span> <span class="hljs-string">athrow</span><br><span class="hljs-attr">37:</span> <span class="hljs-string">getstatic</span> <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">40:</span> <span class="hljs-string">areturn</span><br></code></pre></td></tr></table></figure>

<p>其中</p>
<p>17 表示创建对象，将对象引用入栈 // new Singleton<br>20 表示复制一份对象引用 // 复制了引用地址<br>21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法<br>24 表示利用一个对象引用，赋值给 static INSTANCE<br>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p>
<p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例 对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效。</p>
<p>4）double-checked locking 解决<br>加volatile就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span><br>                    <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>                    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                        INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如上面的注释内容所示，读写 volatile 变量操作（即 getstatic 操作和 putstatic 操作）时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p>
<p>可见性<br>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中<br>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据<br>有序性<br>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后<br>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前<br>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性<br>5、happens-before<br>下面说的变量都是指成员变量或静态成员变量<br>1）线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<pre><code> static int x;
 static Object m = new Object();
 new Thread(()-&gt;&#123;
     synchronized(m) &#123;
         x = 10;
     &#125;
 &#125;,&quot;t1&quot;).start();
 new Thread(()-&gt;&#123;
     synchronized(m) &#123;
         System.out.println(x);
     &#125;
 &#125;,&quot;t2&quot;).start();
</code></pre>
<p>2）线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">volatile <span class="hljs-keyword">static</span> int x;<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> x = <span class="hljs-number">10</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> System.out.println(x);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">3）线程 <span class="hljs-title">start</span> 前对变量的写，对该线程开始后对该变量的读可见</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">static</span> <span class="hljs-title">int</span> <span class="hljs-title">x</span>;</span><br><span class="hljs-function"><span class="hljs-title">x</span> = 10;</span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> System.out.println(x);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure>

<p>4）线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> x = <span class="hljs-number">10</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(x)</span>;</span><br></code></pre></td></tr></table></figure>

<p>5）线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</p>
<pre><code>static int x;
public static void main(String[] args) &#123;
    Thread t2 = new Thread(()-&gt;&#123;
        while(true) &#123;
            if(Thread.currentThread().isInterrupted()) &#123;
                System.out.println(x);
                break;
            &#125;
        &#125;
    &#125;,&quot;t2&quot;);
    t2.start();
    new Thread(()-&gt;&#123;
        sleep(1);
        x = 10;
        t2.interrupt();
    &#125;,&quot;t1&quot;).start();
    while(!t2.isInterrupted()) &#123;
        Thread.yield();
    &#125;
    System.out.println(x);
&#125;
</code></pre>
<p>6）对变量默认值（0，false，null）的写，对其它线程对该变量的读可见<br>7）具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p>
<pre><code>volatile static int x;  
static int y;  
new Thread(() -&gt; &#123;  
    y = 10;  
    x = 20;  
&#125;,&quot;t1&quot;).start();  
    new Thread(() -&gt; &#123;  
    // x=20 对 t2 可见, 同时 y=10 也对 t2 可见  
    System.out.println(x);  
&#125;,&quot;t2&quot;).start(); 
</code></pre>
<p>6、练习<br>1）balking 模式习题<br>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialized) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        doInit();<br>        initialized = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>


<p>volatile 可以保存线程的可见性，有序性，但是不能保证原子性，doInit 方法没加锁，可能会被调用多次。<br>2）线程安全单例习题<br>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试着分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p>
<p>饿汉式：类加载就会导致该单实例对象被创建<br>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建<br>实现1： 饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final，防止子类继承后更改</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// 问题3：为什么设置为私有? 放弃其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</span><br>    <span class="hljs-comment">//1.提供更好的封装性；2.提供范型的支持</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现2： 饿汉式</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 问题<span class="hljs-number">1</span>：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量<br><span class="hljs-regexp">//</span> 问题<span class="hljs-number">2</span>：枚举单例在创建时是否有并发问题：没有，这是静态成员变量<br><span class="hljs-regexp">//</span> 问题<span class="hljs-number">3</span>：枚举单例能否被反射破坏单例：不能<br><span class="hljs-regexp">//</span> 问题<span class="hljs-number">4</span>：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例<br><span class="hljs-regexp">//</span> 问题<span class="hljs-number">5</span>：枚举单例属于懒汉式还是饿汉式：饿汉式<br><span class="hljs-regexp">//</span> 问题<span class="hljs-number">6</span>：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了<br>enum Singleton &#123;<br> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现3：懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次访问都会加锁，性能比较低。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>实现4：DCL 懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?为了防止重排序问题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>        <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。</span><br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现5：静态内部类懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-comment">// 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结论<br>本章重点讲解了 JMM 中的</p>
<p>可见性 - 由 JVM 缓存优化引起<br>有序性 - 由 JVM 指令重排序优化引起<br>happens-before 规则<br>原理方面<br>volatile<br>模式方面<br>两阶段终止模式的 volatile 改进<br>同步模式之 balking<br>五、共享模型之无锁<br>管程即 monitor 是阻塞式的悲观锁实现并发控制，这章我们将通过非阻塞式的乐观锁的来实现并发控制</p>
<p>1、无锁解决线程安全问题<br>如下代码，通过 synchronized 解决线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_04_UnsafeTest</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Account acount = <span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>);    Account.demo(acount);&#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> Integer balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;    <span class="hljs-keyword">this</span>.balance = balance;&#125;<span class="hljs-meta">@Overridepublic</span> <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;&#125;<span class="hljs-meta">@Overridepublic</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">// 加锁。        this.balance -= amount;    &#125;&#125;</span><br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br><br><span class="hljs-comment">// 获取金额的方法Integer getBalance();</span><br><br><span class="hljs-comment">// 取款的方法void withdraw(Integer amount);static void demo(Account account) &#123;   </span><br><br> List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <br><br><span class="hljs-keyword">long</span> start = System.nanoTime();    <br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;   <br><br>​     list.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;   <br><br>​         account.withdraw(<span class="hljs-number">10</span>);     <br><br>   &#125;));   <br><br> &#125;    <br><br>list.forEach(Thread::start);   <br><br> list.forEach(t -&gt; &#123;      <br><br>  <span class="hljs-keyword">try</span> &#123;          <br><br>  t.join();      <br><br>  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; <br><br>​           e.printStackTrace();     <br><br>   &#125;  <br><br>  &#125;); <br><br>   <span class="hljs-keyword">long</span> end = System.nanoTime();   <br><br> System.out.println(account.getBalance()         <br><br>   + <span class="hljs-string">&quot; cost: &quot;</span> + (end-start)/<span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上代码加锁会造成线程堵塞，堵塞的时间取决于临界区代码执行的时间，这使用加锁的性能不高，我们可以使用无锁来解决此问题。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountSafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span></span>&#123;<br><br>AtomicInteger atomicInteger ;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountSafe</span><span class="hljs-params">(Integer balance)</span></span>&#123; <br><span class="hljs-keyword">this</span>.atomicInteger =  <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">return</span> atomicInteger.<span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123; <br><span class="hljs-comment">// 核心代码  </span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;    <br><span class="hljs-keyword">int</span> pre = getBalance();   <br><span class="hljs-keyword">int</span> next = pre - amount; <br><span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(pre,next))&#123;   <br><span class="hljs-keyword">break</span>;     <br>&#125;  <br>&#125;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、CAS 与 volatile<br>1）cas<br>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？<br>其中的关键是 compareAndSwap（比较并设置值），它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p>
<p>如图所示，它的工作流程如下：<br>当一个线程要去修改 Account 对象中的值时，先获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用 cas 方法）。在调用 cas 方法时，会将 pre 与 Account 中的余额进行比较。</p>
<p>如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。<br>如果两者不相等，就不设置值，重新获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用cas方法），直到修改成功为止。<br>注意：</p>
<p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。<br>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的 。<br>2）volatile<br>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。<br>注意<br>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）<br>CAS 是原子性操作借助 volatile 读取到共享变量的新值来实现【比较并交换】的效果</p>
<p>3）为什么无锁效率高<br>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大<br>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。<br>4）CAS 的特点<br>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p>
<p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<br>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。<br>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<br>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一<br>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响<br>3、原子整数<br>java.util.concurrent.atomic并发包提供了一些并发工具类，这里把它分成五类：<br>使用原子的方式更新基本类型</p>
<p>AtomicInteger：整型原子类<br>AtomicLong：长整型原子类<br>AtomicBoolean ：布尔型原子类<br>上面三个类提供的方法几乎相同，所以我们将以 AtomicInteger 为例子来介绍。<br>原子引用<br>原子数组<br>字段更新器<br>原子累加器<br>下面先讨论原子整数类，以 AtomicInteger 为例讨论它的api接口：通过观察源码可以发现，AtomicInteger 内部都是通过cas的原理来实现的。</p>
<pre><code>public static void main(String[] args) &#123;
AtomicInteger i = new AtomicInteger(0);    // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++    System.out.println(i.getAndIncrement());    // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i    System.out.println(i.incrementAndGet());    // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i    System.out.println(i.decrementAndGet());    // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--    System.out.println(i.getAndDecrement());    // 获取并加值（i = 0, 结果 i = 5, 返回 0）    System.out.println(i.getAndAdd(5));    // 加值并获取（i = 5, 结果 i = 0, 返回 0）    System.out.println(i.addAndGet(-5));    // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）   
// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用   
System.out.println(i.getAndUpdate(p -&gt; p - 2));    
// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）    
// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用  
System.out.println(i.updateAndGet(p -&gt; p + 2));   
// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） 
// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用   
// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的   
// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final    System.out.println(i.getAndAccumulate(10, (p, x) -&gt; p + x));   
// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）  
// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用  
System.out.println(i.accumulateAndGet(-10, (p, x) -&gt; p + x));&#125;
</code></pre>
<p>4、原子引用<br>为什么需要原子引用类型？保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。<br>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p>
<p>AtomicReference：引用类型原子类<br>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起。<br>1）AtomicReference<br>先看如下代码的问题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountUnsafe</span> <span class="hljs-title">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    BigDecimal balance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">DecimalAccountUnsafe</span>(<span class="hljs-params">BigDecimal balance</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-function"><span class="hljs-title">getBalance</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>    <span class="hljs-comment">// 取款任务</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">withdraw</span>(<span class="hljs-params">BigDecimal amount</span>)</span> &#123;<br>        BigDecimal balance = <span class="hljs-built_in">this</span>.getBalance();<br>        <span class="hljs-built_in">this</span>.balance = balance.subtract(amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当执行 withdraw 方法时，可能会有线程安全，我们可以加锁解决或者是使用无锁的方式 CAS 来解决，解决方式是用 AtomicReference 原子引用解决。<br>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountCas</span> <span class="hljs-title">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">DecimalAccountCas</span>(<span class="hljs-params">BigDecimal balance</span>)</span> &#123; <br><span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(balance);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-function"><span class="hljs-title">getBalance</span>(<span class="hljs-params"></span>)</span> &#123; <br><span class="hljs-keyword">return</span> balance.get();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">withdraw</span>(<span class="hljs-params">BigDecimal amount</span>)</span> &#123; <br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <br>BigDecimal preVal = balance.get();   <br>BigDecimal nextVal = preVal.subtract(amount);  <br><span class="hljs-keyword">if</span>(balance.compareAndSet(preVal, nextVal)) &#123;  <br><span class="hljs-keyword">break</span>;      <br>&#125;  <br>&#125;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）ABA 问题<br>看如下代码：</p>
<pre><code>public static AtomicReference&lt;String&gt; ref = new AtomicReference&lt;&gt;(&quot;A&quot;);
public static void main(String[] args) throws InterruptedException &#123;  
log.debug(&quot;main start...&quot;);  
String preVal = ref.get();  
other();  
TimeUnit.SECONDS.sleep(1); 
log.debug(&quot;change A-&gt;C &#123;&#125;&quot;, ref.compareAndSet(preVal, &quot;C&quot;));
&#125;
private static void other() throws InterruptedException &#123;
new Thread(() -&gt; &#123;   
log.debug(&quot;change A-&gt;B &#123;&#125;&quot;, 
ref.compareAndSet(ref.get(), &quot;B&quot;));  
&#125;, &quot;t1&quot;).start();  
TimeUnit.SECONDS.sleep(1);  
new Thread(() -&gt; &#123;   
log.debug(&quot;change B-&gt;A &#123;&#125;&quot;, ref.compareAndSet(ref.get(), &quot;A&quot;));
&#125;, &quot;t2&quot;).start();
&#125;
</code></pre>
<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号。使用AtomicStampedReference来解决。</p>
<p>3）AtomicStampedReference<br>使用 AtomicStampedReference 加 stamp （版本号或者时间戳）的方式解决 ABA 问题。代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 两个参数，第一个：变量的值 第二个：版本号初始值</span><br>    public static AtomicStampedReference&lt;String&gt; <span class="hljs-built_in">ref</span> = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;  <br>log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);  <br>String preVal = <span class="hljs-built_in">ref</span>.get<span class="hljs-constructor">Reference()</span>; <br><span class="hljs-built_in">int</span> stamp = <span class="hljs-built_in">ref</span>.get<span class="hljs-constructor">Stamp()</span>; <br>log.info(<span class="hljs-string">&quot;main 拿到的版本号 &#123;&#125;&quot;</span>,stamp); <br>other<span class="hljs-literal">()</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">1</span>);  <br>log.info(<span class="hljs-string">&quot;修改后的版本号 &#123;&#125;&quot;</span>,<span class="hljs-built_in">ref</span>.get<span class="hljs-constructor">Stamp()</span>); <br>log.info(<span class="hljs-string">&quot;change A-&gt;C:&#123;&#125;&quot;</span>, <span class="hljs-built_in">ref</span>.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">preVal</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span> + 1)</span>);<br>&#125;<br><span class="hljs-keyword">private</span> static void other<span class="hljs-literal">()</span> throws InterruptedException &#123;  <br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;    <br><span class="hljs-built_in">int</span> stamp = <span class="hljs-built_in">ref</span>.get<span class="hljs-constructor">Stamp()</span>;     <br>log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);      <br>log.info(<span class="hljs-string">&quot;change A-&gt;B:&#123;&#125;&quot;</span>, <span class="hljs-built_in">ref</span>.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">ref</span>.<span class="hljs-params">getReference</span>()</span>, <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));  <br>&#125;).start<span class="hljs-literal">()</span>;  <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">1</span>); <br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;   <br><span class="hljs-built_in">int</span> stamp = <span class="hljs-built_in">ref</span>.get<span class="hljs-constructor">Stamp()</span>;    <br>log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);       <br>log.debug(<span class="hljs-string">&quot;change B-&gt;A:&#123;&#125;&quot;</span>, <span class="hljs-built_in">ref</span>.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">ref</span>.<span class="hljs-params">getReference</span>()</span>, <span class="hljs-string">&quot;A&quot;</span>,stamp,stamp + <span class="hljs-number">1</span>)); <br>&#125;).start<span class="hljs-literal">()</span>;&#125;<br></code></pre></td></tr></table></figure>

<p>4）AtomicMarkableReference<br>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference 。</p>
<p>5、原子数组<br>使用原子的方式更新数组里的某个元素</p>
<p>AtomicIntegerArray：整形数组原子类<br>AtomicLongArray：长整形数组原子类<br>AtomicReferenceArray ：引用类型数组原子类<br>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Code_10_AtomicArrayTest &#123;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;  <br><span class="hljs-comment">/**     </span><br><span class="hljs-comment">* 结果如下：    </span><br><span class="hljs-comment">* [9934, 9938, 9940, 9931, 9935, 9933, 9944, 9942, 9939, 9940]    </span><br><span class="hljs-comment">* [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]     </span><br><span class="hljs-comment">*/</span>   <br>demo(  <br><span class="hljs-literal">()</span> -&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-number">10</span>]</span>,  <br>(<span class="hljs-built_in">array</span>) -&gt; <span class="hljs-built_in">array</span>.length,         <br>(<span class="hljs-built_in">array</span>, index) -&gt; <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span>++,       <br>(<span class="hljs-built_in">array</span>) -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">array</span>)</span>)  <br>);    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">1</span>);  <br>demo(       <br><span class="hljs-literal">()</span> -&gt; <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicIntegerArray(10)</span>,    <br>(<span class="hljs-built_in">array</span>) -&gt; <span class="hljs-built_in">array</span>.length<span class="hljs-literal">()</span>,        <br>(<span class="hljs-built_in">array</span>, index) -&gt; <span class="hljs-built_in">array</span>.get<span class="hljs-constructor">AndIncrement(<span class="hljs-params">index</span>)</span>,    <br>(<span class="hljs-built_in">array</span>) -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-built_in">array</span>)  <br>);&#125;<span class="hljs-keyword">private</span> static &lt;T&gt; void demo(     <br>Supplier&lt;T&gt; arraySupplier,    <br>Function&lt;T, Integer&gt; lengthFun,     <br>BiConsumer&lt;T, Integer&gt; putConsumer,  <br>Consumer&lt;T&gt; printConsumer) &#123;   <br>ArrayList&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>; <br><span class="hljs-comment">// 创建集合   </span><br>T <span class="hljs-built_in">array</span> = arraySupplier.get<span class="hljs-literal">()</span>;<br><span class="hljs-comment">// 获取数组    </span><br><span class="hljs-built_in">int</span> length = lengthFun.apply(<span class="hljs-built_in">array</span>); <br><span class="hljs-comment">// 获取数组的长度  </span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;  <br>ts.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;           <br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;       <br>putConsumer.accept(<span class="hljs-built_in">array</span>, j % length);       <br>&#125;       <br>&#125;));  <br>&#125;    <br>ts.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(Thread::<span class="hljs-params">start</span>)</span>;    <br>ts.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">thread</span>)</span> -&gt; &#123;   <br><span class="hljs-keyword">try</span> &#123;        <br>thread.join<span class="hljs-literal">()</span>;<br>&#125; catch (InterruptedException e) &#123;      <br>e.print<span class="hljs-constructor">StackTrace()</span>;      <br>&#125;   <br>&#125;);   <br>printConsumer.accept(<span class="hljs-built_in">array</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用原子数组可以保证元素的线程安全。</p>
<p>6、字段更新器<br>AtomicReferenceFieldUpdater // 域 字段<br>AtomicIntegerFieldUpdater<br>AtomicLongFieldUpdater<br>注意：利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Exception</span> <span class="hljs-keyword">in</span> thread &quot;main&quot; java.lang.IllegalArgumentException: Must be <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">type</span><br><br></code></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Code_11_AtomicReferenceFieldUpdaterTest &#123;<br><br><span class="hljs-built_in">public</span> static AtomicReferenceFieldUpdater <span class="hljs-keyword">ref</span> =        AtomicReferenceFieldUpdater.newUpdater(Student.<span class="hljs-keyword">class</span>, String.<span class="hljs-keyword">class</span>, &quot;name&quot;);<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws InterruptedException &#123;    Student student = <span class="hljs-built_in">new</span> Student();    <span class="hljs-built_in">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">ref</span>.compareAndSet(student, <span class="hljs-keyword">null</span>, &quot;list&quot;));    &#125;).<span class="hljs-keyword">start</span>();    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">ref</span>.compareAndSet(student, <span class="hljs-keyword">null</span>, &quot;张三&quot;));    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(student);&#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> Student &#123;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">volatile</span> String <span class="hljs-type">name</span>;@Overridepublic String toString() &#123;    <span class="hljs-keyword">return</span> &quot;Student&#123;&quot; +            &quot;name=&#x27;&quot; + <span class="hljs-type">name</span> + <span class="hljs-string">&#x27;\&#x27;&#x27; +            &#x27;</span>&#125;<span class="hljs-string">&#x27;;&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>字段更新器就是为了保证类中某个属性线程安全问题。</p>
<p>7、原子累加器<br>1）AtomicLong Vs LongAdder</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo<span class="hljs-function"><span class="hljs-params">(() -&gt; <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>), (ref) -&gt; ref.getAndIncrement())</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        <span class="hljs-title">for</span><span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">demo</span><span class="hljs-params">(() -&gt; <span class="hljs-keyword">new</span> LongAdder(), (ref) -&gt; ref.increment())</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-literal">void</span> demo<span class="hljs-function"><span class="hljs-params">(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer)</span> &#123;    <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">Thread</span>&gt; <span class="hljs-title">list</span> = <span class="hljs-title">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;<span class="hljs-params">()</span>;    <span class="hljs-title">T</span> <span class="hljs-title">adder</span> = <span class="hljs-title">supplier</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>;    // 4 个线程，每人累加 50 万    <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)</span> &#123;        <span class="hljs-title">list</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;                consumer.accept(adder);            &#125;        &#125;))</span>;    &#125;    <span class="hljs-title">long</span> <span class="hljs-title">start</span> = <span class="hljs-title">System</span>.<span class="hljs-title">nanoTime</span><span class="hljs-params">()</span>;    <span class="hljs-title">list</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(t -&gt; t.start())</span>;    <span class="hljs-title">list</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(t -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            t.join();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;)</span>;    <span class="hljs-title">long</span> <span class="hljs-title">end</span> = <span class="hljs-title">System</span>.<span class="hljs-title">nanoTime</span><span class="hljs-params">()</span>;    <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>)</span>;&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>


<p>执行代码后，发现使用 LongAdder 比 AtomicLong 快2，3倍，使用 LongAdder 性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p>
<p>8、LongAdder 原理<br>LongAdder 类有几个关键域<br>public class LongAdder extends Striped64 implements Serializable {}<br>下面的变量属于 Striped64 被 LongAdder 继承。</p>
<p>// 累加单元数组, 懒惰初始化<br>transient volatile Cell[] cells;<br>// 基础值, 如果没有竞争, 则用 cas 累加这个域<br>transient volatile long base;<br>// 在 cells 创建或扩容时, 置为 1, 表示加锁<br>transient volatile int cellsBusy; </p>
<p>1）使用 cas 实现一个自旋锁</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_13_LockCas</span> &#123;</span><br><br>public AtomicInteger state = <span class="hljs-keyword">new</span> AtomicInteger<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span>; // 如果 <span class="hljs-title">state</span> 值为 0 表示没上锁, 1 表示上锁<span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> &#123;    <span class="hljs-title">while</span> <span class="hljs-params">(<span class="hljs-literal">true</span>)</span> &#123;        <span class="hljs-title">if</span><span class="hljs-params">(state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))</span> &#123;            <span class="hljs-title">break</span>;        &#125;    &#125;&#125;<span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> &#123;    <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;unlock...&quot;</span>)</span>;    <span class="hljs-title">state</span>.<span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>;&#125;<span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-built_in">String</span>[] args)</span> &#123;    <span class="hljs-title">Code_13_LockCas</span> <span class="hljs-title">lock</span> = <span class="hljs-title">new</span> <span class="hljs-title">Code_13_LockCas</span><span class="hljs-params">()</span>;    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;        log.info(<span class="hljs-string">&quot;begin...&quot;</span>);        lock.lock();        <span class="hljs-keyword">try</span> &#123;            log.info(<span class="hljs-string">&quot;上锁成功&quot;</span>);            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;        log.info(<span class="hljs-string">&quot;begin...&quot;</span>);        lock.lock();        <span class="hljs-keyword">try</span> &#123;            log.info(<span class="hljs-string">&quot;上锁成功&quot;</span>);            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>


<p>2）原理之伪共享<br>其中 Cell 即为累加单元</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>    Cell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;<br>    <span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> prev, <span class="hljs-keyword">long</span> next)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> UNSAFE.<span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, valueOffset, prev, next)</span></span>;<br>    &#125;<br>    <span class="hljs-comment">// 省略不重要代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面讨论 @sun.misc.Contended 注解的重要意义<br>得从缓存说起，缓存与内存的速度比较</p>
<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。缓存离 cpu 越近速度越快。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效。</p>
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了： Core-0 要修改 Cell[0]，Core-1 要修改 Cell[1]</p>
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效，@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</p>
<p>3）add 方法分析<br>LongAdder 进行累加操作是调用 increment 方法，它又调用 add 方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">add</span>(<span class="hljs-number">1L</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>第一步：add 方法分析，流程图如下</p>
<p>源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> x</span>)</span> &#123;<br>        <span class="hljs-comment">// as 为累加单元数组, b 为基础值, x 为累加值</span><br>        Cell[] <span class="hljs-keyword">as</span>; <span class="hljs-built_in">long</span> b, v; <span class="hljs-built_in">int</span> m; Cell a;<br>        <span class="hljs-comment">// 进入 if 的两个条件</span><br>        <span class="hljs-comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span><br>        <span class="hljs-comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span><br>        <span class="hljs-comment">// 3. 如果 as 没有创建, 然后 cas 累加成功就返回，累加到 base 中 不存在线程竞争的时候用到。</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">as</span> = cells) != <span class="hljs-literal">null</span> || !casBase(b = <span class="hljs-keyword">base</span>, b + x)) &#123;<br>            <span class="hljs-comment">// uncontended 表示 cell 是否有竞争，这里赋值为 true 表示有竞争</span><br>            boolean uncontended = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// as 还没有创建</span><br>                    <span class="hljs-keyword">as</span> == <span class="hljs-literal">null</span> || (m = <span class="hljs-keyword">as</span>.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>                            <span class="hljs-comment">// 当前线程对应的 cell 还没有被创建，a为当线程的cell</span><br>                            (a = <span class="hljs-keyword">as</span>[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>       <span class="hljs-comment">// 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span><br>                            !(uncontended = a.cas(v = a.<span class="hljs-keyword">value</span>, v + x))<br>            ) &#123;<br>                <span class="hljs-comment">// 当 cells 为空时，累加操作失败会调用方法，</span><br>                <span class="hljs-comment">// 当 cells 不为空，当前线程的 cell 创建了但是累加失败了会调用方法，</span><br>                <span class="hljs-comment">// 当 cells 不为空，当前线程 cell 没创建会调用这个方法</span><br>                <span class="hljs-comment">// 进入 cell 数组创建、cell 创建的流程</span><br>                longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>第二步：longAccumulate 方法分析，流程图如下：</p>
<p>源码如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> longAccumulate(<span class="hljs-built_in">long</span> x, LongBinaryOperator fn,<br>                              <span class="hljs-built_in">boolean</span> wasUncontended) &#123;<br>        <span class="hljs-built_in">int</span> h;<br>        <span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span><br>        <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 初始化 probe</span><br>            ThreadLocalRandom.current();<br>            <span class="hljs-comment">// h 对应新的 probe 值, 用来对应 cell</span><br>            h = getProbe();<br>            wasUncontended = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// collide 为 true 表示需要扩容</span><br>        <span class="hljs-built_in">boolean</span> collide = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Cell[] <span class="hljs-keyword">as</span>; Cell a; <span class="hljs-built_in">int</span> n; <span class="hljs-built_in">long</span> v;<br>            <span class="hljs-comment">// 已经有了 cells</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">as</span> = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = <span class="hljs-keyword">as</span>.length) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 但是还没有当前线程对应的 cell</span><br>                <span class="hljs-keyword">if</span> ((a = <span class="hljs-keyword">as</span>[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span><br>                    <span class="hljs-comment">// 成功则 break, 否则继续 continue 循环</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                        Cell r = <span class="hljs-keyword">new</span> Cell(x);   <span class="hljs-comment">// Optimistically create</span><br>                        <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                            <span class="hljs-built_in">boolean</span> created = <span class="hljs-literal">false</span>;<br>                            <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                                Cell[] rs; <span class="hljs-built_in">int</span> m, j;<br>                                <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                                    (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                    <span class="hljs-comment">// 判断槽位确实是空的</span><br>                                    rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                                    rs[j] = r;<br>                                    created = <span class="hljs-literal">true</span>;<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                                cellsBusy = <span class="hljs-number">0</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (created)<br>                                <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                        &#125;<br>                &#125;<br>                <span class="hljs-comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)<br>                    wasUncontended = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x : fn.applyAsLong(v, x))))<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != <span class="hljs-keyword">as</span>)<br>                    collide = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                    collide = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// 加锁</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                    <span class="hljs-comment">// 加锁成功, 扩容</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 改变线程对应的 cell</span><br>                h = advanceProbe(h);<br>            &#125;<br>            <span class="hljs-comment">// 还没有 cells, cells==as是指没有其它线程修改cells，as和cells引用相同的对象，使用casCellsBusy()尝试给 cellsBusy 加锁</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == <span class="hljs-keyword">as</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span><br>                <span class="hljs-comment">// 成功则 break;</span><br>                <span class="hljs-built_in">boolean</span> init = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                    <span class="hljs-keyword">if</span> (cells == <span class="hljs-keyword">as</span>) &#123;<br>                        Cell[] rs = <span class="hljs-keyword">new</span> Cell[<span class="hljs-number">2</span>];<br>                        rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Cell(x);<br>                        cells = rs;<br>                        init = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (init)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 上两种情况失败, 尝试给 base 使用casBase累加</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x : fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>4）sum 方法分析<br>获取最终结果通过 sum 方法，将各个累加单元的值加起来就得到了总的结果。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">sum</span>() &#123;<br>        Cell[] <span class="hljs-keyword">as</span> = cells; Cell a;<br>        <span class="hljs-built_in">long</span> <span class="hljs-keyword">sum</span> = base;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">as</span> != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">as</span>.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> ((a = <span class="hljs-keyword">as</span>[i]) != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">sum</span> += a.value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>5、Unsafe<br>1）Unsafe 对象的获取<br>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。LockSupport 的 park 方法，cas 相关的方法底层都是通过Unsafe类来实现的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws NoSuchFieldException, IllegalAccessException</span> &#123;<br>		<span class="hljs-comment">// Unsafe 使用了单例模式，unsafe 对象是类中的一个私有的变量 </span><br>        Field theUnsafe = Unsafe.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        Unsafe <span class="hljs-keyword">unsafe</span> = (Unsafe)theUnsafe.<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>);<br>        <br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）Unsafe 模拟实现 cas 操作</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Code_14_UnsafeTest &#123;<br><br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;    // 创建 unsafe 对象    Field theUnsafe = Unsafe.<span class="hljs-keyword">class</span>.getDeclaredField(&quot;theUnsafe&quot;);    theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);    Unsafe unsafe = (Unsafe)theUnsafe.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">null</span>);    // 拿到偏移量    long idOffset = unsafe.objectFieldOffset(Teacher.<span class="hljs-keyword">class</span>.getDeclaredField(&quot;id&quot;));    long nameOffset = unsafe.objectFieldOffset(Teacher.<span class="hljs-keyword">class</span>.getDeclaredField(&quot;name&quot;));    // 进行 cas 操作    Teacher teacher = <span class="hljs-built_in">new</span> Teacher();    unsafe.compareAndSwapLong(teacher, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);    unsafe.compareAndSwapObject(teacher, nameOffset, <span class="hljs-keyword">null</span>, &quot;lisi&quot;);    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(teacher);&#125;<br><br>&#125;<br><br>@Data<br><span class="hljs-keyword">class</span> Teacher &#123;<br><br>private <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> id;private <span class="hljs-keyword">volatile</span> String <span class="hljs-type">name</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>3）Unsafe 模拟实现原子整数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_15_UnsafeAccessor</span> </span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;    Account.demo(<span class="hljs-keyword">new</span> MyAtomicInteger(<span class="hljs-number">10000</span>));&#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAtomicInteger</span> <span class="hljs-title">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> volatile Integer value;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Unsafe UNSAFE = Unsafe.getUnsafe();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long valueOffset;<span class="hljs-keyword">static</span> &#123;    <span class="hljs-keyword">try</span> &#123;        valueOffset = UNSAFE.objectFieldOffset                (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(ex); &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">MyAtomicInteger</span>(<span class="hljs-params">Integer value</span>)</span> &#123;    <span class="hljs-built_in">this</span>.value = value;&#125;<span class="hljs-keyword">public</span> Integer <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> value;&#125;<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">decrement</span>(<span class="hljs-params">Integer amount</span>)</span> &#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        Integer preVal = <span class="hljs-built_in">this</span>.value;        Integer nextVal = preVal - amount;        <span class="hljs-keyword">if</span>(UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, valueOffset, preVal, nextVal)) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-meta">@Overridepublic</span> Integer <span class="hljs-function"><span class="hljs-title">getBalance</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> get();&#125;<span class="hljs-meta">@Overridepublic</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">withdraw</span>(<span class="hljs-params">Integer amount</span>)</span> &#123;    decrement(amount);&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>结论<br>本章重点讲解</p>
<p>CAS 与 volatile<br>juc 包下 API<br>原子整数<br>原子引用<br>原子数组<br>字段更新器<br>原子累加器<br>Unsafe<br>原理方面<br>LongAdder 源码<br>伪共享<br>六、共享模型之不可变<br>1、日期转换的问题<br>问题提出，下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>      <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                  log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">              &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                  log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);</span></span><br><span class="hljs-params"><span class="hljs-function">              &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">          &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      &#125;</span><br></code></pre></td></tr></table></figure>

<p>思路 - 不可变对象<br>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">DateTimeFormatter dtf = DateTimeFormatter.ofPattern<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>)</span>;    <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)</span> &#123;        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;            LocalDate date = dtf.parse(<span class="hljs-string">&quot;2018-10-01&quot;</span>, LocalDate::<span class="hljs-keyword">from</span>);            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, date);        &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>


<p>2、不可变设计<br>String类中不可变的体现</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> String<br>    <span class="hljs-keyword">implements</span> java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>1）final 的使用<br>发现该类、类中所有属性都是 ﬁnal 的</p>
<p>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改<br>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性<br>2）保护性拷贝<br>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public String substring(<span class="hljs-built_in">int</span> beginIndex, <span class="hljs-built_in">int</span> endIndex) &#123;<br>        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">beginIndex</span>)</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">endIndex</span>)</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> subLen = endIndex - beginIndex;<br>        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">subLen</span>)</span>;<br>        &#125;<br>        <span class="hljs-comment">// 上面是一些校验，下面才是真正的创建新的String对象</span><br>        return ((beginIndex<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<span class="hljs-operator"> &amp;&amp; </span>(endIndex<span class="hljs-operator"> == </span>value.length)) ? this<br>                : <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">value</span>, <span class="hljs-params">beginIndex</span>, <span class="hljs-params">subLen</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法创建了一个新字符串</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">String(<span class="hljs-params">char</span> <span class="hljs-params">value</span>[], <span class="hljs-params">int</span> <span class="hljs-params">offset</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span> &#123;<br>       <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>           throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">offset</span>)</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>               throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">count</span>)</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>               this.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>               return;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>       <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>           throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">offset</span> + <span class="hljs-params">count</span>)</span>;<br>       &#125;<br>       <span class="hljs-comment">// 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值</span><br>       this.value = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">value</span>, <span class="hljs-params">offset</span>, <span class="hljs-params">offset</span>+<span class="hljs-params">count</span>)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p>
<p>3、模式之享元<br>1）简介<br>简介定义英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时，归类为：Structual patterns</p>
<p>2）体现<br>包装类<br>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法。<br>例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">Long</span> valueOf(<span class="hljs-keyword">long</span> l) &#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>;<br> <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br> <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-keyword">int</span>)l + offset];<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Byte, Short, Long 缓存的范围都是 -128<del>127<br>Character 缓存的范围是 0</del>127<br>Integer 的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 “-Djava.lang.Integer.IntegerCache.high “来改变<br>Boolean 缓存了 TRUE 和 FALSE<br>String 池<br>参考如下文章：JDK1.8关于运行时常量池, 字符串常量池的要点<br>BigDecimal、BigInteger</p>
<p>3）DIY 实现简单的数据库连接池<br>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。<br>代码实现如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_17_DatabaseConnectionPoolTest</span> &#123;</span><br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;   <br>Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);    <br><span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;        </span></span><br><span class="hljs-params"><span class="hljs-function">Connection connection = pool.borrow();     </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;             </span></span><br><span class="hljs-params"><span class="hljs-function">Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));     </span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;     </span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();         </span></span><br><span class="hljs-params"><span class="hljs-function">&#125;          </span></span><br><span class="hljs-params"><span class="hljs-function">pool.free(connection);    </span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">@<span class="hljs-title">Slf4j</span><span class="hljs-params">(topic = <span class="hljs-string">&quot;c.Pool&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Pool</span> &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 连接池的大小, 因为没有实现连接池大小的扩容, 用 <span class="hljs-title">final</span> 表示池的大小是一个固定值。<span class="hljs-title">private</span> <span class="hljs-title">final</span> <span class="hljs-title">int</span> <span class="hljs-title">poolSize</span>;// 连接池<span class="hljs-title">private</span> <span class="hljs-title">Connection</span>[] <span class="hljs-title">connections</span>;</span><br><span class="hljs-function">// 表示连接状态, 如果是 0 表示没连接, 1 表示有连接<span class="hljs-title">private</span> <span class="hljs-title">AtomicIntegerArray</span> <span class="hljs-title">status</span>;</span><br><span class="hljs-function">// 初始化连接池</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(int poolSize)</span> &#123;   </span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">poolSize</span> = <span class="hljs-title">poolSize</span>; </span><br><span class="hljs-function"><span class="hljs-title">status</span> = <span class="hljs-title">new</span> <span class="hljs-title">AtomicIntegerArray</span><span class="hljs-params">(<span class="hljs-keyword">new</span> int[poolSize])</span>; </span><br><span class="hljs-function"><span class="hljs-title">connections</span> = <span class="hljs-title">new</span> <span class="hljs-title">Connection</span>[<span class="hljs-title">poolSize</span>];  </span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; poolSize; i++)</span> &#123;    </span><br><span class="hljs-function"><span class="hljs-title">connections</span>[<span class="hljs-title">i</span>] = <span class="hljs-title">new</span> <span class="hljs-title">MockConnection</span><span class="hljs-params">(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>))</span>;  </span><br><span class="hljs-function">&#125;&#125;</span><br><span class="hljs-function">// 从连接池中获取连接</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">Connection</span> <span class="hljs-title">borrow</span><span class="hljs-params">()</span> &#123;  </span><br><span class="hljs-function"><span class="hljs-title">while</span> <span class="hljs-params">(<span class="hljs-literal">true</span>)</span> &#123;      </span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i = <span class="hljs-number">0</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">i &lt; poolSize; i++)</span> &#123;   </span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-number">0</span> == status.get(i))</span> &#123;     </span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(status.compareAndSet(i,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))</span> &#123;    </span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">&quot;获取连接:&#123;&#125;&quot;</span>, connections[i])</span>;    </span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">connections</span>[<span class="hljs-title">i</span>];             </span><br><span class="hljs-function">&#125;           </span><br><span class="hljs-function">&#125;    </span><br><span class="hljs-function">&#125;     </span><br><span class="hljs-function"><span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-built_in">this</span>)</span> &#123;   </span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;            </span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">&quot;wait ...&quot;</span>)</span>;  </span><br><span class="hljs-function"><span class="hljs-title">wait</span><span class="hljs-params">()</span>;       </span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;  </span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;     </span><br><span class="hljs-function">&#125;     </span><br><span class="hljs-function">&#125; </span><br><span class="hljs-function">&#125;&#125;</span><br><span class="hljs-function">// 从连接池中释放指定的连接</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection connection)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; poolSize; i++)</span> &#123;    </span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(connections[i] == connection)</span> &#123;      </span><br><span class="hljs-function"><span class="hljs-title">status</span>.<span class="hljs-title">set</span><span class="hljs-params">(i, <span class="hljs-number">0</span>)</span>;         </span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">&quot;释放连接:&#123;&#125;&quot;</span>, connections[i])</span>;   </span><br><span class="hljs-function"><span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-built_in">this</span>)</span> &#123;           </span><br><span class="hljs-function"><span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>;         </span><br><span class="hljs-function">&#125;     </span><br><span class="hljs-function">&#125;  </span><br><span class="hljs-function">&#125;&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-title">implements</span> <span class="hljs-title">Connection</span> &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">name</span>;<span class="hljs-title">public</span> <span class="hljs-title">MockConnection</span><span class="hljs-params">(<span class="hljs-built_in">String</span> name)</span> &#123;    </span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">name</span> = <span class="hljs-title">name</span>;&#125;</span><br><span class="hljs-function">@<span class="hljs-title">Override</span></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> &#123;   </span><br><span class="hljs-function"><span class="hljs-title">return</span> &quot;<span class="hljs-title">MockConnection</span>&#123;&quot; +    </span><br><span class="hljs-function">&quot;<span class="hljs-title">name</span>=&#x27;&quot; + <span class="hljs-title">name</span> + &#x27;\&#x27;&#x27; +     </span><br><span class="hljs-function">&#x27;&#125;&#x27;;&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>以上实现没有考虑：</p>
<p>连接的动态增长与收缩<br>连接保活（可用性检测）<br>等待超时处理<br>分布式 hash<br>对于关系型数据库，有比较成熟的连接池的实现，例如 c3p0、druid 等<br>对于更通用的对象池，可以考虑用 apache commons pool，例如 redis 连接池可以参考 jedis 中关于连接池的实现。</p>
<p>4、final的原理<br>1）设置 final 变量的原理<br>理解了 volatile 原理，再对比 final 的实现就比较简单了</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">TestFinal</span> &#123;<br>	<span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attr">4:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span> <span class="hljs-number">20</span><br><span class="hljs-attr">7:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#2 // Field a:I</span><br> <span class="hljs-string">&lt;--</span> <span class="hljs-string">写屏障</span><br><span class="hljs-attr">10:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure>

<p>final 变量的赋值操作都必须在定义时或者构造器中进行初始化赋值，并发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。</p>
<p>2）获取 final 变量的原理<br>需要从字节码层面去理解，可以参考如下文章：<br>深入理解final关键字</p>
<p>结论<br>不可变类使用<br>不可变类设计<br>原理方面：final<br>模式方面<br>享元模式-&gt; 设置线程池<br>————————————————</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Jvm/">Jvm</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/01/09/nohup%E5%92%8C&amp;%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%8F%8A%E7%BB%88%E6%AD%A2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">nohup和&后台运行，进程查看及终止</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/01/09/ES%E4%B8%8D%E7%94%9F%E6%95%88&amp;&amp;%E7%A3%81%E7%9B%98%E6%B0%B4%E4%BD%8D%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/">
                        <span class="hidden-mobile">ES不生效&&磁盘水位参数设置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"fc36e17008bd1e3e898d","clientSecret":"d9d3bc7feb2b8abbb2d05b43b2d16a1d19c9bba2","repo":"cylinclinv.github.io","owner":"cylinclinv","admin":["cylinclinv"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":true,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'b56b62f6162a87900a3afc0f4e797378'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>clyde</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
